(() => {
  var e = {
      792: (e) => {
        "use strict";
        e.exports = function e(t, n) {
          if (t === n) return !0;
          if (t && n && "object" == typeof t && "object" == typeof n) {
            if (t.constructor !== n.constructor) return !1;
            var i, r, s;
            if (Array.isArray(t)) {
              if ((i = t.length) != n.length) return !1;
              for (r = i; 0 != r--; ) if (!e(t[r], n[r])) return !1;
              return !0;
            }
            if (t.constructor === RegExp)
              return t.source === n.source && t.flags === n.flags;
            if (t.valueOf !== Object.prototype.valueOf)
              return t.valueOf() === n.valueOf();
            if (t.toString !== Object.prototype.toString)
              return t.toString() === n.toString();
            if ((i = (s = Object.keys(t)).length) !== Object.keys(n).length)
              return !1;
            for (r = i; 0 != r--; )
              if (!Object.prototype.hasOwnProperty.call(n, s[r])) return !1;
            for (r = i; 0 != r--; ) {
              var a = s[r];
              if (!e(t[a], n[a])) return !1;
            }
            return !0;
          }
          return t != t && n != n;
        };
      },
      683: (e, t, n) => {
        var i;
        !(function () {
          "use strict";
          var r = function () {
            this.init();
          };
          r.prototype = {
            init: function () {
              var e = this || s;
              return (
                (e._counter = 1e3),
                (e._html5AudioPool = []),
                (e.html5PoolSize = 10),
                (e._codecs = {}),
                (e._howls = []),
                (e._muted = !1),
                (e._volume = 1),
                (e._canPlayEvent = "canplaythrough"),
                (e._navigator =
                  "undefined" != typeof window && window.navigator
                    ? window.navigator
                    : null),
                (e.masterGain = null),
                (e.noAudio = !1),
                (e.usingWebAudio = !0),
                (e.autoSuspend = !0),
                (e.ctx = null),
                (e.autoUnlock = !0),
                e._setup(),
                e
              );
            },
            volume: function (e) {
              var t = this || s;
              if (
                ((e = parseFloat(e)),
                t.ctx || p(),
                void 0 !== e && e >= 0 && e <= 1)
              ) {
                if (((t._volume = e), t._muted)) return t;
                t.usingWebAudio &&
                  t.masterGain.gain.setValueAtTime(e, s.ctx.currentTime);
                for (var n = 0; n < t._howls.length; n++)
                  if (!t._howls[n]._webAudio)
                    for (
                      var i = t._howls[n]._getSoundIds(), r = 0;
                      r < i.length;
                      r++
                    ) {
                      var a = t._howls[n]._soundById(i[r]);
                      a && a._node && (a._node.volume = a._volume * e);
                    }
                return t;
              }
              return t._volume;
            },
            mute: function (e) {
              var t = this || s;
              t.ctx || p(),
                (t._muted = e),
                t.usingWebAudio &&
                  t.masterGain.gain.setValueAtTime(
                    e ? 0 : t._volume,
                    s.ctx.currentTime
                  );
              for (var n = 0; n < t._howls.length; n++)
                if (!t._howls[n]._webAudio)
                  for (
                    var i = t._howls[n]._getSoundIds(), r = 0;
                    r < i.length;
                    r++
                  ) {
                    var a = t._howls[n]._soundById(i[r]);
                    a && a._node && (a._node.muted = !!e || a._muted);
                  }
              return t;
            },
            stop: function () {
              for (var e = this || s, t = 0; t < e._howls.length; t++)
                e._howls[t].stop();
              return e;
            },
            unload: function () {
              for (var e = this || s, t = e._howls.length - 1; t >= 0; t--)
                e._howls[t].unload();
              return (
                e.usingWebAudio &&
                  e.ctx &&
                  void 0 !== e.ctx.close &&
                  (e.ctx.close(), (e.ctx = null), p()),
                e
              );
            },
            codecs: function (e) {
              return (this || s)._codecs[e.replace(/^x-/, "")];
            },
            _setup: function () {
              var e = this || s;
              if (
                ((e.state = (e.ctx && e.ctx.state) || "suspended"),
                e._autoSuspend(),
                !e.usingWebAudio)
              )
                if ("undefined" != typeof Audio)
                  try {
                    void 0 === new Audio().oncanplaythrough &&
                      (e._canPlayEvent = "canplay");
                  } catch (t) {
                    e.noAudio = !0;
                  }
                else e.noAudio = !0;
              try {
                new Audio().muted && (e.noAudio = !0);
              } catch (e) {}
              return e.noAudio || e._setupCodecs(), e;
            },
            _setupCodecs: function () {
              var e = this || s,
                t = null;
              try {
                t = "undefined" != typeof Audio ? new Audio() : null;
              } catch (t) {
                return e;
              }
              if (!t || "function" != typeof t.canPlayType) return e;
              var n = t.canPlayType("audio/mpeg;").replace(/^no$/, ""),
                i = e._navigator ? e._navigator.userAgent : "",
                r = i.match(/OPR\/(\d+)/g),
                a = r && parseInt(r[0].split("/")[1], 10) < 33,
                o = -1 !== i.indexOf("Safari") && -1 === i.indexOf("Chrome"),
                c = i.match(/Version\/(.*?) /),
                l = o && c && parseInt(c[1], 10) < 15;
              return (
                (e._codecs = {
                  mp3: !(
                    a ||
                    (!n && !t.canPlayType("audio/mp3;").replace(/^no$/, ""))
                  ),
                  mpeg: !!n,
                  opus: !!t
                    .canPlayType('audio/ogg; codecs="opus"')
                    .replace(/^no$/, ""),
                  ogg: !!t
                    .canPlayType('audio/ogg; codecs="vorbis"')
                    .replace(/^no$/, ""),
                  oga: !!t
                    .canPlayType('audio/ogg; codecs="vorbis"')
                    .replace(/^no$/, ""),
                  wav: !!(
                    t.canPlayType('audio/wav; codecs="1"') ||
                    t.canPlayType("audio/wav")
                  ).replace(/^no$/, ""),
                  aac: !!t.canPlayType("audio/aac;").replace(/^no$/, ""),
                  caf: !!t.canPlayType("audio/x-caf;").replace(/^no$/, ""),
                  m4a: !!(
                    t.canPlayType("audio/x-m4a;") ||
                    t.canPlayType("audio/m4a;") ||
                    t.canPlayType("audio/aac;")
                  ).replace(/^no$/, ""),
                  m4b: !!(
                    t.canPlayType("audio/x-m4b;") ||
                    t.canPlayType("audio/m4b;") ||
                    t.canPlayType("audio/aac;")
                  ).replace(/^no$/, ""),
                  mp4: !!(
                    t.canPlayType("audio/x-mp4;") ||
                    t.canPlayType("audio/mp4;") ||
                    t.canPlayType("audio/aac;")
                  ).replace(/^no$/, ""),
                  weba: !(
                    l ||
                    !t
                      .canPlayType('audio/webm; codecs="vorbis"')
                      .replace(/^no$/, "")
                  ),
                  webm: !(
                    l ||
                    !t
                      .canPlayType('audio/webm; codecs="vorbis"')
                      .replace(/^no$/, "")
                  ),
                  dolby: !!t
                    .canPlayType('audio/mp4; codecs="ec-3"')
                    .replace(/^no$/, ""),
                  flac: !!(
                    t.canPlayType("audio/x-flac;") ||
                    t.canPlayType("audio/flac;")
                  ).replace(/^no$/, ""),
                }),
                e
              );
            },
            _unlockAudio: function () {
              var e = this || s;
              if (!e._audioUnlocked && e.ctx) {
                (e._audioUnlocked = !1),
                  (e.autoUnlock = !1),
                  e._mobileUnloaded ||
                    44100 === e.ctx.sampleRate ||
                    ((e._mobileUnloaded = !0), e.unload()),
                  (e._scratchBuffer = e.ctx.createBuffer(1, 1, 22050));
                var t = function (n) {
                  for (; e._html5AudioPool.length < e.html5PoolSize; )
                    try {
                      var i = new Audio();
                      (i._unlocked = !0), e._releaseHtml5Audio(i);
                    } catch (n) {
                      e.noAudio = !0;
                      break;
                    }
                  for (var r = 0; r < e._howls.length; r++)
                    if (!e._howls[r]._webAudio)
                      for (
                        var s = e._howls[r]._getSoundIds(), a = 0;
                        a < s.length;
                        a++
                      ) {
                        var o = e._howls[r]._soundById(s[a]);
                        o &&
                          o._node &&
                          !o._node._unlocked &&
                          ((o._node._unlocked = !0), o._node.load());
                      }
                  e._autoResume();
                  var c = e.ctx.createBufferSource();
                  (c.buffer = e._scratchBuffer),
                    c.connect(e.ctx.destination),
                    void 0 === c.start ? c.noteOn(0) : c.start(0),
                    "function" == typeof e.ctx.resume && e.ctx.resume(),
                    (c.onended = function () {
                      c.disconnect(0),
                        (e._audioUnlocked = !0),
                        document.removeEventListener("touchstart", t, !0),
                        document.removeEventListener("touchend", t, !0),
                        document.removeEventListener("click", t, !0),
                        document.removeEventListener("keydown", t, !0);
                      for (var n = 0; n < e._howls.length; n++)
                        e._howls[n]._emit("unlock");
                    });
                };
                return (
                  document.addEventListener("touchstart", t, !0),
                  document.addEventListener("touchend", t, !0),
                  document.addEventListener("click", t, !0),
                  document.addEventListener("keydown", t, !0),
                  e
                );
              }
            },
            _obtainHtml5Audio: function () {
              var e = this || s;
              if (e._html5AudioPool.length) return e._html5AudioPool.pop();
              var t = new Audio().play();
              return (
                t &&
                  "undefined" != typeof Promise &&
                  (t instanceof Promise || "function" == typeof t.then) &&
                  t.catch(function () {
                    console.warn(
                      "HTML5 Audio pool exhausted, returning potentially locked audio object."
                    );
                  }),
                new Audio()
              );
            },
            _releaseHtml5Audio: function (e) {
              var t = this || s;
              return e._unlocked && t._html5AudioPool.push(e), t;
            },
            _autoSuspend: function () {
              var e = this;
              if (
                e.autoSuspend &&
                e.ctx &&
                void 0 !== e.ctx.suspend &&
                s.usingWebAudio
              ) {
                for (var t = 0; t < e._howls.length; t++)
                  if (e._howls[t]._webAudio)
                    for (var n = 0; n < e._howls[t]._sounds.length; n++)
                      if (!e._howls[t]._sounds[n]._paused) return e;
                return (
                  e._suspendTimer && clearTimeout(e._suspendTimer),
                  (e._suspendTimer = setTimeout(function () {
                    if (e.autoSuspend) {
                      (e._suspendTimer = null), (e.state = "suspending");
                      var t = function () {
                        (e.state = "suspended"),
                          e._resumeAfterSuspend &&
                            (delete e._resumeAfterSuspend, e._autoResume());
                      };
                      e.ctx.suspend().then(t, t);
                    }
                  }, 3e4)),
                  e
                );
              }
            },
            _autoResume: function () {
              var e = this;
              if (e.ctx && void 0 !== e.ctx.resume && s.usingWebAudio)
                return (
                  "running" === e.state &&
                  "interrupted" !== e.ctx.state &&
                  e._suspendTimer
                    ? (clearTimeout(e._suspendTimer), (e._suspendTimer = null))
                    : "suspended" === e.state ||
                      ("running" === e.state && "interrupted" === e.ctx.state)
                    ? (e.ctx.resume().then(function () {
                        e.state = "running";
                        for (var t = 0; t < e._howls.length; t++)
                          e._howls[t]._emit("resume");
                      }),
                      e._suspendTimer &&
                        (clearTimeout(e._suspendTimer),
                        (e._suspendTimer = null)))
                    : "suspending" === e.state && (e._resumeAfterSuspend = !0),
                  e
                );
            },
          };
          var s = new r(),
            a = function (e) {
              e.src && 0 !== e.src.length
                ? this.init(e)
                : console.error(
                    "An array of source files must be passed with any new Howl."
                  );
            };
          a.prototype = {
            init: function (e) {
              var t = this;
              return (
                s.ctx || p(),
                (t._autoplay = e.autoplay || !1),
                (t._format =
                  "string" != typeof e.format ? e.format : [e.format]),
                (t._html5 = e.html5 || !1),
                (t._muted = e.mute || !1),
                (t._loop = e.loop || !1),
                (t._pool = e.pool || 5),
                (t._preload =
                  ("boolean" != typeof e.preload && "metadata" !== e.preload) ||
                  e.preload),
                (t._rate = e.rate || 1),
                (t._sprite = e.sprite || {}),
                (t._src = "string" != typeof e.src ? e.src : [e.src]),
                (t._volume = void 0 !== e.volume ? e.volume : 1),
                (t._xhr = {
                  method: e.xhr && e.xhr.method ? e.xhr.method : "GET",
                  headers: e.xhr && e.xhr.headers ? e.xhr.headers : null,
                  withCredentials:
                    !(!e.xhr || !e.xhr.withCredentials) &&
                    e.xhr.withCredentials,
                }),
                (t._duration = 0),
                (t._state = "unloaded"),
                (t._sounds = []),
                (t._endTimers = {}),
                (t._queue = []),
                (t._playLock = !1),
                (t._onend = e.onend ? [{ fn: e.onend }] : []),
                (t._onfade = e.onfade ? [{ fn: e.onfade }] : []),
                (t._onload = e.onload ? [{ fn: e.onload }] : []),
                (t._onloaderror = e.onloaderror ? [{ fn: e.onloaderror }] : []),
                (t._onplayerror = e.onplayerror ? [{ fn: e.onplayerror }] : []),
                (t._onpause = e.onpause ? [{ fn: e.onpause }] : []),
                (t._onplay = e.onplay ? [{ fn: e.onplay }] : []),
                (t._onstop = e.onstop ? [{ fn: e.onstop }] : []),
                (t._onmute = e.onmute ? [{ fn: e.onmute }] : []),
                (t._onvolume = e.onvolume ? [{ fn: e.onvolume }] : []),
                (t._onrate = e.onrate ? [{ fn: e.onrate }] : []),
                (t._onseek = e.onseek ? [{ fn: e.onseek }] : []),
                (t._onunlock = e.onunlock ? [{ fn: e.onunlock }] : []),
                (t._onresume = []),
                (t._webAudio = s.usingWebAudio && !t._html5),
                void 0 !== s.ctx && s.ctx && s.autoUnlock && s._unlockAudio(),
                s._howls.push(t),
                t._autoplay &&
                  t._queue.push({
                    event: "play",
                    action: function () {
                      t.play();
                    },
                  }),
                t._preload && "none" !== t._preload && t.load(),
                t
              );
            },
            load: function () {
              var e = this,
                t = null;
              if (s.noAudio) e._emit("loaderror", null, "No audio support.");
              else {
                "string" == typeof e._src && (e._src = [e._src]);
                for (var n = 0; n < e._src.length; n++) {
                  var i, r;
                  if (e._format && e._format[n]) i = e._format[n];
                  else {
                    if ("string" != typeof (r = e._src[n])) {
                      e._emit(
                        "loaderror",
                        null,
                        "Non-string found in selected audio sources - ignoring."
                      );
                      continue;
                    }
                    (i = /^data:audio\/([^;,]+);/i.exec(r)) ||
                      (i = /\.([^.]+)$/.exec(r.split("?", 1)[0])),
                      i && (i = i[1].toLowerCase());
                  }
                  if (
                    (i ||
                      console.warn(
                        'No file extension was found. Consider using the "format" property or specify an extension.'
                      ),
                    i && s.codecs(i))
                  ) {
                    t = e._src[n];
                    break;
                  }
                }
                if (t)
                  return (
                    (e._src = t),
                    (e._state = "loading"),
                    "https:" === window.location.protocol &&
                      "http:" === t.slice(0, 5) &&
                      ((e._html5 = !0), (e._webAudio = !1)),
                    new o(e),
                    e._webAudio && l(e),
                    e
                  );
                e._emit(
                  "loaderror",
                  null,
                  "No codec support for selected audio sources."
                );
              }
            },
            play: function (e, t) {
              var n = this,
                i = null;
              if ("number" == typeof e) (i = e), (e = null);
              else {
                if (
                  "string" == typeof e &&
                  "loaded" === n._state &&
                  !n._sprite[e]
                )
                  return null;
                if (void 0 === e && ((e = "__default"), !n._playLock)) {
                  for (var r = 0, a = 0; a < n._sounds.length; a++)
                    n._sounds[a]._paused &&
                      !n._sounds[a]._ended &&
                      (r++, (i = n._sounds[a]._id));
                  1 === r ? (e = null) : (i = null);
                }
              }
              var o = i ? n._soundById(i) : n._inactiveSound();
              if (!o) return null;
              if (
                (i && !e && (e = o._sprite || "__default"),
                "loaded" !== n._state)
              ) {
                (o._sprite = e), (o._ended = !1);
                var c = o._id;
                return (
                  n._queue.push({
                    event: "play",
                    action: function () {
                      n.play(c);
                    },
                  }),
                  c
                );
              }
              if (i && !o._paused) return t || n._loadQueue("play"), o._id;
              n._webAudio && s._autoResume();
              var l = Math.max(
                  0,
                  o._seek > 0 ? o._seek : n._sprite[e][0] / 1e3
                ),
                u = Math.max(0, (n._sprite[e][0] + n._sprite[e][1]) / 1e3 - l),
                h = (1e3 * u) / Math.abs(o._rate),
                d = n._sprite[e][0] / 1e3,
                p = (n._sprite[e][0] + n._sprite[e][1]) / 1e3;
              (o._sprite = e), (o._ended = !1);
              var f = function () {
                (o._paused = !1),
                  (o._seek = l),
                  (o._start = d),
                  (o._stop = p),
                  (o._loop = !(!o._loop && !n._sprite[e][2]));
              };
              if (!(l >= p)) {
                var A = o._node;
                if (n._webAudio) {
                  var g = function () {
                    (n._playLock = !1), f(), n._refreshBuffer(o);
                    var e = o._muted || n._muted ? 0 : o._volume;
                    A.gain.setValueAtTime(e, s.ctx.currentTime),
                      (o._playStart = s.ctx.currentTime),
                      void 0 === A.bufferSource.start
                        ? o._loop
                          ? A.bufferSource.noteGrainOn(0, l, 86400)
                          : A.bufferSource.noteGrainOn(0, l, u)
                        : o._loop
                        ? A.bufferSource.start(0, l, 86400)
                        : A.bufferSource.start(0, l, u),
                      h !== 1 / 0 &&
                        (n._endTimers[o._id] = setTimeout(
                          n._ended.bind(n, o),
                          h
                        )),
                      t ||
                        setTimeout(function () {
                          n._emit("play", o._id), n._loadQueue();
                        }, 0);
                  };
                  "running" === s.state && "interrupted" !== s.ctx.state
                    ? g()
                    : ((n._playLock = !0),
                      n.once("resume", g),
                      n._clearTimer(o._id));
                } else {
                  var m = function () {
                    (A.currentTime = l),
                      (A.muted = o._muted || n._muted || s._muted || A.muted),
                      (A.volume = o._volume * s.volume()),
                      (A.playbackRate = o._rate);
                    try {
                      var i = A.play();
                      if (
                        (i &&
                        "undefined" != typeof Promise &&
                        (i instanceof Promise || "function" == typeof i.then)
                          ? ((n._playLock = !0),
                            f(),
                            i
                              .then(function () {
                                (n._playLock = !1),
                                  (A._unlocked = !0),
                                  t ? n._loadQueue() : n._emit("play", o._id);
                              })
                              .catch(function () {
                                (n._playLock = !1),
                                  n._emit(
                                    "playerror",
                                    o._id,
                                    "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."
                                  ),
                                  (o._ended = !0),
                                  (o._paused = !0);
                              }))
                          : t ||
                            ((n._playLock = !1), f(), n._emit("play", o._id)),
                        (A.playbackRate = o._rate),
                        A.paused)
                      )
                        return void n._emit(
                          "playerror",
                          o._id,
                          "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."
                        );
                      "__default" !== e || o._loop
                        ? (n._endTimers[o._id] = setTimeout(
                            n._ended.bind(n, o),
                            h
                          ))
                        : ((n._endTimers[o._id] = function () {
                            n._ended(o),
                              A.removeEventListener(
                                "ended",
                                n._endTimers[o._id],
                                !1
                              );
                          }),
                          A.addEventListener("ended", n._endTimers[o._id], !1));
                    } catch (e) {
                      n._emit("playerror", o._id, e);
                    }
                  };
                  "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" ===
                    A.src && ((A.src = n._src), A.load());
                  var v =
                    (window && window.ejecta) ||
                    (!A.readyState && s._navigator.isCocoonJS);
                  if (A.readyState >= 3 || v) m();
                  else {
                    (n._playLock = !0), (n._state = "loading");
                    var y = function () {
                      (n._state = "loaded"),
                        m(),
                        A.removeEventListener(s._canPlayEvent, y, !1);
                    };
                    A.addEventListener(s._canPlayEvent, y, !1),
                      n._clearTimer(o._id);
                  }
                }
                return o._id;
              }
              n._ended(o);
            },
            pause: function (e) {
              var t = this;
              if ("loaded" !== t._state || t._playLock)
                return (
                  t._queue.push({
                    event: "pause",
                    action: function () {
                      t.pause(e);
                    },
                  }),
                  t
                );
              for (var n = t._getSoundIds(e), i = 0; i < n.length; i++) {
                t._clearTimer(n[i]);
                var r = t._soundById(n[i]);
                if (
                  r &&
                  !r._paused &&
                  ((r._seek = t.seek(n[i])),
                  (r._rateSeek = 0),
                  (r._paused = !0),
                  t._stopFade(n[i]),
                  r._node)
                )
                  if (t._webAudio) {
                    if (!r._node.bufferSource) continue;
                    void 0 === r._node.bufferSource.stop
                      ? r._node.bufferSource.noteOff(0)
                      : r._node.bufferSource.stop(0),
                      t._cleanBuffer(r._node);
                  } else
                    (isNaN(r._node.duration) && r._node.duration !== 1 / 0) ||
                      r._node.pause();
                arguments[1] || t._emit("pause", r ? r._id : null);
              }
              return t;
            },
            stop: function (e, t) {
              var n = this;
              if ("loaded" !== n._state || n._playLock)
                return (
                  n._queue.push({
                    event: "stop",
                    action: function () {
                      n.stop(e);
                    },
                  }),
                  n
                );
              for (var i = n._getSoundIds(e), r = 0; r < i.length; r++) {
                n._clearTimer(i[r]);
                var s = n._soundById(i[r]);
                s &&
                  ((s._seek = s._start || 0),
                  (s._rateSeek = 0),
                  (s._paused = !0),
                  (s._ended = !0),
                  n._stopFade(i[r]),
                  s._node &&
                    (n._webAudio
                      ? s._node.bufferSource &&
                        (void 0 === s._node.bufferSource.stop
                          ? s._node.bufferSource.noteOff(0)
                          : s._node.bufferSource.stop(0),
                        n._cleanBuffer(s._node))
                      : (isNaN(s._node.duration) &&
                          s._node.duration !== 1 / 0) ||
                        ((s._node.currentTime = s._start || 0),
                        s._node.pause(),
                        s._node.duration === 1 / 0 && n._clearSound(s._node))),
                  t || n._emit("stop", s._id));
              }
              return n;
            },
            mute: function (e, t) {
              var n = this;
              if ("loaded" !== n._state || n._playLock)
                return (
                  n._queue.push({
                    event: "mute",
                    action: function () {
                      n.mute(e, t);
                    },
                  }),
                  n
                );
              if (void 0 === t) {
                if ("boolean" != typeof e) return n._muted;
                n._muted = e;
              }
              for (var i = n._getSoundIds(t), r = 0; r < i.length; r++) {
                var a = n._soundById(i[r]);
                a &&
                  ((a._muted = e),
                  a._interval && n._stopFade(a._id),
                  n._webAudio && a._node
                    ? a._node.gain.setValueAtTime(
                        e ? 0 : a._volume,
                        s.ctx.currentTime
                      )
                    : a._node && (a._node.muted = !!s._muted || e),
                  n._emit("mute", a._id));
              }
              return n;
            },
            volume: function () {
              var e,
                t,
                n,
                i = this,
                r = arguments;
              if (0 === r.length) return i._volume;
              if (
                (1 === r.length || (2 === r.length && void 0 === r[1])
                  ? i._getSoundIds().indexOf(r[0]) >= 0
                    ? (t = parseInt(r[0], 10))
                    : (e = parseFloat(r[0]))
                  : r.length >= 2 &&
                    ((e = parseFloat(r[0])), (t = parseInt(r[1], 10))),
                !(void 0 !== e && e >= 0 && e <= 1))
              )
                return (n = t ? i._soundById(t) : i._sounds[0]) ? n._volume : 0;
              if ("loaded" !== i._state || i._playLock)
                return (
                  i._queue.push({
                    event: "volume",
                    action: function () {
                      i.volume.apply(i, r);
                    },
                  }),
                  i
                );
              void 0 === t && (i._volume = e), (t = i._getSoundIds(t));
              for (var a = 0; a < t.length; a++)
                (n = i._soundById(t[a])) &&
                  ((n._volume = e),
                  r[2] || i._stopFade(t[a]),
                  i._webAudio && n._node && !n._muted
                    ? n._node.gain.setValueAtTime(e, s.ctx.currentTime)
                    : n._node && !n._muted && (n._node.volume = e * s.volume()),
                  i._emit("volume", n._id));
              return i;
            },
            fade: function (e, t, n, i) {
              var r = this;
              if ("loaded" !== r._state || r._playLock)
                return (
                  r._queue.push({
                    event: "fade",
                    action: function () {
                      r.fade(e, t, n, i);
                    },
                  }),
                  r
                );
              (e = Math.min(Math.max(0, parseFloat(e)), 1)),
                (t = Math.min(Math.max(0, parseFloat(t)), 1)),
                (n = parseFloat(n)),
                r.volume(e, i);
              for (var a = r._getSoundIds(i), o = 0; o < a.length; o++) {
                var c = r._soundById(a[o]);
                if (c) {
                  if ((i || r._stopFade(a[o]), r._webAudio && !c._muted)) {
                    var l = s.ctx.currentTime,
                      u = l + n / 1e3;
                    (c._volume = e),
                      c._node.gain.setValueAtTime(e, l),
                      c._node.gain.linearRampToValueAtTime(t, u);
                  }
                  r._startFadeInterval(c, e, t, n, a[o], void 0 === i);
                }
              }
              return r;
            },
            _startFadeInterval: function (e, t, n, i, r, s) {
              var a = this,
                o = t,
                c = n - t,
                l = Math.abs(c / 0.01),
                u = Math.max(4, l > 0 ? i / l : i),
                h = Date.now();
              (e._fadeTo = n),
                (e._interval = setInterval(function () {
                  var r = (Date.now() - h) / i;
                  (h = Date.now()),
                    (o += c * r),
                    (o = Math.round(100 * o) / 100),
                    (o = c < 0 ? Math.max(n, o) : Math.min(n, o)),
                    a._webAudio ? (e._volume = o) : a.volume(o, e._id, !0),
                    s && (a._volume = o),
                    ((n < t && o <= n) || (n > t && o >= n)) &&
                      (clearInterval(e._interval),
                      (e._interval = null),
                      (e._fadeTo = null),
                      a.volume(n, e._id),
                      a._emit("fade", e._id));
                }, u));
            },
            _stopFade: function (e) {
              var t = this,
                n = t._soundById(e);
              return (
                n &&
                  n._interval &&
                  (t._webAudio &&
                    n._node.gain.cancelScheduledValues(s.ctx.currentTime),
                  clearInterval(n._interval),
                  (n._interval = null),
                  t.volume(n._fadeTo, e),
                  (n._fadeTo = null),
                  t._emit("fade", e)),
                t
              );
            },
            loop: function () {
              var e,
                t,
                n,
                i = this,
                r = arguments;
              if (0 === r.length) return i._loop;
              if (1 === r.length) {
                if ("boolean" != typeof r[0])
                  return !!(n = i._soundById(parseInt(r[0], 10))) && n._loop;
                (e = r[0]), (i._loop = e);
              } else 2 === r.length && ((e = r[0]), (t = parseInt(r[1], 10)));
              for (var s = i._getSoundIds(t), a = 0; a < s.length; a++)
                (n = i._soundById(s[a])) &&
                  ((n._loop = e),
                  i._webAudio &&
                    n._node &&
                    n._node.bufferSource &&
                    ((n._node.bufferSource.loop = e),
                    e &&
                      ((n._node.bufferSource.loopStart = n._start || 0),
                      (n._node.bufferSource.loopEnd = n._stop),
                      i.playing(s[a]) &&
                        (i.pause(s[a], !0), i.play(s[a], !0)))));
              return i;
            },
            rate: function () {
              var e,
                t,
                n,
                i = this,
                r = arguments;
              if (0 === r.length) t = i._sounds[0]._id;
              else if (1 === r.length) {
                i._getSoundIds().indexOf(r[0]) >= 0
                  ? (t = parseInt(r[0], 10))
                  : (e = parseFloat(r[0]));
              } else
                2 === r.length &&
                  ((e = parseFloat(r[0])), (t = parseInt(r[1], 10)));
              if ("number" != typeof e)
                return (n = i._soundById(t)) ? n._rate : i._rate;
              if ("loaded" !== i._state || i._playLock)
                return (
                  i._queue.push({
                    event: "rate",
                    action: function () {
                      i.rate.apply(i, r);
                    },
                  }),
                  i
                );
              void 0 === t && (i._rate = e), (t = i._getSoundIds(t));
              for (var a = 0; a < t.length; a++)
                if ((n = i._soundById(t[a]))) {
                  i.playing(t[a]) &&
                    ((n._rateSeek = i.seek(t[a])),
                    (n._playStart = i._webAudio
                      ? s.ctx.currentTime
                      : n._playStart)),
                    (n._rate = e),
                    i._webAudio && n._node && n._node.bufferSource
                      ? n._node.bufferSource.playbackRate.setValueAtTime(
                          e,
                          s.ctx.currentTime
                        )
                      : n._node && (n._node.playbackRate = e);
                  var o = i.seek(t[a]),
                    c =
                      (1e3 *
                        ((i._sprite[n._sprite][0] + i._sprite[n._sprite][1]) /
                          1e3 -
                          o)) /
                      Math.abs(n._rate);
                  (!i._endTimers[t[a]] && n._paused) ||
                    (i._clearTimer(t[a]),
                    (i._endTimers[t[a]] = setTimeout(i._ended.bind(i, n), c))),
                    i._emit("rate", n._id);
                }
              return i;
            },
            seek: function () {
              var e,
                t,
                n = this,
                i = arguments;
              if (0 === i.length) n._sounds.length && (t = n._sounds[0]._id);
              else if (1 === i.length) {
                n._getSoundIds().indexOf(i[0]) >= 0
                  ? (t = parseInt(i[0], 10))
                  : n._sounds.length &&
                    ((t = n._sounds[0]._id), (e = parseFloat(i[0])));
              } else
                2 === i.length &&
                  ((e = parseFloat(i[0])), (t = parseInt(i[1], 10)));
              if (void 0 === t) return 0;
              if (
                "number" == typeof e &&
                ("loaded" !== n._state || n._playLock)
              )
                return (
                  n._queue.push({
                    event: "seek",
                    action: function () {
                      n.seek.apply(n, i);
                    },
                  }),
                  n
                );
              var r = n._soundById(t);
              if (r) {
                if (!("number" == typeof e && e >= 0)) {
                  if (n._webAudio) {
                    var a = n.playing(t) ? s.ctx.currentTime - r._playStart : 0,
                      o = r._rateSeek ? r._rateSeek - r._seek : 0;
                    return r._seek + (o + a * Math.abs(r._rate));
                  }
                  return r._node.currentTime;
                }
                var c = n.playing(t);
                c && n.pause(t, !0),
                  (r._seek = e),
                  (r._ended = !1),
                  n._clearTimer(t),
                  n._webAudio ||
                    !r._node ||
                    isNaN(r._node.duration) ||
                    (r._node.currentTime = e);
                var l = function () {
                  c && n.play(t, !0), n._emit("seek", t);
                };
                if (c && !n._webAudio) {
                  var u = function () {
                    n._playLock ? setTimeout(u, 0) : l();
                  };
                  setTimeout(u, 0);
                } else l();
              }
              return n;
            },
            playing: function (e) {
              var t = this;
              if ("number" == typeof e) {
                var n = t._soundById(e);
                return !!n && !n._paused;
              }
              for (var i = 0; i < t._sounds.length; i++)
                if (!t._sounds[i]._paused) return !0;
              return !1;
            },
            duration: function (e) {
              var t = this,
                n = t._duration,
                i = t._soundById(e);
              return i && (n = t._sprite[i._sprite][1] / 1e3), n;
            },
            state: function () {
              return this._state;
            },
            unload: function () {
              for (var e = this, t = e._sounds, n = 0; n < t.length; n++)
                t[n]._paused || e.stop(t[n]._id),
                  e._webAudio ||
                    (e._clearSound(t[n]._node),
                    t[n]._node.removeEventListener("error", t[n]._errorFn, !1),
                    t[n]._node.removeEventListener(
                      s._canPlayEvent,
                      t[n]._loadFn,
                      !1
                    ),
                    t[n]._node.removeEventListener("ended", t[n]._endFn, !1),
                    s._releaseHtml5Audio(t[n]._node)),
                  delete t[n]._node,
                  e._clearTimer(t[n]._id);
              var i = s._howls.indexOf(e);
              i >= 0 && s._howls.splice(i, 1);
              var r = !0;
              for (n = 0; n < s._howls.length; n++)
                if (
                  s._howls[n]._src === e._src ||
                  e._src.indexOf(s._howls[n]._src) >= 0
                ) {
                  r = !1;
                  break;
                }
              return (
                c && r && delete c[e._src],
                (s.noAudio = !1),
                (e._state = "unloaded"),
                (e._sounds = []),
                (e = null),
                null
              );
            },
            on: function (e, t, n, i) {
              var r = this["_on" + e];
              return (
                "function" == typeof t &&
                  r.push(i ? { id: n, fn: t, once: i } : { id: n, fn: t }),
                this
              );
            },
            off: function (e, t, n) {
              var i = this,
                r = i["_on" + e],
                s = 0;
              if (("number" == typeof t && ((n = t), (t = null)), t || n))
                for (s = 0; s < r.length; s++) {
                  var a = n === r[s].id;
                  if ((t === r[s].fn && a) || (!t && a)) {
                    r.splice(s, 1);
                    break;
                  }
                }
              else if (e) i["_on" + e] = [];
              else {
                var o = Object.keys(i);
                for (s = 0; s < o.length; s++)
                  0 === o[s].indexOf("_on") &&
                    Array.isArray(i[o[s]]) &&
                    (i[o[s]] = []);
              }
              return i;
            },
            once: function (e, t, n) {
              return this.on(e, t, n, 1), this;
            },
            _emit: function (e, t, n) {
              for (
                var i = this, r = i["_on" + e], s = r.length - 1;
                s >= 0;
                s--
              )
                (r[s].id && r[s].id !== t && "load" !== e) ||
                  (setTimeout(
                    function (e) {
                      e.call(this, t, n);
                    }.bind(i, r[s].fn),
                    0
                  ),
                  r[s].once && i.off(e, r[s].fn, r[s].id));
              return i._loadQueue(e), i;
            },
            _loadQueue: function (e) {
              var t = this;
              if (t._queue.length > 0) {
                var n = t._queue[0];
                n.event === e && (t._queue.shift(), t._loadQueue()),
                  e || n.action();
              }
              return t;
            },
            _ended: function (e) {
              var t = this,
                n = e._sprite;
              if (
                !t._webAudio &&
                e._node &&
                !e._node.paused &&
                !e._node.ended &&
                e._node.currentTime < e._stop
              )
                return setTimeout(t._ended.bind(t, e), 100), t;
              var i = !(!e._loop && !t._sprite[n][2]);
              if (
                (t._emit("end", e._id),
                !t._webAudio && i && t.stop(e._id, !0).play(e._id),
                t._webAudio && i)
              ) {
                t._emit("play", e._id),
                  (e._seek = e._start || 0),
                  (e._rateSeek = 0),
                  (e._playStart = s.ctx.currentTime);
                var r = (1e3 * (e._stop - e._start)) / Math.abs(e._rate);
                t._endTimers[e._id] = setTimeout(t._ended.bind(t, e), r);
              }
              return (
                t._webAudio &&
                  !i &&
                  ((e._paused = !0),
                  (e._ended = !0),
                  (e._seek = e._start || 0),
                  (e._rateSeek = 0),
                  t._clearTimer(e._id),
                  t._cleanBuffer(e._node),
                  s._autoSuspend()),
                t._webAudio || i || t.stop(e._id, !0),
                t
              );
            },
            _clearTimer: function (e) {
              var t = this;
              if (t._endTimers[e]) {
                if ("function" != typeof t._endTimers[e])
                  clearTimeout(t._endTimers[e]);
                else {
                  var n = t._soundById(e);
                  n &&
                    n._node &&
                    n._node.removeEventListener("ended", t._endTimers[e], !1);
                }
                delete t._endTimers[e];
              }
              return t;
            },
            _soundById: function (e) {
              for (var t = this, n = 0; n < t._sounds.length; n++)
                if (e === t._sounds[n]._id) return t._sounds[n];
              return null;
            },
            _inactiveSound: function () {
              var e = this;
              e._drain();
              for (var t = 0; t < e._sounds.length; t++)
                if (e._sounds[t]._ended) return e._sounds[t].reset();
              return new o(e);
            },
            _drain: function () {
              var e = this,
                t = e._pool,
                n = 0,
                i = 0;
              if (!(e._sounds.length < t)) {
                for (i = 0; i < e._sounds.length; i++)
                  e._sounds[i]._ended && n++;
                for (i = e._sounds.length - 1; i >= 0; i--) {
                  if (n <= t) return;
                  e._sounds[i]._ended &&
                    (e._webAudio &&
                      e._sounds[i]._node &&
                      e._sounds[i]._node.disconnect(0),
                    e._sounds.splice(i, 1),
                    n--);
                }
              }
            },
            _getSoundIds: function (e) {
              if (void 0 === e) {
                for (var t = [], n = 0; n < this._sounds.length; n++)
                  t.push(this._sounds[n]._id);
                return t;
              }
              return [e];
            },
            _refreshBuffer: function (e) {
              return (
                (e._node.bufferSource = s.ctx.createBufferSource()),
                (e._node.bufferSource.buffer = c[this._src]),
                e._panner
                  ? e._node.bufferSource.connect(e._panner)
                  : e._node.bufferSource.connect(e._node),
                (e._node.bufferSource.loop = e._loop),
                e._loop &&
                  ((e._node.bufferSource.loopStart = e._start || 0),
                  (e._node.bufferSource.loopEnd = e._stop || 0)),
                e._node.bufferSource.playbackRate.setValueAtTime(
                  e._rate,
                  s.ctx.currentTime
                ),
                this
              );
            },
            _cleanBuffer: function (e) {
              var t = s._navigator && s._navigator.vendor.indexOf("Apple") >= 0;
              if (!e.bufferSource) return this;
              if (
                s._scratchBuffer &&
                e.bufferSource &&
                ((e.bufferSource.onended = null),
                e.bufferSource.disconnect(0),
                t)
              )
                try {
                  e.bufferSource.buffer = s._scratchBuffer;
                } catch (e) {}
              return (e.bufferSource = null), this;
            },
            _clearSound: function (e) {
              /MSIE |Trident\//.test(s._navigator && s._navigator.userAgent) ||
                (e.src =
                  "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA");
            },
          };
          var o = function (e) {
            (this._parent = e), this.init();
          };
          o.prototype = {
            init: function () {
              var e = this,
                t = e._parent;
              return (
                (e._muted = t._muted),
                (e._loop = t._loop),
                (e._volume = t._volume),
                (e._rate = t._rate),
                (e._seek = 0),
                (e._paused = !0),
                (e._ended = !0),
                (e._sprite = "__default"),
                (e._id = ++s._counter),
                t._sounds.push(e),
                e.create(),
                e
              );
            },
            create: function () {
              var e = this,
                t = e._parent,
                n = s._muted || e._muted || e._parent._muted ? 0 : e._volume;
              return (
                t._webAudio
                  ? ((e._node =
                      void 0 === s.ctx.createGain
                        ? s.ctx.createGainNode()
                        : s.ctx.createGain()),
                    e._node.gain.setValueAtTime(n, s.ctx.currentTime),
                    (e._node.paused = !0),
                    e._node.connect(s.masterGain))
                  : s.noAudio ||
                    ((e._node = s._obtainHtml5Audio()),
                    (e._errorFn = e._errorListener.bind(e)),
                    e._node.addEventListener("error", e._errorFn, !1),
                    (e._loadFn = e._loadListener.bind(e)),
                    e._node.addEventListener(s._canPlayEvent, e._loadFn, !1),
                    (e._endFn = e._endListener.bind(e)),
                    e._node.addEventListener("ended", e._endFn, !1),
                    (e._node.src = t._src),
                    (e._node.preload = !0 === t._preload ? "auto" : t._preload),
                    (e._node.volume = n * s.volume()),
                    e._node.load()),
                e
              );
            },
            reset: function () {
              var e = this,
                t = e._parent;
              return (
                (e._muted = t._muted),
                (e._loop = t._loop),
                (e._volume = t._volume),
                (e._rate = t._rate),
                (e._seek = 0),
                (e._rateSeek = 0),
                (e._paused = !0),
                (e._ended = !0),
                (e._sprite = "__default"),
                (e._id = ++s._counter),
                e
              );
            },
            _errorListener: function () {
              var e = this;
              e._parent._emit(
                "loaderror",
                e._id,
                e._node.error ? e._node.error.code : 0
              ),
                e._node.removeEventListener("error", e._errorFn, !1);
            },
            _loadListener: function () {
              var e = this,
                t = e._parent;
              (t._duration = Math.ceil(10 * e._node.duration) / 10),
                0 === Object.keys(t._sprite).length &&
                  (t._sprite = { __default: [0, 1e3 * t._duration] }),
                "loaded" !== t._state &&
                  ((t._state = "loaded"), t._emit("load"), t._loadQueue()),
                e._node.removeEventListener(s._canPlayEvent, e._loadFn, !1);
            },
            _endListener: function () {
              var e = this,
                t = e._parent;
              t._duration === 1 / 0 &&
                ((t._duration = Math.ceil(10 * e._node.duration) / 10),
                t._sprite.__default[1] === 1 / 0 &&
                  (t._sprite.__default[1] = 1e3 * t._duration),
                t._ended(e)),
                e._node.removeEventListener("ended", e._endFn, !1);
            },
          };
          var c = {},
            l = function (e) {
              var t = e._src;
              if (c[t]) return (e._duration = c[t].duration), void d(e);
              if (/^data:[^;]+;base64,/.test(t)) {
                for (
                  var n = atob(t.split(",")[1]),
                    i = new Uint8Array(n.length),
                    r = 0;
                  r < n.length;
                  ++r
                )
                  i[r] = n.charCodeAt(r);
                h(i.buffer, e);
              } else {
                var s = new XMLHttpRequest();
                s.open(e._xhr.method, t, !0),
                  (s.withCredentials = e._xhr.withCredentials),
                  (s.responseType = "arraybuffer"),
                  e._xhr.headers &&
                    Object.keys(e._xhr.headers).forEach(function (t) {
                      s.setRequestHeader(t, e._xhr.headers[t]);
                    }),
                  (s.onload = function () {
                    var t = (s.status + "")[0];
                    "0" === t || "2" === t || "3" === t
                      ? h(s.response, e)
                      : e._emit(
                          "loaderror",
                          null,
                          "Failed loading audio file with status: " +
                            s.status +
                            "."
                        );
                  }),
                  (s.onerror = function () {
                    e._webAudio &&
                      ((e._html5 = !0),
                      (e._webAudio = !1),
                      (e._sounds = []),
                      delete c[t],
                      e.load());
                  }),
                  u(s);
              }
            },
            u = function (e) {
              try {
                e.send();
              } catch (t) {
                e.onerror();
              }
            },
            h = function (e, t) {
              var n = function () {
                  t._emit("loaderror", null, "Decoding audio data failed.");
                },
                i = function (e) {
                  e && t._sounds.length > 0 ? ((c[t._src] = e), d(t, e)) : n();
                };
              "undefined" != typeof Promise &&
              1 === s.ctx.decodeAudioData.length
                ? s.ctx.decodeAudioData(e).then(i).catch(n)
                : s.ctx.decodeAudioData(e, i, n);
            },
            d = function (e, t) {
              t && !e._duration && (e._duration = t.duration),
                0 === Object.keys(e._sprite).length &&
                  (e._sprite = { __default: [0, 1e3 * e._duration] }),
                "loaded" !== e._state &&
                  ((e._state = "loaded"), e._emit("load"), e._loadQueue());
            },
            p = function () {
              if (s.usingWebAudio) {
                try {
                  "undefined" != typeof AudioContext
                    ? (s.ctx = new AudioContext())
                    : "undefined" != typeof webkitAudioContext
                    ? (s.ctx = new webkitAudioContext())
                    : (s.usingWebAudio = !1);
                } catch (e) {
                  s.usingWebAudio = !1;
                }
                s.ctx || (s.usingWebAudio = !1);
                var e = /iP(hone|od|ad)/.test(
                    s._navigator && s._navigator.platform
                  ),
                  t =
                    s._navigator &&
                    s._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),
                  n = t ? parseInt(t[1], 10) : null;
                if (e && n && n < 9) {
                  var i = /safari/.test(
                    s._navigator && s._navigator.userAgent.toLowerCase()
                  );
                  s._navigator && !i && (s.usingWebAudio = !1);
                }
                s.usingWebAudio &&
                  ((s.masterGain =
                    void 0 === s.ctx.createGain
                      ? s.ctx.createGainNode()
                      : s.ctx.createGain()),
                  s.masterGain.gain.setValueAtTime(
                    s._muted ? 0 : s._volume,
                    s.ctx.currentTime
                  ),
                  s.masterGain.connect(s.ctx.destination)),
                  s._setup();
              }
            };
          void 0 ===
            (i = function () {
              return { Howler: s, Howl: a };
            }.apply(t, [])) || (e.exports = i),
            (t.Howler = s),
            (t.Howl = a),
            void 0 !== n.g
              ? ((n.g.HowlerGlobal = r),
                (n.g.Howler = s),
                (n.g.Howl = a),
                (n.g.Sound = o))
              : "undefined" != typeof window &&
                ((window.HowlerGlobal = r),
                (window.Howler = s),
                (window.Howl = a),
                (window.Sound = o));
        })(),
          (function () {
            "use strict";
            var e;
            (HowlerGlobal.prototype._pos = [0, 0, 0]),
              (HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0]),
              (HowlerGlobal.prototype.stereo = function (e) {
                var t = this;
                if (!t.ctx || !t.ctx.listener) return t;
                for (var n = t._howls.length - 1; n >= 0; n--)
                  t._howls[n].stereo(e);
                return t;
              }),
              (HowlerGlobal.prototype.pos = function (e, t, n) {
                var i = this;
                return i.ctx && i.ctx.listener
                  ? ((t = "number" != typeof t ? i._pos[1] : t),
                    (n = "number" != typeof n ? i._pos[2] : n),
                    "number" != typeof e
                      ? i._pos
                      : ((i._pos = [e, t, n]),
                        void 0 !== i.ctx.listener.positionX
                          ? (i.ctx.listener.positionX.setTargetAtTime(
                              i._pos[0],
                              Howler.ctx.currentTime,
                              0.1
                            ),
                            i.ctx.listener.positionY.setTargetAtTime(
                              i._pos[1],
                              Howler.ctx.currentTime,
                              0.1
                            ),
                            i.ctx.listener.positionZ.setTargetAtTime(
                              i._pos[2],
                              Howler.ctx.currentTime,
                              0.1
                            ))
                          : i.ctx.listener.setPosition(
                              i._pos[0],
                              i._pos[1],
                              i._pos[2]
                            ),
                        i))
                  : i;
              }),
              (HowlerGlobal.prototype.orientation = function (
                e,
                t,
                n,
                i,
                r,
                s
              ) {
                var a = this;
                if (!a.ctx || !a.ctx.listener) return a;
                var o = a._orientation;
                return (
                  (t = "number" != typeof t ? o[1] : t),
                  (n = "number" != typeof n ? o[2] : n),
                  (i = "number" != typeof i ? o[3] : i),
                  (r = "number" != typeof r ? o[4] : r),
                  (s = "number" != typeof s ? o[5] : s),
                  "number" != typeof e
                    ? o
                    : ((a._orientation = [e, t, n, i, r, s]),
                      void 0 !== a.ctx.listener.forwardX
                        ? (a.ctx.listener.forwardX.setTargetAtTime(
                            e,
                            Howler.ctx.currentTime,
                            0.1
                          ),
                          a.ctx.listener.forwardY.setTargetAtTime(
                            t,
                            Howler.ctx.currentTime,
                            0.1
                          ),
                          a.ctx.listener.forwardZ.setTargetAtTime(
                            n,
                            Howler.ctx.currentTime,
                            0.1
                          ),
                          a.ctx.listener.upX.setTargetAtTime(
                            i,
                            Howler.ctx.currentTime,
                            0.1
                          ),
                          a.ctx.listener.upY.setTargetAtTime(
                            r,
                            Howler.ctx.currentTime,
                            0.1
                          ),
                          a.ctx.listener.upZ.setTargetAtTime(
                            s,
                            Howler.ctx.currentTime,
                            0.1
                          ))
                        : a.ctx.listener.setOrientation(e, t, n, i, r, s),
                      a)
                );
              }),
              (Howl.prototype.init =
                ((e = Howl.prototype.init),
                function (t) {
                  var n = this;
                  return (
                    (n._orientation = t.orientation || [1, 0, 0]),
                    (n._stereo = t.stereo || null),
                    (n._pos = t.pos || null),
                    (n._pannerAttr = {
                      coneInnerAngle:
                        void 0 !== t.coneInnerAngle ? t.coneInnerAngle : 360,
                      coneOuterAngle:
                        void 0 !== t.coneOuterAngle ? t.coneOuterAngle : 360,
                      coneOuterGain:
                        void 0 !== t.coneOuterGain ? t.coneOuterGain : 0,
                      distanceModel:
                        void 0 !== t.distanceModel
                          ? t.distanceModel
                          : "inverse",
                      maxDistance:
                        void 0 !== t.maxDistance ? t.maxDistance : 1e4,
                      panningModel:
                        void 0 !== t.panningModel ? t.panningModel : "HRTF",
                      refDistance: void 0 !== t.refDistance ? t.refDistance : 1,
                      rolloffFactor:
                        void 0 !== t.rolloffFactor ? t.rolloffFactor : 1,
                    }),
                    (n._onstereo = t.onstereo ? [{ fn: t.onstereo }] : []),
                    (n._onpos = t.onpos ? [{ fn: t.onpos }] : []),
                    (n._onorientation = t.onorientation
                      ? [{ fn: t.onorientation }]
                      : []),
                    e.call(this, t)
                  );
                })),
              (Howl.prototype.stereo = function (e, n) {
                var i = this;
                if (!i._webAudio) return i;
                if ("loaded" !== i._state)
                  return (
                    i._queue.push({
                      event: "stereo",
                      action: function () {
                        i.stereo(e, n);
                      },
                    }),
                    i
                  );
                var r =
                  void 0 === Howler.ctx.createStereoPanner
                    ? "spatial"
                    : "stereo";
                if (void 0 === n) {
                  if ("number" != typeof e) return i._stereo;
                  (i._stereo = e), (i._pos = [e, 0, 0]);
                }
                for (var s = i._getSoundIds(n), a = 0; a < s.length; a++) {
                  var o = i._soundById(s[a]);
                  if (o) {
                    if ("number" != typeof e) return o._stereo;
                    (o._stereo = e),
                      (o._pos = [e, 0, 0]),
                      o._node &&
                        ((o._pannerAttr.panningModel = "equalpower"),
                        (o._panner && o._panner.pan) || t(o, r),
                        "spatial" === r
                          ? void 0 !== o._panner.positionX
                            ? (o._panner.positionX.setValueAtTime(
                                e,
                                Howler.ctx.currentTime
                              ),
                              o._panner.positionY.setValueAtTime(
                                0,
                                Howler.ctx.currentTime
                              ),
                              o._panner.positionZ.setValueAtTime(
                                0,
                                Howler.ctx.currentTime
                              ))
                            : o._panner.setPosition(e, 0, 0)
                          : o._panner.pan.setValueAtTime(
                              e,
                              Howler.ctx.currentTime
                            )),
                      i._emit("stereo", o._id);
                  }
                }
                return i;
              }),
              (Howl.prototype.pos = function (e, n, i, r) {
                var s = this;
                if (!s._webAudio) return s;
                if ("loaded" !== s._state)
                  return (
                    s._queue.push({
                      event: "pos",
                      action: function () {
                        s.pos(e, n, i, r);
                      },
                    }),
                    s
                  );
                if (
                  ((n = "number" != typeof n ? 0 : n),
                  (i = "number" != typeof i ? -0.5 : i),
                  void 0 === r)
                ) {
                  if ("number" != typeof e) return s._pos;
                  s._pos = [e, n, i];
                }
                for (var a = s._getSoundIds(r), o = 0; o < a.length; o++) {
                  var c = s._soundById(a[o]);
                  if (c) {
                    if ("number" != typeof e) return c._pos;
                    (c._pos = [e, n, i]),
                      c._node &&
                        ((c._panner && !c._panner.pan) || t(c, "spatial"),
                        void 0 !== c._panner.positionX
                          ? (c._panner.positionX.setValueAtTime(
                              e,
                              Howler.ctx.currentTime
                            ),
                            c._panner.positionY.setValueAtTime(
                              n,
                              Howler.ctx.currentTime
                            ),
                            c._panner.positionZ.setValueAtTime(
                              i,
                              Howler.ctx.currentTime
                            ))
                          : c._panner.setPosition(e, n, i)),
                      s._emit("pos", c._id);
                  }
                }
                return s;
              }),
              (Howl.prototype.orientation = function (e, n, i, r) {
                var s = this;
                if (!s._webAudio) return s;
                if ("loaded" !== s._state)
                  return (
                    s._queue.push({
                      event: "orientation",
                      action: function () {
                        s.orientation(e, n, i, r);
                      },
                    }),
                    s
                  );
                if (
                  ((n = "number" != typeof n ? s._orientation[1] : n),
                  (i = "number" != typeof i ? s._orientation[2] : i),
                  void 0 === r)
                ) {
                  if ("number" != typeof e) return s._orientation;
                  s._orientation = [e, n, i];
                }
                for (var a = s._getSoundIds(r), o = 0; o < a.length; o++) {
                  var c = s._soundById(a[o]);
                  if (c) {
                    if ("number" != typeof e) return c._orientation;
                    (c._orientation = [e, n, i]),
                      c._node &&
                        (c._panner ||
                          (c._pos || (c._pos = s._pos || [0, 0, -0.5]),
                          t(c, "spatial")),
                        void 0 !== c._panner.orientationX
                          ? (c._panner.orientationX.setValueAtTime(
                              e,
                              Howler.ctx.currentTime
                            ),
                            c._panner.orientationY.setValueAtTime(
                              n,
                              Howler.ctx.currentTime
                            ),
                            c._panner.orientationZ.setValueAtTime(
                              i,
                              Howler.ctx.currentTime
                            ))
                          : c._panner.setOrientation(e, n, i)),
                      s._emit("orientation", c._id);
                  }
                }
                return s;
              }),
              (Howl.prototype.pannerAttr = function () {
                var e,
                  n,
                  i,
                  r = this,
                  s = arguments;
                if (!r._webAudio) return r;
                if (0 === s.length) return r._pannerAttr;
                if (1 === s.length) {
                  if ("object" != typeof s[0])
                    return (i = r._soundById(parseInt(s[0], 10)))
                      ? i._pannerAttr
                      : r._pannerAttr;
                  (e = s[0]),
                    void 0 === n &&
                      (e.pannerAttr ||
                        (e.pannerAttr = {
                          coneInnerAngle: e.coneInnerAngle,
                          coneOuterAngle: e.coneOuterAngle,
                          coneOuterGain: e.coneOuterGain,
                          distanceModel: e.distanceModel,
                          maxDistance: e.maxDistance,
                          refDistance: e.refDistance,
                          rolloffFactor: e.rolloffFactor,
                          panningModel: e.panningModel,
                        }),
                      (r._pannerAttr = {
                        coneInnerAngle:
                          void 0 !== e.pannerAttr.coneInnerAngle
                            ? e.pannerAttr.coneInnerAngle
                            : r._coneInnerAngle,
                        coneOuterAngle:
                          void 0 !== e.pannerAttr.coneOuterAngle
                            ? e.pannerAttr.coneOuterAngle
                            : r._coneOuterAngle,
                        coneOuterGain:
                          void 0 !== e.pannerAttr.coneOuterGain
                            ? e.pannerAttr.coneOuterGain
                            : r._coneOuterGain,
                        distanceModel:
                          void 0 !== e.pannerAttr.distanceModel
                            ? e.pannerAttr.distanceModel
                            : r._distanceModel,
                        maxDistance:
                          void 0 !== e.pannerAttr.maxDistance
                            ? e.pannerAttr.maxDistance
                            : r._maxDistance,
                        refDistance:
                          void 0 !== e.pannerAttr.refDistance
                            ? e.pannerAttr.refDistance
                            : r._refDistance,
                        rolloffFactor:
                          void 0 !== e.pannerAttr.rolloffFactor
                            ? e.pannerAttr.rolloffFactor
                            : r._rolloffFactor,
                        panningModel:
                          void 0 !== e.pannerAttr.panningModel
                            ? e.pannerAttr.panningModel
                            : r._panningModel,
                      }));
                } else 2 === s.length && ((e = s[0]), (n = parseInt(s[1], 10)));
                for (var a = r._getSoundIds(n), o = 0; o < a.length; o++)
                  if ((i = r._soundById(a[o]))) {
                    var c = i._pannerAttr;
                    c = {
                      coneInnerAngle:
                        void 0 !== e.coneInnerAngle
                          ? e.coneInnerAngle
                          : c.coneInnerAngle,
                      coneOuterAngle:
                        void 0 !== e.coneOuterAngle
                          ? e.coneOuterAngle
                          : c.coneOuterAngle,
                      coneOuterGain:
                        void 0 !== e.coneOuterGain
                          ? e.coneOuterGain
                          : c.coneOuterGain,
                      distanceModel:
                        void 0 !== e.distanceModel
                          ? e.distanceModel
                          : c.distanceModel,
                      maxDistance:
                        void 0 !== e.maxDistance
                          ? e.maxDistance
                          : c.maxDistance,
                      refDistance:
                        void 0 !== e.refDistance
                          ? e.refDistance
                          : c.refDistance,
                      rolloffFactor:
                        void 0 !== e.rolloffFactor
                          ? e.rolloffFactor
                          : c.rolloffFactor,
                      panningModel:
                        void 0 !== e.panningModel
                          ? e.panningModel
                          : c.panningModel,
                    };
                    var l = i._panner;
                    l ||
                      (i._pos || (i._pos = r._pos || [0, 0, -0.5]),
                      t(i, "spatial"),
                      (l = i._panner)),
                      (l.coneInnerAngle = c.coneInnerAngle),
                      (l.coneOuterAngle = c.coneOuterAngle),
                      (l.coneOuterGain = c.coneOuterGain),
                      (l.distanceModel = c.distanceModel),
                      (l.maxDistance = c.maxDistance),
                      (l.refDistance = c.refDistance),
                      (l.rolloffFactor = c.rolloffFactor),
                      (l.panningModel = c.panningModel);
                  }
                return r;
              }),
              (Sound.prototype.init = (function (e) {
                return function () {
                  var t = this,
                    n = t._parent;
                  (t._orientation = n._orientation),
                    (t._stereo = n._stereo),
                    (t._pos = n._pos),
                    (t._pannerAttr = n._pannerAttr),
                    e.call(this),
                    t._stereo
                      ? n.stereo(t._stereo)
                      : t._pos && n.pos(t._pos[0], t._pos[1], t._pos[2], t._id);
                };
              })(Sound.prototype.init)),
              (Sound.prototype.reset = (function (e) {
                return function () {
                  var t = this,
                    n = t._parent;
                  return (
                    (t._orientation = n._orientation),
                    (t._stereo = n._stereo),
                    (t._pos = n._pos),
                    (t._pannerAttr = n._pannerAttr),
                    t._stereo
                      ? n.stereo(t._stereo)
                      : t._pos
                      ? n.pos(t._pos[0], t._pos[1], t._pos[2], t._id)
                      : t._panner &&
                        (t._panner.disconnect(0),
                        (t._panner = void 0),
                        n._refreshBuffer(t)),
                    e.call(this)
                  );
                };
              })(Sound.prototype.reset));
            var t = function (e, t) {
              "spatial" === (t = t || "spatial")
                ? ((e._panner = Howler.ctx.createPanner()),
                  (e._panner.coneInnerAngle = e._pannerAttr.coneInnerAngle),
                  (e._panner.coneOuterAngle = e._pannerAttr.coneOuterAngle),
                  (e._panner.coneOuterGain = e._pannerAttr.coneOuterGain),
                  (e._panner.distanceModel = e._pannerAttr.distanceModel),
                  (e._panner.maxDistance = e._pannerAttr.maxDistance),
                  (e._panner.refDistance = e._pannerAttr.refDistance),
                  (e._panner.rolloffFactor = e._pannerAttr.rolloffFactor),
                  (e._panner.panningModel = e._pannerAttr.panningModel),
                  void 0 !== e._panner.positionX
                    ? (e._panner.positionX.setValueAtTime(
                        e._pos[0],
                        Howler.ctx.currentTime
                      ),
                      e._panner.positionY.setValueAtTime(
                        e._pos[1],
                        Howler.ctx.currentTime
                      ),
                      e._panner.positionZ.setValueAtTime(
                        e._pos[2],
                        Howler.ctx.currentTime
                      ))
                    : e._panner.setPosition(e._pos[0], e._pos[1], e._pos[2]),
                  void 0 !== e._panner.orientationX
                    ? (e._panner.orientationX.setValueAtTime(
                        e._orientation[0],
                        Howler.ctx.currentTime
                      ),
                      e._panner.orientationY.setValueAtTime(
                        e._orientation[1],
                        Howler.ctx.currentTime
                      ),
                      e._panner.orientationZ.setValueAtTime(
                        e._orientation[2],
                        Howler.ctx.currentTime
                      ))
                    : e._panner.setOrientation(
                        e._orientation[0],
                        e._orientation[1],
                        e._orientation[2]
                      ))
                : ((e._panner = Howler.ctx.createStereoPanner()),
                  e._panner.pan.setValueAtTime(
                    e._stereo,
                    Howler.ctx.currentTime
                  )),
                e._panner.connect(e._node),
                e._paused || e._parent.pause(e._id, !0).play(e._id, !0);
            };
          })();
      },
      336: (e) => {
        var t, n;
        (t = []),
          (n = []),
          (e.exports = function (e, i, r) {
            var s, a, o, c, l, u, h, d;
            if (e === i) return 0;
            if (((s = e.length), (a = i.length), 0 === s)) return a;
            if (0 === a) return s;
            for (
              r && ((e = e.toLowerCase()), (i = i.toLowerCase())), h = 0;
              h < s;

            )
              (n[h] = e.charCodeAt(h)), (t[h] = ++h);
            for (d = 0; d < a; )
              for (o = i.charCodeAt(d), c = l = d++, h = -1; ++h < s; )
                (u = o === n[h] ? l : l + 1),
                  (l = t[h]),
                  (t[h] = c = l > c ? (u > c ? c + 1 : u) : u > l ? l + 1 : u);
            return c;
          });
      },
      722: (e, t, n) => {
        var i = n(336);
        e.exports = function () {
          var e,
            t,
            n,
            r,
            s,
            a = 0,
            o = arguments[0],
            c = arguments[1],
            l = c.length,
            u = arguments[2];
          u && ((r = u.threshold), (s = u.ignoreCase)), void 0 === r && (r = 0);
          for (var h = 0; h < l; ++h)
            (e =
              (t = s ? i(o, c[h], !0) : i(o, c[h])) > o.length
                ? 1 - t / c[h].length
                : 1 - t / o.length) > a && ((a = e), (n = c[h]));
          return a >= r ? n : null;
        };
      },
      52: function (e) {
        var t;
        e.exports =
          (((t = function () {
            function e(e) {
              return r.appendChild(e.dom), e;
            }
            function n(e) {
              for (var t = 0; t < r.children.length; t++)
                r.children[t].style.display = t === e ? "block" : "none";
              i = e;
            }
            var i = 0,
              r = document.createElement("div");
            (r.style.cssText =
              "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000"),
              r.addEventListener(
                "click",
                function (e) {
                  e.preventDefault(), n(++i % r.children.length);
                },
                !1
              );
            var s = (performance || Date).now(),
              a = s,
              o = 0,
              c = e(new t.Panel("FPS", "#0ff", "#002")),
              l = e(new t.Panel("MS", "#0f0", "#020"));
            if (self.performance && self.performance.memory)
              var u = e(new t.Panel("MB", "#f08", "#201"));
            return (
              n(0),
              {
                REVISION: 16,
                dom: r,
                addPanel: e,
                showPanel: n,
                begin: function () {
                  s = (performance || Date).now();
                },
                end: function () {
                  o++;
                  var e = (performance || Date).now();
                  if (
                    (l.update(e - s, 200),
                    e > a + 1e3 &&
                      (c.update((1e3 * o) / (e - a), 100), (a = e), (o = 0), u))
                  ) {
                    var t = performance.memory;
                    u.update(
                      t.usedJSHeapSize / 1048576,
                      t.jsHeapSizeLimit / 1048576
                    );
                  }
                  return e;
                },
                update: function () {
                  s = this.end();
                },
                domElement: r,
                setMode: n,
              }
            );
          }).Panel = function (e, t, n) {
            var i = 1 / 0,
              r = 0,
              s = Math.round,
              a = s(window.devicePixelRatio || 1),
              o = 80 * a,
              c = 48 * a,
              l = 3 * a,
              u = 2 * a,
              h = 3 * a,
              d = 15 * a,
              p = 74 * a,
              f = 30 * a,
              A = document.createElement("canvas");
            (A.width = o),
              (A.height = c),
              (A.style.cssText = "width:80px;height:48px");
            var g = A.getContext("2d");
            return (
              (g.font = "bold " + 9 * a + "px Helvetica,Arial,sans-serif"),
              (g.textBaseline = "top"),
              (g.fillStyle = n),
              g.fillRect(0, 0, o, c),
              (g.fillStyle = t),
              g.fillText(e, l, u),
              g.fillRect(h, d, p, f),
              (g.fillStyle = n),
              (g.globalAlpha = 0.9),
              g.fillRect(h, d, p, f),
              {
                dom: A,
                update: function (c, m) {
                  (i = Math.min(i, c)),
                    (r = Math.max(r, c)),
                    (g.fillStyle = n),
                    (g.globalAlpha = 1),
                    g.fillRect(0, 0, o, d),
                    (g.fillStyle = t),
                    g.fillText(
                      s(c) + " " + e + " (" + s(i) + "-" + s(r) + ")",
                      l,
                      u
                    ),
                    g.drawImage(A, h + a, d, p - a, f, h, d, p - a, f),
                    g.fillRect(h + p - a, d, a, f),
                    (g.fillStyle = n),
                    (g.globalAlpha = 0.9),
                    g.fillRect(h + p - a, d, a, s((1 - c / m) * f));
                },
              }
            );
          }),
          t);
      },
      314: (e) => {
        e.exports = (function () {
          function e(e, t, n, i) {
            this.set(e, t, n, i);
          }
          return (
            (e.prototype.set = function (e, t, n, i) {
              (this._cx = 3 * e),
                (this._bx = 3 * (n - e) - this._cx),
                (this._ax = 1 - this._cx - this._bx),
                (this._cy = 3 * t),
                (this._by = 3 * (i - t) - this._cy),
                (this._ay = 1 - this._cy - this._by);
            }),
            (e.epsilon = 1e-6),
            (e.prototype._sampleCurveX = function (e) {
              return ((this._ax * e + this._bx) * e + this._cx) * e;
            }),
            (e.prototype._sampleCurveY = function (e) {
              return ((this._ay * e + this._by) * e + this._cy) * e;
            }),
            (e.prototype._sampleCurveDerivativeX = function (e) {
              return (3 * this._ax * e + 2 * this._bx) * e + this._cx;
            }),
            (e.prototype._solveCurveX = function (e, t) {
              var n, i, r, s, a, o;
              for (
                r = void 0,
                  s = void 0,
                  a = void 0,
                  o = void 0,
                  n = void 0,
                  i = void 0,
                  a = e,
                  i = 0;
                i < 8;

              ) {
                if (((o = this._sampleCurveX(a) - e), Math.abs(o) < t))
                  return a;
                if (((n = this._sampleCurveDerivativeX(a)), Math.abs(n) < t))
                  break;
                (a -= o / n), i++;
              }
              if ((a = e) < (r = 0)) return r;
              if (a > (s = 1)) return s;
              for (; r < s; ) {
                if (((o = this._sampleCurveX(a)), Math.abs(o - e) < t))
                  return a;
                e > o ? (r = a) : (s = a), (a = 0.5 * (s - r) + r);
              }
              return a;
            }),
            (e.prototype.solve = function (e, t) {
              return this._sampleCurveY(this._solveCurveX(e, t));
            }),
            (e.prototype.solveSimple = function (e) {
              return this._sampleCurveY(this._solveCurveX(e, 1e-6));
            }),
            e
          );
        })();
      },
    },
    t = {};
  function n(i) {
    var r = t[i];
    if (void 0 !== r) return r.exports;
    var s = (t[i] = { exports: {} });
    return e[i].call(s.exports, s, s.exports, n), s.exports;
  }
  (n.n = (e) => {
    var t = e && e.__esModule ? () => e.default : () => e;
    return n.d(t, { a: t }), t;
  }),
    (n.d = (e, t) => {
      for (var i in t)
        n.o(t, i) &&
          !n.o(e, i) &&
          Object.defineProperty(e, i, { enumerable: !0, get: t[i] });
    }),
    (n.g = (function () {
      if ("object" == typeof globalThis) return globalThis;
      try {
        return this || new Function("return this")();
      } catch (e) {
        if ("object" == typeof window) return window;
      }
    })()),
    (n.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t)),
    (() => {
      "use strict";
      const e = Array.isArray;
      const t =
        "object" == typeof global &&
        global &&
        global.Object === Object &&
        global;
      var i = "object" == typeof self && self && self.Object === Object && self;
      const r = t || i || Function("return this")();
      const s = r.Symbol;
      var a = Object.prototype,
        o = a.hasOwnProperty,
        c = a.toString,
        l = s ? s.toStringTag : void 0;
      const u = function (e) {
        var t = o.call(e, l),
          n = e[l];
        try {
          e[l] = void 0;
          var i = !0;
        } catch (e) {}
        var r = c.call(e);
        return i && (t ? (e[l] = n) : delete e[l]), r;
      };
      var h = Object.prototype.toString;
      const d = function (e) {
        return h.call(e);
      };
      var p = s ? s.toStringTag : void 0;
      const f = function (e) {
        return null == e
          ? void 0 === e
            ? "[object Undefined]"
            : "[object Null]"
          : p && p in Object(e)
          ? u(e)
          : d(e);
      };
      const A = function (e) {
        return null != e && "object" == typeof e;
      };
      const g = function (e) {
        return "symbol" == typeof e || (A(e) && "[object Symbol]" == f(e));
      };
      var m = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        v = /^\w*$/;
      const y = function (t, n) {
        if (e(t)) return !1;
        var i = typeof t;
        return (
          !(
            "number" != i &&
            "symbol" != i &&
            "boolean" != i &&
            null != t &&
            !g(t)
          ) ||
          v.test(t) ||
          !m.test(t) ||
          (null != n && t in Object(n))
        );
      };
      const b = function (e) {
        var t = typeof e;
        return null != e && ("object" == t || "function" == t);
      };
      const _ = function (e) {
        if (!b(e)) return !1;
        var t = f(e);
        return (
          "[object Function]" == t ||
          "[object GeneratorFunction]" == t ||
          "[object AsyncFunction]" == t ||
          "[object Proxy]" == t
        );
      };
      const x = r["__core-js_shared__"];
      var E,
        w = (E = /[^.]+$/.exec((x && x.keys && x.keys.IE_PROTO) || ""))
          ? "Symbol(src)_1." + E
          : "";
      const C = function (e) {
        return !!w && w in e;
      };
      var S = Function.prototype.toString;
      const I = function (e) {
        if (null != e) {
          try {
            return S.call(e);
          } catch (e) {}
          try {
            return e + "";
          } catch (e) {}
        }
        return "";
      };
      var M = /^\[object .+?Constructor\]$/,
        T = Function.prototype,
        B = Object.prototype,
        R = T.toString,
        D = B.hasOwnProperty,
        P = RegExp(
          "^" +
            R.call(D)
              .replace(/[\\^$.*+?()[\]{}|]/g, "\\$&")
              .replace(
                /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                "$1.*?"
              ) +
            "$"
        );
      const L = function (e) {
        return !(!b(e) || C(e)) && (_(e) ? P : M).test(I(e));
      };
      const U = function (e, t) {
        return null == e ? void 0 : e[t];
      };
      const F = function (e, t) {
        var n = U(e, t);
        return L(n) ? n : void 0;
      };
      const O = F(Object, "create");
      const N = function () {
        (this.__data__ = O ? O(null) : {}), (this.size = 0);
      };
      const k = function (e) {
        var t = this.has(e) && delete this.__data__[e];
        return (this.size -= t ? 1 : 0), t;
      };
      var Q = Object.prototype.hasOwnProperty;
      const G = function (e) {
        var t = this.__data__;
        if (O) {
          var n = t[e];
          return "__lodash_hash_undefined__" === n ? void 0 : n;
        }
        return Q.call(t, e) ? t[e] : void 0;
      };
      var H = Object.prototype.hasOwnProperty;
      const z = function (e) {
        var t = this.__data__;
        return O ? void 0 !== t[e] : H.call(t, e);
      };
      const V = function (e, t) {
        var n = this.__data__;
        return (
          (this.size += this.has(e) ? 0 : 1),
          (n[e] = O && void 0 === t ? "__lodash_hash_undefined__" : t),
          this
        );
      };
      function j(e) {
        var t = -1,
          n = null == e ? 0 : e.length;
        for (this.clear(); ++t < n; ) {
          var i = e[t];
          this.set(i[0], i[1]);
        }
      }
      (j.prototype.clear = N),
        (j.prototype.delete = k),
        (j.prototype.get = G),
        (j.prototype.has = z),
        (j.prototype.set = V);
      const W = j;
      const X = function () {
        (this.__data__ = []), (this.size = 0);
      };
      const q = function (e, t) {
        return e === t || (e != e && t != t);
      };
      const Y = function (e, t) {
        for (var n = e.length; n--; ) if (q(e[n][0], t)) return n;
        return -1;
      };
      var K = Array.prototype.splice;
      const J = function (e) {
        var t = this.__data__,
          n = Y(t, e);
        return (
          !(n < 0) &&
          (n == t.length - 1 ? t.pop() : K.call(t, n, 1), --this.size, !0)
        );
      };
      const Z = function (e) {
        var t = this.__data__,
          n = Y(t, e);
        return n < 0 ? void 0 : t[n][1];
      };
      const $ = function (e) {
        return Y(this.__data__, e) > -1;
      };
      const ee = function (e, t) {
        var n = this.__data__,
          i = Y(n, e);
        return i < 0 ? (++this.size, n.push([e, t])) : (n[i][1] = t), this;
      };
      function te(e) {
        var t = -1,
          n = null == e ? 0 : e.length;
        for (this.clear(); ++t < n; ) {
          var i = e[t];
          this.set(i[0], i[1]);
        }
      }
      (te.prototype.clear = X),
        (te.prototype.delete = J),
        (te.prototype.get = Z),
        (te.prototype.has = $),
        (te.prototype.set = ee);
      const ne = te;
      const ie = F(r, "Map");
      const re = function () {
        (this.size = 0),
          (this.__data__ = {
            hash: new W(),
            map: new (ie || ne)(),
            string: new W(),
          });
      };
      const se = function (e) {
        var t = typeof e;
        return "string" == t || "number" == t || "symbol" == t || "boolean" == t
          ? "__proto__" !== e
          : null === e;
      };
      const ae = function (e, t) {
        var n = e.__data__;
        return se(t) ? n["string" == typeof t ? "string" : "hash"] : n.map;
      };
      const oe = function (e) {
        var t = ae(this, e).delete(e);
        return (this.size -= t ? 1 : 0), t;
      };
      const ce = function (e) {
        return ae(this, e).get(e);
      };
      const le = function (e) {
        return ae(this, e).has(e);
      };
      const ue = function (e, t) {
        var n = ae(this, e),
          i = n.size;
        return n.set(e, t), (this.size += n.size == i ? 0 : 1), this;
      };
      function he(e) {
        var t = -1,
          n = null == e ? 0 : e.length;
        for (this.clear(); ++t < n; ) {
          var i = e[t];
          this.set(i[0], i[1]);
        }
      }
      (he.prototype.clear = re),
        (he.prototype.delete = oe),
        (he.prototype.get = ce),
        (he.prototype.has = le),
        (he.prototype.set = ue);
      const de = he;
      function pe(e, t) {
        if ("function" != typeof e || (null != t && "function" != typeof t))
          throw new TypeError("Expected a function");
        var n = function () {
          var i = arguments,
            r = t ? t.apply(this, i) : i[0],
            s = n.cache;
          if (s.has(r)) return s.get(r);
          var a = e.apply(this, i);
          return (n.cache = s.set(r, a) || s), a;
        };
        return (n.cache = new (pe.Cache || de)()), n;
      }
      pe.Cache = de;
      const fe = pe;
      const Ae = function (e) {
        var t = fe(e, function (e) {
            return 500 === n.size && n.clear(), e;
          }),
          n = t.cache;
        return t;
      };
      var ge =
          /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
        me = /\\(\\)?/g,
        ve = Ae(function (e) {
          var t = [];
          return (
            46 === e.charCodeAt(0) && t.push(""),
            e.replace(ge, function (e, n, i, r) {
              t.push(i ? r.replace(me, "$1") : n || e);
            }),
            t
          );
        });
      const ye = ve;
      const be = function (e, t) {
        for (var n = -1, i = null == e ? 0 : e.length, r = Array(i); ++n < i; )
          r[n] = t(e[n], n, e);
        return r;
      };
      var _e = s ? s.prototype : void 0,
        xe = _e ? _e.toString : void 0;
      const Ee = function t(n) {
        if ("string" == typeof n) return n;
        if (e(n)) return be(n, t) + "";
        if (g(n)) return xe ? xe.call(n) : "";
        var i = n + "";
        return "0" == i && 1 / n == -Infinity ? "-0" : i;
      };
      const we = function (e) {
        return null == e ? "" : Ee(e);
      };
      const Ce = function (t, n) {
        return e(t) ? t : y(t, n) ? [t] : ye(we(t));
      };
      const Se = function (e) {
        if ("string" == typeof e || g(e)) return e;
        var t = e + "";
        return "0" == t && 1 / e == -Infinity ? "-0" : t;
      };
      const Ie = function (e, t) {
        for (var n = 0, i = (t = Ce(t, e)).length; null != e && n < i; )
          e = e[Se(t[n++])];
        return n && n == i ? e : void 0;
      };
      const Me = function (e, t, n) {
        var i = null == e ? void 0 : Ie(e, t);
        return void 0 === i ? n : i;
      };
      var Te, Be;
      !(function (e) {
        (e.Default = "default"), (e.Pointer = "pointer");
      })(Te || (Te = {})),
        (function (e) {
          (e.SceneState = "sceneState.json"),
            (e.UIState = "uiState.json"),
            (e.Index = "index.html"),
            (e.Styles = "styles.css"),
            (e.Favicon = "favicon.ico"),
            (e.MetaImage = "meta-image.jpg"),
            (e.ErrorPage = "error-page.html"),
            (e.ErrorPageStyles = "error-page-styles.css");
        })(Be || (Be = {}));
      Be.Index, Be.Styles, Be.SceneState, Be.UIState, Be.Favicon, Be.MetaImage;
      var Re, De, Pe, Le, Ue, Fe, Oe, Ne, ke, Qe, Ge, He, ze, Ve, je, We;
      !(function (e) {
        e.WebsitePreviewData = "WEBSITE_PREVIEW_DATA";
      })(Re || (Re = {})),
        (function (e) {
          (e[(e.Raycast = 1)] = "Raycast"),
            (e[(e.Helpers = 2)] = "Helpers"),
            (e[(e.HelpersRaycast = 3)] = "HelpersRaycast");
        })(De || (De = {})),
        (function (e) {
          (e[(e.Low = 512)] = "Low"),
            (e[(e.Normal = 1024)] = "Normal"),
            (e[(e.High = 2048)] = "High");
        })(Pe || (Pe = {})),
        (function (e) {
          (e[(e.Low = 256)] = "Low"),
            (e[(e.Normal = 512)] = "Normal"),
            (e[(e.High = 1024)] = "High");
        })(Le || (Le = {})),
        (function (e) {
          (e.Imported = "IMPORTED"),
            (e.Scene = "SCENE"),
            (e.Mesh = "MESH"),
            (e.Group = " GROUP"),
            (e.Light = "LIGHT"),
            (e.Camera = "CAMERA"),
            (e.Water = "Water"),
            (e.Html = "HTML");
        })(Ue || (Ue = {})),
        (function (e) {
          (e.Plane = "PLANE"),
            (e.Box = "BOX"),
            (e.Sphere = "SPHERE"),
            (e.Cylinder = "CYLINDER"),
            (e.Cone = "CONE"),
            (e.Torus = "TORUS");
        })(Fe || (Fe = {})),
        (function (e) {
          (e.Perspective = "PERSPECTIVE"), (e.Orthographic = "ORTHOGRAPHIC");
        })(Oe || (Oe = {})),
        (function (e) {
          (e.Directional = "DIRECTIONAL"),
            (e.Ambient = "AMBIENT"),
            (e.Spot = "SPOT"),
            (e.Point = "POINT");
        })(Ne || (Ne = {})),
        (function (e) {
          (e.Unlit = "UNLIT"),
            (e.Lit = "LIT"),
            (e.Physical = "PHYSICAL"),
            (e.Phong = "PHONG");
        })(ke || (ke = {})),
        (function (e) {
          (e.Front = "FRONT"), (e.Back = "BACK"), (e.Double = "DOUBLE");
        })(Qe || (Qe = {})),
        (function (e) {
          (e.Gltf = "GLTF"),
            (e.FBX = "FBX"),
            (e.Obj = "OBJ"),
            (e.Texture = "TEXTURE"),
            (e.VideoTexture = "VIDEO_TEXTURE"),
            (e.EXRTexture = "EXR_TEXTURE"),
            (e.HDRTexture = "HDR_TEXTURE");
        })(Ge || (Ge = {})),
        (function (e) {
          (e[(e.Low = 256)] = "Low"),
            (e[(e.Normal = 512)] = "Normal"),
            (e[(e.High = 1024)] = "High");
        })(He || (He = {})),
        (function (e) {
          (e.Clamp = "Clamp"),
            (e.Repeat = "Repeat"),
            (e.MirroredRepeat = "MirroredRepeat");
        })(ze || (ze = {})),
        (function (e) {
          (e.Absolute = "ABSOLUTE"), (e.Relative = "RELATIVE");
        })(Ve || (Ve = {})),
        (function (e) {
          (e.Tilt = "TILT"), (e.Pan = "PAN");
        })(je || (je = {})),
        (function (e) {
          (e.Blur = "BLUR"),
            (e.DepthOfField = "DOF"),
            (e.Bloom = "BLOOM"),
            (e.Vignette = "VIGNETTE"),
            (e.Pixelation = "PIXELATION"),
            (e.HueSaturation = "HUE_SATURATION"),
            (e.BrightnessContrast = "BRIGHTNESS_CONTRAST"),
            (e.Noise = "NOISE"),
            (e.ColorDepth = "COLOR_DEPTH"),
            (e.SMAA = "SMAA"),
            (e.ToneMapping = "TONE_MAPPING");
        })(We || (We = {}));
      const Xe = [
        We.SMAA,
        We.Bloom,
        We.Vignette,
        We.Pixelation,
        We.DepthOfField,
        We.HueSaturation,
        We.BrightnessContrast,
        We.Noise,
        We.ColorDepth,
        We.ToneMapping,
      ];
      const qe = (function () {
        const e = new Map();
        return (
          Xe.forEach((t, n) => {
            e.set(t, n);
          }),
          e
        );
      })();
      var Ye,
        Ke,
        Je,
        Ze,
        $e,
        et,
        tt,
        nt,
        it,
        rt,
        st,
        at,
        ot,
        ct,
        lt,
        ut,
        ht,
        dt,
        pt,
        ft,
        At,
        gt,
        mt,
        vt,
        yt,
        bt,
        _t,
        xt,
        Et,
        wt,
        Ct,
        St,
        It,
        Mt,
        Tt,
        Bt,
        Rt;
      !(function (e) {
        (e.ScrollAnimation = "ScrollAnimation"),
          (e.ScrollTransform = "ScrollTransform");
      })(Ye || (Ye = {})),
        (function (e) {
          (e.Rotate2D = "2d"), (e.Rotate3D = "3d");
        })(Ke || (Ke = {})),
        (function (e) {
          (e.Linear = "linear"),
            (e.EaseIn = "easeIn"),
            (e.EaseOut = "easeOut"),
            (e.EaseInOut = "easeInOut"),
            (e.CircIn = "circIn"),
            (e.CircOut = "circOut"),
            (e.CircInOut = "circInOut"),
            (e.BackIn = "backIn"),
            (e.BackOut = "backOut"),
            (e.BackInOut = "backInOut"),
            (e.Anticipate = "anticipate");
        })(Je || (Je = {})),
        (function (e) {
          e.Spring = "spring";
        })(Ze || (Ze = {})),
        (function (e) {
          (e.OnAppear = "appear"),
            (e.OnScroll = "scroll"),
            (e.ElementInView = "element"),
            (e.SectionInView = "section");
        })($e || ($e = {})),
        (function (e) {
          (e.Down = "down"), (e.Up = "up");
        })(et || (et = {})),
        (function (e) {
          (e.Top = "top"), (e.Center = "center"), (e.Bottom = "bottom");
        })(tt || (tt = {})),
        (function (e) {
          (e.Fade = "fade"),
            (e.Scale = "scale"),
            (e.ScaleBottom = "scale_bottom"),
            (e.FlipHorizontal = "flip_horizontal"),
            (e.FlipVertical = "flip_vertical"),
            (e.SlideTop = "slide_top"),
            (e.SlideLeft = "slide_left"),
            (e.SlideRight = "slide_right"),
            (e.SlideBottom = "slide_bottom"),
            (e.Custom = "custom");
        })(nt || (nt = {})),
        (function (e) {
          (e.Upload = "upload"), (e.URL = "url");
        })(it || (it = {})),
        (function (e) {
          (e.Pause = "pause"), (e.Continue = "continue");
        })(rt || (rt = {})),
        (function (e) {
          (e.None = "none"),
            (e.PlayPause = "play_pause"),
            (e.Waveform = "waveform"),
            (e.Speaker = "speaker"),
            (e.Custom = "custom");
        })(st || (st = {})),
        (function (e) {
          (e.Top = "top"),
            (e.Right = "right"),
            (e.Bottom = "bottom"),
            (e.Left = "left");
        })(at || (at = {})),
        (function (e) {
          (e.Start = "start"), (e.Center = "center"), (e.End = "end");
        })(ot || (ot = {})),
        (function (e) {
          (e.Auto = "auto"), (e.Click = "click"), (e.None = "none");
        })(ct || (ct = {})),
        (function (e) {
          (e.UIOverlay = "uiOverlay"), (e.UIAudio = "uiAudio");
        })(lt || (lt = {})),
        (function (e) {
          (e.Play = "play"),
            (e.Pause = "pause"),
            (e.Stop = "stop"),
            (e.TogglePlayPause = "toggle_play_pause"),
            (e.TogglePlayStop = "toggle_play_stop");
        })(ut || (ut = {})),
        (function (e) {
          (e.Open = "open"),
            (e.Close = "close"),
            (e.ToggleOpenClose = "toggle_open_close");
        })(ht || (ht = {})),
        (function (e) {
          (e.MouseClick = "mouseClick"),
            (e.MouseEnter = "mouseEnter"),
            (e.MouseLeave = "mouseLeave");
        })(dt || (dt = {})),
        (function (e) {
          (e.External = "external"), (e.Internal = "internal");
        })(pt || (pt = {})),
        (function (e) {
          (e.Canvases = "canvases"),
            (e.Sections = "sections"),
            (e.Links = "links"),
            (e.ScrollAnimations = "scrollAnimations"),
            (e.Audio = "audio"),
            (e.AudioStyle = "audioStyle");
        })(ft || (ft = {})),
        (function (e) {
          (e.Interactions = "interactions"),
            (e.RelativeOverlays = "relativeOverlays");
        })(At || (At = {})),
        (function (e) {
          (e.Mobile = "mobile"), (e.Tablet = "tablet"), (e.Desktop = "desktop");
        })(gt || (gt = {})),
        (function (e) {
          (e.Standard = "standard"), (e.Smooth = "smooth");
        })(mt || (mt = {})),
        (function (e) {
          (e.Objects = "objects"),
            (e.Keyframes = "keyframes"),
            (e.AnimationLines = "animationLines");
        })(vt || (vt = {})),
        (function (e) {
          (e.Standard = "standard"), (e.Animation = "animation"), (e.UI = "UI");
        })(yt || (yt = {})),
        (function (e) {
          (e.Hdri = "HDRI"),
            (e.Audio = "audio"),
            (e.Font = "font"),
            (e.Image = "image"),
            (e.Model3d = "model3d"),
            (e.Vector = "vector"),
            (e.Video = "video");
        })(bt || (bt = {})),
        (function (e) {
          (e.Failed = "failed"),
            (e.Pending = "pending"),
            (e.Verified = "verified");
        })(_t || (_t = {})),
        (function (e) {
          (e.Deployed = "deployed"),
            (e.Deploying = "deploying"),
            (e.Failed = "failed"),
            (e.Pending = "pending"),
            (e.Undeployed = "undeployed");
        })(xt || (xt = {})),
        (function (e) {
          (e.A = "A"), (e.Cname = "CNAME"), (e.Txt = "TXT");
        })(Et || (Et = {})),
        (function (e) {
          (e.Template = "template"), (e.User = "user"), (e.Website = "website");
        })(wt || (wt = {})),
        (function (e) {
          (e.Asset = "asset"),
            (e.Avatar = "avatar"),
            (e.Cover = "cover"),
            (e.Favicon = "favicon"),
            (e.MetaSocialImage = "metaSocialImage"),
            (e.SceneThumbnail = "sceneThumbnail");
        })(Ct || (Ct = {})),
        (function (e) {
          (e.Asc = "asc"), (e.Desc = "desc");
        })(St || (St = {})),
        (function (e) {
          (e.CreatedAt = "createdAt"),
            (e.Random = "random"),
            (e.Title = "title"),
            (e.UpdatedAt = "updatedAt");
        })(It || (It = {})),
        (function (e) {
          (e.Admin = "admin"), (e.User = "user");
        })(Mt || (Mt = {})),
        (function (e) {
          (e.Active = "active"), (e.Deactivated = "deactivated");
        })(Tt || (Tt = {})),
        (function (e) {
          (e.Basic = "basic"), (e.Pro = "pro"), (e.Starter = "starter");
        })(Bt || (Bt = {})),
        (function (e) {
          (e.CreatedAt = "createdAt"),
            (e.Title = "title"),
            (e.UpdatedAt = "updatedAt");
        })(Rt || (Rt = {}));
      function Dt(e) {
        return e.type === We.Bloom;
      }
      function Pt(e) {
        return e.type === We.Vignette;
      }
      function Lt(e) {
        return e.type === We.Noise;
      }
      function Ut(e) {
        return e.type === We.SMAA;
      }
      function Ft(e) {
        return e.type === We.DepthOfField;
      }
      function Ot(e) {
        return e.type === We.Pixelation;
      }
      function Nt(e) {
        return e.type === We.HueSaturation;
      }
      function kt(e) {
        return e.type === We.ColorDepth;
      }
      function Qt(e) {
        return e.type === We.BrightnessContrast;
      }
      function Gt(e) {
        return e.type === We.ToneMapping;
      }
      function Ht(e) {
        return e.type === Ue.Light;
      }
      function zt(e) {
        return e.type === Ue.Mesh;
      }
      function Vt(e) {
        return e.type === Ue.Scene;
      }
      function jt(e) {
        return e.type === Ue.Imported;
      }
      function Wt(e) {
        return e.type === Ue.Water;
      }
      function Xt(e) {
        return (null == e ? void 0 : e.assetType) === Ge.VideoTexture;
      }
      function qt(e) {
        return e.type === ke.Physical;
      }
      function Yt(e) {
        return e.type === Ue.Camera;
      }
      function Kt(e) {
        return e.cameraType === Oe.Perspective;
      }
      function Jt(e) {
        return e.cameraType === Oe.Orthographic;
      }
      function Zt(e) {
        return e.lightType === Ne.Point;
      }
      function $t(e) {
        return e.lightType === Ne.Directional;
      }
      function en(e) {
        return e.lightType === Ne.Ambient;
      }
      function tn(e) {
        return e.lightType === Ne.Spot;
      }
      function nn(e) {
        return "MeshPhysicalMaterial" === e.type;
      }
      const rn = "170",
        sn = 1,
        an = 2,
        on = 3,
        cn = 0,
        ln = 1,
        un = 2,
        hn = 100,
        dn = 0,
        pn = 1,
        fn = 2,
        An = 0,
        gn = 1,
        mn = 2,
        vn = 3,
        yn = 4,
        bn = 5,
        _n = 6,
        xn = 7,
        En = "attached",
        wn = 301,
        Cn = 302,
        Sn = 303,
        In = 304,
        Mn = 306,
        Tn = 1e3,
        Bn = 1001,
        Rn = 1002,
        Dn = 1003,
        Pn = 1004,
        Ln = 1005,
        Un = 1006,
        Fn = 1007,
        On = 1008,
        Nn = 1009,
        kn = 1010,
        Qn = 1011,
        Gn = 1012,
        Hn = 1013,
        zn = 1014,
        Vn = 1015,
        jn = 1016,
        Wn = 1017,
        Xn = 1018,
        qn = 1020,
        Yn = 35902,
        Kn = 1021,
        Jn = 1022,
        Zn = 1023,
        $n = 1024,
        ei = 1025,
        ti = 1026,
        ni = 1027,
        ii = 1028,
        ri = 1029,
        si = 1030,
        ai = 1031,
        oi = 1033,
        ci = 33776,
        li = 33777,
        ui = 33778,
        hi = 33779,
        di = 35840,
        pi = 35841,
        fi = 35842,
        Ai = 35843,
        gi = 36196,
        mi = 37492,
        vi = 37496,
        yi = 37808,
        bi = 37809,
        _i = 37810,
        xi = 37811,
        Ei = 37812,
        wi = 37813,
        Ci = 37814,
        Si = 37815,
        Ii = 37816,
        Mi = 37817,
        Ti = 37818,
        Bi = 37819,
        Ri = 37820,
        Di = 37821,
        Pi = 36492,
        Li = 36494,
        Ui = 36495,
        Fi = 36283,
        Oi = 36284,
        Ni = 36285,
        ki = 36286,
        Qi = 2200,
        Gi = 2201,
        Hi = 2300,
        zi = 2301,
        Vi = 2302,
        ji = 2400,
        Wi = 2401,
        Xi = 2402,
        qi = 2500,
        Yi = 3200,
        Ki = 3201,
        Ji = "",
        Zi = "srgb",
        $i = "srgb-linear",
        er = "linear",
        tr = "srgb",
        nr = 7680,
        ir = 515,
        rr = 35044,
        sr = "300 es",
        ar = 2e3,
        or = 2001;
      class cr {
        addEventListener(e, t) {
          void 0 === this._listeners && (this._listeners = {});
          const n = this._listeners;
          void 0 === n[e] && (n[e] = []),
            -1 === n[e].indexOf(t) && n[e].push(t);
        }
        hasEventListener(e, t) {
          if (void 0 === this._listeners) return !1;
          const n = this._listeners;
          return void 0 !== n[e] && -1 !== n[e].indexOf(t);
        }
        removeEventListener(e, t) {
          if (void 0 === this._listeners) return;
          const n = this._listeners[e];
          if (void 0 !== n) {
            const e = n.indexOf(t);
            -1 !== e && n.splice(e, 1);
          }
        }
        dispatchEvent(e) {
          if (void 0 === this._listeners) return;
          const t = this._listeners[e.type];
          if (void 0 !== t) {
            e.target = this;
            const n = t.slice(0);
            for (let t = 0, i = n.length; t < i; t++) n[t].call(this, e);
            e.target = null;
          }
        }
      }
      const lr = [
        "00",
        "01",
        "02",
        "03",
        "04",
        "05",
        "06",
        "07",
        "08",
        "09",
        "0a",
        "0b",
        "0c",
        "0d",
        "0e",
        "0f",
        "10",
        "11",
        "12",
        "13",
        "14",
        "15",
        "16",
        "17",
        "18",
        "19",
        "1a",
        "1b",
        "1c",
        "1d",
        "1e",
        "1f",
        "20",
        "21",
        "22",
        "23",
        "24",
        "25",
        "26",
        "27",
        "28",
        "29",
        "2a",
        "2b",
        "2c",
        "2d",
        "2e",
        "2f",
        "30",
        "31",
        "32",
        "33",
        "34",
        "35",
        "36",
        "37",
        "38",
        "39",
        "3a",
        "3b",
        "3c",
        "3d",
        "3e",
        "3f",
        "40",
        "41",
        "42",
        "43",
        "44",
        "45",
        "46",
        "47",
        "48",
        "49",
        "4a",
        "4b",
        "4c",
        "4d",
        "4e",
        "4f",
        "50",
        "51",
        "52",
        "53",
        "54",
        "55",
        "56",
        "57",
        "58",
        "59",
        "5a",
        "5b",
        "5c",
        "5d",
        "5e",
        "5f",
        "60",
        "61",
        "62",
        "63",
        "64",
        "65",
        "66",
        "67",
        "68",
        "69",
        "6a",
        "6b",
        "6c",
        "6d",
        "6e",
        "6f",
        "70",
        "71",
        "72",
        "73",
        "74",
        "75",
        "76",
        "77",
        "78",
        "79",
        "7a",
        "7b",
        "7c",
        "7d",
        "7e",
        "7f",
        "80",
        "81",
        "82",
        "83",
        "84",
        "85",
        "86",
        "87",
        "88",
        "89",
        "8a",
        "8b",
        "8c",
        "8d",
        "8e",
        "8f",
        "90",
        "91",
        "92",
        "93",
        "94",
        "95",
        "96",
        "97",
        "98",
        "99",
        "9a",
        "9b",
        "9c",
        "9d",
        "9e",
        "9f",
        "a0",
        "a1",
        "a2",
        "a3",
        "a4",
        "a5",
        "a6",
        "a7",
        "a8",
        "a9",
        "aa",
        "ab",
        "ac",
        "ad",
        "ae",
        "af",
        "b0",
        "b1",
        "b2",
        "b3",
        "b4",
        "b5",
        "b6",
        "b7",
        "b8",
        "b9",
        "ba",
        "bb",
        "bc",
        "bd",
        "be",
        "bf",
        "c0",
        "c1",
        "c2",
        "c3",
        "c4",
        "c5",
        "c6",
        "c7",
        "c8",
        "c9",
        "ca",
        "cb",
        "cc",
        "cd",
        "ce",
        "cf",
        "d0",
        "d1",
        "d2",
        "d3",
        "d4",
        "d5",
        "d6",
        "d7",
        "d8",
        "d9",
        "da",
        "db",
        "dc",
        "dd",
        "de",
        "df",
        "e0",
        "e1",
        "e2",
        "e3",
        "e4",
        "e5",
        "e6",
        "e7",
        "e8",
        "e9",
        "ea",
        "eb",
        "ec",
        "ed",
        "ee",
        "ef",
        "f0",
        "f1",
        "f2",
        "f3",
        "f4",
        "f5",
        "f6",
        "f7",
        "f8",
        "f9",
        "fa",
        "fb",
        "fc",
        "fd",
        "fe",
        "ff",
      ];
      let ur = 1234567;
      const hr = Math.PI / 180,
        dr = 180 / Math.PI;
      function pr() {
        const e = (4294967295 * Math.random()) | 0,
          t = (4294967295 * Math.random()) | 0,
          n = (4294967295 * Math.random()) | 0,
          i = (4294967295 * Math.random()) | 0;
        return (
          lr[255 & e] +
          lr[(e >> 8) & 255] +
          lr[(e >> 16) & 255] +
          lr[(e >> 24) & 255] +
          "-" +
          lr[255 & t] +
          lr[(t >> 8) & 255] +
          "-" +
          lr[((t >> 16) & 15) | 64] +
          lr[(t >> 24) & 255] +
          "-" +
          lr[(63 & n) | 128] +
          lr[(n >> 8) & 255] +
          "-" +
          lr[(n >> 16) & 255] +
          lr[(n >> 24) & 255] +
          lr[255 & i] +
          lr[(i >> 8) & 255] +
          lr[(i >> 16) & 255] +
          lr[(i >> 24) & 255]
        ).toLowerCase();
      }
      function fr(e, t, n) {
        return Math.max(t, Math.min(n, e));
      }
      function Ar(e, t) {
        return ((e % t) + t) % t;
      }
      function gr(e, t, n) {
        return (1 - n) * e + n * t;
      }
      function mr(e, t) {
        switch (t.constructor) {
          case Float32Array:
            return e;
          case Uint32Array:
            return e / 4294967295;
          case Uint16Array:
            return e / 65535;
          case Uint8Array:
            return e / 255;
          case Int32Array:
            return Math.max(e / 2147483647, -1);
          case Int16Array:
            return Math.max(e / 32767, -1);
          case Int8Array:
            return Math.max(e / 127, -1);
          default:
            throw new Error("Invalid component type.");
        }
      }
      function vr(e, t) {
        switch (t.constructor) {
          case Float32Array:
            return e;
          case Uint32Array:
            return Math.round(4294967295 * e);
          case Uint16Array:
            return Math.round(65535 * e);
          case Uint8Array:
            return Math.round(255 * e);
          case Int32Array:
            return Math.round(2147483647 * e);
          case Int16Array:
            return Math.round(32767 * e);
          case Int8Array:
            return Math.round(127 * e);
          default:
            throw new Error("Invalid component type.");
        }
      }
      const yr = {
        DEG2RAD: hr,
        RAD2DEG: dr,
        generateUUID: pr,
        clamp: fr,
        euclideanModulo: Ar,
        mapLinear: function (e, t, n, i, r) {
          return i + ((e - t) * (r - i)) / (n - t);
        },
        inverseLerp: function (e, t, n) {
          return e !== t ? (n - e) / (t - e) : 0;
        },
        lerp: gr,
        damp: function (e, t, n, i) {
          return gr(e, t, 1 - Math.exp(-n * i));
        },
        pingpong: function (e, t = 1) {
          return t - Math.abs(Ar(e, 2 * t) - t);
        },
        smoothstep: function (e, t, n) {
          return e <= t
            ? 0
            : e >= n
            ? 1
            : (e = (e - t) / (n - t)) * e * (3 - 2 * e);
        },
        smootherstep: function (e, t, n) {
          return e <= t
            ? 0
            : e >= n
            ? 1
            : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10);
        },
        randInt: function (e, t) {
          return e + Math.floor(Math.random() * (t - e + 1));
        },
        randFloat: function (e, t) {
          return e + Math.random() * (t - e);
        },
        randFloatSpread: function (e) {
          return e * (0.5 - Math.random());
        },
        seededRandom: function (e) {
          void 0 !== e && (ur = e);
          let t = (ur += 1831565813);
          return (
            (t = Math.imul(t ^ (t >>> 15), 1 | t)),
            (t ^= t + Math.imul(t ^ (t >>> 7), 61 | t)),
            ((t ^ (t >>> 14)) >>> 0) / 4294967296
          );
        },
        degToRad: function (e) {
          return e * hr;
        },
        radToDeg: function (e) {
          return e * dr;
        },
        isPowerOfTwo: function (e) {
          return !(e & (e - 1)) && 0 !== e;
        },
        ceilPowerOfTwo: function (e) {
          return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2));
        },
        floorPowerOfTwo: function (e) {
          return Math.pow(2, Math.floor(Math.log(e) / Math.LN2));
        },
        setQuaternionFromProperEuler: function (e, t, n, i, r) {
          const s = Math.cos,
            a = Math.sin,
            o = s(n / 2),
            c = a(n / 2),
            l = s((t + i) / 2),
            u = a((t + i) / 2),
            h = s((t - i) / 2),
            d = a((t - i) / 2),
            p = s((i - t) / 2),
            f = a((i - t) / 2);
          switch (r) {
            case "XYX":
              e.set(o * u, c * h, c * d, o * l);
              break;
            case "YZY":
              e.set(c * d, o * u, c * h, o * l);
              break;
            case "ZXZ":
              e.set(c * h, c * d, o * u, o * l);
              break;
            case "XZX":
              e.set(o * u, c * f, c * p, o * l);
              break;
            case "YXY":
              e.set(c * p, o * u, c * f, o * l);
              break;
            case "ZYZ":
              e.set(c * f, c * p, o * u, o * l);
              break;
            default:
              console.warn(
                "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
                  r
              );
          }
        },
        normalize: vr,
        denormalize: mr,
      };
      class br {
        constructor(e = 0, t = 0) {
          (br.prototype.isVector2 = !0), (this.x = e), (this.y = t);
        }
        get width() {
          return this.x;
        }
        set width(e) {
          this.x = e;
        }
        get height() {
          return this.y;
        }
        set height(e) {
          this.y = e;
        }
        set(e, t) {
          return (this.x = e), (this.y = t), this;
        }
        setScalar(e) {
          return (this.x = e), (this.y = e), this;
        }
        setX(e) {
          return (this.x = e), this;
        }
        setY(e) {
          return (this.y = e), this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y);
        }
        copy(e) {
          return (this.x = e.x), (this.y = e.y), this;
        }
        add(e) {
          return (this.x += e.x), (this.y += e.y), this;
        }
        addScalar(e) {
          return (this.x += e), (this.y += e), this;
        }
        addVectors(e, t) {
          return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
        }
        addScaledVector(e, t) {
          return (this.x += e.x * t), (this.y += e.y * t), this;
        }
        sub(e) {
          return (this.x -= e.x), (this.y -= e.y), this;
        }
        subScalar(e) {
          return (this.x -= e), (this.y -= e), this;
        }
        subVectors(e, t) {
          return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
        }
        multiply(e) {
          return (this.x *= e.x), (this.y *= e.y), this;
        }
        multiplyScalar(e) {
          return (this.x *= e), (this.y *= e), this;
        }
        divide(e) {
          return (this.x /= e.x), (this.y /= e.y), this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        applyMatrix3(e) {
          const t = this.x,
            n = this.y,
            i = e.elements;
          return (
            (this.x = i[0] * t + i[3] * n + i[6]),
            (this.y = i[1] * t + i[4] * n + i[7]),
            this
          );
        }
        min(e) {
          return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            this
          );
        }
        max(e) {
          return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            this
          );
        }
        clamp(e, t) {
          return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            this
          );
        }
        clampScalar(e, t) {
          return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            this
          );
        }
        clampLength(e, t) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(e, Math.min(t, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
          );
        }
        roundToZero() {
          return (
            (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this
          );
        }
        negate() {
          return (this.x = -this.x), (this.y = -this.y), this;
        }
        dot(e) {
          return this.x * e.x + this.y * e.y;
        }
        cross(e) {
          return this.x * e.y - this.y * e.x;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        angle() {
          return Math.atan2(-this.y, -this.x) + Math.PI;
        }
        angleTo(e) {
          const t = Math.sqrt(this.lengthSq() * e.lengthSq());
          if (0 === t) return Math.PI / 2;
          const n = this.dot(e) / t;
          return Math.acos(fr(n, -1, 1));
        }
        distanceTo(e) {
          return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
          const t = this.x - e.x,
            n = this.y - e.y;
          return t * t + n * n;
        }
        manhattanDistanceTo(e) {
          return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return (
            (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this
          );
        }
        lerpVectors(e, t, n) {
          return (
            (this.x = e.x + (t.x - e.x) * n),
            (this.y = e.y + (t.y - e.y) * n),
            this
          );
        }
        equals(e) {
          return e.x === this.x && e.y === this.y;
        }
        fromArray(e, t = 0) {
          return (this.x = e[t]), (this.y = e[t + 1]), this;
        }
        toArray(e = [], t = 0) {
          return (e[t] = this.x), (e[t + 1] = this.y), e;
        }
        fromBufferAttribute(e, t) {
          return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
        }
        rotateAround(e, t) {
          const n = Math.cos(t),
            i = Math.sin(t),
            r = this.x - e.x,
            s = this.y - e.y;
          return (
            (this.x = r * n - s * i + e.x), (this.y = r * i + s * n + e.y), this
          );
        }
        random() {
          return (this.x = Math.random()), (this.y = Math.random()), this;
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y;
        }
      }
      class _r {
        constructor(e, t, n, i, r, s, a, o, c) {
          (_r.prototype.isMatrix3 = !0),
            (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
            void 0 !== e && this.set(e, t, n, i, r, s, a, o, c);
        }
        set(e, t, n, i, r, s, a, o, c) {
          const l = this.elements;
          return (
            (l[0] = e),
            (l[1] = i),
            (l[2] = a),
            (l[3] = t),
            (l[4] = r),
            (l[5] = o),
            (l[6] = n),
            (l[7] = s),
            (l[8] = c),
            this
          );
        }
        identity() {
          return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
        }
        copy(e) {
          const t = this.elements,
            n = e.elements;
          return (
            (t[0] = n[0]),
            (t[1] = n[1]),
            (t[2] = n[2]),
            (t[3] = n[3]),
            (t[4] = n[4]),
            (t[5] = n[5]),
            (t[6] = n[6]),
            (t[7] = n[7]),
            (t[8] = n[8]),
            this
          );
        }
        extractBasis(e, t, n) {
          return (
            e.setFromMatrix3Column(this, 0),
            t.setFromMatrix3Column(this, 1),
            n.setFromMatrix3Column(this, 2),
            this
          );
        }
        setFromMatrix4(e) {
          const t = e.elements;
          return (
            this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
            this
          );
        }
        multiply(e) {
          return this.multiplyMatrices(this, e);
        }
        premultiply(e) {
          return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
          const n = e.elements,
            i = t.elements,
            r = this.elements,
            s = n[0],
            a = n[3],
            o = n[6],
            c = n[1],
            l = n[4],
            u = n[7],
            h = n[2],
            d = n[5],
            p = n[8],
            f = i[0],
            A = i[3],
            g = i[6],
            m = i[1],
            v = i[4],
            y = i[7],
            b = i[2],
            _ = i[5],
            x = i[8];
          return (
            (r[0] = s * f + a * m + o * b),
            (r[3] = s * A + a * v + o * _),
            (r[6] = s * g + a * y + o * x),
            (r[1] = c * f + l * m + u * b),
            (r[4] = c * A + l * v + u * _),
            (r[7] = c * g + l * y + u * x),
            (r[2] = h * f + d * m + p * b),
            (r[5] = h * A + d * v + p * _),
            (r[8] = h * g + d * y + p * x),
            this
          );
        }
        multiplyScalar(e) {
          const t = this.elements;
          return (
            (t[0] *= e),
            (t[3] *= e),
            (t[6] *= e),
            (t[1] *= e),
            (t[4] *= e),
            (t[7] *= e),
            (t[2] *= e),
            (t[5] *= e),
            (t[8] *= e),
            this
          );
        }
        determinant() {
          const e = this.elements,
            t = e[0],
            n = e[1],
            i = e[2],
            r = e[3],
            s = e[4],
            a = e[5],
            o = e[6],
            c = e[7],
            l = e[8];
          return (
            t * s * l -
            t * a * c -
            n * r * l +
            n * a * o +
            i * r * c -
            i * s * o
          );
        }
        invert() {
          const e = this.elements,
            t = e[0],
            n = e[1],
            i = e[2],
            r = e[3],
            s = e[4],
            a = e[5],
            o = e[6],
            c = e[7],
            l = e[8],
            u = l * s - a * c,
            h = a * o - l * r,
            d = c * r - s * o,
            p = t * u + n * h + i * d;
          if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
          const f = 1 / p;
          return (
            (e[0] = u * f),
            (e[1] = (i * c - l * n) * f),
            (e[2] = (a * n - i * s) * f),
            (e[3] = h * f),
            (e[4] = (l * t - i * o) * f),
            (e[5] = (i * r - a * t) * f),
            (e[6] = d * f),
            (e[7] = (n * o - c * t) * f),
            (e[8] = (s * t - n * r) * f),
            this
          );
        }
        transpose() {
          let e;
          const t = this.elements;
          return (
            (e = t[1]),
            (t[1] = t[3]),
            (t[3] = e),
            (e = t[2]),
            (t[2] = t[6]),
            (t[6] = e),
            (e = t[5]),
            (t[5] = t[7]),
            (t[7] = e),
            this
          );
        }
        getNormalMatrix(e) {
          return this.setFromMatrix4(e).invert().transpose();
        }
        transposeIntoArray(e) {
          const t = this.elements;
          return (
            (e[0] = t[0]),
            (e[1] = t[3]),
            (e[2] = t[6]),
            (e[3] = t[1]),
            (e[4] = t[4]),
            (e[5] = t[7]),
            (e[6] = t[2]),
            (e[7] = t[5]),
            (e[8] = t[8]),
            this
          );
        }
        setUvTransform(e, t, n, i, r, s, a) {
          const o = Math.cos(r),
            c = Math.sin(r);
          return (
            this.set(
              n * o,
              n * c,
              -n * (o * s + c * a) + s + e,
              -i * c,
              i * o,
              -i * (-c * s + o * a) + a + t,
              0,
              0,
              1
            ),
            this
          );
        }
        scale(e, t) {
          return this.premultiply(xr.makeScale(e, t)), this;
        }
        rotate(e) {
          return this.premultiply(xr.makeRotation(-e)), this;
        }
        translate(e, t) {
          return this.premultiply(xr.makeTranslation(e, t)), this;
        }
        makeTranslation(e, t) {
          return (
            e.isVector2
              ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1)
              : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
            this
          );
        }
        makeRotation(e) {
          const t = Math.cos(e),
            n = Math.sin(e);
          return this.set(t, -n, 0, n, t, 0, 0, 0, 1), this;
        }
        makeScale(e, t) {
          return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
        }
        equals(e) {
          const t = this.elements,
            n = e.elements;
          for (let e = 0; e < 9; e++) if (t[e] !== n[e]) return !1;
          return !0;
        }
        fromArray(e, t = 0) {
          for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
          return this;
        }
        toArray(e = [], t = 0) {
          const n = this.elements;
          return (
            (e[t] = n[0]),
            (e[t + 1] = n[1]),
            (e[t + 2] = n[2]),
            (e[t + 3] = n[3]),
            (e[t + 4] = n[4]),
            (e[t + 5] = n[5]),
            (e[t + 6] = n[6]),
            (e[t + 7] = n[7]),
            (e[t + 8] = n[8]),
            e
          );
        }
        clone() {
          return new this.constructor().fromArray(this.elements);
        }
      }
      const xr = new _r();
      function Er(e) {
        for (let t = e.length - 1; t >= 0; --t) if (e[t] >= 65535) return !0;
        return !1;
      }
      Int8Array,
        Uint8Array,
        Uint8ClampedArray,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array;
      function wr(e) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", e);
      }
      function Cr() {
        const e = wr("canvas");
        return (e.style.display = "block"), e;
      }
      const Sr = {};
      function Ir(e) {
        e in Sr || ((Sr[e] = !0), console.warn(e));
      }
      const Mr = {
        enabled: !0,
        workingColorSpace: $i,
        spaces: {},
        convert: function (e, t, n) {
          return !1 !== this.enabled && t !== n && t && n
            ? (this.spaces[t].transfer === tr &&
                ((e.r = Tr(e.r)), (e.g = Tr(e.g)), (e.b = Tr(e.b))),
              this.spaces[t].primaries !== this.spaces[n].primaries &&
                (e.applyMatrix3(this.spaces[t].toXYZ),
                e.applyMatrix3(this.spaces[n].fromXYZ)),
              this.spaces[n].transfer === tr &&
                ((e.r = Br(e.r)), (e.g = Br(e.g)), (e.b = Br(e.b))),
              e)
            : e;
        },
        fromWorkingColorSpace: function (e, t) {
          return this.convert(e, this.workingColorSpace, t);
        },
        toWorkingColorSpace: function (e, t) {
          return this.convert(e, t, this.workingColorSpace);
        },
        getPrimaries: function (e) {
          return this.spaces[e].primaries;
        },
        getTransfer: function (e) {
          return e === Ji ? er : this.spaces[e].transfer;
        },
        getLuminanceCoefficients: function (e, t = this.workingColorSpace) {
          return e.fromArray(this.spaces[t].luminanceCoefficients);
        },
        define: function (e) {
          Object.assign(this.spaces, e);
        },
        _getMatrix: function (e, t, n) {
          return e.copy(this.spaces[t].toXYZ).multiply(this.spaces[n].fromXYZ);
        },
        _getDrawingBufferColorSpace: function (e) {
          return this.spaces[e].outputColorSpaceConfig.drawingBufferColorSpace;
        },
        _getUnpackColorSpace: function (e = this.workingColorSpace) {
          return this.spaces[e].workingColorSpaceConfig.unpackColorSpace;
        },
      };
      function Tr(e) {
        return e < 0.04045
          ? 0.0773993808 * e
          : Math.pow(0.9478672986 * e + 0.0521327014, 2.4);
      }
      function Br(e) {
        return e < 0.0031308 ? 12.92 * e : 1.055 * Math.pow(e, 0.41666) - 0.055;
      }
      const Rr = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06],
        Dr = [0.2126, 0.7152, 0.0722],
        Pr = [0.3127, 0.329],
        Lr = new _r().set(
          0.4123908,
          0.3575843,
          0.1804808,
          0.212639,
          0.7151687,
          0.0721923,
          0.0193308,
          0.1191948,
          0.9505322
        ),
        Ur = new _r().set(
          3.2409699,
          -1.5373832,
          -0.4986108,
          -0.9692436,
          1.8759675,
          0.0415551,
          0.0556301,
          -0.203977,
          1.0569715
        );
      let Fr;
      Mr.define({
        [$i]: {
          primaries: Rr,
          whitePoint: Pr,
          transfer: er,
          toXYZ: Lr,
          fromXYZ: Ur,
          luminanceCoefficients: Dr,
          workingColorSpaceConfig: { unpackColorSpace: Zi },
          outputColorSpaceConfig: { drawingBufferColorSpace: Zi },
        },
        [Zi]: {
          primaries: Rr,
          whitePoint: Pr,
          transfer: tr,
          toXYZ: Lr,
          fromXYZ: Ur,
          luminanceCoefficients: Dr,
          outputColorSpaceConfig: { drawingBufferColorSpace: Zi },
        },
      });
      class Or {
        static getDataURL(e) {
          if (/^data:/i.test(e.src)) return e.src;
          if ("undefined" == typeof HTMLCanvasElement) return e.src;
          let t;
          if (e instanceof HTMLCanvasElement) t = e;
          else {
            void 0 === Fr && (Fr = wr("canvas")),
              (Fr.width = e.width),
              (Fr.height = e.height);
            const n = Fr.getContext("2d");
            e instanceof ImageData
              ? n.putImageData(e, 0, 0)
              : n.drawImage(e, 0, 0, e.width, e.height),
              (t = Fr);
          }
          return t.width > 2048 || t.height > 2048
            ? (console.warn(
                "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
                e
              ),
              t.toDataURL("image/jpeg", 0.6))
            : t.toDataURL("image/png");
        }
        static sRGBToLinear(e) {
          if (
            ("undefined" != typeof HTMLImageElement &&
              e instanceof HTMLImageElement) ||
            ("undefined" != typeof HTMLCanvasElement &&
              e instanceof HTMLCanvasElement) ||
            ("undefined" != typeof ImageBitmap && e instanceof ImageBitmap)
          ) {
            const t = wr("canvas");
            (t.width = e.width), (t.height = e.height);
            const n = t.getContext("2d");
            n.drawImage(e, 0, 0, e.width, e.height);
            const i = n.getImageData(0, 0, e.width, e.height),
              r = i.data;
            for (let e = 0; e < r.length; e++) r[e] = 255 * Tr(r[e] / 255);
            return n.putImageData(i, 0, 0), t;
          }
          if (e.data) {
            const t = e.data.slice(0);
            for (let e = 0; e < t.length; e++)
              t instanceof Uint8Array || t instanceof Uint8ClampedArray
                ? (t[e] = Math.floor(255 * Tr(t[e] / 255)))
                : (t[e] = Tr(t[e]));
            return { data: t, width: e.width, height: e.height };
          }
          return (
            console.warn(
              "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
            ),
            e
          );
        }
      }
      let Nr = 0;
      class kr {
        constructor(e = null) {
          (this.isSource = !0),
            Object.defineProperty(this, "id", { value: Nr++ }),
            (this.uuid = pr()),
            (this.data = e),
            (this.dataReady = !0),
            (this.version = 0);
        }
        set needsUpdate(e) {
          !0 === e && this.version++;
        }
        toJSON(e) {
          const t = void 0 === e || "string" == typeof e;
          if (!t && void 0 !== e.images[this.uuid]) return e.images[this.uuid];
          const n = { uuid: this.uuid, url: "" },
            i = this.data;
          if (null !== i) {
            let e;
            if (Array.isArray(i)) {
              e = [];
              for (let t = 0, n = i.length; t < n; t++)
                i[t].isDataTexture ? e.push(Qr(i[t].image)) : e.push(Qr(i[t]));
            } else e = Qr(i);
            n.url = e;
          }
          return t || (e.images[this.uuid] = n), n;
        }
      }
      function Qr(e) {
        return ("undefined" != typeof HTMLImageElement &&
          e instanceof HTMLImageElement) ||
          ("undefined" != typeof HTMLCanvasElement &&
            e instanceof HTMLCanvasElement) ||
          ("undefined" != typeof ImageBitmap && e instanceof ImageBitmap)
          ? Or.getDataURL(e)
          : e.data
          ? {
              data: Array.from(e.data),
              width: e.width,
              height: e.height,
              type: e.data.constructor.name,
            }
          : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
      }
      let Gr = 0;
      class Hr extends cr {
        constructor(
          e = Hr.DEFAULT_IMAGE,
          t = Hr.DEFAULT_MAPPING,
          n = 1001,
          i = 1001,
          r = 1006,
          s = 1008,
          a = Zn,
          o = Nn,
          c = Hr.DEFAULT_ANISOTROPY,
          l = Ji
        ) {
          super(),
            (this.isTexture = !0),
            Object.defineProperty(this, "id", { value: Gr++ }),
            (this.uuid = pr()),
            (this.name = ""),
            (this.source = new kr(e)),
            (this.mipmaps = []),
            (this.mapping = t),
            (this.channel = 0),
            (this.wrapS = n),
            (this.wrapT = i),
            (this.magFilter = r),
            (this.minFilter = s),
            (this.anisotropy = c),
            (this.format = a),
            (this.internalFormat = null),
            (this.type = o),
            (this.offset = new br(0, 0)),
            (this.repeat = new br(1, 1)),
            (this.center = new br(0, 0)),
            (this.rotation = 0),
            (this.matrixAutoUpdate = !0),
            (this.matrix = new _r()),
            (this.generateMipmaps = !0),
            (this.premultiplyAlpha = !1),
            (this.flipY = !0),
            (this.unpackAlignment = 4),
            (this.colorSpace = l),
            (this.userData = {}),
            (this.version = 0),
            (this.onUpdate = null),
            (this.isRenderTargetTexture = !1),
            (this.pmremVersion = 0);
        }
        get image() {
          return this.source.data;
        }
        set image(e = null) {
          this.source.data = e;
        }
        updateMatrix() {
          this.matrix.setUvTransform(
            this.offset.x,
            this.offset.y,
            this.repeat.x,
            this.repeat.y,
            this.rotation,
            this.center.x,
            this.center.y
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return (
            (this.name = e.name),
            (this.source = e.source),
            (this.mipmaps = e.mipmaps.slice(0)),
            (this.mapping = e.mapping),
            (this.channel = e.channel),
            (this.wrapS = e.wrapS),
            (this.wrapT = e.wrapT),
            (this.magFilter = e.magFilter),
            (this.minFilter = e.minFilter),
            (this.anisotropy = e.anisotropy),
            (this.format = e.format),
            (this.internalFormat = e.internalFormat),
            (this.type = e.type),
            this.offset.copy(e.offset),
            this.repeat.copy(e.repeat),
            this.center.copy(e.center),
            (this.rotation = e.rotation),
            (this.matrixAutoUpdate = e.matrixAutoUpdate),
            this.matrix.copy(e.matrix),
            (this.generateMipmaps = e.generateMipmaps),
            (this.premultiplyAlpha = e.premultiplyAlpha),
            (this.flipY = e.flipY),
            (this.unpackAlignment = e.unpackAlignment),
            (this.colorSpace = e.colorSpace),
            (this.userData = JSON.parse(JSON.stringify(e.userData))),
            (this.needsUpdate = !0),
            this
          );
        }
        toJSON(e) {
          const t = void 0 === e || "string" == typeof e;
          if (!t && void 0 !== e.textures[this.uuid])
            return e.textures[this.uuid];
          const n = {
            metadata: {
              version: 4.6,
              type: "Texture",
              generator: "Texture.toJSON",
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment,
          };
          return (
            Object.keys(this.userData).length > 0 &&
              (n.userData = this.userData),
            t || (e.textures[this.uuid] = n),
            n
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        transformUv(e) {
          if (300 !== this.mapping) return e;
          if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
            switch (this.wrapS) {
              case Tn:
                e.x = e.x - Math.floor(e.x);
                break;
              case Bn:
                e.x = e.x < 0 ? 0 : 1;
                break;
              case Rn:
                1 === Math.abs(Math.floor(e.x) % 2)
                  ? (e.x = Math.ceil(e.x) - e.x)
                  : (e.x = e.x - Math.floor(e.x));
            }
          if (e.y < 0 || e.y > 1)
            switch (this.wrapT) {
              case Tn:
                e.y = e.y - Math.floor(e.y);
                break;
              case Bn:
                e.y = e.y < 0 ? 0 : 1;
                break;
              case Rn:
                1 === Math.abs(Math.floor(e.y) % 2)
                  ? (e.y = Math.ceil(e.y) - e.y)
                  : (e.y = e.y - Math.floor(e.y));
            }
          return this.flipY && (e.y = 1 - e.y), e;
        }
        set needsUpdate(e) {
          !0 === e && (this.version++, (this.source.needsUpdate = !0));
        }
        set needsPMREMUpdate(e) {
          !0 === e && this.pmremVersion++;
        }
      }
      (Hr.DEFAULT_IMAGE = null),
        (Hr.DEFAULT_MAPPING = 300),
        (Hr.DEFAULT_ANISOTROPY = 1);
      class zr {
        constructor(e = 0, t = 0, n = 0, i = 1) {
          (zr.prototype.isVector4 = !0),
            (this.x = e),
            (this.y = t),
            (this.z = n),
            (this.w = i);
        }
        get width() {
          return this.z;
        }
        set width(e) {
          this.z = e;
        }
        get height() {
          return this.w;
        }
        set height(e) {
          this.w = e;
        }
        set(e, t, n, i) {
          return (this.x = e), (this.y = t), (this.z = n), (this.w = i), this;
        }
        setScalar(e) {
          return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
        }
        setX(e) {
          return (this.x = e), this;
        }
        setY(e) {
          return (this.y = e), this;
        }
        setZ(e) {
          return (this.z = e), this;
        }
        setW(e) {
          return (this.w = e), this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            case 2:
              this.z = t;
              break;
            case 3:
              this.w = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(e) {
          return (
            (this.x = e.x),
            (this.y = e.y),
            (this.z = e.z),
            (this.w = void 0 !== e.w ? e.w : 1),
            this
          );
        }
        add(e) {
          return (
            (this.x += e.x),
            (this.y += e.y),
            (this.z += e.z),
            (this.w += e.w),
            this
          );
        }
        addScalar(e) {
          return (
            (this.x += e), (this.y += e), (this.z += e), (this.w += e), this
          );
        }
        addVectors(e, t) {
          return (
            (this.x = e.x + t.x),
            (this.y = e.y + t.y),
            (this.z = e.z + t.z),
            (this.w = e.w + t.w),
            this
          );
        }
        addScaledVector(e, t) {
          return (
            (this.x += e.x * t),
            (this.y += e.y * t),
            (this.z += e.z * t),
            (this.w += e.w * t),
            this
          );
        }
        sub(e) {
          return (
            (this.x -= e.x),
            (this.y -= e.y),
            (this.z -= e.z),
            (this.w -= e.w),
            this
          );
        }
        subScalar(e) {
          return (
            (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this
          );
        }
        subVectors(e, t) {
          return (
            (this.x = e.x - t.x),
            (this.y = e.y - t.y),
            (this.z = e.z - t.z),
            (this.w = e.w - t.w),
            this
          );
        }
        multiply(e) {
          return (
            (this.x *= e.x),
            (this.y *= e.y),
            (this.z *= e.z),
            (this.w *= e.w),
            this
          );
        }
        multiplyScalar(e) {
          return (
            (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this
          );
        }
        applyMatrix4(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = this.w,
            s = e.elements;
          return (
            (this.x = s[0] * t + s[4] * n + s[8] * i + s[12] * r),
            (this.y = s[1] * t + s[5] * n + s[9] * i + s[13] * r),
            (this.z = s[2] * t + s[6] * n + s[10] * i + s[14] * r),
            (this.w = s[3] * t + s[7] * n + s[11] * i + s[15] * r),
            this
          );
        }
        divide(e) {
          return (
            (this.x /= e.x),
            (this.y /= e.y),
            (this.z /= e.z),
            (this.w /= e.w),
            this
          );
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        setAxisAngleFromQuaternion(e) {
          this.w = 2 * Math.acos(e.w);
          const t = Math.sqrt(1 - e.w * e.w);
          return (
            t < 1e-4
              ? ((this.x = 1), (this.y = 0), (this.z = 0))
              : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
            this
          );
        }
        setAxisAngleFromRotationMatrix(e) {
          let t, n, i, r;
          const s = 0.01,
            a = 0.1,
            o = e.elements,
            c = o[0],
            l = o[4],
            u = o[8],
            h = o[1],
            d = o[5],
            p = o[9],
            f = o[2],
            A = o[6],
            g = o[10];
          if (
            Math.abs(l - h) < s &&
            Math.abs(u - f) < s &&
            Math.abs(p - A) < s
          ) {
            if (
              Math.abs(l + h) < a &&
              Math.abs(u + f) < a &&
              Math.abs(p + A) < a &&
              Math.abs(c + d + g - 3) < a
            )
              return this.set(1, 0, 0, 0), this;
            t = Math.PI;
            const e = (c + 1) / 2,
              o = (d + 1) / 2,
              m = (g + 1) / 2,
              v = (l + h) / 4,
              y = (u + f) / 4,
              b = (p + A) / 4;
            return (
              e > o && e > m
                ? e < s
                  ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
                  : ((n = Math.sqrt(e)), (i = v / n), (r = y / n))
                : o > m
                ? o < s
                  ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
                  : ((i = Math.sqrt(o)), (n = v / i), (r = b / i))
                : m < s
                ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
                : ((r = Math.sqrt(m)), (n = y / r), (i = b / r)),
              this.set(n, i, r, t),
              this
            );
          }
          let m = Math.sqrt(
            (A - p) * (A - p) + (u - f) * (u - f) + (h - l) * (h - l)
          );
          return (
            Math.abs(m) < 0.001 && (m = 1),
            (this.x = (A - p) / m),
            (this.y = (u - f) / m),
            (this.z = (h - l) / m),
            (this.w = Math.acos((c + d + g - 1) / 2)),
            this
          );
        }
        setFromMatrixPosition(e) {
          const t = e.elements;
          return (
            (this.x = t[12]),
            (this.y = t[13]),
            (this.z = t[14]),
            (this.w = t[15]),
            this
          );
        }
        min(e) {
          return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            (this.z = Math.min(this.z, e.z)),
            (this.w = Math.min(this.w, e.w)),
            this
          );
        }
        max(e) {
          return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            (this.z = Math.max(this.z, e.z)),
            (this.w = Math.max(this.w, e.w)),
            this
          );
        }
        clamp(e, t) {
          return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            (this.z = Math.max(e.z, Math.min(t.z, this.z))),
            (this.w = Math.max(e.w, Math.min(t.w, this.w))),
            this
          );
        }
        clampScalar(e, t) {
          return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            (this.z = Math.max(e, Math.min(t, this.z))),
            (this.w = Math.max(e, Math.min(t, this.w))),
            this
          );
        }
        clampLength(e, t) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(e, Math.min(t, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            (this.w = Math.floor(this.w)),
            this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            (this.w = Math.ceil(this.w)),
            this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            (this.w = Math.round(this.w)),
            this
          );
        }
        roundToZero() {
          return (
            (this.x = Math.trunc(this.x)),
            (this.y = Math.trunc(this.y)),
            (this.z = Math.trunc(this.z)),
            (this.w = Math.trunc(this.w)),
            this
          );
        }
        negate() {
          return (
            (this.x = -this.x),
            (this.y = -this.y),
            (this.z = -this.z),
            (this.w = -this.w),
            this
          );
        }
        dot(e) {
          return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
        }
        lengthSq() {
          return (
            this.x * this.x +
            this.y * this.y +
            this.z * this.z +
            this.w * this.w
          );
        }
        length() {
          return Math.sqrt(
            this.x * this.x +
              this.y * this.y +
              this.z * this.z +
              this.w * this.w
          );
        }
        manhattanLength() {
          return (
            Math.abs(this.x) +
            Math.abs(this.y) +
            Math.abs(this.z) +
            Math.abs(this.w)
          );
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return (
            (this.x += (e.x - this.x) * t),
            (this.y += (e.y - this.y) * t),
            (this.z += (e.z - this.z) * t),
            (this.w += (e.w - this.w) * t),
            this
          );
        }
        lerpVectors(e, t, n) {
          return (
            (this.x = e.x + (t.x - e.x) * n),
            (this.y = e.y + (t.y - e.y) * n),
            (this.z = e.z + (t.z - e.z) * n),
            (this.w = e.w + (t.w - e.w) * n),
            this
          );
        }
        equals(e) {
          return (
            e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
          );
        }
        fromArray(e, t = 0) {
          return (
            (this.x = e[t]),
            (this.y = e[t + 1]),
            (this.z = e[t + 2]),
            (this.w = e[t + 3]),
            this
          );
        }
        toArray(e = [], t = 0) {
          return (
            (e[t] = this.x),
            (e[t + 1] = this.y),
            (e[t + 2] = this.z),
            (e[t + 3] = this.w),
            e
          );
        }
        fromBufferAttribute(e, t) {
          return (
            (this.x = e.getX(t)),
            (this.y = e.getY(t)),
            (this.z = e.getZ(t)),
            (this.w = e.getW(t)),
            this
          );
        }
        random() {
          return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            (this.w = Math.random()),
            this
          );
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z, yield this.w;
        }
      }
      class Vr extends cr {
        constructor(e = 1, t = 1, n = {}) {
          super(),
            (this.isRenderTarget = !0),
            (this.width = e),
            (this.height = t),
            (this.depth = 1),
            (this.scissor = new zr(0, 0, e, t)),
            (this.scissorTest = !1),
            (this.viewport = new zr(0, 0, e, t));
          const i = { width: e, height: t, depth: 1 };
          n = Object.assign(
            {
              generateMipmaps: !1,
              internalFormat: null,
              minFilter: Un,
              depthBuffer: !0,
              stencilBuffer: !1,
              resolveDepthBuffer: !0,
              resolveStencilBuffer: !0,
              depthTexture: null,
              samples: 0,
              count: 1,
            },
            n
          );
          const r = new Hr(
            i,
            n.mapping,
            n.wrapS,
            n.wrapT,
            n.magFilter,
            n.minFilter,
            n.format,
            n.type,
            n.anisotropy,
            n.colorSpace
          );
          (r.flipY = !1),
            (r.generateMipmaps = n.generateMipmaps),
            (r.internalFormat = n.internalFormat),
            (this.textures = []);
          const s = n.count;
          for (let e = 0; e < s; e++)
            (this.textures[e] = r.clone()),
              (this.textures[e].isRenderTargetTexture = !0);
          (this.depthBuffer = n.depthBuffer),
            (this.stencilBuffer = n.stencilBuffer),
            (this.resolveDepthBuffer = n.resolveDepthBuffer),
            (this.resolveStencilBuffer = n.resolveStencilBuffer),
            (this.depthTexture = n.depthTexture),
            (this.samples = n.samples);
        }
        get texture() {
          return this.textures[0];
        }
        set texture(e) {
          this.textures[0] = e;
        }
        setSize(e, t, n = 1) {
          if (this.width !== e || this.height !== t || this.depth !== n) {
            (this.width = e), (this.height = t), (this.depth = n);
            for (let i = 0, r = this.textures.length; i < r; i++)
              (this.textures[i].image.width = e),
                (this.textures[i].image.height = t),
                (this.textures[i].image.depth = n);
            this.dispose();
          }
          this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          (this.width = e.width),
            (this.height = e.height),
            (this.depth = e.depth),
            this.scissor.copy(e.scissor),
            (this.scissorTest = e.scissorTest),
            this.viewport.copy(e.viewport),
            (this.textures.length = 0);
          for (let t = 0, n = e.textures.length; t < n; t++)
            (this.textures[t] = e.textures[t].clone()),
              (this.textures[t].isRenderTargetTexture = !0);
          const t = Object.assign({}, e.texture.image);
          return (
            (this.texture.source = new kr(t)),
            (this.depthBuffer = e.depthBuffer),
            (this.stencilBuffer = e.stencilBuffer),
            (this.resolveDepthBuffer = e.resolveDepthBuffer),
            (this.resolveStencilBuffer = e.resolveStencilBuffer),
            null !== e.depthTexture &&
              (this.depthTexture = e.depthTexture.clone()),
            (this.samples = e.samples),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      class jr extends Vr {
        constructor(e = 1, t = 1, n = {}) {
          super(e, t, n), (this.isWebGLRenderTarget = !0);
        }
      }
      class Wr extends Hr {
        constructor(e = null, t = 1, n = 1, i = 1) {
          super(null),
            (this.isDataArrayTexture = !0),
            (this.image = { data: e, width: t, height: n, depth: i }),
            (this.magFilter = Dn),
            (this.minFilter = Dn),
            (this.wrapR = Bn),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1),
            (this.layerUpdates = new Set());
        }
        addLayerUpdate(e) {
          this.layerUpdates.add(e);
        }
        clearLayerUpdates() {
          this.layerUpdates.clear();
        }
      }
      class Xr extends Hr {
        constructor(e = null, t = 1, n = 1, i = 1) {
          super(null),
            (this.isData3DTexture = !0),
            (this.image = { data: e, width: t, height: n, depth: i }),
            (this.magFilter = Dn),
            (this.minFilter = Dn),
            (this.wrapR = Bn),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1);
        }
      }
      class qr {
        constructor(e = 0, t = 0, n = 0, i = 1) {
          (this.isQuaternion = !0),
            (this._x = e),
            (this._y = t),
            (this._z = n),
            (this._w = i);
        }
        static slerpFlat(e, t, n, i, r, s, a) {
          let o = n[i + 0],
            c = n[i + 1],
            l = n[i + 2],
            u = n[i + 3];
          const h = r[s + 0],
            d = r[s + 1],
            p = r[s + 2],
            f = r[s + 3];
          if (0 === a)
            return (
              (e[t + 0] = o),
              (e[t + 1] = c),
              (e[t + 2] = l),
              void (e[t + 3] = u)
            );
          if (1 === a)
            return (
              (e[t + 0] = h),
              (e[t + 1] = d),
              (e[t + 2] = p),
              void (e[t + 3] = f)
            );
          if (u !== f || o !== h || c !== d || l !== p) {
            let e = 1 - a;
            const t = o * h + c * d + l * p + u * f,
              n = t >= 0 ? 1 : -1,
              i = 1 - t * t;
            if (i > Number.EPSILON) {
              const r = Math.sqrt(i),
                s = Math.atan2(r, t * n);
              (e = Math.sin(e * s) / r), (a = Math.sin(a * s) / r);
            }
            const r = a * n;
            if (
              ((o = o * e + h * r),
              (c = c * e + d * r),
              (l = l * e + p * r),
              (u = u * e + f * r),
              e === 1 - a)
            ) {
              const e = 1 / Math.sqrt(o * o + c * c + l * l + u * u);
              (o *= e), (c *= e), (l *= e), (u *= e);
            }
          }
          (e[t] = o), (e[t + 1] = c), (e[t + 2] = l), (e[t + 3] = u);
        }
        static multiplyQuaternionsFlat(e, t, n, i, r, s) {
          const a = n[i],
            o = n[i + 1],
            c = n[i + 2],
            l = n[i + 3],
            u = r[s],
            h = r[s + 1],
            d = r[s + 2],
            p = r[s + 3];
          return (
            (e[t] = a * p + l * u + o * d - c * h),
            (e[t + 1] = o * p + l * h + c * u - a * d),
            (e[t + 2] = c * p + l * d + a * h - o * u),
            (e[t + 3] = l * p - a * u - o * h - c * d),
            e
          );
        }
        get x() {
          return this._x;
        }
        set x(e) {
          (this._x = e), this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(e) {
          (this._y = e), this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(e) {
          (this._z = e), this._onChangeCallback();
        }
        get w() {
          return this._w;
        }
        set w(e) {
          (this._w = e), this._onChangeCallback();
        }
        set(e, t, n, i) {
          return (
            (this._x = e),
            (this._y = t),
            (this._z = n),
            (this._w = i),
            this._onChangeCallback(),
            this
          );
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(e) {
          return (
            (this._x = e.x),
            (this._y = e.y),
            (this._z = e.z),
            (this._w = e.w),
            this._onChangeCallback(),
            this
          );
        }
        setFromEuler(e, t = !0) {
          const n = e._x,
            i = e._y,
            r = e._z,
            s = e._order,
            a = Math.cos,
            o = Math.sin,
            c = a(n / 2),
            l = a(i / 2),
            u = a(r / 2),
            h = o(n / 2),
            d = o(i / 2),
            p = o(r / 2);
          switch (s) {
            case "XYZ":
              (this._x = h * l * u + c * d * p),
                (this._y = c * d * u - h * l * p),
                (this._z = c * l * p + h * d * u),
                (this._w = c * l * u - h * d * p);
              break;
            case "YXZ":
              (this._x = h * l * u + c * d * p),
                (this._y = c * d * u - h * l * p),
                (this._z = c * l * p - h * d * u),
                (this._w = c * l * u + h * d * p);
              break;
            case "ZXY":
              (this._x = h * l * u - c * d * p),
                (this._y = c * d * u + h * l * p),
                (this._z = c * l * p + h * d * u),
                (this._w = c * l * u - h * d * p);
              break;
            case "ZYX":
              (this._x = h * l * u - c * d * p),
                (this._y = c * d * u + h * l * p),
                (this._z = c * l * p - h * d * u),
                (this._w = c * l * u + h * d * p);
              break;
            case "YZX":
              (this._x = h * l * u + c * d * p),
                (this._y = c * d * u + h * l * p),
                (this._z = c * l * p - h * d * u),
                (this._w = c * l * u - h * d * p);
              break;
            case "XZY":
              (this._x = h * l * u - c * d * p),
                (this._y = c * d * u - h * l * p),
                (this._z = c * l * p + h * d * u),
                (this._w = c * l * u + h * d * p);
              break;
            default:
              console.warn(
                "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
                  s
              );
          }
          return !0 === t && this._onChangeCallback(), this;
        }
        setFromAxisAngle(e, t) {
          const n = t / 2,
            i = Math.sin(n);
          return (
            (this._x = e.x * i),
            (this._y = e.y * i),
            (this._z = e.z * i),
            (this._w = Math.cos(n)),
            this._onChangeCallback(),
            this
          );
        }
        setFromRotationMatrix(e) {
          const t = e.elements,
            n = t[0],
            i = t[4],
            r = t[8],
            s = t[1],
            a = t[5],
            o = t[9],
            c = t[2],
            l = t[6],
            u = t[10],
            h = n + a + u;
          if (h > 0) {
            const e = 0.5 / Math.sqrt(h + 1);
            (this._w = 0.25 / e),
              (this._x = (l - o) * e),
              (this._y = (r - c) * e),
              (this._z = (s - i) * e);
          } else if (n > a && n > u) {
            const e = 2 * Math.sqrt(1 + n - a - u);
            (this._w = (l - o) / e),
              (this._x = 0.25 * e),
              (this._y = (i + s) / e),
              (this._z = (r + c) / e);
          } else if (a > u) {
            const e = 2 * Math.sqrt(1 + a - n - u);
            (this._w = (r - c) / e),
              (this._x = (i + s) / e),
              (this._y = 0.25 * e),
              (this._z = (o + l) / e);
          } else {
            const e = 2 * Math.sqrt(1 + u - n - a);
            (this._w = (s - i) / e),
              (this._x = (r + c) / e),
              (this._y = (o + l) / e),
              (this._z = 0.25 * e);
          }
          return this._onChangeCallback(), this;
        }
        setFromUnitVectors(e, t) {
          let n = e.dot(t) + 1;
          return (
            n < Number.EPSILON
              ? ((n = 0),
                Math.abs(e.x) > Math.abs(e.z)
                  ? ((this._x = -e.y),
                    (this._y = e.x),
                    (this._z = 0),
                    (this._w = n))
                  : ((this._x = 0),
                    (this._y = -e.z),
                    (this._z = e.y),
                    (this._w = n)))
              : ((this._x = e.y * t.z - e.z * t.y),
                (this._y = e.z * t.x - e.x * t.z),
                (this._z = e.x * t.y - e.y * t.x),
                (this._w = n)),
            this.normalize()
          );
        }
        angleTo(e) {
          return 2 * Math.acos(Math.abs(fr(this.dot(e), -1, 1)));
        }
        rotateTowards(e, t) {
          const n = this.angleTo(e);
          if (0 === n) return this;
          const i = Math.min(1, t / n);
          return this.slerp(e, i), this;
        }
        identity() {
          return this.set(0, 0, 0, 1);
        }
        invert() {
          return this.conjugate();
        }
        conjugate() {
          return (
            (this._x *= -1),
            (this._y *= -1),
            (this._z *= -1),
            this._onChangeCallback(),
            this
          );
        }
        dot(e) {
          return (
            this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
          );
        }
        lengthSq() {
          return (
            this._x * this._x +
            this._y * this._y +
            this._z * this._z +
            this._w * this._w
          );
        }
        length() {
          return Math.sqrt(
            this._x * this._x +
              this._y * this._y +
              this._z * this._z +
              this._w * this._w
          );
        }
        normalize() {
          let e = this.length();
          return (
            0 === e
              ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
              : ((e = 1 / e),
                (this._x = this._x * e),
                (this._y = this._y * e),
                (this._z = this._z * e),
                (this._w = this._w * e)),
            this._onChangeCallback(),
            this
          );
        }
        multiply(e) {
          return this.multiplyQuaternions(this, e);
        }
        premultiply(e) {
          return this.multiplyQuaternions(e, this);
        }
        multiplyQuaternions(e, t) {
          const n = e._x,
            i = e._y,
            r = e._z,
            s = e._w,
            a = t._x,
            o = t._y,
            c = t._z,
            l = t._w;
          return (
            (this._x = n * l + s * a + i * c - r * o),
            (this._y = i * l + s * o + r * a - n * c),
            (this._z = r * l + s * c + n * o - i * a),
            (this._w = s * l - n * a - i * o - r * c),
            this._onChangeCallback(),
            this
          );
        }
        slerp(e, t) {
          if (0 === t) return this;
          if (1 === t) return this.copy(e);
          const n = this._x,
            i = this._y,
            r = this._z,
            s = this._w;
          let a = s * e._w + n * e._x + i * e._y + r * e._z;
          if (
            (a < 0
              ? ((this._w = -e._w),
                (this._x = -e._x),
                (this._y = -e._y),
                (this._z = -e._z),
                (a = -a))
              : this.copy(e),
            a >= 1)
          )
            return (
              (this._w = s), (this._x = n), (this._y = i), (this._z = r), this
            );
          const o = 1 - a * a;
          if (o <= Number.EPSILON) {
            const e = 1 - t;
            return (
              (this._w = e * s + t * this._w),
              (this._x = e * n + t * this._x),
              (this._y = e * i + t * this._y),
              (this._z = e * r + t * this._z),
              this.normalize(),
              this
            );
          }
          const c = Math.sqrt(o),
            l = Math.atan2(c, a),
            u = Math.sin((1 - t) * l) / c,
            h = Math.sin(t * l) / c;
          return (
            (this._w = s * u + this._w * h),
            (this._x = n * u + this._x * h),
            (this._y = i * u + this._y * h),
            (this._z = r * u + this._z * h),
            this._onChangeCallback(),
            this
          );
        }
        slerpQuaternions(e, t, n) {
          return this.copy(e).slerp(t, n);
        }
        random() {
          const e = 2 * Math.PI * Math.random(),
            t = 2 * Math.PI * Math.random(),
            n = Math.random(),
            i = Math.sqrt(1 - n),
            r = Math.sqrt(n);
          return this.set(
            i * Math.sin(e),
            i * Math.cos(e),
            r * Math.sin(t),
            r * Math.cos(t)
          );
        }
        equals(e) {
          return (
            e._x === this._x &&
            e._y === this._y &&
            e._z === this._z &&
            e._w === this._w
          );
        }
        fromArray(e, t = 0) {
          return (
            (this._x = e[t]),
            (this._y = e[t + 1]),
            (this._z = e[t + 2]),
            (this._w = e[t + 3]),
            this._onChangeCallback(),
            this
          );
        }
        toArray(e = [], t = 0) {
          return (
            (e[t] = this._x),
            (e[t + 1] = this._y),
            (e[t + 2] = this._z),
            (e[t + 3] = this._w),
            e
          );
        }
        fromBufferAttribute(e, t) {
          return (
            (this._x = e.getX(t)),
            (this._y = e.getY(t)),
            (this._z = e.getZ(t)),
            (this._w = e.getW(t)),
            this._onChangeCallback(),
            this
          );
        }
        toJSON() {
          return this.toArray();
        }
        _onChange(e) {
          return (this._onChangeCallback = e), this;
        }
        _onChangeCallback() {}
        *[Symbol.iterator]() {
          yield this._x, yield this._y, yield this._z, yield this._w;
        }
      }
      class Yr {
        constructor(e = 0, t = 0, n = 0) {
          (Yr.prototype.isVector3 = !0),
            (this.x = e),
            (this.y = t),
            (this.z = n);
        }
        set(e, t, n) {
          return (
            void 0 === n && (n = this.z),
            (this.x = e),
            (this.y = t),
            (this.z = n),
            this
          );
        }
        setScalar(e) {
          return (this.x = e), (this.y = e), (this.z = e), this;
        }
        setX(e) {
          return (this.x = e), this;
        }
        setY(e) {
          return (this.y = e), this;
        }
        setZ(e) {
          return (this.z = e), this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            case 2:
              this.z = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z);
        }
        copy(e) {
          return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
        }
        add(e) {
          return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
        }
        addScalar(e) {
          return (this.x += e), (this.y += e), (this.z += e), this;
        }
        addVectors(e, t) {
          return (
            (this.x = e.x + t.x),
            (this.y = e.y + t.y),
            (this.z = e.z + t.z),
            this
          );
        }
        addScaledVector(e, t) {
          return (
            (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this
          );
        }
        sub(e) {
          return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
        }
        subScalar(e) {
          return (this.x -= e), (this.y -= e), (this.z -= e), this;
        }
        subVectors(e, t) {
          return (
            (this.x = e.x - t.x),
            (this.y = e.y - t.y),
            (this.z = e.z - t.z),
            this
          );
        }
        multiply(e) {
          return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
        }
        multiplyScalar(e) {
          return (this.x *= e), (this.y *= e), (this.z *= e), this;
        }
        multiplyVectors(e, t) {
          return (
            (this.x = e.x * t.x),
            (this.y = e.y * t.y),
            (this.z = e.z * t.z),
            this
          );
        }
        applyEuler(e) {
          return this.applyQuaternion(Jr.setFromEuler(e));
        }
        applyAxisAngle(e, t) {
          return this.applyQuaternion(Jr.setFromAxisAngle(e, t));
        }
        applyMatrix3(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = e.elements;
          return (
            (this.x = r[0] * t + r[3] * n + r[6] * i),
            (this.y = r[1] * t + r[4] * n + r[7] * i),
            (this.z = r[2] * t + r[5] * n + r[8] * i),
            this
          );
        }
        applyNormalMatrix(e) {
          return this.applyMatrix3(e).normalize();
        }
        applyMatrix4(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = e.elements,
            s = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
          return (
            (this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * s),
            (this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * s),
            (this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * s),
            this
          );
        }
        applyQuaternion(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = e.x,
            s = e.y,
            a = e.z,
            o = e.w,
            c = 2 * (s * i - a * n),
            l = 2 * (a * t - r * i),
            u = 2 * (r * n - s * t);
          return (
            (this.x = t + o * c + s * u - a * l),
            (this.y = n + o * l + a * c - r * u),
            (this.z = i + o * u + r * l - s * c),
            this
          );
        }
        project(e) {
          return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
            e.projectionMatrix
          );
        }
        unproject(e) {
          return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
            e.matrixWorld
          );
        }
        transformDirection(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = e.elements;
          return (
            (this.x = r[0] * t + r[4] * n + r[8] * i),
            (this.y = r[1] * t + r[5] * n + r[9] * i),
            (this.z = r[2] * t + r[6] * n + r[10] * i),
            this.normalize()
          );
        }
        divide(e) {
          return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        min(e) {
          return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            (this.z = Math.min(this.z, e.z)),
            this
          );
        }
        max(e) {
          return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            (this.z = Math.max(this.z, e.z)),
            this
          );
        }
        clamp(e, t) {
          return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            (this.z = Math.max(e.z, Math.min(t.z, this.z))),
            this
          );
        }
        clampScalar(e, t) {
          return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            (this.z = Math.max(e, Math.min(t, this.z))),
            this
          );
        }
        clampLength(e, t) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(e, Math.min(t, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            this
          );
        }
        roundToZero() {
          return (
            (this.x = Math.trunc(this.x)),
            (this.y = Math.trunc(this.y)),
            (this.z = Math.trunc(this.z)),
            this
          );
        }
        negate() {
          return (
            (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this
          );
        }
        dot(e) {
          return this.x * e.x + this.y * e.y + this.z * e.z;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return (
            (this.x += (e.x - this.x) * t),
            (this.y += (e.y - this.y) * t),
            (this.z += (e.z - this.z) * t),
            this
          );
        }
        lerpVectors(e, t, n) {
          return (
            (this.x = e.x + (t.x - e.x) * n),
            (this.y = e.y + (t.y - e.y) * n),
            (this.z = e.z + (t.z - e.z) * n),
            this
          );
        }
        cross(e) {
          return this.crossVectors(this, e);
        }
        crossVectors(e, t) {
          const n = e.x,
            i = e.y,
            r = e.z,
            s = t.x,
            a = t.y,
            o = t.z;
          return (
            (this.x = i * o - r * a),
            (this.y = r * s - n * o),
            (this.z = n * a - i * s),
            this
          );
        }
        projectOnVector(e) {
          const t = e.lengthSq();
          if (0 === t) return this.set(0, 0, 0);
          const n = e.dot(this) / t;
          return this.copy(e).multiplyScalar(n);
        }
        projectOnPlane(e) {
          return Kr.copy(this).projectOnVector(e), this.sub(Kr);
        }
        reflect(e) {
          return this.sub(Kr.copy(e).multiplyScalar(2 * this.dot(e)));
        }
        angleTo(e) {
          const t = Math.sqrt(this.lengthSq() * e.lengthSq());
          if (0 === t) return Math.PI / 2;
          const n = this.dot(e) / t;
          return Math.acos(fr(n, -1, 1));
        }
        distanceTo(e) {
          return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
          const t = this.x - e.x,
            n = this.y - e.y,
            i = this.z - e.z;
          return t * t + n * n + i * i;
        }
        manhattanDistanceTo(e) {
          return (
            Math.abs(this.x - e.x) +
            Math.abs(this.y - e.y) +
            Math.abs(this.z - e.z)
          );
        }
        setFromSpherical(e) {
          return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
        }
        setFromSphericalCoords(e, t, n) {
          const i = Math.sin(t) * e;
          return (
            (this.x = i * Math.sin(n)),
            (this.y = Math.cos(t) * e),
            (this.z = i * Math.cos(n)),
            this
          );
        }
        setFromCylindrical(e) {
          return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
        }
        setFromCylindricalCoords(e, t, n) {
          return (
            (this.x = e * Math.sin(t)),
            (this.y = n),
            (this.z = e * Math.cos(t)),
            this
          );
        }
        setFromMatrixPosition(e) {
          const t = e.elements;
          return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
        }
        setFromMatrixScale(e) {
          const t = this.setFromMatrixColumn(e, 0).length(),
            n = this.setFromMatrixColumn(e, 1).length(),
            i = this.setFromMatrixColumn(e, 2).length();
          return (this.x = t), (this.y = n), (this.z = i), this;
        }
        setFromMatrixColumn(e, t) {
          return this.fromArray(e.elements, 4 * t);
        }
        setFromMatrix3Column(e, t) {
          return this.fromArray(e.elements, 3 * t);
        }
        setFromEuler(e) {
          return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
        }
        setFromColor(e) {
          return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
        }
        equals(e) {
          return e.x === this.x && e.y === this.y && e.z === this.z;
        }
        fromArray(e, t = 0) {
          return (
            (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this
          );
        }
        toArray(e = [], t = 0) {
          return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
        }
        fromBufferAttribute(e, t) {
          return (
            (this.x = e.getX(t)),
            (this.y = e.getY(t)),
            (this.z = e.getZ(t)),
            this
          );
        }
        random() {
          return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            this
          );
        }
        randomDirection() {
          const e = Math.random() * Math.PI * 2,
            t = 2 * Math.random() - 1,
            n = Math.sqrt(1 - t * t);
          return (
            (this.x = n * Math.cos(e)),
            (this.y = t),
            (this.z = n * Math.sin(e)),
            this
          );
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z;
        }
      }
      const Kr = new Yr(),
        Jr = new qr();
      class Zr {
        constructor(
          e = new Yr(1 / 0, 1 / 0, 1 / 0),
          t = new Yr(-1 / 0, -1 / 0, -1 / 0)
        ) {
          (this.isBox3 = !0), (this.min = e), (this.max = t);
        }
        set(e, t) {
          return this.min.copy(e), this.max.copy(t), this;
        }
        setFromArray(e) {
          this.makeEmpty();
          for (let t = 0, n = e.length; t < n; t += 3)
            this.expandByPoint(es.fromArray(e, t));
          return this;
        }
        setFromBufferAttribute(e) {
          this.makeEmpty();
          for (let t = 0, n = e.count; t < n; t++)
            this.expandByPoint(es.fromBufferAttribute(e, t));
          return this;
        }
        setFromPoints(e) {
          this.makeEmpty();
          for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
          return this;
        }
        setFromCenterAndSize(e, t) {
          const n = es.copy(t).multiplyScalar(0.5);
          return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
        }
        setFromObject(e, t = !1) {
          return this.makeEmpty(), this.expandByObject(e, t);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.min.copy(e.min), this.max.copy(e.max), this;
        }
        makeEmpty() {
          return (
            (this.min.x = this.min.y = this.min.z = 1 / 0),
            (this.max.x = this.max.y = this.max.z = -1 / 0),
            this
          );
        }
        isEmpty() {
          return (
            this.max.x < this.min.x ||
            this.max.y < this.min.y ||
            this.max.z < this.min.z
          );
        }
        getCenter(e) {
          return this.isEmpty()
            ? e.set(0, 0, 0)
            : e.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(e) {
          return this.isEmpty()
            ? e.set(0, 0, 0)
            : e.subVectors(this.max, this.min);
        }
        expandByPoint(e) {
          return this.min.min(e), this.max.max(e), this;
        }
        expandByVector(e) {
          return this.min.sub(e), this.max.add(e), this;
        }
        expandByScalar(e) {
          return this.min.addScalar(-e), this.max.addScalar(e), this;
        }
        expandByObject(e, t = !1) {
          e.updateWorldMatrix(!1, !1);
          const n = e.geometry;
          if (void 0 !== n) {
            const i = n.getAttribute("position");
            if (!0 === t && void 0 !== i && !0 !== e.isInstancedMesh)
              for (let t = 0, n = i.count; t < n; t++)
                !0 === e.isMesh
                  ? e.getVertexPosition(t, es)
                  : es.fromBufferAttribute(i, t),
                  es.applyMatrix4(e.matrixWorld),
                  this.expandByPoint(es);
            else
              void 0 !== e.boundingBox
                ? (null === e.boundingBox && e.computeBoundingBox(),
                  ts.copy(e.boundingBox))
                : (null === n.boundingBox && n.computeBoundingBox(),
                  ts.copy(n.boundingBox)),
                ts.applyMatrix4(e.matrixWorld),
                this.union(ts);
          }
          const i = e.children;
          for (let e = 0, n = i.length; e < n; e++)
            this.expandByObject(i[e], t);
          return this;
        }
        containsPoint(e) {
          return (
            e.x >= this.min.x &&
            e.x <= this.max.x &&
            e.y >= this.min.y &&
            e.y <= this.max.y &&
            e.z >= this.min.z &&
            e.z <= this.max.z
          );
        }
        containsBox(e) {
          return (
            this.min.x <= e.min.x &&
            e.max.x <= this.max.x &&
            this.min.y <= e.min.y &&
            e.max.y <= this.max.y &&
            this.min.z <= e.min.z &&
            e.max.z <= this.max.z
          );
        }
        getParameter(e, t) {
          return t.set(
            (e.x - this.min.x) / (this.max.x - this.min.x),
            (e.y - this.min.y) / (this.max.y - this.min.y),
            (e.z - this.min.z) / (this.max.z - this.min.z)
          );
        }
        intersectsBox(e) {
          return (
            e.max.x >= this.min.x &&
            e.min.x <= this.max.x &&
            e.max.y >= this.min.y &&
            e.min.y <= this.max.y &&
            e.max.z >= this.min.z &&
            e.min.z <= this.max.z
          );
        }
        intersectsSphere(e) {
          return (
            this.clampPoint(e.center, es),
            es.distanceToSquared(e.center) <= e.radius * e.radius
          );
        }
        intersectsPlane(e) {
          let t, n;
          return (
            e.normal.x > 0
              ? ((t = e.normal.x * this.min.x), (n = e.normal.x * this.max.x))
              : ((t = e.normal.x * this.max.x), (n = e.normal.x * this.min.x)),
            e.normal.y > 0
              ? ((t += e.normal.y * this.min.y), (n += e.normal.y * this.max.y))
              : ((t += e.normal.y * this.max.y),
                (n += e.normal.y * this.min.y)),
            e.normal.z > 0
              ? ((t += e.normal.z * this.min.z), (n += e.normal.z * this.max.z))
              : ((t += e.normal.z * this.max.z),
                (n += e.normal.z * this.min.z)),
            t <= -e.constant && n >= -e.constant
          );
        }
        intersectsTriangle(e) {
          if (this.isEmpty()) return !1;
          this.getCenter(cs),
            ls.subVectors(this.max, cs),
            ns.subVectors(e.a, cs),
            is.subVectors(e.b, cs),
            rs.subVectors(e.c, cs),
            ss.subVectors(is, ns),
            as.subVectors(rs, is),
            os.subVectors(ns, rs);
          let t = [
            0,
            -ss.z,
            ss.y,
            0,
            -as.z,
            as.y,
            0,
            -os.z,
            os.y,
            ss.z,
            0,
            -ss.x,
            as.z,
            0,
            -as.x,
            os.z,
            0,
            -os.x,
            -ss.y,
            ss.x,
            0,
            -as.y,
            as.x,
            0,
            -os.y,
            os.x,
            0,
          ];
          return (
            !!ds(t, ns, is, rs, ls) &&
            ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
            !!ds(t, ns, is, rs, ls) &&
              (us.crossVectors(ss, as),
              (t = [us.x, us.y, us.z]),
              ds(t, ns, is, rs, ls)))
          );
        }
        clampPoint(e, t) {
          return t.copy(e).clamp(this.min, this.max);
        }
        distanceToPoint(e) {
          return this.clampPoint(e, es).distanceTo(e);
        }
        getBoundingSphere(e) {
          return (
            this.isEmpty()
              ? e.makeEmpty()
              : (this.getCenter(e.center),
                (e.radius = 0.5 * this.getSize(es).length())),
            e
          );
        }
        intersect(e) {
          return (
            this.min.max(e.min),
            this.max.min(e.max),
            this.isEmpty() && this.makeEmpty(),
            this
          );
        }
        union(e) {
          return this.min.min(e.min), this.max.max(e.max), this;
        }
        applyMatrix4(e) {
          return (
            this.isEmpty() ||
              ($r[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
              $r[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
              $r[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
              $r[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
              $r[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
              $r[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
              $r[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
              $r[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
              this.setFromPoints($r)),
            this
          );
        }
        translate(e) {
          return this.min.add(e), this.max.add(e), this;
        }
        equals(e) {
          return e.min.equals(this.min) && e.max.equals(this.max);
        }
      }
      const $r = [
          new Yr(),
          new Yr(),
          new Yr(),
          new Yr(),
          new Yr(),
          new Yr(),
          new Yr(),
          new Yr(),
        ],
        es = new Yr(),
        ts = new Zr(),
        ns = new Yr(),
        is = new Yr(),
        rs = new Yr(),
        ss = new Yr(),
        as = new Yr(),
        os = new Yr(),
        cs = new Yr(),
        ls = new Yr(),
        us = new Yr(),
        hs = new Yr();
      function ds(e, t, n, i, r) {
        for (let s = 0, a = e.length - 3; s <= a; s += 3) {
          hs.fromArray(e, s);
          const a =
              r.x * Math.abs(hs.x) +
              r.y * Math.abs(hs.y) +
              r.z * Math.abs(hs.z),
            o = t.dot(hs),
            c = n.dot(hs),
            l = i.dot(hs);
          if (Math.max(-Math.max(o, c, l), Math.min(o, c, l)) > a) return !1;
        }
        return !0;
      }
      const ps = new Zr(),
        fs = new Yr(),
        As = new Yr();
      class gs {
        constructor(e = new Yr(), t = -1) {
          (this.isSphere = !0), (this.center = e), (this.radius = t);
        }
        set(e, t) {
          return this.center.copy(e), (this.radius = t), this;
        }
        setFromPoints(e, t) {
          const n = this.center;
          void 0 !== t ? n.copy(t) : ps.setFromPoints(e).getCenter(n);
          let i = 0;
          for (let t = 0, r = e.length; t < r; t++)
            i = Math.max(i, n.distanceToSquared(e[t]));
          return (this.radius = Math.sqrt(i)), this;
        }
        copy(e) {
          return this.center.copy(e.center), (this.radius = e.radius), this;
        }
        isEmpty() {
          return this.radius < 0;
        }
        makeEmpty() {
          return this.center.set(0, 0, 0), (this.radius = -1), this;
        }
        containsPoint(e) {
          return e.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(e) {
          return e.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(e) {
          const t = this.radius + e.radius;
          return e.center.distanceToSquared(this.center) <= t * t;
        }
        intersectsBox(e) {
          return e.intersectsSphere(this);
        }
        intersectsPlane(e) {
          return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(e, t) {
          const n = this.center.distanceToSquared(e);
          return (
            t.copy(e),
            n > this.radius * this.radius &&
              (t.sub(this.center).normalize(),
              t.multiplyScalar(this.radius).add(this.center)),
            t
          );
        }
        getBoundingBox(e) {
          return this.isEmpty()
            ? (e.makeEmpty(), e)
            : (e.set(this.center, this.center),
              e.expandByScalar(this.radius),
              e);
        }
        applyMatrix4(e) {
          return (
            this.center.applyMatrix4(e),
            (this.radius = this.radius * e.getMaxScaleOnAxis()),
            this
          );
        }
        translate(e) {
          return this.center.add(e), this;
        }
        expandByPoint(e) {
          if (this.isEmpty())
            return this.center.copy(e), (this.radius = 0), this;
          fs.subVectors(e, this.center);
          const t = fs.lengthSq();
          if (t > this.radius * this.radius) {
            const e = Math.sqrt(t),
              n = 0.5 * (e - this.radius);
            this.center.addScaledVector(fs, n / e), (this.radius += n);
          }
          return this;
        }
        union(e) {
          return e.isEmpty()
            ? this
            : this.isEmpty()
            ? (this.copy(e), this)
            : (!0 === this.center.equals(e.center)
                ? (this.radius = Math.max(this.radius, e.radius))
                : (As.subVectors(e.center, this.center).setLength(e.radius),
                  this.expandByPoint(fs.copy(e.center).add(As)),
                  this.expandByPoint(fs.copy(e.center).sub(As))),
              this);
        }
        equals(e) {
          return e.center.equals(this.center) && e.radius === this.radius;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const ms = new Yr(),
        vs = new Yr(),
        ys = new Yr(),
        bs = new Yr(),
        _s = new Yr(),
        xs = new Yr(),
        Es = new Yr();
      class ws {
        constructor(e = new Yr(), t = new Yr(0, 0, -1)) {
          (this.origin = e), (this.direction = t);
        }
        set(e, t) {
          return this.origin.copy(e), this.direction.copy(t), this;
        }
        copy(e) {
          return (
            this.origin.copy(e.origin), this.direction.copy(e.direction), this
          );
        }
        at(e, t) {
          return t.copy(this.origin).addScaledVector(this.direction, e);
        }
        lookAt(e) {
          return this.direction.copy(e).sub(this.origin).normalize(), this;
        }
        recast(e) {
          return this.origin.copy(this.at(e, ms)), this;
        }
        closestPointToPoint(e, t) {
          t.subVectors(e, this.origin);
          const n = t.dot(this.direction);
          return n < 0
            ? t.copy(this.origin)
            : t.copy(this.origin).addScaledVector(this.direction, n);
        }
        distanceToPoint(e) {
          return Math.sqrt(this.distanceSqToPoint(e));
        }
        distanceSqToPoint(e) {
          const t = ms.subVectors(e, this.origin).dot(this.direction);
          return t < 0
            ? this.origin.distanceToSquared(e)
            : (ms.copy(this.origin).addScaledVector(this.direction, t),
              ms.distanceToSquared(e));
        }
        distanceSqToSegment(e, t, n, i) {
          vs.copy(e).add(t).multiplyScalar(0.5),
            ys.copy(t).sub(e).normalize(),
            bs.copy(this.origin).sub(vs);
          const r = 0.5 * e.distanceTo(t),
            s = -this.direction.dot(ys),
            a = bs.dot(this.direction),
            o = -bs.dot(ys),
            c = bs.lengthSq(),
            l = Math.abs(1 - s * s);
          let u, h, d, p;
          if (l > 0)
            if (((u = s * o - a), (h = s * a - o), (p = r * l), u >= 0))
              if (h >= -p)
                if (h <= p) {
                  const e = 1 / l;
                  (u *= e),
                    (h *= e),
                    (d = u * (u + s * h + 2 * a) + h * (s * u + h + 2 * o) + c);
                } else
                  (h = r),
                    (u = Math.max(0, -(s * h + a))),
                    (d = -u * u + h * (h + 2 * o) + c);
              else
                (h = -r),
                  (u = Math.max(0, -(s * h + a))),
                  (d = -u * u + h * (h + 2 * o) + c);
            else
              h <= -p
                ? ((u = Math.max(0, -(-s * r + a))),
                  (h = u > 0 ? -r : Math.min(Math.max(-r, -o), r)),
                  (d = -u * u + h * (h + 2 * o) + c))
                : h <= p
                ? ((u = 0),
                  (h = Math.min(Math.max(-r, -o), r)),
                  (d = h * (h + 2 * o) + c))
                : ((u = Math.max(0, -(s * r + a))),
                  (h = u > 0 ? r : Math.min(Math.max(-r, -o), r)),
                  (d = -u * u + h * (h + 2 * o) + c));
          else
            (h = s > 0 ? -r : r),
              (u = Math.max(0, -(s * h + a))),
              (d = -u * u + h * (h + 2 * o) + c);
          return (
            n && n.copy(this.origin).addScaledVector(this.direction, u),
            i && i.copy(vs).addScaledVector(ys, h),
            d
          );
        }
        intersectSphere(e, t) {
          ms.subVectors(e.center, this.origin);
          const n = ms.dot(this.direction),
            i = ms.dot(ms) - n * n,
            r = e.radius * e.radius;
          if (i > r) return null;
          const s = Math.sqrt(r - i),
            a = n - s,
            o = n + s;
          return o < 0 ? null : a < 0 ? this.at(o, t) : this.at(a, t);
        }
        intersectsSphere(e) {
          return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
        }
        distanceToPlane(e) {
          const t = e.normal.dot(this.direction);
          if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
          const n = -(this.origin.dot(e.normal) + e.constant) / t;
          return n >= 0 ? n : null;
        }
        intersectPlane(e, t) {
          const n = this.distanceToPlane(e);
          return null === n ? null : this.at(n, t);
        }
        intersectsPlane(e) {
          const t = e.distanceToPoint(this.origin);
          if (0 === t) return !0;
          return e.normal.dot(this.direction) * t < 0;
        }
        intersectBox(e, t) {
          let n, i, r, s, a, o;
          const c = 1 / this.direction.x,
            l = 1 / this.direction.y,
            u = 1 / this.direction.z,
            h = this.origin;
          return (
            c >= 0
              ? ((n = (e.min.x - h.x) * c), (i = (e.max.x - h.x) * c))
              : ((n = (e.max.x - h.x) * c), (i = (e.min.x - h.x) * c)),
            l >= 0
              ? ((r = (e.min.y - h.y) * l), (s = (e.max.y - h.y) * l))
              : ((r = (e.max.y - h.y) * l), (s = (e.min.y - h.y) * l)),
            n > s || r > i
              ? null
              : ((r > n || isNaN(n)) && (n = r),
                (s < i || isNaN(i)) && (i = s),
                u >= 0
                  ? ((a = (e.min.z - h.z) * u), (o = (e.max.z - h.z) * u))
                  : ((a = (e.max.z - h.z) * u), (o = (e.min.z - h.z) * u)),
                n > o || a > i
                  ? null
                  : ((a > n || n != n) && (n = a),
                    (o < i || i != i) && (i = o),
                    i < 0 ? null : this.at(n >= 0 ? n : i, t)))
          );
        }
        intersectsBox(e) {
          return null !== this.intersectBox(e, ms);
        }
        intersectTriangle(e, t, n, i, r) {
          _s.subVectors(t, e), xs.subVectors(n, e), Es.crossVectors(_s, xs);
          let s,
            a = this.direction.dot(Es);
          if (a > 0) {
            if (i) return null;
            s = 1;
          } else {
            if (!(a < 0)) return null;
            (s = -1), (a = -a);
          }
          bs.subVectors(this.origin, e);
          const o = s * this.direction.dot(xs.crossVectors(bs, xs));
          if (o < 0) return null;
          const c = s * this.direction.dot(_s.cross(bs));
          if (c < 0) return null;
          if (o + c > a) return null;
          const l = -s * bs.dot(Es);
          return l < 0 ? null : this.at(l / a, r);
        }
        applyMatrix4(e) {
          return (
            this.origin.applyMatrix4(e),
            this.direction.transformDirection(e),
            this
          );
        }
        equals(e) {
          return (
            e.origin.equals(this.origin) && e.direction.equals(this.direction)
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class Cs {
        constructor(e, t, n, i, r, s, a, o, c, l, u, h, d, p, f, A) {
          (Cs.prototype.isMatrix4 = !0),
            (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
            void 0 !== e &&
              this.set(e, t, n, i, r, s, a, o, c, l, u, h, d, p, f, A);
        }
        set(e, t, n, i, r, s, a, o, c, l, u, h, d, p, f, A) {
          const g = this.elements;
          return (
            (g[0] = e),
            (g[4] = t),
            (g[8] = n),
            (g[12] = i),
            (g[1] = r),
            (g[5] = s),
            (g[9] = a),
            (g[13] = o),
            (g[2] = c),
            (g[6] = l),
            (g[10] = u),
            (g[14] = h),
            (g[3] = d),
            (g[7] = p),
            (g[11] = f),
            (g[15] = A),
            this
          );
        }
        identity() {
          return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        clone() {
          return new Cs().fromArray(this.elements);
        }
        copy(e) {
          const t = this.elements,
            n = e.elements;
          return (
            (t[0] = n[0]),
            (t[1] = n[1]),
            (t[2] = n[2]),
            (t[3] = n[3]),
            (t[4] = n[4]),
            (t[5] = n[5]),
            (t[6] = n[6]),
            (t[7] = n[7]),
            (t[8] = n[8]),
            (t[9] = n[9]),
            (t[10] = n[10]),
            (t[11] = n[11]),
            (t[12] = n[12]),
            (t[13] = n[13]),
            (t[14] = n[14]),
            (t[15] = n[15]),
            this
          );
        }
        copyPosition(e) {
          const t = this.elements,
            n = e.elements;
          return (t[12] = n[12]), (t[13] = n[13]), (t[14] = n[14]), this;
        }
        setFromMatrix3(e) {
          const t = e.elements;
          return (
            this.set(
              t[0],
              t[3],
              t[6],
              0,
              t[1],
              t[4],
              t[7],
              0,
              t[2],
              t[5],
              t[8],
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        extractBasis(e, t, n) {
          return (
            e.setFromMatrixColumn(this, 0),
            t.setFromMatrixColumn(this, 1),
            n.setFromMatrixColumn(this, 2),
            this
          );
        }
        makeBasis(e, t, n) {
          return (
            this.set(
              e.x,
              t.x,
              n.x,
              0,
              e.y,
              t.y,
              n.y,
              0,
              e.z,
              t.z,
              n.z,
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        extractRotation(e) {
          const t = this.elements,
            n = e.elements,
            i = 1 / Ss.setFromMatrixColumn(e, 0).length(),
            r = 1 / Ss.setFromMatrixColumn(e, 1).length(),
            s = 1 / Ss.setFromMatrixColumn(e, 2).length();
          return (
            (t[0] = n[0] * i),
            (t[1] = n[1] * i),
            (t[2] = n[2] * i),
            (t[3] = 0),
            (t[4] = n[4] * r),
            (t[5] = n[5] * r),
            (t[6] = n[6] * r),
            (t[7] = 0),
            (t[8] = n[8] * s),
            (t[9] = n[9] * s),
            (t[10] = n[10] * s),
            (t[11] = 0),
            (t[12] = 0),
            (t[13] = 0),
            (t[14] = 0),
            (t[15] = 1),
            this
          );
        }
        makeRotationFromEuler(e) {
          const t = this.elements,
            n = e.x,
            i = e.y,
            r = e.z,
            s = Math.cos(n),
            a = Math.sin(n),
            o = Math.cos(i),
            c = Math.sin(i),
            l = Math.cos(r),
            u = Math.sin(r);
          if ("XYZ" === e.order) {
            const e = s * l,
              n = s * u,
              i = a * l,
              r = a * u;
            (t[0] = o * l),
              (t[4] = -o * u),
              (t[8] = c),
              (t[1] = n + i * c),
              (t[5] = e - r * c),
              (t[9] = -a * o),
              (t[2] = r - e * c),
              (t[6] = i + n * c),
              (t[10] = s * o);
          } else if ("YXZ" === e.order) {
            const e = o * l,
              n = o * u,
              i = c * l,
              r = c * u;
            (t[0] = e + r * a),
              (t[4] = i * a - n),
              (t[8] = s * c),
              (t[1] = s * u),
              (t[5] = s * l),
              (t[9] = -a),
              (t[2] = n * a - i),
              (t[6] = r + e * a),
              (t[10] = s * o);
          } else if ("ZXY" === e.order) {
            const e = o * l,
              n = o * u,
              i = c * l,
              r = c * u;
            (t[0] = e - r * a),
              (t[4] = -s * u),
              (t[8] = i + n * a),
              (t[1] = n + i * a),
              (t[5] = s * l),
              (t[9] = r - e * a),
              (t[2] = -s * c),
              (t[6] = a),
              (t[10] = s * o);
          } else if ("ZYX" === e.order) {
            const e = s * l,
              n = s * u,
              i = a * l,
              r = a * u;
            (t[0] = o * l),
              (t[4] = i * c - n),
              (t[8] = e * c + r),
              (t[1] = o * u),
              (t[5] = r * c + e),
              (t[9] = n * c - i),
              (t[2] = -c),
              (t[6] = a * o),
              (t[10] = s * o);
          } else if ("YZX" === e.order) {
            const e = s * o,
              n = s * c,
              i = a * o,
              r = a * c;
            (t[0] = o * l),
              (t[4] = r - e * u),
              (t[8] = i * u + n),
              (t[1] = u),
              (t[5] = s * l),
              (t[9] = -a * l),
              (t[2] = -c * l),
              (t[6] = n * u + i),
              (t[10] = e - r * u);
          } else if ("XZY" === e.order) {
            const e = s * o,
              n = s * c,
              i = a * o,
              r = a * c;
            (t[0] = o * l),
              (t[4] = -u),
              (t[8] = c * l),
              (t[1] = e * u + r),
              (t[5] = s * l),
              (t[9] = n * u - i),
              (t[2] = i * u - n),
              (t[6] = a * l),
              (t[10] = r * u + e);
          }
          return (
            (t[3] = 0),
            (t[7] = 0),
            (t[11] = 0),
            (t[12] = 0),
            (t[13] = 0),
            (t[14] = 0),
            (t[15] = 1),
            this
          );
        }
        makeRotationFromQuaternion(e) {
          return this.compose(Ms, e, Ts);
        }
        lookAt(e, t, n) {
          const i = this.elements;
          return (
            Ds.subVectors(e, t),
            0 === Ds.lengthSq() && (Ds.z = 1),
            Ds.normalize(),
            Bs.crossVectors(n, Ds),
            0 === Bs.lengthSq() &&
              (1 === Math.abs(n.z) ? (Ds.x += 1e-4) : (Ds.z += 1e-4),
              Ds.normalize(),
              Bs.crossVectors(n, Ds)),
            Bs.normalize(),
            Rs.crossVectors(Ds, Bs),
            (i[0] = Bs.x),
            (i[4] = Rs.x),
            (i[8] = Ds.x),
            (i[1] = Bs.y),
            (i[5] = Rs.y),
            (i[9] = Ds.y),
            (i[2] = Bs.z),
            (i[6] = Rs.z),
            (i[10] = Ds.z),
            this
          );
        }
        multiply(e) {
          return this.multiplyMatrices(this, e);
        }
        premultiply(e) {
          return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
          const n = e.elements,
            i = t.elements,
            r = this.elements,
            s = n[0],
            a = n[4],
            o = n[8],
            c = n[12],
            l = n[1],
            u = n[5],
            h = n[9],
            d = n[13],
            p = n[2],
            f = n[6],
            A = n[10],
            g = n[14],
            m = n[3],
            v = n[7],
            y = n[11],
            b = n[15],
            _ = i[0],
            x = i[4],
            E = i[8],
            w = i[12],
            C = i[1],
            S = i[5],
            I = i[9],
            M = i[13],
            T = i[2],
            B = i[6],
            R = i[10],
            D = i[14],
            P = i[3],
            L = i[7],
            U = i[11],
            F = i[15];
          return (
            (r[0] = s * _ + a * C + o * T + c * P),
            (r[4] = s * x + a * S + o * B + c * L),
            (r[8] = s * E + a * I + o * R + c * U),
            (r[12] = s * w + a * M + o * D + c * F),
            (r[1] = l * _ + u * C + h * T + d * P),
            (r[5] = l * x + u * S + h * B + d * L),
            (r[9] = l * E + u * I + h * R + d * U),
            (r[13] = l * w + u * M + h * D + d * F),
            (r[2] = p * _ + f * C + A * T + g * P),
            (r[6] = p * x + f * S + A * B + g * L),
            (r[10] = p * E + f * I + A * R + g * U),
            (r[14] = p * w + f * M + A * D + g * F),
            (r[3] = m * _ + v * C + y * T + b * P),
            (r[7] = m * x + v * S + y * B + b * L),
            (r[11] = m * E + v * I + y * R + b * U),
            (r[15] = m * w + v * M + y * D + b * F),
            this
          );
        }
        multiplyScalar(e) {
          const t = this.elements;
          return (
            (t[0] *= e),
            (t[4] *= e),
            (t[8] *= e),
            (t[12] *= e),
            (t[1] *= e),
            (t[5] *= e),
            (t[9] *= e),
            (t[13] *= e),
            (t[2] *= e),
            (t[6] *= e),
            (t[10] *= e),
            (t[14] *= e),
            (t[3] *= e),
            (t[7] *= e),
            (t[11] *= e),
            (t[15] *= e),
            this
          );
        }
        determinant() {
          const e = this.elements,
            t = e[0],
            n = e[4],
            i = e[8],
            r = e[12],
            s = e[1],
            a = e[5],
            o = e[9],
            c = e[13],
            l = e[2],
            u = e[6],
            h = e[10],
            d = e[14];
          return (
            e[3] *
              (+r * o * u -
                i * c * u -
                r * a * h +
                n * c * h +
                i * a * d -
                n * o * d) +
            e[7] *
              (+t * o * d -
                t * c * h +
                r * s * h -
                i * s * d +
                i * c * l -
                r * o * l) +
            e[11] *
              (+t * c * u -
                t * a * d -
                r * s * u +
                n * s * d +
                r * a * l -
                n * c * l) +
            e[15] *
              (-i * a * l -
                t * o * u +
                t * a * h +
                i * s * u -
                n * s * h +
                n * o * l)
          );
        }
        transpose() {
          const e = this.elements;
          let t;
          return (
            (t = e[1]),
            (e[1] = e[4]),
            (e[4] = t),
            (t = e[2]),
            (e[2] = e[8]),
            (e[8] = t),
            (t = e[6]),
            (e[6] = e[9]),
            (e[9] = t),
            (t = e[3]),
            (e[3] = e[12]),
            (e[12] = t),
            (t = e[7]),
            (e[7] = e[13]),
            (e[13] = t),
            (t = e[11]),
            (e[11] = e[14]),
            (e[14] = t),
            this
          );
        }
        setPosition(e, t, n) {
          const i = this.elements;
          return (
            e.isVector3
              ? ((i[12] = e.x), (i[13] = e.y), (i[14] = e.z))
              : ((i[12] = e), (i[13] = t), (i[14] = n)),
            this
          );
        }
        invert() {
          const e = this.elements,
            t = e[0],
            n = e[1],
            i = e[2],
            r = e[3],
            s = e[4],
            a = e[5],
            o = e[6],
            c = e[7],
            l = e[8],
            u = e[9],
            h = e[10],
            d = e[11],
            p = e[12],
            f = e[13],
            A = e[14],
            g = e[15],
            m =
              u * A * c -
              f * h * c +
              f * o * d -
              a * A * d -
              u * o * g +
              a * h * g,
            v =
              p * h * c -
              l * A * c -
              p * o * d +
              s * A * d +
              l * o * g -
              s * h * g,
            y =
              l * f * c -
              p * u * c +
              p * a * d -
              s * f * d -
              l * a * g +
              s * u * g,
            b =
              p * u * o -
              l * f * o -
              p * a * h +
              s * f * h +
              l * a * A -
              s * u * A,
            _ = t * m + n * v + i * y + r * b;
          if (0 === _)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          const x = 1 / _;
          return (
            (e[0] = m * x),
            (e[1] =
              (f * h * r -
                u * A * r -
                f * i * d +
                n * A * d +
                u * i * g -
                n * h * g) *
              x),
            (e[2] =
              (a * A * r -
                f * o * r +
                f * i * c -
                n * A * c -
                a * i * g +
                n * o * g) *
              x),
            (e[3] =
              (u * o * r -
                a * h * r -
                u * i * c +
                n * h * c +
                a * i * d -
                n * o * d) *
              x),
            (e[4] = v * x),
            (e[5] =
              (l * A * r -
                p * h * r +
                p * i * d -
                t * A * d -
                l * i * g +
                t * h * g) *
              x),
            (e[6] =
              (p * o * r -
                s * A * r -
                p * i * c +
                t * A * c +
                s * i * g -
                t * o * g) *
              x),
            (e[7] =
              (s * h * r -
                l * o * r +
                l * i * c -
                t * h * c -
                s * i * d +
                t * o * d) *
              x),
            (e[8] = y * x),
            (e[9] =
              (p * u * r -
                l * f * r -
                p * n * d +
                t * f * d +
                l * n * g -
                t * u * g) *
              x),
            (e[10] =
              (s * f * r -
                p * a * r +
                p * n * c -
                t * f * c -
                s * n * g +
                t * a * g) *
              x),
            (e[11] =
              (l * a * r -
                s * u * r -
                l * n * c +
                t * u * c +
                s * n * d -
                t * a * d) *
              x),
            (e[12] = b * x),
            (e[13] =
              (l * f * i -
                p * u * i +
                p * n * h -
                t * f * h -
                l * n * A +
                t * u * A) *
              x),
            (e[14] =
              (p * a * i -
                s * f * i -
                p * n * o +
                t * f * o +
                s * n * A -
                t * a * A) *
              x),
            (e[15] =
              (s * u * i -
                l * a * i +
                l * n * o -
                t * u * o -
                s * n * h +
                t * a * h) *
              x),
            this
          );
        }
        scale(e) {
          const t = this.elements,
            n = e.x,
            i = e.y,
            r = e.z;
          return (
            (t[0] *= n),
            (t[4] *= i),
            (t[8] *= r),
            (t[1] *= n),
            (t[5] *= i),
            (t[9] *= r),
            (t[2] *= n),
            (t[6] *= i),
            (t[10] *= r),
            (t[3] *= n),
            (t[7] *= i),
            (t[11] *= r),
            this
          );
        }
        getMaxScaleOnAxis() {
          const e = this.elements,
            t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
            n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
            i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
          return Math.sqrt(Math.max(t, n, i));
        }
        makeTranslation(e, t, n) {
          return (
            e.isVector3
              ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
              : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1),
            this
          );
        }
        makeRotationX(e) {
          const t = Math.cos(e),
            n = Math.sin(e);
          return (
            this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationY(e) {
          const t = Math.cos(e),
            n = Math.sin(e);
          return (
            this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationZ(e) {
          const t = Math.cos(e),
            n = Math.sin(e);
          return (
            this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationAxis(e, t) {
          const n = Math.cos(t),
            i = Math.sin(t),
            r = 1 - n,
            s = e.x,
            a = e.y,
            o = e.z,
            c = r * s,
            l = r * a;
          return (
            this.set(
              c * s + n,
              c * a - i * o,
              c * o + i * a,
              0,
              c * a + i * o,
              l * a + n,
              l * o - i * s,
              0,
              c * o - i * a,
              l * o + i * s,
              r * o * o + n,
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        makeScale(e, t, n) {
          return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
        }
        makeShear(e, t, n, i, r, s) {
          return this.set(1, n, r, 0, e, 1, s, 0, t, i, 1, 0, 0, 0, 0, 1), this;
        }
        compose(e, t, n) {
          const i = this.elements,
            r = t._x,
            s = t._y,
            a = t._z,
            o = t._w,
            c = r + r,
            l = s + s,
            u = a + a,
            h = r * c,
            d = r * l,
            p = r * u,
            f = s * l,
            A = s * u,
            g = a * u,
            m = o * c,
            v = o * l,
            y = o * u,
            b = n.x,
            _ = n.y,
            x = n.z;
          return (
            (i[0] = (1 - (f + g)) * b),
            (i[1] = (d + y) * b),
            (i[2] = (p - v) * b),
            (i[3] = 0),
            (i[4] = (d - y) * _),
            (i[5] = (1 - (h + g)) * _),
            (i[6] = (A + m) * _),
            (i[7] = 0),
            (i[8] = (p + v) * x),
            (i[9] = (A - m) * x),
            (i[10] = (1 - (h + f)) * x),
            (i[11] = 0),
            (i[12] = e.x),
            (i[13] = e.y),
            (i[14] = e.z),
            (i[15] = 1),
            this
          );
        }
        decompose(e, t, n) {
          const i = this.elements;
          let r = Ss.set(i[0], i[1], i[2]).length();
          const s = Ss.set(i[4], i[5], i[6]).length(),
            a = Ss.set(i[8], i[9], i[10]).length();
          this.determinant() < 0 && (r = -r),
            (e.x = i[12]),
            (e.y = i[13]),
            (e.z = i[14]),
            Is.copy(this);
          const o = 1 / r,
            c = 1 / s,
            l = 1 / a;
          return (
            (Is.elements[0] *= o),
            (Is.elements[1] *= o),
            (Is.elements[2] *= o),
            (Is.elements[4] *= c),
            (Is.elements[5] *= c),
            (Is.elements[6] *= c),
            (Is.elements[8] *= l),
            (Is.elements[9] *= l),
            (Is.elements[10] *= l),
            t.setFromRotationMatrix(Is),
            (n.x = r),
            (n.y = s),
            (n.z = a),
            this
          );
        }
        makePerspective(e, t, n, i, r, s, a = 2e3) {
          const o = this.elements,
            c = (2 * r) / (t - e),
            l = (2 * r) / (n - i),
            u = (t + e) / (t - e),
            h = (n + i) / (n - i);
          let d, p;
          if (a === ar) (d = -(s + r) / (s - r)), (p = (-2 * s * r) / (s - r));
          else {
            if (a !== or)
              throw new Error(
                "THREE.Matrix4.makePerspective(): Invalid coordinate system: " +
                  a
              );
            (d = -s / (s - r)), (p = (-s * r) / (s - r));
          }
          return (
            (o[0] = c),
            (o[4] = 0),
            (o[8] = u),
            (o[12] = 0),
            (o[1] = 0),
            (o[5] = l),
            (o[9] = h),
            (o[13] = 0),
            (o[2] = 0),
            (o[6] = 0),
            (o[10] = d),
            (o[14] = p),
            (o[3] = 0),
            (o[7] = 0),
            (o[11] = -1),
            (o[15] = 0),
            this
          );
        }
        makeOrthographic(e, t, n, i, r, s, a = 2e3) {
          const o = this.elements,
            c = 1 / (t - e),
            l = 1 / (n - i),
            u = 1 / (s - r),
            h = (t + e) * c,
            d = (n + i) * l;
          let p, f;
          if (a === ar) (p = (s + r) * u), (f = -2 * u);
          else {
            if (a !== or)
              throw new Error(
                "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " +
                  a
              );
            (p = r * u), (f = -1 * u);
          }
          return (
            (o[0] = 2 * c),
            (o[4] = 0),
            (o[8] = 0),
            (o[12] = -h),
            (o[1] = 0),
            (o[5] = 2 * l),
            (o[9] = 0),
            (o[13] = -d),
            (o[2] = 0),
            (o[6] = 0),
            (o[10] = f),
            (o[14] = -p),
            (o[3] = 0),
            (o[7] = 0),
            (o[11] = 0),
            (o[15] = 1),
            this
          );
        }
        equals(e) {
          const t = this.elements,
            n = e.elements;
          for (let e = 0; e < 16; e++) if (t[e] !== n[e]) return !1;
          return !0;
        }
        fromArray(e, t = 0) {
          for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
          return this;
        }
        toArray(e = [], t = 0) {
          const n = this.elements;
          return (
            (e[t] = n[0]),
            (e[t + 1] = n[1]),
            (e[t + 2] = n[2]),
            (e[t + 3] = n[3]),
            (e[t + 4] = n[4]),
            (e[t + 5] = n[5]),
            (e[t + 6] = n[6]),
            (e[t + 7] = n[7]),
            (e[t + 8] = n[8]),
            (e[t + 9] = n[9]),
            (e[t + 10] = n[10]),
            (e[t + 11] = n[11]),
            (e[t + 12] = n[12]),
            (e[t + 13] = n[13]),
            (e[t + 14] = n[14]),
            (e[t + 15] = n[15]),
            e
          );
        }
      }
      const Ss = new Yr(),
        Is = new Cs(),
        Ms = new Yr(0, 0, 0),
        Ts = new Yr(1, 1, 1),
        Bs = new Yr(),
        Rs = new Yr(),
        Ds = new Yr(),
        Ps = new Cs(),
        Ls = new qr();
      class Us {
        constructor(e = 0, t = 0, n = 0, i = Us.DEFAULT_ORDER) {
          (this.isEuler = !0),
            (this._x = e),
            (this._y = t),
            (this._z = n),
            (this._order = i);
        }
        get x() {
          return this._x;
        }
        set x(e) {
          (this._x = e), this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(e) {
          (this._y = e), this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(e) {
          (this._z = e), this._onChangeCallback();
        }
        get order() {
          return this._order;
        }
        set order(e) {
          (this._order = e), this._onChangeCallback();
        }
        set(e, t, n, i = this._order) {
          return (
            (this._x = e),
            (this._y = t),
            (this._z = n),
            (this._order = i),
            this._onChangeCallback(),
            this
          );
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(e) {
          return (
            (this._x = e._x),
            (this._y = e._y),
            (this._z = e._z),
            (this._order = e._order),
            this._onChangeCallback(),
            this
          );
        }
        setFromRotationMatrix(e, t = this._order, n = !0) {
          const i = e.elements,
            r = i[0],
            s = i[4],
            a = i[8],
            o = i[1],
            c = i[5],
            l = i[9],
            u = i[2],
            h = i[6],
            d = i[10];
          switch (t) {
            case "XYZ":
              (this._y = Math.asin(fr(a, -1, 1))),
                Math.abs(a) < 0.9999999
                  ? ((this._x = Math.atan2(-l, d)),
                    (this._z = Math.atan2(-s, r)))
                  : ((this._x = Math.atan2(h, c)), (this._z = 0));
              break;
            case "YXZ":
              (this._x = Math.asin(-fr(l, -1, 1))),
                Math.abs(l) < 0.9999999
                  ? ((this._y = Math.atan2(a, d)), (this._z = Math.atan2(o, c)))
                  : ((this._y = Math.atan2(-u, r)), (this._z = 0));
              break;
            case "ZXY":
              (this._x = Math.asin(fr(h, -1, 1))),
                Math.abs(h) < 0.9999999
                  ? ((this._y = Math.atan2(-u, d)),
                    (this._z = Math.atan2(-s, c)))
                  : ((this._y = 0), (this._z = Math.atan2(o, r)));
              break;
            case "ZYX":
              (this._y = Math.asin(-fr(u, -1, 1))),
                Math.abs(u) < 0.9999999
                  ? ((this._x = Math.atan2(h, d)), (this._z = Math.atan2(o, r)))
                  : ((this._x = 0), (this._z = Math.atan2(-s, c)));
              break;
            case "YZX":
              (this._z = Math.asin(fr(o, -1, 1))),
                Math.abs(o) < 0.9999999
                  ? ((this._x = Math.atan2(-l, c)),
                    (this._y = Math.atan2(-u, r)))
                  : ((this._x = 0), (this._y = Math.atan2(a, d)));
              break;
            case "XZY":
              (this._z = Math.asin(-fr(s, -1, 1))),
                Math.abs(s) < 0.9999999
                  ? ((this._x = Math.atan2(h, c)), (this._y = Math.atan2(a, r)))
                  : ((this._x = Math.atan2(-l, d)), (this._y = 0));
              break;
            default:
              console.warn(
                "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
                  t
              );
          }
          return (this._order = t), !0 === n && this._onChangeCallback(), this;
        }
        setFromQuaternion(e, t, n) {
          return (
            Ps.makeRotationFromQuaternion(e),
            this.setFromRotationMatrix(Ps, t, n)
          );
        }
        setFromVector3(e, t = this._order) {
          return this.set(e.x, e.y, e.z, t);
        }
        reorder(e) {
          return Ls.setFromEuler(this), this.setFromQuaternion(Ls, e);
        }
        equals(e) {
          return (
            e._x === this._x &&
            e._y === this._y &&
            e._z === this._z &&
            e._order === this._order
          );
        }
        fromArray(e) {
          return (
            (this._x = e[0]),
            (this._y = e[1]),
            (this._z = e[2]),
            void 0 !== e[3] && (this._order = e[3]),
            this._onChangeCallback(),
            this
          );
        }
        toArray(e = [], t = 0) {
          return (
            (e[t] = this._x),
            (e[t + 1] = this._y),
            (e[t + 2] = this._z),
            (e[t + 3] = this._order),
            e
          );
        }
        _onChange(e) {
          return (this._onChangeCallback = e), this;
        }
        _onChangeCallback() {}
        *[Symbol.iterator]() {
          yield this._x, yield this._y, yield this._z, yield this._order;
        }
      }
      Us.DEFAULT_ORDER = "XYZ";
      class Fs {
        constructor() {
          this.mask = 1;
        }
        set(e) {
          this.mask = (1 << e) >>> 0;
        }
        enable(e) {
          this.mask |= 1 << e;
        }
        enableAll() {
          this.mask = -1;
        }
        toggle(e) {
          this.mask ^= 1 << e;
        }
        disable(e) {
          this.mask &= ~(1 << e);
        }
        disableAll() {
          this.mask = 0;
        }
        test(e) {
          return !!(this.mask & e.mask);
        }
        isEnabled(e) {
          return !!(this.mask & (1 << e));
        }
      }
      let Os = 0;
      const Ns = new Yr(),
        ks = new qr(),
        Qs = new Cs(),
        Gs = new Yr(),
        Hs = new Yr(),
        zs = new Yr(),
        Vs = new qr(),
        js = new Yr(1, 0, 0),
        Ws = new Yr(0, 1, 0),
        Xs = new Yr(0, 0, 1),
        qs = { type: "added" },
        Ys = { type: "removed" },
        Ks = { type: "childadded", child: null },
        Js = { type: "childremoved", child: null };
      class Zs extends cr {
        constructor() {
          super(),
            (this.isObject3D = !0),
            Object.defineProperty(this, "id", { value: Os++ }),
            (this.uuid = pr()),
            (this.name = ""),
            (this.type = "Object3D"),
            (this.parent = null),
            (this.children = []),
            (this.up = Zs.DEFAULT_UP.clone());
          const e = new Yr(),
            t = new Us(),
            n = new qr(),
            i = new Yr(1, 1, 1);
          t._onChange(function () {
            n.setFromEuler(t, !1);
          }),
            n._onChange(function () {
              t.setFromQuaternion(n, void 0, !1);
            }),
            Object.defineProperties(this, {
              position: { configurable: !0, enumerable: !0, value: e },
              rotation: { configurable: !0, enumerable: !0, value: t },
              quaternion: { configurable: !0, enumerable: !0, value: n },
              scale: { configurable: !0, enumerable: !0, value: i },
              modelViewMatrix: { value: new Cs() },
              normalMatrix: { value: new _r() },
            }),
            (this.matrix = new Cs()),
            (this.matrixWorld = new Cs()),
            (this.matrixAutoUpdate = Zs.DEFAULT_MATRIX_AUTO_UPDATE),
            (this.matrixWorldAutoUpdate = Zs.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
            (this.matrixWorldNeedsUpdate = !1),
            (this.layers = new Fs()),
            (this.visible = !0),
            (this.castShadow = !1),
            (this.receiveShadow = !1),
            (this.frustumCulled = !0),
            (this.renderOrder = 0),
            (this.animations = []),
            (this.userData = {});
        }
        onBeforeShadow() {}
        onAfterShadow() {}
        onBeforeRender() {}
        onAfterRender() {}
        applyMatrix4(e) {
          this.matrixAutoUpdate && this.updateMatrix(),
            this.matrix.premultiply(e),
            this.matrix.decompose(this.position, this.quaternion, this.scale);
        }
        applyQuaternion(e) {
          return this.quaternion.premultiply(e), this;
        }
        setRotationFromAxisAngle(e, t) {
          this.quaternion.setFromAxisAngle(e, t);
        }
        setRotationFromEuler(e) {
          this.quaternion.setFromEuler(e, !0);
        }
        setRotationFromMatrix(e) {
          this.quaternion.setFromRotationMatrix(e);
        }
        setRotationFromQuaternion(e) {
          this.quaternion.copy(e);
        }
        rotateOnAxis(e, t) {
          return ks.setFromAxisAngle(e, t), this.quaternion.multiply(ks), this;
        }
        rotateOnWorldAxis(e, t) {
          return (
            ks.setFromAxisAngle(e, t), this.quaternion.premultiply(ks), this
          );
        }
        rotateX(e) {
          return this.rotateOnAxis(js, e);
        }
        rotateY(e) {
          return this.rotateOnAxis(Ws, e);
        }
        rotateZ(e) {
          return this.rotateOnAxis(Xs, e);
        }
        translateOnAxis(e, t) {
          return (
            Ns.copy(e).applyQuaternion(this.quaternion),
            this.position.add(Ns.multiplyScalar(t)),
            this
          );
        }
        translateX(e) {
          return this.translateOnAxis(js, e);
        }
        translateY(e) {
          return this.translateOnAxis(Ws, e);
        }
        translateZ(e) {
          return this.translateOnAxis(Xs, e);
        }
        localToWorld(e) {
          return (
            this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld)
          );
        }
        worldToLocal(e) {
          return (
            this.updateWorldMatrix(!0, !1),
            e.applyMatrix4(Qs.copy(this.matrixWorld).invert())
          );
        }
        lookAt(e, t, n) {
          e.isVector3 ? Gs.copy(e) : Gs.set(e, t, n);
          const i = this.parent;
          this.updateWorldMatrix(!0, !1),
            Hs.setFromMatrixPosition(this.matrixWorld),
            this.isCamera || this.isLight
              ? Qs.lookAt(Hs, Gs, this.up)
              : Qs.lookAt(Gs, Hs, this.up),
            this.quaternion.setFromRotationMatrix(Qs),
            i &&
              (Qs.extractRotation(i.matrixWorld),
              ks.setFromRotationMatrix(Qs),
              this.quaternion.premultiply(ks.invert()));
        }
        add(e) {
          if (arguments.length > 1) {
            for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
            return this;
          }
          return e === this
            ? (console.error(
                "THREE.Object3D.add: object can't be added as a child of itself.",
                e
              ),
              this)
            : (e && e.isObject3D
                ? (e.removeFromParent(),
                  (e.parent = this),
                  this.children.push(e),
                  e.dispatchEvent(qs),
                  (Ks.child = e),
                  this.dispatchEvent(Ks),
                  (Ks.child = null))
                : console.error(
                    "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                    e
                  ),
              this);
        }
        remove(e) {
          if (arguments.length > 1) {
            for (let e = 0; e < arguments.length; e++)
              this.remove(arguments[e]);
            return this;
          }
          const t = this.children.indexOf(e);
          return (
            -1 !== t &&
              ((e.parent = null),
              this.children.splice(t, 1),
              e.dispatchEvent(Ys),
              (Js.child = e),
              this.dispatchEvent(Js),
              (Js.child = null)),
            this
          );
        }
        removeFromParent() {
          const e = this.parent;
          return null !== e && e.remove(this), this;
        }
        clear() {
          return this.remove(...this.children);
        }
        attach(e) {
          return (
            this.updateWorldMatrix(!0, !1),
            Qs.copy(this.matrixWorld).invert(),
            null !== e.parent &&
              (e.parent.updateWorldMatrix(!0, !1),
              Qs.multiply(e.parent.matrixWorld)),
            e.applyMatrix4(Qs),
            e.removeFromParent(),
            (e.parent = this),
            this.children.push(e),
            e.updateWorldMatrix(!1, !0),
            e.dispatchEvent(qs),
            (Ks.child = e),
            this.dispatchEvent(Ks),
            (Ks.child = null),
            this
          );
        }
        getObjectById(e) {
          return this.getObjectByProperty("id", e);
        }
        getObjectByName(e) {
          return this.getObjectByProperty("name", e);
        }
        getObjectByProperty(e, t) {
          if (this[e] === t) return this;
          for (let n = 0, i = this.children.length; n < i; n++) {
            const i = this.children[n].getObjectByProperty(e, t);
            if (void 0 !== i) return i;
          }
        }
        getObjectsByProperty(e, t, n = []) {
          this[e] === t && n.push(this);
          const i = this.children;
          for (let r = 0, s = i.length; r < s; r++)
            i[r].getObjectsByProperty(e, t, n);
          return n;
        }
        getWorldPosition(e) {
          return (
            this.updateWorldMatrix(!0, !1),
            e.setFromMatrixPosition(this.matrixWorld)
          );
        }
        getWorldQuaternion(e) {
          return (
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(Hs, e, zs),
            e
          );
        }
        getWorldScale(e) {
          return (
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(Hs, Vs, e),
            e
          );
        }
        getWorldDirection(e) {
          this.updateWorldMatrix(!0, !1);
          const t = this.matrixWorld.elements;
          return e.set(t[8], t[9], t[10]).normalize();
        }
        raycast() {}
        traverse(e) {
          e(this);
          const t = this.children;
          for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e);
        }
        traverseVisible(e) {
          if (!1 === this.visible) return;
          e(this);
          const t = this.children;
          for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e);
        }
        traverseAncestors(e) {
          const t = this.parent;
          null !== t && (e(t), t.traverseAncestors(e));
        }
        updateMatrix() {
          this.matrix.compose(this.position, this.quaternion, this.scale),
            (this.matrixWorldNeedsUpdate = !0);
        }
        updateMatrixWorld(e) {
          this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || e) &&
              (!0 === this.matrixWorldAutoUpdate &&
                (null === this.parent
                  ? this.matrixWorld.copy(this.matrix)
                  : this.matrixWorld.multiplyMatrices(
                      this.parent.matrixWorld,
                      this.matrix
                    )),
              (this.matrixWorldNeedsUpdate = !1),
              (e = !0));
          const t = this.children;
          for (let n = 0, i = t.length; n < i; n++) {
            t[n].updateMatrixWorld(e);
          }
        }
        updateWorldMatrix(e, t) {
          const n = this.parent;
          if (
            (!0 === e && null !== n && n.updateWorldMatrix(!0, !1),
            this.matrixAutoUpdate && this.updateMatrix(),
            !0 === this.matrixWorldAutoUpdate &&
              (null === this.parent
                ? this.matrixWorld.copy(this.matrix)
                : this.matrixWorld.multiplyMatrices(
                    this.parent.matrixWorld,
                    this.matrix
                  )),
            !0 === t)
          ) {
            const e = this.children;
            for (let t = 0, n = e.length; t < n; t++) {
              e[t].updateWorldMatrix(!1, !0);
            }
          }
        }
        toJSON(e) {
          const t = void 0 === e || "string" == typeof e,
            n = {};
          t &&
            ((e = {
              geometries: {},
              materials: {},
              textures: {},
              images: {},
              shapes: {},
              skeletons: {},
              animations: {},
              nodes: {},
            }),
            (n.metadata = {
              version: 4.6,
              type: "Object",
              generator: "Object3D.toJSON",
            }));
          const i = {};
          function r(t, n) {
            return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid;
          }
          if (
            ((i.uuid = this.uuid),
            (i.type = this.type),
            "" !== this.name && (i.name = this.name),
            !0 === this.castShadow && (i.castShadow = !0),
            !0 === this.receiveShadow && (i.receiveShadow = !0),
            !1 === this.visible && (i.visible = !1),
            !1 === this.frustumCulled && (i.frustumCulled = !1),
            0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
            Object.keys(this.userData).length > 0 &&
              (i.userData = this.userData),
            (i.layers = this.layers.mask),
            (i.matrix = this.matrix.toArray()),
            (i.up = this.up.toArray()),
            !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
            this.isInstancedMesh &&
              ((i.type = "InstancedMesh"),
              (i.count = this.count),
              (i.instanceMatrix = this.instanceMatrix.toJSON()),
              null !== this.instanceColor &&
                (i.instanceColor = this.instanceColor.toJSON())),
            this.isBatchedMesh &&
              ((i.type = "BatchedMesh"),
              (i.perObjectFrustumCulled = this.perObjectFrustumCulled),
              (i.sortObjects = this.sortObjects),
              (i.drawRanges = this._drawRanges),
              (i.reservedRanges = this._reservedRanges),
              (i.visibility = this._visibility),
              (i.active = this._active),
              (i.bounds = this._bounds.map((e) => ({
                boxInitialized: e.boxInitialized,
                boxMin: e.box.min.toArray(),
                boxMax: e.box.max.toArray(),
                sphereInitialized: e.sphereInitialized,
                sphereRadius: e.sphere.radius,
                sphereCenter: e.sphere.center.toArray(),
              }))),
              (i.maxInstanceCount = this._maxInstanceCount),
              (i.maxVertexCount = this._maxVertexCount),
              (i.maxIndexCount = this._maxIndexCount),
              (i.geometryInitialized = this._geometryInitialized),
              (i.geometryCount = this._geometryCount),
              (i.matricesTexture = this._matricesTexture.toJSON(e)),
              null !== this._colorsTexture &&
                (i.colorsTexture = this._colorsTexture.toJSON(e)),
              null !== this.boundingSphere &&
                (i.boundingSphere = {
                  center: i.boundingSphere.center.toArray(),
                  radius: i.boundingSphere.radius,
                }),
              null !== this.boundingBox &&
                (i.boundingBox = {
                  min: i.boundingBox.min.toArray(),
                  max: i.boundingBox.max.toArray(),
                })),
            this.isScene)
          )
            this.background &&
              (this.background.isColor
                ? (i.background = this.background.toJSON())
                : this.background.isTexture &&
                  (i.background = this.background.toJSON(e).uuid)),
              this.environment &&
                this.environment.isTexture &&
                !0 !== this.environment.isRenderTargetTexture &&
                (i.environment = this.environment.toJSON(e).uuid);
          else if (this.isMesh || this.isLine || this.isPoints) {
            i.geometry = r(e.geometries, this.geometry);
            const t = this.geometry.parameters;
            if (void 0 !== t && void 0 !== t.shapes) {
              const n = t.shapes;
              if (Array.isArray(n))
                for (let t = 0, i = n.length; t < i; t++) {
                  const i = n[t];
                  r(e.shapes, i);
                }
              else r(e.shapes, n);
            }
          }
          if (
            (this.isSkinnedMesh &&
              ((i.bindMode = this.bindMode),
              (i.bindMatrix = this.bindMatrix.toArray()),
              void 0 !== this.skeleton &&
                (r(e.skeletons, this.skeleton),
                (i.skeleton = this.skeleton.uuid))),
            void 0 !== this.material)
          )
            if (Array.isArray(this.material)) {
              const t = [];
              for (let n = 0, i = this.material.length; n < i; n++)
                t.push(r(e.materials, this.material[n]));
              i.material = t;
            } else i.material = r(e.materials, this.material);
          if (this.children.length > 0) {
            i.children = [];
            for (let t = 0; t < this.children.length; t++)
              i.children.push(this.children[t].toJSON(e).object);
          }
          if (this.animations.length > 0) {
            i.animations = [];
            for (let t = 0; t < this.animations.length; t++) {
              const n = this.animations[t];
              i.animations.push(r(e.animations, n));
            }
          }
          if (t) {
            const t = s(e.geometries),
              i = s(e.materials),
              r = s(e.textures),
              a = s(e.images),
              o = s(e.shapes),
              c = s(e.skeletons),
              l = s(e.animations),
              u = s(e.nodes);
            t.length > 0 && (n.geometries = t),
              i.length > 0 && (n.materials = i),
              r.length > 0 && (n.textures = r),
              a.length > 0 && (n.images = a),
              o.length > 0 && (n.shapes = o),
              c.length > 0 && (n.skeletons = c),
              l.length > 0 && (n.animations = l),
              u.length > 0 && (n.nodes = u);
          }
          return (n.object = i), n;
          function s(e) {
            const t = [];
            for (const n in e) {
              const i = e[n];
              delete i.metadata, t.push(i);
            }
            return t;
          }
        }
        clone(e) {
          return new this.constructor().copy(this, e);
        }
        copy(e, t = !0) {
          if (
            ((this.name = e.name),
            this.up.copy(e.up),
            this.position.copy(e.position),
            (this.rotation.order = e.rotation.order),
            this.quaternion.copy(e.quaternion),
            this.scale.copy(e.scale),
            this.matrix.copy(e.matrix),
            this.matrixWorld.copy(e.matrixWorld),
            (this.matrixAutoUpdate = e.matrixAutoUpdate),
            (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
            (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
            (this.layers.mask = e.layers.mask),
            (this.visible = e.visible),
            (this.castShadow = e.castShadow),
            (this.receiveShadow = e.receiveShadow),
            (this.frustumCulled = e.frustumCulled),
            (this.renderOrder = e.renderOrder),
            (this.animations = e.animations.slice()),
            (this.userData = JSON.parse(JSON.stringify(e.userData))),
            !0 === t)
          )
            for (let t = 0; t < e.children.length; t++) {
              const n = e.children[t];
              this.add(n.clone());
            }
          return this;
        }
      }
      (Zs.DEFAULT_UP = new Yr(0, 1, 0)),
        (Zs.DEFAULT_MATRIX_AUTO_UPDATE = !0),
        (Zs.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0);
      const $s = new Yr(),
        ea = new Yr(),
        ta = new Yr(),
        na = new Yr(),
        ia = new Yr(),
        ra = new Yr(),
        sa = new Yr(),
        aa = new Yr(),
        oa = new Yr(),
        ca = new Yr(),
        la = new zr(),
        ua = new zr(),
        ha = new zr();
      class da {
        constructor(e = new Yr(), t = new Yr(), n = new Yr()) {
          (this.a = e), (this.b = t), (this.c = n);
        }
        static getNormal(e, t, n, i) {
          i.subVectors(n, t), $s.subVectors(e, t), i.cross($s);
          const r = i.lengthSq();
          return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
        }
        static getBarycoord(e, t, n, i, r) {
          $s.subVectors(i, t), ea.subVectors(n, t), ta.subVectors(e, t);
          const s = $s.dot($s),
            a = $s.dot(ea),
            o = $s.dot(ta),
            c = ea.dot(ea),
            l = ea.dot(ta),
            u = s * c - a * a;
          if (0 === u) return r.set(0, 0, 0), null;
          const h = 1 / u,
            d = (c * o - a * l) * h,
            p = (s * l - a * o) * h;
          return r.set(1 - d - p, p, d);
        }
        static containsPoint(e, t, n, i) {
          return (
            null !== this.getBarycoord(e, t, n, i, na) &&
            na.x >= 0 &&
            na.y >= 0 &&
            na.x + na.y <= 1
          );
        }
        static getInterpolation(e, t, n, i, r, s, a, o) {
          return null === this.getBarycoord(e, t, n, i, na)
            ? ((o.x = 0),
              (o.y = 0),
              "z" in o && (o.z = 0),
              "w" in o && (o.w = 0),
              null)
            : (o.setScalar(0),
              o.addScaledVector(r, na.x),
              o.addScaledVector(s, na.y),
              o.addScaledVector(a, na.z),
              o);
        }
        static getInterpolatedAttribute(e, t, n, i, r, s) {
          return (
            la.setScalar(0),
            ua.setScalar(0),
            ha.setScalar(0),
            la.fromBufferAttribute(e, t),
            ua.fromBufferAttribute(e, n),
            ha.fromBufferAttribute(e, i),
            s.setScalar(0),
            s.addScaledVector(la, r.x),
            s.addScaledVector(ua, r.y),
            s.addScaledVector(ha, r.z),
            s
          );
        }
        static isFrontFacing(e, t, n, i) {
          return (
            $s.subVectors(n, t), ea.subVectors(e, t), $s.cross(ea).dot(i) < 0
          );
        }
        set(e, t, n) {
          return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
        }
        setFromPointsAndIndices(e, t, n, i) {
          return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this;
        }
        setFromAttributeAndIndices(e, t, n, i) {
          return (
            this.a.fromBufferAttribute(e, t),
            this.b.fromBufferAttribute(e, n),
            this.c.fromBufferAttribute(e, i),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
        }
        getArea() {
          return (
            $s.subVectors(this.c, this.b),
            ea.subVectors(this.a, this.b),
            0.5 * $s.cross(ea).length()
          );
        }
        getMidpoint(e) {
          return e
            .addVectors(this.a, this.b)
            .add(this.c)
            .multiplyScalar(1 / 3);
        }
        getNormal(e) {
          return da.getNormal(this.a, this.b, this.c, e);
        }
        getPlane(e) {
          return e.setFromCoplanarPoints(this.a, this.b, this.c);
        }
        getBarycoord(e, t) {
          return da.getBarycoord(e, this.a, this.b, this.c, t);
        }
        getInterpolation(e, t, n, i, r) {
          return da.getInterpolation(e, this.a, this.b, this.c, t, n, i, r);
        }
        containsPoint(e) {
          return da.containsPoint(e, this.a, this.b, this.c);
        }
        isFrontFacing(e) {
          return da.isFrontFacing(this.a, this.b, this.c, e);
        }
        intersectsBox(e) {
          return e.intersectsTriangle(this);
        }
        closestPointToPoint(e, t) {
          const n = this.a,
            i = this.b,
            r = this.c;
          let s, a;
          ia.subVectors(i, n), ra.subVectors(r, n), aa.subVectors(e, n);
          const o = ia.dot(aa),
            c = ra.dot(aa);
          if (o <= 0 && c <= 0) return t.copy(n);
          oa.subVectors(e, i);
          const l = ia.dot(oa),
            u = ra.dot(oa);
          if (l >= 0 && u <= l) return t.copy(i);
          const h = o * u - l * c;
          if (h <= 0 && o >= 0 && l <= 0)
            return (s = o / (o - l)), t.copy(n).addScaledVector(ia, s);
          ca.subVectors(e, r);
          const d = ia.dot(ca),
            p = ra.dot(ca);
          if (p >= 0 && d <= p) return t.copy(r);
          const f = d * c - o * p;
          if (f <= 0 && c >= 0 && p <= 0)
            return (a = c / (c - p)), t.copy(n).addScaledVector(ra, a);
          const A = l * p - d * u;
          if (A <= 0 && u - l >= 0 && d - p >= 0)
            return (
              sa.subVectors(r, i),
              (a = (u - l) / (u - l + (d - p))),
              t.copy(i).addScaledVector(sa, a)
            );
          const g = 1 / (A + f + h);
          return (
            (s = f * g),
            (a = h * g),
            t.copy(n).addScaledVector(ia, s).addScaledVector(ra, a)
          );
        }
        equals(e) {
          return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
        }
      }
      const pa = {
          aliceblue: 15792383,
          antiquewhite: 16444375,
          aqua: 65535,
          aquamarine: 8388564,
          azure: 15794175,
          beige: 16119260,
          bisque: 16770244,
          black: 0,
          blanchedalmond: 16772045,
          blue: 255,
          blueviolet: 9055202,
          brown: 10824234,
          burlywood: 14596231,
          cadetblue: 6266528,
          chartreuse: 8388352,
          chocolate: 13789470,
          coral: 16744272,
          cornflowerblue: 6591981,
          cornsilk: 16775388,
          crimson: 14423100,
          cyan: 65535,
          darkblue: 139,
          darkcyan: 35723,
          darkgoldenrod: 12092939,
          darkgray: 11119017,
          darkgreen: 25600,
          darkgrey: 11119017,
          darkkhaki: 12433259,
          darkmagenta: 9109643,
          darkolivegreen: 5597999,
          darkorange: 16747520,
          darkorchid: 10040012,
          darkred: 9109504,
          darksalmon: 15308410,
          darkseagreen: 9419919,
          darkslateblue: 4734347,
          darkslategray: 3100495,
          darkslategrey: 3100495,
          darkturquoise: 52945,
          darkviolet: 9699539,
          deeppink: 16716947,
          deepskyblue: 49151,
          dimgray: 6908265,
          dimgrey: 6908265,
          dodgerblue: 2003199,
          firebrick: 11674146,
          floralwhite: 16775920,
          forestgreen: 2263842,
          fuchsia: 16711935,
          gainsboro: 14474460,
          ghostwhite: 16316671,
          gold: 16766720,
          goldenrod: 14329120,
          gray: 8421504,
          green: 32768,
          greenyellow: 11403055,
          grey: 8421504,
          honeydew: 15794160,
          hotpink: 16738740,
          indianred: 13458524,
          indigo: 4915330,
          ivory: 16777200,
          khaki: 15787660,
          lavender: 15132410,
          lavenderblush: 16773365,
          lawngreen: 8190976,
          lemonchiffon: 16775885,
          lightblue: 11393254,
          lightcoral: 15761536,
          lightcyan: 14745599,
          lightgoldenrodyellow: 16448210,
          lightgray: 13882323,
          lightgreen: 9498256,
          lightgrey: 13882323,
          lightpink: 16758465,
          lightsalmon: 16752762,
          lightseagreen: 2142890,
          lightskyblue: 8900346,
          lightslategray: 7833753,
          lightslategrey: 7833753,
          lightsteelblue: 11584734,
          lightyellow: 16777184,
          lime: 65280,
          limegreen: 3329330,
          linen: 16445670,
          magenta: 16711935,
          maroon: 8388608,
          mediumaquamarine: 6737322,
          mediumblue: 205,
          mediumorchid: 12211667,
          mediumpurple: 9662683,
          mediumseagreen: 3978097,
          mediumslateblue: 8087790,
          mediumspringgreen: 64154,
          mediumturquoise: 4772300,
          mediumvioletred: 13047173,
          midnightblue: 1644912,
          mintcream: 16121850,
          mistyrose: 16770273,
          moccasin: 16770229,
          navajowhite: 16768685,
          navy: 128,
          oldlace: 16643558,
          olive: 8421376,
          olivedrab: 7048739,
          orange: 16753920,
          orangered: 16729344,
          orchid: 14315734,
          palegoldenrod: 15657130,
          palegreen: 10025880,
          paleturquoise: 11529966,
          palevioletred: 14381203,
          papayawhip: 16773077,
          peachpuff: 16767673,
          peru: 13468991,
          pink: 16761035,
          plum: 14524637,
          powderblue: 11591910,
          purple: 8388736,
          rebeccapurple: 6697881,
          red: 16711680,
          rosybrown: 12357519,
          royalblue: 4286945,
          saddlebrown: 9127187,
          salmon: 16416882,
          sandybrown: 16032864,
          seagreen: 3050327,
          seashell: 16774638,
          sienna: 10506797,
          silver: 12632256,
          skyblue: 8900331,
          slateblue: 6970061,
          slategray: 7372944,
          slategrey: 7372944,
          snow: 16775930,
          springgreen: 65407,
          steelblue: 4620980,
          tan: 13808780,
          teal: 32896,
          thistle: 14204888,
          tomato: 16737095,
          turquoise: 4251856,
          violet: 15631086,
          wheat: 16113331,
          white: 16777215,
          whitesmoke: 16119285,
          yellow: 16776960,
          yellowgreen: 10145074,
        },
        fa = { h: 0, s: 0, l: 0 },
        Aa = { h: 0, s: 0, l: 0 };
      function ga(e, t, n) {
        return (
          n < 0 && (n += 1),
          n > 1 && (n -= 1),
          n < 1 / 6
            ? e + 6 * (t - e) * n
            : n < 0.5
            ? t
            : n < 2 / 3
            ? e + 6 * (t - e) * (2 / 3 - n)
            : e
        );
      }
      class ma {
        constructor(e, t, n) {
          return (
            (this.isColor = !0),
            (this.r = 1),
            (this.g = 1),
            (this.b = 1),
            this.set(e, t, n)
          );
        }
        set(e, t, n) {
          if (void 0 === t && void 0 === n) {
            const t = e;
            t && t.isColor
              ? this.copy(t)
              : "number" == typeof t
              ? this.setHex(t)
              : "string" == typeof t && this.setStyle(t);
          } else this.setRGB(e, t, n);
          return this;
        }
        setScalar(e) {
          return (this.r = e), (this.g = e), (this.b = e), this;
        }
        setHex(e, t = Zi) {
          return (
            (e = Math.floor(e)),
            (this.r = ((e >> 16) & 255) / 255),
            (this.g = ((e >> 8) & 255) / 255),
            (this.b = (255 & e) / 255),
            Mr.toWorkingColorSpace(this, t),
            this
          );
        }
        setRGB(e, t, n, i = Mr.workingColorSpace) {
          return (
            (this.r = e),
            (this.g = t),
            (this.b = n),
            Mr.toWorkingColorSpace(this, i),
            this
          );
        }
        setHSL(e, t, n, i = Mr.workingColorSpace) {
          if (((e = Ar(e, 1)), (t = fr(t, 0, 1)), (n = fr(n, 0, 1)), 0 === t))
            this.r = this.g = this.b = n;
          else {
            const i = n <= 0.5 ? n * (1 + t) : n + t - n * t,
              r = 2 * n - i;
            (this.r = ga(r, i, e + 1 / 3)),
              (this.g = ga(r, i, e)),
              (this.b = ga(r, i, e - 1 / 3));
          }
          return Mr.toWorkingColorSpace(this, i), this;
        }
        setStyle(e, t = Zi) {
          function n(t) {
            void 0 !== t &&
              parseFloat(t) < 1 &&
              console.warn(
                "THREE.Color: Alpha component of " + e + " will be ignored."
              );
          }
          let i;
          if ((i = /^(\w+)\(([^\)]*)\)/.exec(e))) {
            let r;
            const s = i[1],
              a = i[2];
            switch (s) {
              case "rgb":
              case "rgba":
                if (
                  (r =
                    /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      a
                    ))
                )
                  return (
                    n(r[4]),
                    this.setRGB(
                      Math.min(255, parseInt(r[1], 10)) / 255,
                      Math.min(255, parseInt(r[2], 10)) / 255,
                      Math.min(255, parseInt(r[3], 10)) / 255,
                      t
                    )
                  );
                if (
                  (r =
                    /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      a
                    ))
                )
                  return (
                    n(r[4]),
                    this.setRGB(
                      Math.min(100, parseInt(r[1], 10)) / 100,
                      Math.min(100, parseInt(r[2], 10)) / 100,
                      Math.min(100, parseInt(r[3], 10)) / 100,
                      t
                    )
                  );
                break;
              case "hsl":
              case "hsla":
                if (
                  (r =
                    /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      a
                    ))
                )
                  return (
                    n(r[4]),
                    this.setHSL(
                      parseFloat(r[1]) / 360,
                      parseFloat(r[2]) / 100,
                      parseFloat(r[3]) / 100,
                      t
                    )
                  );
                break;
              default:
                console.warn("THREE.Color: Unknown color model " + e);
            }
          } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(e))) {
            const n = i[1],
              r = n.length;
            if (3 === r)
              return this.setRGB(
                parseInt(n.charAt(0), 16) / 15,
                parseInt(n.charAt(1), 16) / 15,
                parseInt(n.charAt(2), 16) / 15,
                t
              );
            if (6 === r) return this.setHex(parseInt(n, 16), t);
            console.warn("THREE.Color: Invalid hex color " + e);
          } else if (e && e.length > 0) return this.setColorName(e, t);
          return this;
        }
        setColorName(e, t = Zi) {
          const n = pa[e.toLowerCase()];
          return (
            void 0 !== n
              ? this.setHex(n, t)
              : console.warn("THREE.Color: Unknown color " + e),
            this
          );
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b);
        }
        copy(e) {
          return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
        }
        copySRGBToLinear(e) {
          return (
            (this.r = Tr(e.r)), (this.g = Tr(e.g)), (this.b = Tr(e.b)), this
          );
        }
        copyLinearToSRGB(e) {
          return (
            (this.r = Br(e.r)), (this.g = Br(e.g)), (this.b = Br(e.b)), this
          );
        }
        convertSRGBToLinear() {
          return this.copySRGBToLinear(this), this;
        }
        convertLinearToSRGB() {
          return this.copyLinearToSRGB(this), this;
        }
        getHex(e = Zi) {
          return (
            Mr.fromWorkingColorSpace(va.copy(this), e),
            65536 * Math.round(fr(255 * va.r, 0, 255)) +
              256 * Math.round(fr(255 * va.g, 0, 255)) +
              Math.round(fr(255 * va.b, 0, 255))
          );
        }
        getHexString(e = Zi) {
          return ("000000" + this.getHex(e).toString(16)).slice(-6);
        }
        getHSL(e, t = Mr.workingColorSpace) {
          Mr.fromWorkingColorSpace(va.copy(this), t);
          const n = va.r,
            i = va.g,
            r = va.b,
            s = Math.max(n, i, r),
            a = Math.min(n, i, r);
          let o, c;
          const l = (a + s) / 2;
          if (a === s) (o = 0), (c = 0);
          else {
            const e = s - a;
            switch (((c = l <= 0.5 ? e / (s + a) : e / (2 - s - a)), s)) {
              case n:
                o = (i - r) / e + (i < r ? 6 : 0);
                break;
              case i:
                o = (r - n) / e + 2;
                break;
              case r:
                o = (n - i) / e + 4;
            }
            o /= 6;
          }
          return (e.h = o), (e.s = c), (e.l = l), e;
        }
        getRGB(e, t = Mr.workingColorSpace) {
          return (
            Mr.fromWorkingColorSpace(va.copy(this), t),
            (e.r = va.r),
            (e.g = va.g),
            (e.b = va.b),
            e
          );
        }
        getStyle(e = Zi) {
          Mr.fromWorkingColorSpace(va.copy(this), e);
          const t = va.r,
            n = va.g,
            i = va.b;
          return e !== Zi
            ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})`
            : `rgb(${Math.round(255 * t)},${Math.round(255 * n)},${Math.round(
                255 * i
              )})`;
        }
        offsetHSL(e, t, n) {
          return this.getHSL(fa), this.setHSL(fa.h + e, fa.s + t, fa.l + n);
        }
        add(e) {
          return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
        }
        addColors(e, t) {
          return (
            (this.r = e.r + t.r),
            (this.g = e.g + t.g),
            (this.b = e.b + t.b),
            this
          );
        }
        addScalar(e) {
          return (this.r += e), (this.g += e), (this.b += e), this;
        }
        sub(e) {
          return (
            (this.r = Math.max(0, this.r - e.r)),
            (this.g = Math.max(0, this.g - e.g)),
            (this.b = Math.max(0, this.b - e.b)),
            this
          );
        }
        multiply(e) {
          return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
        }
        multiplyScalar(e) {
          return (this.r *= e), (this.g *= e), (this.b *= e), this;
        }
        lerp(e, t) {
          return (
            (this.r += (e.r - this.r) * t),
            (this.g += (e.g - this.g) * t),
            (this.b += (e.b - this.b) * t),
            this
          );
        }
        lerpColors(e, t, n) {
          return (
            (this.r = e.r + (t.r - e.r) * n),
            (this.g = e.g + (t.g - e.g) * n),
            (this.b = e.b + (t.b - e.b) * n),
            this
          );
        }
        lerpHSL(e, t) {
          this.getHSL(fa), e.getHSL(Aa);
          const n = gr(fa.h, Aa.h, t),
            i = gr(fa.s, Aa.s, t),
            r = gr(fa.l, Aa.l, t);
          return this.setHSL(n, i, r), this;
        }
        setFromVector3(e) {
          return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
        }
        applyMatrix3(e) {
          const t = this.r,
            n = this.g,
            i = this.b,
            r = e.elements;
          return (
            (this.r = r[0] * t + r[3] * n + r[6] * i),
            (this.g = r[1] * t + r[4] * n + r[7] * i),
            (this.b = r[2] * t + r[5] * n + r[8] * i),
            this
          );
        }
        equals(e) {
          return e.r === this.r && e.g === this.g && e.b === this.b;
        }
        fromArray(e, t = 0) {
          return (
            (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this
          );
        }
        toArray(e = [], t = 0) {
          return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
        }
        fromBufferAttribute(e, t) {
          return (
            (this.r = e.getX(t)),
            (this.g = e.getY(t)),
            (this.b = e.getZ(t)),
            this
          );
        }
        toJSON() {
          return this.getHex();
        }
        *[Symbol.iterator]() {
          yield this.r, yield this.g, yield this.b;
        }
      }
      const va = new ma();
      ma.NAMES = pa;
      let ya = 0;
      class ba extends cr {
        static get type() {
          return "Material";
        }
        get type() {
          return this.constructor.type;
        }
        set type(e) {}
        constructor() {
          super(),
            (this.isMaterial = !0),
            Object.defineProperty(this, "id", { value: ya++ }),
            (this.uuid = pr()),
            (this.name = ""),
            (this.blending = 1),
            (this.side = cn),
            (this.vertexColors = !1),
            (this.opacity = 1),
            (this.transparent = !1),
            (this.alphaHash = !1),
            (this.blendSrc = 204),
            (this.blendDst = 205),
            (this.blendEquation = hn),
            (this.blendSrcAlpha = null),
            (this.blendDstAlpha = null),
            (this.blendEquationAlpha = null),
            (this.blendColor = new ma(0, 0, 0)),
            (this.blendAlpha = 0),
            (this.depthFunc = 3),
            (this.depthTest = !0),
            (this.depthWrite = !0),
            (this.stencilWriteMask = 255),
            (this.stencilFunc = 519),
            (this.stencilRef = 0),
            (this.stencilFuncMask = 255),
            (this.stencilFail = nr),
            (this.stencilZFail = nr),
            (this.stencilZPass = nr),
            (this.stencilWrite = !1),
            (this.clippingPlanes = null),
            (this.clipIntersection = !1),
            (this.clipShadows = !1),
            (this.shadowSide = null),
            (this.colorWrite = !0),
            (this.precision = null),
            (this.polygonOffset = !1),
            (this.polygonOffsetFactor = 0),
            (this.polygonOffsetUnits = 0),
            (this.dithering = !1),
            (this.alphaToCoverage = !1),
            (this.premultipliedAlpha = !1),
            (this.forceSinglePass = !1),
            (this.visible = !0),
            (this.toneMapped = !0),
            (this.userData = {}),
            (this.version = 0),
            (this._alphaTest = 0);
        }
        get alphaTest() {
          return this._alphaTest;
        }
        set alphaTest(e) {
          this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
        }
        onBeforeRender() {}
        onBeforeCompile() {}
        customProgramCacheKey() {
          return this.onBeforeCompile.toString();
        }
        setValues(e) {
          if (void 0 !== e)
            for (const t in e) {
              const n = e[t];
              if (void 0 === n) {
                console.warn(
                  `THREE.Material: parameter '${t}' has value of undefined.`
                );
                continue;
              }
              const i = this[t];
              void 0 !== i
                ? i && i.isColor
                  ? i.set(n)
                  : i && i.isVector3 && n && n.isVector3
                  ? i.copy(n)
                  : (this[t] = n)
                : console.warn(
                    `THREE.Material: '${t}' is not a property of THREE.${this.type}.`
                  );
            }
        }
        toJSON(e) {
          const t = void 0 === e || "string" == typeof e;
          t && (e = { textures: {}, images: {} });
          const n = {
            metadata: {
              version: 4.6,
              type: "Material",
              generator: "Material.toJSON",
            },
          };
          function i(e) {
            const t = [];
            for (const n in e) {
              const i = e[n];
              delete i.metadata, t.push(i);
            }
            return t;
          }
          if (
            ((n.uuid = this.uuid),
            (n.type = this.type),
            "" !== this.name && (n.name = this.name),
            this.color && this.color.isColor && (n.color = this.color.getHex()),
            void 0 !== this.roughness && (n.roughness = this.roughness),
            void 0 !== this.metalness && (n.metalness = this.metalness),
            void 0 !== this.sheen && (n.sheen = this.sheen),
            this.sheenColor &&
              this.sheenColor.isColor &&
              (n.sheenColor = this.sheenColor.getHex()),
            void 0 !== this.sheenRoughness &&
              (n.sheenRoughness = this.sheenRoughness),
            this.emissive &&
              this.emissive.isColor &&
              (n.emissive = this.emissive.getHex()),
            void 0 !== this.emissiveIntensity &&
              1 !== this.emissiveIntensity &&
              (n.emissiveIntensity = this.emissiveIntensity),
            this.specular &&
              this.specular.isColor &&
              (n.specular = this.specular.getHex()),
            void 0 !== this.specularIntensity &&
              (n.specularIntensity = this.specularIntensity),
            this.specularColor &&
              this.specularColor.isColor &&
              (n.specularColor = this.specularColor.getHex()),
            void 0 !== this.shininess && (n.shininess = this.shininess),
            void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
            void 0 !== this.clearcoatRoughness &&
              (n.clearcoatRoughness = this.clearcoatRoughness),
            this.clearcoatMap &&
              this.clearcoatMap.isTexture &&
              (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
            this.clearcoatRoughnessMap &&
              this.clearcoatRoughnessMap.isTexture &&
              (n.clearcoatRoughnessMap =
                this.clearcoatRoughnessMap.toJSON(e).uuid),
            this.clearcoatNormalMap &&
              this.clearcoatNormalMap.isTexture &&
              ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
              (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
            void 0 !== this.dispersion && (n.dispersion = this.dispersion),
            void 0 !== this.iridescence && (n.iridescence = this.iridescence),
            void 0 !== this.iridescenceIOR &&
              (n.iridescenceIOR = this.iridescenceIOR),
            void 0 !== this.iridescenceThicknessRange &&
              (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
            this.iridescenceMap &&
              this.iridescenceMap.isTexture &&
              (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
            this.iridescenceThicknessMap &&
              this.iridescenceThicknessMap.isTexture &&
              (n.iridescenceThicknessMap =
                this.iridescenceThicknessMap.toJSON(e).uuid),
            void 0 !== this.anisotropy && (n.anisotropy = this.anisotropy),
            void 0 !== this.anisotropyRotation &&
              (n.anisotropyRotation = this.anisotropyRotation),
            this.anisotropyMap &&
              this.anisotropyMap.isTexture &&
              (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
            this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
            this.matcap &&
              this.matcap.isTexture &&
              (n.matcap = this.matcap.toJSON(e).uuid),
            this.alphaMap &&
              this.alphaMap.isTexture &&
              (n.alphaMap = this.alphaMap.toJSON(e).uuid),
            this.lightMap &&
              this.lightMap.isTexture &&
              ((n.lightMap = this.lightMap.toJSON(e).uuid),
              (n.lightMapIntensity = this.lightMapIntensity)),
            this.aoMap &&
              this.aoMap.isTexture &&
              ((n.aoMap = this.aoMap.toJSON(e).uuid),
              (n.aoMapIntensity = this.aoMapIntensity)),
            this.bumpMap &&
              this.bumpMap.isTexture &&
              ((n.bumpMap = this.bumpMap.toJSON(e).uuid),
              (n.bumpScale = this.bumpScale)),
            this.normalMap &&
              this.normalMap.isTexture &&
              ((n.normalMap = this.normalMap.toJSON(e).uuid),
              (n.normalMapType = this.normalMapType),
              (n.normalScale = this.normalScale.toArray())),
            this.displacementMap &&
              this.displacementMap.isTexture &&
              ((n.displacementMap = this.displacementMap.toJSON(e).uuid),
              (n.displacementScale = this.displacementScale),
              (n.displacementBias = this.displacementBias)),
            this.roughnessMap &&
              this.roughnessMap.isTexture &&
              (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
            this.metalnessMap &&
              this.metalnessMap.isTexture &&
              (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
            this.emissiveMap &&
              this.emissiveMap.isTexture &&
              (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
            this.specularMap &&
              this.specularMap.isTexture &&
              (n.specularMap = this.specularMap.toJSON(e).uuid),
            this.specularIntensityMap &&
              this.specularIntensityMap.isTexture &&
              (n.specularIntensityMap =
                this.specularIntensityMap.toJSON(e).uuid),
            this.specularColorMap &&
              this.specularColorMap.isTexture &&
              (n.specularColorMap = this.specularColorMap.toJSON(e).uuid),
            this.envMap &&
              this.envMap.isTexture &&
              ((n.envMap = this.envMap.toJSON(e).uuid),
              void 0 !== this.combine && (n.combine = this.combine)),
            void 0 !== this.envMapRotation &&
              (n.envMapRotation = this.envMapRotation.toArray()),
            void 0 !== this.envMapIntensity &&
              (n.envMapIntensity = this.envMapIntensity),
            void 0 !== this.reflectivity &&
              (n.reflectivity = this.reflectivity),
            void 0 !== this.refractionRatio &&
              (n.refractionRatio = this.refractionRatio),
            this.gradientMap &&
              this.gradientMap.isTexture &&
              (n.gradientMap = this.gradientMap.toJSON(e).uuid),
            void 0 !== this.transmission &&
              (n.transmission = this.transmission),
            this.transmissionMap &&
              this.transmissionMap.isTexture &&
              (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
            void 0 !== this.thickness && (n.thickness = this.thickness),
            this.thicknessMap &&
              this.thicknessMap.isTexture &&
              (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
            void 0 !== this.attenuationDistance &&
              this.attenuationDistance !== 1 / 0 &&
              (n.attenuationDistance = this.attenuationDistance),
            void 0 !== this.attenuationColor &&
              (n.attenuationColor = this.attenuationColor.getHex()),
            void 0 !== this.size && (n.size = this.size),
            null !== this.shadowSide && (n.shadowSide = this.shadowSide),
            void 0 !== this.sizeAttenuation &&
              (n.sizeAttenuation = this.sizeAttenuation),
            1 !== this.blending && (n.blending = this.blending),
            this.side !== cn && (n.side = this.side),
            !0 === this.vertexColors && (n.vertexColors = !0),
            this.opacity < 1 && (n.opacity = this.opacity),
            !0 === this.transparent && (n.transparent = !0),
            204 !== this.blendSrc && (n.blendSrc = this.blendSrc),
            205 !== this.blendDst && (n.blendDst = this.blendDst),
            this.blendEquation !== hn && (n.blendEquation = this.blendEquation),
            null !== this.blendSrcAlpha &&
              (n.blendSrcAlpha = this.blendSrcAlpha),
            null !== this.blendDstAlpha &&
              (n.blendDstAlpha = this.blendDstAlpha),
            null !== this.blendEquationAlpha &&
              (n.blendEquationAlpha = this.blendEquationAlpha),
            this.blendColor &&
              this.blendColor.isColor &&
              (n.blendColor = this.blendColor.getHex()),
            0 !== this.blendAlpha && (n.blendAlpha = this.blendAlpha),
            3 !== this.depthFunc && (n.depthFunc = this.depthFunc),
            !1 === this.depthTest && (n.depthTest = this.depthTest),
            !1 === this.depthWrite && (n.depthWrite = this.depthWrite),
            !1 === this.colorWrite && (n.colorWrite = this.colorWrite),
            255 !== this.stencilWriteMask &&
              (n.stencilWriteMask = this.stencilWriteMask),
            519 !== this.stencilFunc && (n.stencilFunc = this.stencilFunc),
            0 !== this.stencilRef && (n.stencilRef = this.stencilRef),
            255 !== this.stencilFuncMask &&
              (n.stencilFuncMask = this.stencilFuncMask),
            this.stencilFail !== nr && (n.stencilFail = this.stencilFail),
            this.stencilZFail !== nr && (n.stencilZFail = this.stencilZFail),
            this.stencilZPass !== nr && (n.stencilZPass = this.stencilZPass),
            !0 === this.stencilWrite && (n.stencilWrite = this.stencilWrite),
            void 0 !== this.rotation &&
              0 !== this.rotation &&
              (n.rotation = this.rotation),
            !0 === this.polygonOffset && (n.polygonOffset = !0),
            0 !== this.polygonOffsetFactor &&
              (n.polygonOffsetFactor = this.polygonOffsetFactor),
            0 !== this.polygonOffsetUnits &&
              (n.polygonOffsetUnits = this.polygonOffsetUnits),
            void 0 !== this.linewidth &&
              1 !== this.linewidth &&
              (n.linewidth = this.linewidth),
            void 0 !== this.dashSize && (n.dashSize = this.dashSize),
            void 0 !== this.gapSize && (n.gapSize = this.gapSize),
            void 0 !== this.scale && (n.scale = this.scale),
            !0 === this.dithering && (n.dithering = !0),
            this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
            !0 === this.alphaHash && (n.alphaHash = !0),
            !0 === this.alphaToCoverage && (n.alphaToCoverage = !0),
            !0 === this.premultipliedAlpha && (n.premultipliedAlpha = !0),
            !0 === this.forceSinglePass && (n.forceSinglePass = !0),
            !0 === this.wireframe && (n.wireframe = !0),
            this.wireframeLinewidth > 1 &&
              (n.wireframeLinewidth = this.wireframeLinewidth),
            "round" !== this.wireframeLinecap &&
              (n.wireframeLinecap = this.wireframeLinecap),
            "round" !== this.wireframeLinejoin &&
              (n.wireframeLinejoin = this.wireframeLinejoin),
            !0 === this.flatShading && (n.flatShading = !0),
            !1 === this.visible && (n.visible = !1),
            !1 === this.toneMapped && (n.toneMapped = !1),
            !1 === this.fog && (n.fog = !1),
            Object.keys(this.userData).length > 0 &&
              (n.userData = this.userData),
            t)
          ) {
            const t = i(e.textures),
              r = i(e.images);
            t.length > 0 && (n.textures = t), r.length > 0 && (n.images = r);
          }
          return n;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          (this.name = e.name),
            (this.blending = e.blending),
            (this.side = e.side),
            (this.vertexColors = e.vertexColors),
            (this.opacity = e.opacity),
            (this.transparent = e.transparent),
            (this.blendSrc = e.blendSrc),
            (this.blendDst = e.blendDst),
            (this.blendEquation = e.blendEquation),
            (this.blendSrcAlpha = e.blendSrcAlpha),
            (this.blendDstAlpha = e.blendDstAlpha),
            (this.blendEquationAlpha = e.blendEquationAlpha),
            this.blendColor.copy(e.blendColor),
            (this.blendAlpha = e.blendAlpha),
            (this.depthFunc = e.depthFunc),
            (this.depthTest = e.depthTest),
            (this.depthWrite = e.depthWrite),
            (this.stencilWriteMask = e.stencilWriteMask),
            (this.stencilFunc = e.stencilFunc),
            (this.stencilRef = e.stencilRef),
            (this.stencilFuncMask = e.stencilFuncMask),
            (this.stencilFail = e.stencilFail),
            (this.stencilZFail = e.stencilZFail),
            (this.stencilZPass = e.stencilZPass),
            (this.stencilWrite = e.stencilWrite);
          const t = e.clippingPlanes;
          let n = null;
          if (null !== t) {
            const e = t.length;
            n = new Array(e);
            for (let i = 0; i !== e; ++i) n[i] = t[i].clone();
          }
          return (
            (this.clippingPlanes = n),
            (this.clipIntersection = e.clipIntersection),
            (this.clipShadows = e.clipShadows),
            (this.shadowSide = e.shadowSide),
            (this.colorWrite = e.colorWrite),
            (this.precision = e.precision),
            (this.polygonOffset = e.polygonOffset),
            (this.polygonOffsetFactor = e.polygonOffsetFactor),
            (this.polygonOffsetUnits = e.polygonOffsetUnits),
            (this.dithering = e.dithering),
            (this.alphaTest = e.alphaTest),
            (this.alphaHash = e.alphaHash),
            (this.alphaToCoverage = e.alphaToCoverage),
            (this.premultipliedAlpha = e.premultipliedAlpha),
            (this.forceSinglePass = e.forceSinglePass),
            (this.visible = e.visible),
            (this.toneMapped = e.toneMapped),
            (this.userData = JSON.parse(JSON.stringify(e.userData))),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        set needsUpdate(e) {
          !0 === e && this.version++;
        }
        onBuild() {
          console.warn("Material: onBuild() has been removed.");
        }
      }
      class _a extends ba {
        static get type() {
          return "MeshBasicMaterial";
        }
        constructor(e) {
          super(),
            (this.isMeshBasicMaterial = !0),
            (this.color = new ma(16777215)),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.envMapRotation = new Us()),
            (this.combine = dn),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            this.envMapRotation.copy(e.envMapRotation),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.fog = e.fog),
            this
          );
        }
      }
      const xa = Ea();
      function Ea() {
        const e = new ArrayBuffer(4),
          t = new Float32Array(e),
          n = new Uint32Array(e),
          i = new Uint32Array(512),
          r = new Uint32Array(512);
        for (let e = 0; e < 256; ++e) {
          const t = e - 127;
          t < -27
            ? ((i[e] = 0), (i[256 | e] = 32768), (r[e] = 24), (r[256 | e] = 24))
            : t < -14
            ? ((i[e] = 1024 >> (-t - 14)),
              (i[256 | e] = (1024 >> (-t - 14)) | 32768),
              (r[e] = -t - 1),
              (r[256 | e] = -t - 1))
            : t <= 15
            ? ((i[e] = (t + 15) << 10),
              (i[256 | e] = ((t + 15) << 10) | 32768),
              (r[e] = 13),
              (r[256 | e] = 13))
            : t < 128
            ? ((i[e] = 31744),
              (i[256 | e] = 64512),
              (r[e] = 24),
              (r[256 | e] = 24))
            : ((i[e] = 31744),
              (i[256 | e] = 64512),
              (r[e] = 13),
              (r[256 | e] = 13));
        }
        const s = new Uint32Array(2048),
          a = new Uint32Array(64),
          o = new Uint32Array(64);
        for (let e = 1; e < 1024; ++e) {
          let t = e << 13,
            n = 0;
          for (; !(8388608 & t); ) (t <<= 1), (n -= 8388608);
          (t &= -8388609), (n += 947912704), (s[e] = t | n);
        }
        for (let e = 1024; e < 2048; ++e) s[e] = 939524096 + ((e - 1024) << 13);
        for (let e = 1; e < 31; ++e) a[e] = e << 23;
        (a[31] = 1199570944), (a[32] = 2147483648);
        for (let e = 33; e < 63; ++e) a[e] = 2147483648 + ((e - 32) << 23);
        a[63] = 3347054592;
        for (let e = 1; e < 64; ++e) 32 !== e && (o[e] = 1024);
        return {
          floatView: t,
          uint32View: n,
          baseTable: i,
          shiftTable: r,
          mantissaTable: s,
          exponentTable: a,
          offsetTable: o,
        };
      }
      function wa(e) {
        Math.abs(e) > 65504 &&
          console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
          (e = fr(e, -65504, 65504)),
          (xa.floatView[0] = e);
        const t = xa.uint32View[0],
          n = (t >> 23) & 511;
        return xa.baseTable[n] + ((8388607 & t) >> xa.shiftTable[n]);
      }
      function Ca(e) {
        const t = e >> 10;
        return (
          (xa.uint32View[0] =
            xa.mantissaTable[xa.offsetTable[t] + (1023 & e)] +
            xa.exponentTable[t]),
          xa.floatView[0]
        );
      }
      const Sa = { toHalfFloat: wa, fromHalfFloat: Ca },
        Ia = new Yr(),
        Ma = new br();
      class Ta {
        constructor(e, t, n = !1) {
          if (Array.isArray(e))
            throw new TypeError(
              "THREE.BufferAttribute: array should be a Typed Array."
            );
          (this.isBufferAttribute = !0),
            (this.name = ""),
            (this.array = e),
            (this.itemSize = t),
            (this.count = void 0 !== e ? e.length / t : 0),
            (this.normalized = n),
            (this.usage = rr),
            (this.updateRanges = []),
            (this.gpuType = Vn),
            (this.version = 0);
        }
        onUploadCallback() {}
        set needsUpdate(e) {
          !0 === e && this.version++;
        }
        setUsage(e) {
          return (this.usage = e), this;
        }
        addUpdateRange(e, t) {
          this.updateRanges.push({ start: e, count: t });
        }
        clearUpdateRanges() {
          this.updateRanges.length = 0;
        }
        copy(e) {
          return (
            (this.name = e.name),
            (this.array = new e.array.constructor(e.array)),
            (this.itemSize = e.itemSize),
            (this.count = e.count),
            (this.normalized = e.normalized),
            (this.usage = e.usage),
            (this.gpuType = e.gpuType),
            this
          );
        }
        copyAt(e, t, n) {
          (e *= this.itemSize), (n *= t.itemSize);
          for (let i = 0, r = this.itemSize; i < r; i++)
            this.array[e + i] = t.array[n + i];
          return this;
        }
        copyArray(e) {
          return this.array.set(e), this;
        }
        applyMatrix3(e) {
          if (2 === this.itemSize)
            for (let t = 0, n = this.count; t < n; t++)
              Ma.fromBufferAttribute(this, t),
                Ma.applyMatrix3(e),
                this.setXY(t, Ma.x, Ma.y);
          else if (3 === this.itemSize)
            for (let t = 0, n = this.count; t < n; t++)
              Ia.fromBufferAttribute(this, t),
                Ia.applyMatrix3(e),
                this.setXYZ(t, Ia.x, Ia.y, Ia.z);
          return this;
        }
        applyMatrix4(e) {
          for (let t = 0, n = this.count; t < n; t++)
            Ia.fromBufferAttribute(this, t),
              Ia.applyMatrix4(e),
              this.setXYZ(t, Ia.x, Ia.y, Ia.z);
          return this;
        }
        applyNormalMatrix(e) {
          for (let t = 0, n = this.count; t < n; t++)
            Ia.fromBufferAttribute(this, t),
              Ia.applyNormalMatrix(e),
              this.setXYZ(t, Ia.x, Ia.y, Ia.z);
          return this;
        }
        transformDirection(e) {
          for (let t = 0, n = this.count; t < n; t++)
            Ia.fromBufferAttribute(this, t),
              Ia.transformDirection(e),
              this.setXYZ(t, Ia.x, Ia.y, Ia.z);
          return this;
        }
        set(e, t = 0) {
          return this.array.set(e, t), this;
        }
        getComponent(e, t) {
          let n = this.array[e * this.itemSize + t];
          return this.normalized && (n = mr(n, this.array)), n;
        }
        setComponent(e, t, n) {
          return (
            this.normalized && (n = vr(n, this.array)),
            (this.array[e * this.itemSize + t] = n),
            this
          );
        }
        getX(e) {
          let t = this.array[e * this.itemSize];
          return this.normalized && (t = mr(t, this.array)), t;
        }
        setX(e, t) {
          return (
            this.normalized && (t = vr(t, this.array)),
            (this.array[e * this.itemSize] = t),
            this
          );
        }
        getY(e) {
          let t = this.array[e * this.itemSize + 1];
          return this.normalized && (t = mr(t, this.array)), t;
        }
        setY(e, t) {
          return (
            this.normalized && (t = vr(t, this.array)),
            (this.array[e * this.itemSize + 1] = t),
            this
          );
        }
        getZ(e) {
          let t = this.array[e * this.itemSize + 2];
          return this.normalized && (t = mr(t, this.array)), t;
        }
        setZ(e, t) {
          return (
            this.normalized && (t = vr(t, this.array)),
            (this.array[e * this.itemSize + 2] = t),
            this
          );
        }
        getW(e) {
          let t = this.array[e * this.itemSize + 3];
          return this.normalized && (t = mr(t, this.array)), t;
        }
        setW(e, t) {
          return (
            this.normalized && (t = vr(t, this.array)),
            (this.array[e * this.itemSize + 3] = t),
            this
          );
        }
        setXY(e, t, n) {
          return (
            (e *= this.itemSize),
            this.normalized &&
              ((t = vr(t, this.array)), (n = vr(n, this.array))),
            (this.array[e + 0] = t),
            (this.array[e + 1] = n),
            this
          );
        }
        setXYZ(e, t, n, i) {
          return (
            (e *= this.itemSize),
            this.normalized &&
              ((t = vr(t, this.array)),
              (n = vr(n, this.array)),
              (i = vr(i, this.array))),
            (this.array[e + 0] = t),
            (this.array[e + 1] = n),
            (this.array[e + 2] = i),
            this
          );
        }
        setXYZW(e, t, n, i, r) {
          return (
            (e *= this.itemSize),
            this.normalized &&
              ((t = vr(t, this.array)),
              (n = vr(n, this.array)),
              (i = vr(i, this.array)),
              (r = vr(r, this.array))),
            (this.array[e + 0] = t),
            (this.array[e + 1] = n),
            (this.array[e + 2] = i),
            (this.array[e + 3] = r),
            this
          );
        }
        onUpload(e) {
          return (this.onUploadCallback = e), this;
        }
        clone() {
          return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
          const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized,
          };
          return (
            "" !== this.name && (e.name = this.name),
            this.usage !== rr && (e.usage = this.usage),
            e
          );
        }
      }
      class Ba extends Ta {
        constructor(e, t, n) {
          super(new Uint16Array(e), t, n);
        }
      }
      class Ra extends Ta {
        constructor(e, t, n) {
          super(new Uint32Array(e), t, n);
        }
      }
      class Da extends Ta {
        constructor(e, t, n) {
          super(new Float32Array(e), t, n);
        }
      }
      let Pa = 0;
      const La = new Cs(),
        Ua = new Zs(),
        Fa = new Yr(),
        Oa = new Zr(),
        Na = new Zr(),
        ka = new Yr();
      class Qa extends cr {
        constructor() {
          super(),
            (this.isBufferGeometry = !0),
            Object.defineProperty(this, "id", { value: Pa++ }),
            (this.uuid = pr()),
            (this.name = ""),
            (this.type = "BufferGeometry"),
            (this.index = null),
            (this.indirect = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.morphTargetsRelative = !1),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null),
            (this.drawRange = { start: 0, count: 1 / 0 }),
            (this.userData = {});
        }
        getIndex() {
          return this.index;
        }
        setIndex(e) {
          return (
            Array.isArray(e)
              ? (this.index = new (Er(e) ? Ra : Ba)(e, 1))
              : (this.index = e),
            this
          );
        }
        setIndirect(e) {
          return (this.indirect = e), this;
        }
        getIndirect() {
          return this.indirect;
        }
        getAttribute(e) {
          return this.attributes[e];
        }
        setAttribute(e, t) {
          return (this.attributes[e] = t), this;
        }
        deleteAttribute(e) {
          return delete this.attributes[e], this;
        }
        hasAttribute(e) {
          return void 0 !== this.attributes[e];
        }
        addGroup(e, t, n = 0) {
          this.groups.push({ start: e, count: t, materialIndex: n });
        }
        clearGroups() {
          this.groups = [];
        }
        setDrawRange(e, t) {
          (this.drawRange.start = e), (this.drawRange.count = t);
        }
        applyMatrix4(e) {
          const t = this.attributes.position;
          void 0 !== t && (t.applyMatrix4(e), (t.needsUpdate = !0));
          const n = this.attributes.normal;
          if (void 0 !== n) {
            const t = new _r().getNormalMatrix(e);
            n.applyNormalMatrix(t), (n.needsUpdate = !0);
          }
          const i = this.attributes.tangent;
          return (
            void 0 !== i && (i.transformDirection(e), (i.needsUpdate = !0)),
            null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this
          );
        }
        applyQuaternion(e) {
          return La.makeRotationFromQuaternion(e), this.applyMatrix4(La), this;
        }
        rotateX(e) {
          return La.makeRotationX(e), this.applyMatrix4(La), this;
        }
        rotateY(e) {
          return La.makeRotationY(e), this.applyMatrix4(La), this;
        }
        rotateZ(e) {
          return La.makeRotationZ(e), this.applyMatrix4(La), this;
        }
        translate(e, t, n) {
          return La.makeTranslation(e, t, n), this.applyMatrix4(La), this;
        }
        scale(e, t, n) {
          return La.makeScale(e, t, n), this.applyMatrix4(La), this;
        }
        lookAt(e) {
          return (
            Ua.lookAt(e), Ua.updateMatrix(), this.applyMatrix4(Ua.matrix), this
          );
        }
        center() {
          return (
            this.computeBoundingBox(),
            this.boundingBox.getCenter(Fa).negate(),
            this.translate(Fa.x, Fa.y, Fa.z),
            this
          );
        }
        setFromPoints(e) {
          const t = this.getAttribute("position");
          if (void 0 === t) {
            const t = [];
            for (let n = 0, i = e.length; n < i; n++) {
              const i = e[n];
              t.push(i.x, i.y, i.z || 0);
            }
            this.setAttribute("position", new Da(t, 3));
          } else {
            for (let n = 0, i = t.count; n < i; n++) {
              const i = e[n];
              t.setXYZ(n, i.x, i.y, i.z || 0);
            }
            e.length > t.count &&
              console.warn(
                "THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."
              ),
              (t.needsUpdate = !0);
          }
          return this;
        }
        computeBoundingBox() {
          null === this.boundingBox && (this.boundingBox = new Zr());
          const e = this.attributes.position,
            t = this.morphAttributes.position;
          if (e && e.isGLBufferAttribute)
            return (
              console.error(
                "THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",
                this
              ),
              void this.boundingBox.set(
                new Yr(-1 / 0, -1 / 0, -1 / 0),
                new Yr(1 / 0, 1 / 0, 1 / 0)
              )
            );
          if (void 0 !== e) {
            if ((this.boundingBox.setFromBufferAttribute(e), t))
              for (let e = 0, n = t.length; e < n; e++) {
                const n = t[e];
                Oa.setFromBufferAttribute(n),
                  this.morphTargetsRelative
                    ? (ka.addVectors(this.boundingBox.min, Oa.min),
                      this.boundingBox.expandByPoint(ka),
                      ka.addVectors(this.boundingBox.max, Oa.max),
                      this.boundingBox.expandByPoint(ka))
                    : (this.boundingBox.expandByPoint(Oa.min),
                      this.boundingBox.expandByPoint(Oa.max));
              }
          } else this.boundingBox.makeEmpty();
          (isNaN(this.boundingBox.min.x) ||
            isNaN(this.boundingBox.min.y) ||
            isNaN(this.boundingBox.min.z)) &&
            console.error(
              'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
              this
            );
        }
        computeBoundingSphere() {
          null === this.boundingSphere && (this.boundingSphere = new gs());
          const e = this.attributes.position,
            t = this.morphAttributes.position;
          if (e && e.isGLBufferAttribute)
            return (
              console.error(
                "THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",
                this
              ),
              void this.boundingSphere.set(new Yr(), 1 / 0)
            );
          if (e) {
            const n = this.boundingSphere.center;
            if ((Oa.setFromBufferAttribute(e), t))
              for (let e = 0, n = t.length; e < n; e++) {
                const n = t[e];
                Na.setFromBufferAttribute(n),
                  this.morphTargetsRelative
                    ? (ka.addVectors(Oa.min, Na.min),
                      Oa.expandByPoint(ka),
                      ka.addVectors(Oa.max, Na.max),
                      Oa.expandByPoint(ka))
                    : (Oa.expandByPoint(Na.min), Oa.expandByPoint(Na.max));
              }
            Oa.getCenter(n);
            let i = 0;
            for (let t = 0, r = e.count; t < r; t++)
              ka.fromBufferAttribute(e, t),
                (i = Math.max(i, n.distanceToSquared(ka)));
            if (t)
              for (let r = 0, s = t.length; r < s; r++) {
                const s = t[r],
                  a = this.morphTargetsRelative;
                for (let t = 0, r = s.count; t < r; t++)
                  ka.fromBufferAttribute(s, t),
                    a && (Fa.fromBufferAttribute(e, t), ka.add(Fa)),
                    (i = Math.max(i, n.distanceToSquared(ka)));
              }
            (this.boundingSphere.radius = Math.sqrt(i)),
              isNaN(this.boundingSphere.radius) &&
                console.error(
                  'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                  this
                );
          }
        }
        computeTangents() {
          const e = this.index,
            t = this.attributes;
          if (
            null === e ||
            void 0 === t.position ||
            void 0 === t.normal ||
            void 0 === t.uv
          )
            return void console.error(
              "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
            );
          const n = t.position,
            i = t.normal,
            r = t.uv;
          !1 === this.hasAttribute("tangent") &&
            this.setAttribute(
              "tangent",
              new Ta(new Float32Array(4 * n.count), 4)
            );
          const s = this.getAttribute("tangent"),
            a = [],
            o = [];
          for (let e = 0; e < n.count; e++)
            (a[e] = new Yr()), (o[e] = new Yr());
          const c = new Yr(),
            l = new Yr(),
            u = new Yr(),
            h = new br(),
            d = new br(),
            p = new br(),
            f = new Yr(),
            A = new Yr();
          function g(e, t, i) {
            c.fromBufferAttribute(n, e),
              l.fromBufferAttribute(n, t),
              u.fromBufferAttribute(n, i),
              h.fromBufferAttribute(r, e),
              d.fromBufferAttribute(r, t),
              p.fromBufferAttribute(r, i),
              l.sub(c),
              u.sub(c),
              d.sub(h),
              p.sub(h);
            const s = 1 / (d.x * p.y - p.x * d.y);
            isFinite(s) &&
              (f
                .copy(l)
                .multiplyScalar(p.y)
                .addScaledVector(u, -d.y)
                .multiplyScalar(s),
              A.copy(u)
                .multiplyScalar(d.x)
                .addScaledVector(l, -p.x)
                .multiplyScalar(s),
              a[e].add(f),
              a[t].add(f),
              a[i].add(f),
              o[e].add(A),
              o[t].add(A),
              o[i].add(A));
          }
          let m = this.groups;
          0 === m.length && (m = [{ start: 0, count: e.count }]);
          for (let t = 0, n = m.length; t < n; ++t) {
            const n = m[t],
              i = n.start;
            for (let t = i, r = i + n.count; t < r; t += 3)
              g(e.getX(t + 0), e.getX(t + 1), e.getX(t + 2));
          }
          const v = new Yr(),
            y = new Yr(),
            b = new Yr(),
            _ = new Yr();
          function x(e) {
            b.fromBufferAttribute(i, e), _.copy(b);
            const t = a[e];
            v.copy(t),
              v.sub(b.multiplyScalar(b.dot(t))).normalize(),
              y.crossVectors(_, t);
            const n = y.dot(o[e]) < 0 ? -1 : 1;
            s.setXYZW(e, v.x, v.y, v.z, n);
          }
          for (let t = 0, n = m.length; t < n; ++t) {
            const n = m[t],
              i = n.start;
            for (let t = i, r = i + n.count; t < r; t += 3)
              x(e.getX(t + 0)), x(e.getX(t + 1)), x(e.getX(t + 2));
          }
        }
        computeVertexNormals() {
          const e = this.index,
            t = this.getAttribute("position");
          if (void 0 !== t) {
            let n = this.getAttribute("normal");
            if (void 0 === n)
              (n = new Ta(new Float32Array(3 * t.count), 3)),
                this.setAttribute("normal", n);
            else for (let e = 0, t = n.count; e < t; e++) n.setXYZ(e, 0, 0, 0);
            const i = new Yr(),
              r = new Yr(),
              s = new Yr(),
              a = new Yr(),
              o = new Yr(),
              c = new Yr(),
              l = new Yr(),
              u = new Yr();
            if (e)
              for (let h = 0, d = e.count; h < d; h += 3) {
                const d = e.getX(h + 0),
                  p = e.getX(h + 1),
                  f = e.getX(h + 2);
                i.fromBufferAttribute(t, d),
                  r.fromBufferAttribute(t, p),
                  s.fromBufferAttribute(t, f),
                  l.subVectors(s, r),
                  u.subVectors(i, r),
                  l.cross(u),
                  a.fromBufferAttribute(n, d),
                  o.fromBufferAttribute(n, p),
                  c.fromBufferAttribute(n, f),
                  a.add(l),
                  o.add(l),
                  c.add(l),
                  n.setXYZ(d, a.x, a.y, a.z),
                  n.setXYZ(p, o.x, o.y, o.z),
                  n.setXYZ(f, c.x, c.y, c.z);
              }
            else
              for (let e = 0, a = t.count; e < a; e += 3)
                i.fromBufferAttribute(t, e + 0),
                  r.fromBufferAttribute(t, e + 1),
                  s.fromBufferAttribute(t, e + 2),
                  l.subVectors(s, r),
                  u.subVectors(i, r),
                  l.cross(u),
                  n.setXYZ(e + 0, l.x, l.y, l.z),
                  n.setXYZ(e + 1, l.x, l.y, l.z),
                  n.setXYZ(e + 2, l.x, l.y, l.z);
            this.normalizeNormals(), (n.needsUpdate = !0);
          }
        }
        normalizeNormals() {
          const e = this.attributes.normal;
          for (let t = 0, n = e.count; t < n; t++)
            ka.fromBufferAttribute(e, t),
              ka.normalize(),
              e.setXYZ(t, ka.x, ka.y, ka.z);
        }
        toNonIndexed() {
          function e(e, t) {
            const n = e.array,
              i = e.itemSize,
              r = e.normalized,
              s = new n.constructor(t.length * i);
            let a = 0,
              o = 0;
            for (let r = 0, c = t.length; r < c; r++) {
              a = e.isInterleavedBufferAttribute
                ? t[r] * e.data.stride + e.offset
                : t[r] * i;
              for (let e = 0; e < i; e++) s[o++] = n[a++];
            }
            return new Ta(s, i, r);
          }
          if (null === this.index)
            return (
              console.warn(
                "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
              ),
              this
            );
          const t = new Qa(),
            n = this.index.array,
            i = this.attributes;
          for (const r in i) {
            const s = e(i[r], n);
            t.setAttribute(r, s);
          }
          const r = this.morphAttributes;
          for (const i in r) {
            const s = [],
              a = r[i];
            for (let t = 0, i = a.length; t < i; t++) {
              const i = e(a[t], n);
              s.push(i);
            }
            t.morphAttributes[i] = s;
          }
          t.morphTargetsRelative = this.morphTargetsRelative;
          const s = this.groups;
          for (let e = 0, n = s.length; e < n; e++) {
            const n = s[e];
            t.addGroup(n.start, n.count, n.materialIndex);
          }
          return t;
        }
        toJSON() {
          const e = {
            metadata: {
              version: 4.6,
              type: "BufferGeometry",
              generator: "BufferGeometry.toJSON",
            },
          };
          if (
            ((e.uuid = this.uuid),
            (e.type = this.type),
            "" !== this.name && (e.name = this.name),
            Object.keys(this.userData).length > 0 &&
              (e.userData = this.userData),
            void 0 !== this.parameters)
          ) {
            const t = this.parameters;
            for (const n in t) void 0 !== t[n] && (e[n] = t[n]);
            return e;
          }
          e.data = { attributes: {} };
          const t = this.index;
          null !== t &&
            (e.data.index = {
              type: t.array.constructor.name,
              array: Array.prototype.slice.call(t.array),
            });
          const n = this.attributes;
          for (const t in n) {
            const i = n[t];
            e.data.attributes[t] = i.toJSON(e.data);
          }
          const i = {};
          let r = !1;
          for (const t in this.morphAttributes) {
            const n = this.morphAttributes[t],
              s = [];
            for (let t = 0, i = n.length; t < i; t++) {
              const i = n[t];
              s.push(i.toJSON(e.data));
            }
            s.length > 0 && ((i[t] = s), (r = !0));
          }
          r &&
            ((e.data.morphAttributes = i),
            (e.data.morphTargetsRelative = this.morphTargetsRelative));
          const s = this.groups;
          s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s)));
          const a = this.boundingSphere;
          return (
            null !== a &&
              (e.data.boundingSphere = {
                center: a.center.toArray(),
                radius: a.radius,
              }),
            e
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null);
          const t = {};
          this.name = e.name;
          const n = e.index;
          null !== n && this.setIndex(n.clone(t));
          const i = e.attributes;
          for (const e in i) {
            const n = i[e];
            this.setAttribute(e, n.clone(t));
          }
          const r = e.morphAttributes;
          for (const e in r) {
            const n = [],
              i = r[e];
            for (let e = 0, r = i.length; e < r; e++) n.push(i[e].clone(t));
            this.morphAttributes[e] = n;
          }
          this.morphTargetsRelative = e.morphTargetsRelative;
          const s = e.groups;
          for (let e = 0, t = s.length; e < t; e++) {
            const t = s[e];
            this.addGroup(t.start, t.count, t.materialIndex);
          }
          const a = e.boundingBox;
          null !== a && (this.boundingBox = a.clone());
          const o = e.boundingSphere;
          return (
            null !== o && (this.boundingSphere = o.clone()),
            (this.drawRange.start = e.drawRange.start),
            (this.drawRange.count = e.drawRange.count),
            (this.userData = e.userData),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      const Ga = new Cs(),
        Ha = new ws(),
        za = new gs(),
        Va = new Yr(),
        ja = new Yr(),
        Wa = new Yr(),
        Xa = new Yr(),
        qa = new Yr(),
        Ya = new Yr(),
        Ka = new Yr(),
        Ja = new Yr();
      class Za extends Zs {
        constructor(e = new Qa(), t = new _a()) {
          super(),
            (this.isMesh = !0),
            (this.type = "Mesh"),
            (this.geometry = e),
            (this.material = t),
            this.updateMorphTargets();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            void 0 !== e.morphTargetInfluences &&
              (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
            void 0 !== e.morphTargetDictionary &&
              (this.morphTargetDictionary = Object.assign(
                {},
                e.morphTargetDictionary
              )),
            (this.material = Array.isArray(e.material)
              ? e.material.slice()
              : e.material),
            (this.geometry = e.geometry),
            this
          );
        }
        updateMorphTargets() {
          const e = this.geometry.morphAttributes,
            t = Object.keys(e);
          if (t.length > 0) {
            const n = e[t[0]];
            if (void 0 !== n) {
              (this.morphTargetInfluences = []),
                (this.morphTargetDictionary = {});
              for (let e = 0, t = n.length; e < t; e++) {
                const t = n[e].name || String(e);
                this.morphTargetInfluences.push(0),
                  (this.morphTargetDictionary[t] = e);
              }
            }
          }
        }
        getVertexPosition(e, t) {
          const n = this.geometry,
            i = n.attributes.position,
            r = n.morphAttributes.position,
            s = n.morphTargetsRelative;
          t.fromBufferAttribute(i, e);
          const a = this.morphTargetInfluences;
          if (r && a) {
            Ya.set(0, 0, 0);
            for (let n = 0, i = r.length; n < i; n++) {
              const i = a[n],
                o = r[n];
              0 !== i &&
                (qa.fromBufferAttribute(o, e),
                s
                  ? Ya.addScaledVector(qa, i)
                  : Ya.addScaledVector(qa.sub(t), i));
            }
            t.add(Ya);
          }
          return t;
        }
        raycast(e, t) {
          const n = this.geometry,
            i = this.material,
            r = this.matrixWorld;
          if (void 0 !== i) {
            if (
              (null === n.boundingSphere && n.computeBoundingSphere(),
              za.copy(n.boundingSphere),
              za.applyMatrix4(r),
              Ha.copy(e.ray).recast(e.near),
              !1 === za.containsPoint(Ha.origin))
            ) {
              if (null === Ha.intersectSphere(za, Va)) return;
              if (Ha.origin.distanceToSquared(Va) > (e.far - e.near) ** 2)
                return;
            }
            Ga.copy(r).invert(),
              Ha.copy(e.ray).applyMatrix4(Ga),
              (null !== n.boundingBox &&
                !1 === Ha.intersectsBox(n.boundingBox)) ||
                this._computeIntersections(e, t, Ha);
          }
        }
        _computeIntersections(e, t, n) {
          let i;
          const r = this.geometry,
            s = this.material,
            a = r.index,
            o = r.attributes.position,
            c = r.attributes.uv,
            l = r.attributes.uv1,
            u = r.attributes.normal,
            h = r.groups,
            d = r.drawRange;
          if (null !== a)
            if (Array.isArray(s))
              for (let r = 0, o = h.length; r < o; r++) {
                const o = h[r],
                  p = s[o.materialIndex];
                for (
                  let r = Math.max(o.start, d.start),
                    s = Math.min(
                      a.count,
                      Math.min(o.start + o.count, d.start + d.count)
                    );
                  r < s;
                  r += 3
                ) {
                  (i = $a(
                    this,
                    p,
                    e,
                    n,
                    c,
                    l,
                    u,
                    a.getX(r),
                    a.getX(r + 1),
                    a.getX(r + 2)
                  )),
                    i &&
                      ((i.faceIndex = Math.floor(r / 3)),
                      (i.face.materialIndex = o.materialIndex),
                      t.push(i));
                }
              }
            else {
              for (
                let r = Math.max(0, d.start),
                  o = Math.min(a.count, d.start + d.count);
                r < o;
                r += 3
              ) {
                (i = $a(
                  this,
                  s,
                  e,
                  n,
                  c,
                  l,
                  u,
                  a.getX(r),
                  a.getX(r + 1),
                  a.getX(r + 2)
                )),
                  i && ((i.faceIndex = Math.floor(r / 3)), t.push(i));
              }
            }
          else if (void 0 !== o)
            if (Array.isArray(s))
              for (let r = 0, a = h.length; r < a; r++) {
                const a = h[r],
                  p = s[a.materialIndex];
                for (
                  let r = Math.max(a.start, d.start),
                    s = Math.min(
                      o.count,
                      Math.min(a.start + a.count, d.start + d.count)
                    );
                  r < s;
                  r += 3
                ) {
                  (i = $a(this, p, e, n, c, l, u, r, r + 1, r + 2)),
                    i &&
                      ((i.faceIndex = Math.floor(r / 3)),
                      (i.face.materialIndex = a.materialIndex),
                      t.push(i));
                }
              }
            else {
              for (
                let r = Math.max(0, d.start),
                  a = Math.min(o.count, d.start + d.count);
                r < a;
                r += 3
              ) {
                (i = $a(this, s, e, n, c, l, u, r, r + 1, r + 2)),
                  i && ((i.faceIndex = Math.floor(r / 3)), t.push(i));
              }
            }
        }
      }
      function $a(e, t, n, i, r, s, a, o, c, l) {
        e.getVertexPosition(o, ja),
          e.getVertexPosition(c, Wa),
          e.getVertexPosition(l, Xa);
        const u = (function (e, t, n, i, r, s, a, o) {
          let c;
          if (
            ((c =
              t.side === ln
                ? i.intersectTriangle(a, s, r, !0, o)
                : i.intersectTriangle(r, s, a, t.side === cn, o)),
            null === c)
          )
            return null;
          Ja.copy(o), Ja.applyMatrix4(e.matrixWorld);
          const l = n.ray.origin.distanceTo(Ja);
          return l < n.near || l > n.far
            ? null
            : { distance: l, point: Ja.clone(), object: e };
        })(e, t, n, i, ja, Wa, Xa, Ka);
        if (u) {
          const e = new Yr();
          da.getBarycoord(Ka, ja, Wa, Xa, e),
            r && (u.uv = da.getInterpolatedAttribute(r, o, c, l, e, new br())),
            s && (u.uv1 = da.getInterpolatedAttribute(s, o, c, l, e, new br())),
            a &&
              ((u.normal = da.getInterpolatedAttribute(
                a,
                o,
                c,
                l,
                e,
                new Yr()
              )),
              u.normal.dot(i.direction) > 0 && u.normal.multiplyScalar(-1));
          const t = { a: o, b: c, c: l, normal: new Yr(), materialIndex: 0 };
          da.getNormal(ja, Wa, Xa, t.normal), (u.face = t), (u.barycoord = e);
        }
        return u;
      }
      class eo extends Qa {
        constructor(e = 1, t = 1, n = 1, i = 1, r = 1, s = 1) {
          super(),
            (this.type = "BoxGeometry"),
            (this.parameters = {
              width: e,
              height: t,
              depth: n,
              widthSegments: i,
              heightSegments: r,
              depthSegments: s,
            });
          const a = this;
          (i = Math.floor(i)), (r = Math.floor(r)), (s = Math.floor(s));
          const o = [],
            c = [],
            l = [],
            u = [];
          let h = 0,
            d = 0;
          function p(e, t, n, i, r, s, p, f, A, g, m) {
            const v = s / A,
              y = p / g,
              b = s / 2,
              _ = p / 2,
              x = f / 2,
              E = A + 1,
              w = g + 1;
            let C = 0,
              S = 0;
            const I = new Yr();
            for (let s = 0; s < w; s++) {
              const a = s * y - _;
              for (let o = 0; o < E; o++) {
                const h = o * v - b;
                (I[e] = h * i),
                  (I[t] = a * r),
                  (I[n] = x),
                  c.push(I.x, I.y, I.z),
                  (I[e] = 0),
                  (I[t] = 0),
                  (I[n] = f > 0 ? 1 : -1),
                  l.push(I.x, I.y, I.z),
                  u.push(o / A),
                  u.push(1 - s / g),
                  (C += 1);
              }
            }
            for (let e = 0; e < g; e++)
              for (let t = 0; t < A; t++) {
                const n = h + t + E * e,
                  i = h + t + E * (e + 1),
                  r = h + (t + 1) + E * (e + 1),
                  s = h + (t + 1) + E * e;
                o.push(n, i, s), o.push(i, r, s), (S += 6);
              }
            a.addGroup(d, S, m), (d += S), (h += C);
          }
          p("z", "y", "x", -1, -1, n, t, e, s, r, 0),
            p("z", "y", "x", 1, -1, n, t, -e, s, r, 1),
            p("x", "z", "y", 1, 1, e, n, t, i, s, 2),
            p("x", "z", "y", 1, -1, e, n, -t, i, s, 3),
            p("x", "y", "z", 1, -1, e, t, n, i, r, 4),
            p("x", "y", "z", -1, -1, e, t, -n, i, r, 5),
            this.setIndex(o),
            this.setAttribute("position", new Da(c, 3)),
            this.setAttribute("normal", new Da(l, 3)),
            this.setAttribute("uv", new Da(u, 2));
        }
        copy(e) {
          return (
            super.copy(e),
            (this.parameters = Object.assign({}, e.parameters)),
            this
          );
        }
        static fromJSON(e) {
          return new eo(
            e.width,
            e.height,
            e.depth,
            e.widthSegments,
            e.heightSegments,
            e.depthSegments
          );
        }
      }
      function to(e) {
        const t = {};
        for (const n in e) {
          t[n] = {};
          for (const i in e[n]) {
            const r = e[n][i];
            r &&
            (r.isColor ||
              r.isMatrix3 ||
              r.isMatrix4 ||
              r.isVector2 ||
              r.isVector3 ||
              r.isVector4 ||
              r.isTexture ||
              r.isQuaternion)
              ? r.isRenderTargetTexture
                ? (console.warn(
                    "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
                  ),
                  (t[n][i] = null))
                : (t[n][i] = r.clone())
              : Array.isArray(r)
              ? (t[n][i] = r.slice())
              : (t[n][i] = r);
          }
        }
        return t;
      }
      function no(e) {
        const t = {};
        for (let n = 0; n < e.length; n++) {
          const i = to(e[n]);
          for (const e in i) t[e] = i[e];
        }
        return t;
      }
      function io(e) {
        const t = e.getRenderTarget();
        return null === t
          ? e.outputColorSpace
          : !0 === t.isXRRenderTarget
          ? t.texture.colorSpace
          : Mr.workingColorSpace;
      }
      const ro = { clone: to, merge: no };
      class so extends ba {
        static get type() {
          return "ShaderMaterial";
        }
        constructor(e) {
          super(),
            (this.isShaderMaterial = !0),
            (this.defines = {}),
            (this.uniforms = {}),
            (this.uniformsGroups = []),
            (this.vertexShader =
              "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"),
            (this.fragmentShader =
              "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"),
            (this.linewidth = 1),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            (this.lights = !1),
            (this.clipping = !1),
            (this.forceSinglePass = !0),
            (this.extensions = { clipCullDistance: !1, multiDraw: !1 }),
            (this.defaultAttributeValues = {
              color: [1, 1, 1],
              uv: [0, 0],
              uv1: [0, 0],
            }),
            (this.index0AttributeName = void 0),
            (this.uniformsNeedUpdate = !1),
            (this.glslVersion = null),
            void 0 !== e && this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.fragmentShader = e.fragmentShader),
            (this.vertexShader = e.vertexShader),
            (this.uniforms = to(e.uniforms)),
            (this.uniformsGroups = (function (e) {
              const t = [];
              for (let n = 0; n < e.length; n++) t.push(e[n].clone());
              return t;
            })(e.uniformsGroups)),
            (this.defines = Object.assign({}, e.defines)),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.fog = e.fog),
            (this.lights = e.lights),
            (this.clipping = e.clipping),
            (this.extensions = Object.assign({}, e.extensions)),
            (this.glslVersion = e.glslVersion),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          (t.glslVersion = this.glslVersion), (t.uniforms = {});
          for (const n in this.uniforms) {
            const i = this.uniforms[n].value;
            i && i.isTexture
              ? (t.uniforms[n] = { type: "t", value: i.toJSON(e).uuid })
              : i && i.isColor
              ? (t.uniforms[n] = { type: "c", value: i.getHex() })
              : i && i.isVector2
              ? (t.uniforms[n] = { type: "v2", value: i.toArray() })
              : i && i.isVector3
              ? (t.uniforms[n] = { type: "v3", value: i.toArray() })
              : i && i.isVector4
              ? (t.uniforms[n] = { type: "v4", value: i.toArray() })
              : i && i.isMatrix3
              ? (t.uniforms[n] = { type: "m3", value: i.toArray() })
              : i && i.isMatrix4
              ? (t.uniforms[n] = { type: "m4", value: i.toArray() })
              : (t.uniforms[n] = { value: i });
          }
          Object.keys(this.defines).length > 0 && (t.defines = this.defines),
            (t.vertexShader = this.vertexShader),
            (t.fragmentShader = this.fragmentShader),
            (t.lights = this.lights),
            (t.clipping = this.clipping);
          const n = {};
          for (const e in this.extensions)
            !0 === this.extensions[e] && (n[e] = !0);
          return Object.keys(n).length > 0 && (t.extensions = n), t;
        }
      }
      class ao extends Zs {
        constructor() {
          super(),
            (this.isCamera = !0),
            (this.type = "Camera"),
            (this.matrixWorldInverse = new Cs()),
            (this.projectionMatrix = new Cs()),
            (this.projectionMatrixInverse = new Cs()),
            (this.coordinateSystem = ar);
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            this.matrixWorldInverse.copy(e.matrixWorldInverse),
            this.projectionMatrix.copy(e.projectionMatrix),
            this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
            (this.coordinateSystem = e.coordinateSystem),
            this
          );
        }
        getWorldDirection(e) {
          return super.getWorldDirection(e).negate();
        }
        updateMatrixWorld(e) {
          super.updateMatrixWorld(e),
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        updateWorldMatrix(e, t) {
          super.updateWorldMatrix(e, t),
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const oo = new Yr(),
        co = new br(),
        lo = new br();
      class uo extends ao {
        constructor(e = 50, t = 1, n = 0.1, i = 2e3) {
          super(),
            (this.isPerspectiveCamera = !0),
            (this.type = "PerspectiveCamera"),
            (this.fov = e),
            (this.zoom = 1),
            (this.near = n),
            (this.far = i),
            (this.focus = 10),
            (this.aspect = t),
            (this.view = null),
            (this.filmGauge = 35),
            (this.filmOffset = 0),
            this.updateProjectionMatrix();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.fov = e.fov),
            (this.zoom = e.zoom),
            (this.near = e.near),
            (this.far = e.far),
            (this.focus = e.focus),
            (this.aspect = e.aspect),
            (this.view = null === e.view ? null : Object.assign({}, e.view)),
            (this.filmGauge = e.filmGauge),
            (this.filmOffset = e.filmOffset),
            this
          );
        }
        setFocalLength(e) {
          const t = (0.5 * this.getFilmHeight()) / e;
          (this.fov = 2 * dr * Math.atan(t)), this.updateProjectionMatrix();
        }
        getFocalLength() {
          const e = Math.tan(0.5 * hr * this.fov);
          return (0.5 * this.getFilmHeight()) / e;
        }
        getEffectiveFOV() {
          return 2 * dr * Math.atan(Math.tan(0.5 * hr * this.fov) / this.zoom);
        }
        getFilmWidth() {
          return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
          return this.filmGauge / Math.max(this.aspect, 1);
        }
        getViewBounds(e, t, n) {
          oo.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse),
            t.set(oo.x, oo.y).multiplyScalar(-e / oo.z),
            oo.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse),
            n.set(oo.x, oo.y).multiplyScalar(-e / oo.z);
        }
        getViewSize(e, t) {
          return this.getViewBounds(e, co, lo), t.subVectors(lo, co);
        }
        setViewOffset(e, t, n, i, r, s) {
          (this.aspect = e / t),
            null === this.view &&
              (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1,
              }),
            (this.view.enabled = !0),
            (this.view.fullWidth = e),
            (this.view.fullHeight = t),
            (this.view.offsetX = n),
            (this.view.offsetY = i),
            (this.view.width = r),
            (this.view.height = s),
            this.updateProjectionMatrix();
        }
        clearViewOffset() {
          null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const e = this.near;
          let t = (e * Math.tan(0.5 * hr * this.fov)) / this.zoom,
            n = 2 * t,
            i = this.aspect * n,
            r = -0.5 * i;
          const s = this.view;
          if (null !== this.view && this.view.enabled) {
            const e = s.fullWidth,
              a = s.fullHeight;
            (r += (s.offsetX * i) / e),
              (t -= (s.offsetY * n) / a),
              (i *= s.width / e),
              (n *= s.height / a);
          }
          const a = this.filmOffset;
          0 !== a && (r += (e * a) / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(
              r,
              r + i,
              t,
              t - n,
              e,
              this.far,
              this.coordinateSystem
            ),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.fov = this.fov),
            (t.object.zoom = this.zoom),
            (t.object.near = this.near),
            (t.object.far = this.far),
            (t.object.focus = this.focus),
            (t.object.aspect = this.aspect),
            null !== this.view &&
              (t.object.view = Object.assign({}, this.view)),
            (t.object.filmGauge = this.filmGauge),
            (t.object.filmOffset = this.filmOffset),
            t
          );
        }
      }
      const ho = -90;
      class po extends Zs {
        constructor(e, t, n) {
          super(),
            (this.type = "CubeCamera"),
            (this.renderTarget = n),
            (this.coordinateSystem = null),
            (this.activeMipmapLevel = 0);
          const i = new uo(ho, 1, e, t);
          (i.layers = this.layers), this.add(i);
          const r = new uo(ho, 1, e, t);
          (r.layers = this.layers), this.add(r);
          const s = new uo(ho, 1, e, t);
          (s.layers = this.layers), this.add(s);
          const a = new uo(ho, 1, e, t);
          (a.layers = this.layers), this.add(a);
          const o = new uo(ho, 1, e, t);
          (o.layers = this.layers), this.add(o);
          const c = new uo(ho, 1, e, t);
          (c.layers = this.layers), this.add(c);
        }
        updateCoordinateSystem() {
          const e = this.coordinateSystem,
            t = this.children.concat(),
            [n, i, r, s, a, o] = t;
          for (const e of t) this.remove(e);
          if (e === ar)
            n.up.set(0, 1, 0),
              n.lookAt(1, 0, 0),
              i.up.set(0, 1, 0),
              i.lookAt(-1, 0, 0),
              r.up.set(0, 0, -1),
              r.lookAt(0, 1, 0),
              s.up.set(0, 0, 1),
              s.lookAt(0, -1, 0),
              a.up.set(0, 1, 0),
              a.lookAt(0, 0, 1),
              o.up.set(0, 1, 0),
              o.lookAt(0, 0, -1);
          else {
            if (e !== or)
              throw new Error(
                "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
                  e
              );
            n.up.set(0, -1, 0),
              n.lookAt(-1, 0, 0),
              i.up.set(0, -1, 0),
              i.lookAt(1, 0, 0),
              r.up.set(0, 0, 1),
              r.lookAt(0, 1, 0),
              s.up.set(0, 0, -1),
              s.lookAt(0, -1, 0),
              a.up.set(0, -1, 0),
              a.lookAt(0, 0, 1),
              o.up.set(0, -1, 0),
              o.lookAt(0, 0, -1);
          }
          for (const e of t) this.add(e), e.updateMatrixWorld();
        }
        update(e, t) {
          null === this.parent && this.updateMatrixWorld();
          const { renderTarget: n, activeMipmapLevel: i } = this;
          this.coordinateSystem !== e.coordinateSystem &&
            ((this.coordinateSystem = e.coordinateSystem),
            this.updateCoordinateSystem());
          const [r, s, a, o, c, l] = this.children,
            u = e.getRenderTarget(),
            h = e.getActiveCubeFace(),
            d = e.getActiveMipmapLevel(),
            p = e.xr.enabled;
          e.xr.enabled = !1;
          const f = n.texture.generateMipmaps;
          (n.texture.generateMipmaps = !1),
            e.setRenderTarget(n, 0, i),
            e.render(t, r),
            e.setRenderTarget(n, 1, i),
            e.render(t, s),
            e.setRenderTarget(n, 2, i),
            e.render(t, a),
            e.setRenderTarget(n, 3, i),
            e.render(t, o),
            e.setRenderTarget(n, 4, i),
            e.render(t, c),
            (n.texture.generateMipmaps = f),
            e.setRenderTarget(n, 5, i),
            e.render(t, l),
            e.setRenderTarget(u, h, d),
            (e.xr.enabled = p),
            (n.texture.needsPMREMUpdate = !0);
        }
      }
      class fo extends Hr {
        constructor(e, t, n, i, r, s, a, o, c, l) {
          super(
            (e = void 0 !== e ? e : []),
            (t = void 0 !== t ? t : wn),
            n,
            i,
            r,
            s,
            a,
            o,
            c,
            l
          ),
            (this.isCubeTexture = !0),
            (this.flipY = !1);
        }
        get images() {
          return this.image;
        }
        set images(e) {
          this.image = e;
        }
      }
      class Ao extends jr {
        constructor(e = 1, t = {}) {
          super(e, e, t), (this.isWebGLCubeRenderTarget = !0);
          const n = { width: e, height: e, depth: 1 },
            i = [n, n, n, n, n, n];
          (this.texture = new fo(
            i,
            t.mapping,
            t.wrapS,
            t.wrapT,
            t.magFilter,
            t.minFilter,
            t.format,
            t.type,
            t.anisotropy,
            t.colorSpace
          )),
            (this.texture.isRenderTargetTexture = !0),
            (this.texture.generateMipmaps =
              void 0 !== t.generateMipmaps && t.generateMipmaps),
            (this.texture.minFilter =
              void 0 !== t.minFilter ? t.minFilter : Un);
        }
        fromEquirectangularTexture(e, t) {
          (this.texture.type = t.type),
            (this.texture.colorSpace = t.colorSpace),
            (this.texture.generateMipmaps = t.generateMipmaps),
            (this.texture.minFilter = t.minFilter),
            (this.texture.magFilter = t.magFilter);
          const n = {
              uniforms: { tEquirect: { value: null } },
              vertexShader:
                "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
              fragmentShader:
                "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
            },
            i = new eo(5, 5, 5),
            r = new so({
              name: "CubemapFromEquirect",
              uniforms: to(n.uniforms),
              vertexShader: n.vertexShader,
              fragmentShader: n.fragmentShader,
              side: ln,
              blending: 0,
            });
          r.uniforms.tEquirect.value = t;
          const s = new Za(i, r),
            a = t.minFilter;
          t.minFilter === On && (t.minFilter = Un);
          return (
            new po(1, 10, this).update(e, s),
            (t.minFilter = a),
            s.geometry.dispose(),
            s.material.dispose(),
            this
          );
        }
        clear(e, t, n, i) {
          const r = e.getRenderTarget();
          for (let r = 0; r < 6; r++)
            e.setRenderTarget(this, r), e.clear(t, n, i);
          e.setRenderTarget(r);
        }
      }
      const go = new Yr(),
        mo = new Yr(),
        vo = new _r();
      class yo {
        constructor(e = new Yr(1, 0, 0), t = 0) {
          (this.isPlane = !0), (this.normal = e), (this.constant = t);
        }
        set(e, t) {
          return this.normal.copy(e), (this.constant = t), this;
        }
        setComponents(e, t, n, i) {
          return this.normal.set(e, t, n), (this.constant = i), this;
        }
        setFromNormalAndCoplanarPoint(e, t) {
          return (
            this.normal.copy(e), (this.constant = -t.dot(this.normal)), this
          );
        }
        setFromCoplanarPoints(e, t, n) {
          const i = go.subVectors(n, t).cross(mo.subVectors(e, t)).normalize();
          return this.setFromNormalAndCoplanarPoint(i, e), this;
        }
        copy(e) {
          return this.normal.copy(e.normal), (this.constant = e.constant), this;
        }
        normalize() {
          const e = 1 / this.normal.length();
          return this.normal.multiplyScalar(e), (this.constant *= e), this;
        }
        negate() {
          return (this.constant *= -1), this.normal.negate(), this;
        }
        distanceToPoint(e) {
          return this.normal.dot(e) + this.constant;
        }
        distanceToSphere(e) {
          return this.distanceToPoint(e.center) - e.radius;
        }
        projectPoint(e, t) {
          return t
            .copy(e)
            .addScaledVector(this.normal, -this.distanceToPoint(e));
        }
        intersectLine(e, t) {
          const n = e.delta(go),
            i = this.normal.dot(n);
          if (0 === i)
            return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
          const r = -(e.start.dot(this.normal) + this.constant) / i;
          return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(n, r);
        }
        intersectsLine(e) {
          const t = this.distanceToPoint(e.start),
            n = this.distanceToPoint(e.end);
          return (t < 0 && n > 0) || (n < 0 && t > 0);
        }
        intersectsBox(e) {
          return e.intersectsPlane(this);
        }
        intersectsSphere(e) {
          return e.intersectsPlane(this);
        }
        coplanarPoint(e) {
          return e.copy(this.normal).multiplyScalar(-this.constant);
        }
        applyMatrix4(e, t) {
          const n = t || vo.getNormalMatrix(e),
            i = this.coplanarPoint(go).applyMatrix4(e),
            r = this.normal.applyMatrix3(n).normalize();
          return (this.constant = -i.dot(r)), this;
        }
        translate(e) {
          return (this.constant -= e.dot(this.normal)), this;
        }
        equals(e) {
          return e.normal.equals(this.normal) && e.constant === this.constant;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const bo = new gs(),
        _o = new Yr();
      class xo {
        constructor(
          e = new yo(),
          t = new yo(),
          n = new yo(),
          i = new yo(),
          r = new yo(),
          s = new yo()
        ) {
          this.planes = [e, t, n, i, r, s];
        }
        set(e, t, n, i, r, s) {
          const a = this.planes;
          return (
            a[0].copy(e),
            a[1].copy(t),
            a[2].copy(n),
            a[3].copy(i),
            a[4].copy(r),
            a[5].copy(s),
            this
          );
        }
        copy(e) {
          const t = this.planes;
          for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
          return this;
        }
        setFromProjectionMatrix(e, t = 2e3) {
          const n = this.planes,
            i = e.elements,
            r = i[0],
            s = i[1],
            a = i[2],
            o = i[3],
            c = i[4],
            l = i[5],
            u = i[6],
            h = i[7],
            d = i[8],
            p = i[9],
            f = i[10],
            A = i[11],
            g = i[12],
            m = i[13],
            v = i[14],
            y = i[15];
          if (
            (n[0].setComponents(o - r, h - c, A - d, y - g).normalize(),
            n[1].setComponents(o + r, h + c, A + d, y + g).normalize(),
            n[2].setComponents(o + s, h + l, A + p, y + m).normalize(),
            n[3].setComponents(o - s, h - l, A - p, y - m).normalize(),
            n[4].setComponents(o - a, h - u, A - f, y - v).normalize(),
            t === ar)
          )
            n[5].setComponents(o + a, h + u, A + f, y + v).normalize();
          else {
            if (t !== or)
              throw new Error(
                "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
                  t
              );
            n[5].setComponents(a, u, f, v).normalize();
          }
          return this;
        }
        intersectsObject(e) {
          if (void 0 !== e.boundingSphere)
            null === e.boundingSphere && e.computeBoundingSphere(),
              bo.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
          else {
            const t = e.geometry;
            null === t.boundingSphere && t.computeBoundingSphere(),
              bo.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
          }
          return this.intersectsSphere(bo);
        }
        intersectsSprite(e) {
          return (
            bo.center.set(0, 0, 0),
            (bo.radius = 0.7071067811865476),
            bo.applyMatrix4(e.matrixWorld),
            this.intersectsSphere(bo)
          );
        }
        intersectsSphere(e) {
          const t = this.planes,
            n = e.center,
            i = -e.radius;
          for (let e = 0; e < 6; e++) {
            if (t[e].distanceToPoint(n) < i) return !1;
          }
          return !0;
        }
        intersectsBox(e) {
          const t = this.planes;
          for (let n = 0; n < 6; n++) {
            const i = t[n];
            if (
              ((_o.x = i.normal.x > 0 ? e.max.x : e.min.x),
              (_o.y = i.normal.y > 0 ? e.max.y : e.min.y),
              (_o.z = i.normal.z > 0 ? e.max.z : e.min.z),
              i.distanceToPoint(_o) < 0)
            )
              return !1;
          }
          return !0;
        }
        containsPoint(e) {
          const t = this.planes;
          for (let n = 0; n < 6; n++)
            if (t[n].distanceToPoint(e) < 0) return !1;
          return !0;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      function Eo() {
        let e = null,
          t = !1,
          n = null,
          i = null;
        function r(t, s) {
          n(t, s), (i = e.requestAnimationFrame(r));
        }
        return {
          start: function () {
            !0 !== t &&
              null !== n &&
              ((i = e.requestAnimationFrame(r)), (t = !0));
          },
          stop: function () {
            e.cancelAnimationFrame(i), (t = !1);
          },
          setAnimationLoop: function (e) {
            n = e;
          },
          setContext: function (t) {
            e = t;
          },
        };
      }
      function wo(e) {
        const t = new WeakMap();
        return {
          get: function (e) {
            return e.isInterleavedBufferAttribute && (e = e.data), t.get(e);
          },
          remove: function (n) {
            n.isInterleavedBufferAttribute && (n = n.data);
            const i = t.get(n);
            i && (e.deleteBuffer(i.buffer), t.delete(n));
          },
          update: function (n, i) {
            if (
              (n.isInterleavedBufferAttribute && (n = n.data),
              n.isGLBufferAttribute)
            ) {
              const e = t.get(n);
              return void (
                (!e || e.version < n.version) &&
                t.set(n, {
                  buffer: n.buffer,
                  type: n.type,
                  bytesPerElement: n.elementSize,
                  version: n.version,
                })
              );
            }
            const r = t.get(n);
            if (void 0 === r)
              t.set(
                n,
                (function (t, n) {
                  const i = t.array,
                    r = t.usage,
                    s = i.byteLength,
                    a = e.createBuffer();
                  let o;
                  if (
                    (e.bindBuffer(n, a),
                    e.bufferData(n, i, r),
                    t.onUploadCallback(),
                    i instanceof Float32Array)
                  )
                    o = e.FLOAT;
                  else if (i instanceof Uint16Array)
                    o = t.isFloat16BufferAttribute
                      ? e.HALF_FLOAT
                      : e.UNSIGNED_SHORT;
                  else if (i instanceof Int16Array) o = e.SHORT;
                  else if (i instanceof Uint32Array) o = e.UNSIGNED_INT;
                  else if (i instanceof Int32Array) o = e.INT;
                  else if (i instanceof Int8Array) o = e.BYTE;
                  else if (i instanceof Uint8Array) o = e.UNSIGNED_BYTE;
                  else {
                    if (!(i instanceof Uint8ClampedArray))
                      throw new Error(
                        "THREE.WebGLAttributes: Unsupported buffer data format: " +
                          i
                      );
                    o = e.UNSIGNED_BYTE;
                  }
                  return {
                    buffer: a,
                    type: o,
                    bytesPerElement: i.BYTES_PER_ELEMENT,
                    version: t.version,
                    size: s,
                  };
                })(n, i)
              );
            else if (r.version < n.version) {
              if (r.size !== n.array.byteLength)
                throw new Error(
                  "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported."
                );
              !(function (t, n, i) {
                const r = n.array,
                  s = n.updateRanges;
                if ((e.bindBuffer(i, t), 0 === s.length))
                  e.bufferSubData(i, 0, r);
                else {
                  s.sort((e, t) => e.start - t.start);
                  let t = 0;
                  for (let e = 1; e < s.length; e++) {
                    const n = s[t],
                      i = s[e];
                    i.start <= n.start + n.count + 1
                      ? (n.count = Math.max(
                          n.count,
                          i.start + i.count - n.start
                        ))
                      : (++t, (s[t] = i));
                  }
                  s.length = t + 1;
                  for (let t = 0, n = s.length; t < n; t++) {
                    const n = s[t];
                    e.bufferSubData(
                      i,
                      n.start * r.BYTES_PER_ELEMENT,
                      r,
                      n.start,
                      n.count
                    );
                  }
                  n.clearUpdateRanges();
                }
                n.onUploadCallback();
              })(r.buffer, n, i),
                (r.version = n.version);
            }
          },
        };
      }
      class Co extends Qa {
        constructor(e = 1, t = 1, n = 1, i = 1) {
          super(),
            (this.type = "PlaneGeometry"),
            (this.parameters = {
              width: e,
              height: t,
              widthSegments: n,
              heightSegments: i,
            });
          const r = e / 2,
            s = t / 2,
            a = Math.floor(n),
            o = Math.floor(i),
            c = a + 1,
            l = o + 1,
            u = e / a,
            h = t / o,
            d = [],
            p = [],
            f = [],
            A = [];
          for (let e = 0; e < l; e++) {
            const t = e * h - s;
            for (let n = 0; n < c; n++) {
              const i = n * u - r;
              p.push(i, -t, 0),
                f.push(0, 0, 1),
                A.push(n / a),
                A.push(1 - e / o);
            }
          }
          for (let e = 0; e < o; e++)
            for (let t = 0; t < a; t++) {
              const n = t + c * e,
                i = t + c * (e + 1),
                r = t + 1 + c * (e + 1),
                s = t + 1 + c * e;
              d.push(n, i, s), d.push(i, r, s);
            }
          this.setIndex(d),
            this.setAttribute("position", new Da(p, 3)),
            this.setAttribute("normal", new Da(f, 3)),
            this.setAttribute("uv", new Da(A, 2));
        }
        copy(e) {
          return (
            super.copy(e),
            (this.parameters = Object.assign({}, e.parameters)),
            this
          );
        }
        static fromJSON(e) {
          return new Co(e.width, e.height, e.widthSegments, e.heightSegments);
        }
      }
      const So = {
          alphahash_fragment:
            "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
          alphahash_pars_fragment:
            "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",
          alphamap_fragment:
            "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
          alphamap_pars_fragment:
            "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
          alphatest_fragment:
            "#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif",
          alphatest_pars_fragment:
            "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
          aomap_fragment:
            "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
          aomap_pars_fragment:
            "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
          batching_pars_vertex:
            "#ifdef USE_BATCHING\n\t#if ! defined( GL_ANGLE_multi_draw )\n\t#define gl_DrawID _gl_DrawID\n\tuniform int _gl_DrawID;\n\t#endif\n\tuniform highp sampler2D batchingTexture;\n\tuniform highp usampler2D batchingIdTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n\tfloat getIndirectIndex( const in int i ) {\n\t\tint size = textureSize( batchingIdTexture, 0 ).x;\n\t\tint x = i % size;\n\t\tint y = i / size;\n\t\treturn float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n\t}\n#endif\n#ifdef USE_BATCHING_COLOR\n\tuniform sampler2D batchingColorTexture;\n\tvec3 getBatchingColor( const in float i ) {\n\t\tint size = textureSize( batchingColorTexture, 0 ).x;\n\t\tint j = int( i );\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\treturn texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n\t}\n#endif",
          batching_vertex:
            "#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif",
          begin_vertex:
            "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",
          beginnormal_vertex:
            "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
          bsdfs:
            "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",
          iridescence_fragment:
            "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
          bumpmap_pars_fragment:
            "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
          clipping_planes_fragment:
            "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif",
          clipping_planes_pars_fragment:
            "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
          clipping_planes_pars_vertex:
            "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
          clipping_planes_vertex:
            "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
          color_fragment:
            "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
          color_pars_fragment:
            "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
          color_pars_vertex:
            "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvarying vec3 vColor;\n#endif",
          color_vertex:
            "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n\tvec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n\tvColor.xyz *= batchingColor.xyz;\n#endif",
          common:
            "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
          cube_uv_reflection_fragment:
            "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
          defaultnormal_vertex:
            "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
          displacementmap_pars_vertex:
            "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
          displacementmap_vertex:
            "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
          emissivemap_fragment:
            "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE\n\t\temissiveColor = sRGBTransferEOTF( emissiveColor );\n\t#endif\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
          emissivemap_pars_fragment:
            "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
          colorspace_fragment:
            "gl_FragColor = linearToOutputTexel( gl_FragColor );",
          colorspace_pars_fragment:
            "vec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferEOTF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
          envmap_fragment:
            "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
          envmap_common_pars_fragment:
            "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform mat3 envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
          envmap_pars_fragment:
            "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
          envmap_pars_vertex:
            "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
          envmap_physical_pars_fragment:
            "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",
          envmap_vertex:
            "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
          fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
          fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
          fog_fragment:
            "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
          fog_pars_fragment:
            "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
          gradientmap_pars_fragment:
            "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
          lightmap_pars_fragment:
            "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
          lights_lambert_fragment:
            "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
          lights_lambert_pars_fragment:
            "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",
          lights_pars_begin:
            "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif ( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
          lights_toon_fragment:
            "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
          lights_toon_pars_fragment:
            "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",
          lights_phong_fragment:
            "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
          lights_phong_pars_fragment:
            "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",
          lights_physical_fragment:
            "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n\tmaterial.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif",
          lights_physical_pars_fragment:
            "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\tfloat dispersion;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
          lights_fragment_begin:
            "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
          lights_fragment_maps:
            "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
          lights_fragment_end:
            "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif",
          logdepthbuf_fragment:
            "#if defined( USE_LOGDEPTHBUF )\n\tgl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
          logdepthbuf_pars_fragment:
            "#if defined( USE_LOGDEPTHBUF )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
          logdepthbuf_pars_vertex:
            "#ifdef USE_LOGDEPTHBUF\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
          logdepthbuf_vertex:
            "#ifdef USE_LOGDEPTHBUF\n\tvFragDepth = 1.0 + gl_Position.w;\n\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif",
          map_fragment:
            "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
          map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
          map_particle_fragment:
            "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
          map_particle_pars_fragment:
            "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
          metalnessmap_fragment:
            "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
          metalnessmap_pars_fragment:
            "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
          morphinstance_vertex:
            "#ifdef USE_INSTANCING_MORPH\n\tfloat morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n\t}\n#endif",
          morphcolor_vertex:
            "#if defined( USE_MORPHCOLORS )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
          morphnormal_vertex:
            "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif",
          morphtarget_pars_vertex:
            "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_INSTANCING_MORPH\n\t\tuniform float morphTargetBaseInfluence;\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t#endif\n\tuniform sampler2DArray morphTargetsTexture;\n\tuniform ivec2 morphTargetsTextureSize;\n\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t}\n#endif",
          morphtarget_vertex:
            "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif",
          normal_fragment_begin:
            "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;",
          normal_fragment_maps:
            "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
          normal_pars_fragment:
            "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
          normal_pars_vertex:
            "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
          normal_vertex:
            "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
          normalmap_pars_fragment:
            "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",
          clearcoat_normal_fragment_begin:
            "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif",
          clearcoat_normal_fragment_maps:
            "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
          clearcoat_pars_fragment:
            "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",
          iridescence_pars_fragment:
            "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
          opaque_fragment:
            "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
          packing:
            "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec4( 0., 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec4( 1., 1., 1., 1. );\n\tfloat vuf;\n\tfloat af = modf( v * PackFactors.a, vuf );\n\tfloat bf = modf( vuf * ShiftRight8, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec3( 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec3( 1., 1., 1. );\n\tfloat vuf;\n\tfloat bf = modf( v * PackFactors.b, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec2( 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec2( 1., 1. );\n\tfloat vuf;\n\tfloat gf = modf( v * 256., vuf );\n\treturn vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n\treturn dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n\treturn v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",
          premultiplied_alpha_fragment:
            "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
          project_vertex:
            "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
          dithering_fragment:
            "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
          dithering_pars_fragment:
            "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
          roughnessmap_fragment:
            "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
          roughnessmap_pars_fragment:
            "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
          shadowmap_pars_fragment:
            "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tfloat shadow = 1.0;\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\t\n\t\tfloat lightToPositionLength = length( lightToPosition );\n\t\tif ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n\t\t\tfloat dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\t\tdp += shadowBias;\n\t\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\t\tshadow = (\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t\t) * ( 1.0 / 9.0 );\n\t\t\t#else\n\t\t\t\tshadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n#endif",
          shadowmap_pars_vertex:
            "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
          shadowmap_vertex:
            "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",
          shadowmask_pars_fragment:
            "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
          skinbase_vertex:
            "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
          skinning_pars_vertex:
            "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
          skinning_vertex:
            "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
          skinnormal_vertex:
            "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
          specularmap_fragment:
            "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
          specularmap_pars_fragment:
            "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
          tonemapping_fragment:
            "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
          tonemapping_pars_fragment:
            "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 CineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n\tconst float StartCompression = 0.8 - 0.04;\n\tconst float Desaturation = 0.15;\n\tcolor *= toneMappingExposure;\n\tfloat x = min( color.r, min( color.g, color.b ) );\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max( color.r, max( color.g, color.b ) );\n\tif ( peak < StartCompression ) return color;\n\tfloat d = 1. - StartCompression;\n\tfloat newPeak = 1. - d * d / ( peak + d - StartCompression );\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n\treturn mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
          transmission_fragment:
            "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
          transmission_pars_fragment:
            "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec4 transmittedLight;\n\t\tvec3 transmittance;\n\t\t#ifdef USE_DISPERSION\n\t\t\tfloat halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n\t\t\tvec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n\t\t\tfor ( int i = 0; i < 3; i ++ ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\t\t\n\t\t\t\tvec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n\t\t\t\ttransmittedLight[ i ] = transmissionSample[ i ];\n\t\t\t\ttransmittedLight.a += transmissionSample.a;\n\t\t\t\ttransmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n\t\t\t}\n\t\t\ttransmittedLight.a /= 3.0;\n\t\t\n\t\t#else\n\t\t\n\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\trefractionCoords += 1.0;\n\t\t\trefractionCoords /= 2.0;\n\t\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\t\ttransmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\t\n\t\t#endif\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",
          uv_pars_fragment:
            "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
          uv_pars_vertex:
            "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
          uv_vertex:
            "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
          worldpos_vertex:
            "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
          background_vert:
            "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
          background_frag:
            "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
          backgroundCube_vert:
            "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
          backgroundCube_frag:
            "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
          cube_vert:
            "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
          cube_frag:
            "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
          depth_vert:
            "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
          depth_frag:
            "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#elif DEPTH_PACKING == 3202\n\t\tgl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n\t#elif DEPTH_PACKING == 3203\n\t\tgl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n\t#endif\n}",
          distanceRGBA_vert:
            "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
          distanceRGBA_frag:
            "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
          equirect_vert:
            "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
          equirect_frag:
            "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
          linedashed_vert:
            "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
          linedashed_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
          meshbasic_vert:
            "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
          meshbasic_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshlambert_vert:
            "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          meshlambert_frag:
            "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshmatcap_vert:
            "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
          meshmatcap_frag:
            "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshnormal_vert:
            "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
          meshnormal_frag:
            "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
          meshphong_vert:
            "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          meshphong_frag:
            "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshphysical_vert:
            "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
          meshphysical_frag:
            "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n\tuniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshtoon_vert:
            "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          meshtoon_frag:
            "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          points_vert:
            "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
          points_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
          shadow_vert:
            "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          shadow_frag:
            "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
          sprite_vert:
            "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix[ 3 ];\n\tvec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
          sprite_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
        },
        Io = {
          common: {
            diffuse: { value: new ma(16777215) },
            opacity: { value: 1 },
            map: { value: null },
            mapTransform: { value: new _r() },
            alphaMap: { value: null },
            alphaMapTransform: { value: new _r() },
            alphaTest: { value: 0 },
          },
          specularmap: {
            specularMap: { value: null },
            specularMapTransform: { value: new _r() },
          },
          envmap: {
            envMap: { value: null },
            envMapRotation: { value: new _r() },
            flipEnvMap: { value: -1 },
            reflectivity: { value: 1 },
            ior: { value: 1.5 },
            refractionRatio: { value: 0.98 },
          },
          aomap: {
            aoMap: { value: null },
            aoMapIntensity: { value: 1 },
            aoMapTransform: { value: new _r() },
          },
          lightmap: {
            lightMap: { value: null },
            lightMapIntensity: { value: 1 },
            lightMapTransform: { value: new _r() },
          },
          bumpmap: {
            bumpMap: { value: null },
            bumpMapTransform: { value: new _r() },
            bumpScale: { value: 1 },
          },
          normalmap: {
            normalMap: { value: null },
            normalMapTransform: { value: new _r() },
            normalScale: { value: new br(1, 1) },
          },
          displacementmap: {
            displacementMap: { value: null },
            displacementMapTransform: { value: new _r() },
            displacementScale: { value: 1 },
            displacementBias: { value: 0 },
          },
          emissivemap: {
            emissiveMap: { value: null },
            emissiveMapTransform: { value: new _r() },
          },
          metalnessmap: {
            metalnessMap: { value: null },
            metalnessMapTransform: { value: new _r() },
          },
          roughnessmap: {
            roughnessMap: { value: null },
            roughnessMapTransform: { value: new _r() },
          },
          gradientmap: { gradientMap: { value: null } },
          fog: {
            fogDensity: { value: 25e-5 },
            fogNear: { value: 1 },
            fogFar: { value: 2e3 },
            fogColor: { value: new ma(16777215) },
          },
          lights: {
            ambientLightColor: { value: [] },
            lightProbe: { value: [] },
            directionalLights: {
              value: [],
              properties: { direction: {}, color: {} },
            },
            directionalLightShadows: {
              value: [],
              properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            directionalShadowMap: { value: [] },
            directionalShadowMatrix: { value: [] },
            spotLights: {
              value: [],
              properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {},
              },
            },
            spotLightShadows: {
              value: [],
              properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            spotLightMap: { value: [] },
            spotShadowMap: { value: [] },
            spotLightMatrix: { value: [] },
            pointLights: {
              value: [],
              properties: { color: {}, position: {}, decay: {}, distance: {} },
            },
            pointLightShadows: {
              value: [],
              properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {},
              },
            },
            pointShadowMap: { value: [] },
            pointShadowMatrix: { value: [] },
            hemisphereLights: {
              value: [],
              properties: { direction: {}, skyColor: {}, groundColor: {} },
            },
            rectAreaLights: {
              value: [],
              properties: { color: {}, position: {}, width: {}, height: {} },
            },
            ltc_1: { value: null },
            ltc_2: { value: null },
          },
          points: {
            diffuse: { value: new ma(16777215) },
            opacity: { value: 1 },
            size: { value: 1 },
            scale: { value: 1 },
            map: { value: null },
            alphaMap: { value: null },
            alphaMapTransform: { value: new _r() },
            alphaTest: { value: 0 },
            uvTransform: { value: new _r() },
          },
          sprite: {
            diffuse: { value: new ma(16777215) },
            opacity: { value: 1 },
            center: { value: new br(0.5, 0.5) },
            rotation: { value: 0 },
            map: { value: null },
            mapTransform: { value: new _r() },
            alphaMap: { value: null },
            alphaMapTransform: { value: new _r() },
            alphaTest: { value: 0 },
          },
        },
        Mo = {
          basic: {
            uniforms: no([
              Io.common,
              Io.specularmap,
              Io.envmap,
              Io.aomap,
              Io.lightmap,
              Io.fog,
            ]),
            vertexShader: So.meshbasic_vert,
            fragmentShader: So.meshbasic_frag,
          },
          lambert: {
            uniforms: no([
              Io.common,
              Io.specularmap,
              Io.envmap,
              Io.aomap,
              Io.lightmap,
              Io.emissivemap,
              Io.bumpmap,
              Io.normalmap,
              Io.displacementmap,
              Io.fog,
              Io.lights,
              { emissive: { value: new ma(0) } },
            ]),
            vertexShader: So.meshlambert_vert,
            fragmentShader: So.meshlambert_frag,
          },
          phong: {
            uniforms: no([
              Io.common,
              Io.specularmap,
              Io.envmap,
              Io.aomap,
              Io.lightmap,
              Io.emissivemap,
              Io.bumpmap,
              Io.normalmap,
              Io.displacementmap,
              Io.fog,
              Io.lights,
              {
                emissive: { value: new ma(0) },
                specular: { value: new ma(1118481) },
                shininess: { value: 30 },
              },
            ]),
            vertexShader: So.meshphong_vert,
            fragmentShader: So.meshphong_frag,
          },
          standard: {
            uniforms: no([
              Io.common,
              Io.envmap,
              Io.aomap,
              Io.lightmap,
              Io.emissivemap,
              Io.bumpmap,
              Io.normalmap,
              Io.displacementmap,
              Io.roughnessmap,
              Io.metalnessmap,
              Io.fog,
              Io.lights,
              {
                emissive: { value: new ma(0) },
                roughness: { value: 1 },
                metalness: { value: 0 },
                envMapIntensity: { value: 1 },
              },
            ]),
            vertexShader: So.meshphysical_vert,
            fragmentShader: So.meshphysical_frag,
          },
          toon: {
            uniforms: no([
              Io.common,
              Io.aomap,
              Io.lightmap,
              Io.emissivemap,
              Io.bumpmap,
              Io.normalmap,
              Io.displacementmap,
              Io.gradientmap,
              Io.fog,
              Io.lights,
              { emissive: { value: new ma(0) } },
            ]),
            vertexShader: So.meshtoon_vert,
            fragmentShader: So.meshtoon_frag,
          },
          matcap: {
            uniforms: no([
              Io.common,
              Io.bumpmap,
              Io.normalmap,
              Io.displacementmap,
              Io.fog,
              { matcap: { value: null } },
            ]),
            vertexShader: So.meshmatcap_vert,
            fragmentShader: So.meshmatcap_frag,
          },
          points: {
            uniforms: no([Io.points, Io.fog]),
            vertexShader: So.points_vert,
            fragmentShader: So.points_frag,
          },
          dashed: {
            uniforms: no([
              Io.common,
              Io.fog,
              {
                scale: { value: 1 },
                dashSize: { value: 1 },
                totalSize: { value: 2 },
              },
            ]),
            vertexShader: So.linedashed_vert,
            fragmentShader: So.linedashed_frag,
          },
          depth: {
            uniforms: no([Io.common, Io.displacementmap]),
            vertexShader: So.depth_vert,
            fragmentShader: So.depth_frag,
          },
          normal: {
            uniforms: no([
              Io.common,
              Io.bumpmap,
              Io.normalmap,
              Io.displacementmap,
              { opacity: { value: 1 } },
            ]),
            vertexShader: So.meshnormal_vert,
            fragmentShader: So.meshnormal_frag,
          },
          sprite: {
            uniforms: no([Io.sprite, Io.fog]),
            vertexShader: So.sprite_vert,
            fragmentShader: So.sprite_frag,
          },
          background: {
            uniforms: {
              uvTransform: { value: new _r() },
              t2D: { value: null },
              backgroundIntensity: { value: 1 },
            },
            vertexShader: So.background_vert,
            fragmentShader: So.background_frag,
          },
          backgroundCube: {
            uniforms: {
              envMap: { value: null },
              flipEnvMap: { value: -1 },
              backgroundBlurriness: { value: 0 },
              backgroundIntensity: { value: 1 },
              backgroundRotation: { value: new _r() },
            },
            vertexShader: So.backgroundCube_vert,
            fragmentShader: So.backgroundCube_frag,
          },
          cube: {
            uniforms: {
              tCube: { value: null },
              tFlip: { value: -1 },
              opacity: { value: 1 },
            },
            vertexShader: So.cube_vert,
            fragmentShader: So.cube_frag,
          },
          equirect: {
            uniforms: { tEquirect: { value: null } },
            vertexShader: So.equirect_vert,
            fragmentShader: So.equirect_frag,
          },
          distanceRGBA: {
            uniforms: no([
              Io.common,
              Io.displacementmap,
              {
                referencePosition: { value: new Yr() },
                nearDistance: { value: 1 },
                farDistance: { value: 1e3 },
              },
            ]),
            vertexShader: So.distanceRGBA_vert,
            fragmentShader: So.distanceRGBA_frag,
          },
          shadow: {
            uniforms: no([
              Io.lights,
              Io.fog,
              { color: { value: new ma(0) }, opacity: { value: 1 } },
            ]),
            vertexShader: So.shadow_vert,
            fragmentShader: So.shadow_frag,
          },
        };
      Mo.physical = {
        uniforms: no([
          Mo.standard.uniforms,
          {
            clearcoat: { value: 0 },
            clearcoatMap: { value: null },
            clearcoatMapTransform: { value: new _r() },
            clearcoatNormalMap: { value: null },
            clearcoatNormalMapTransform: { value: new _r() },
            clearcoatNormalScale: { value: new br(1, 1) },
            clearcoatRoughness: { value: 0 },
            clearcoatRoughnessMap: { value: null },
            clearcoatRoughnessMapTransform: { value: new _r() },
            dispersion: { value: 0 },
            iridescence: { value: 0 },
            iridescenceMap: { value: null },
            iridescenceMapTransform: { value: new _r() },
            iridescenceIOR: { value: 1.3 },
            iridescenceThicknessMinimum: { value: 100 },
            iridescenceThicknessMaximum: { value: 400 },
            iridescenceThicknessMap: { value: null },
            iridescenceThicknessMapTransform: { value: new _r() },
            sheen: { value: 0 },
            sheenColor: { value: new ma(0) },
            sheenColorMap: { value: null },
            sheenColorMapTransform: { value: new _r() },
            sheenRoughness: { value: 1 },
            sheenRoughnessMap: { value: null },
            sheenRoughnessMapTransform: { value: new _r() },
            transmission: { value: 0 },
            transmissionMap: { value: null },
            transmissionMapTransform: { value: new _r() },
            transmissionSamplerSize: { value: new br() },
            transmissionSamplerMap: { value: null },
            thickness: { value: 0 },
            thicknessMap: { value: null },
            thicknessMapTransform: { value: new _r() },
            attenuationDistance: { value: 0 },
            attenuationColor: { value: new ma(0) },
            specularColor: { value: new ma(1, 1, 1) },
            specularColorMap: { value: null },
            specularColorMapTransform: { value: new _r() },
            specularIntensity: { value: 1 },
            specularIntensityMap: { value: null },
            specularIntensityMapTransform: { value: new _r() },
            anisotropyVector: { value: new br() },
            anisotropyMap: { value: null },
            anisotropyMapTransform: { value: new _r() },
          },
        ]),
        vertexShader: So.meshphysical_vert,
        fragmentShader: So.meshphysical_frag,
      };
      const To = { r: 0, b: 0, g: 0 },
        Bo = new Us(),
        Ro = new Cs();
      function Do(e, t, n, i, r, s, a) {
        const o = new ma(0);
        let c,
          l,
          u = !0 === s ? 0 : 1,
          h = null,
          d = 0,
          p = null;
        function f(e) {
          let i = !0 === e.isScene ? e.background : null;
          if (i && i.isTexture) {
            i = (e.backgroundBlurriness > 0 ? n : t).get(i);
          }
          return i;
        }
        function A(t, n) {
          t.getRGB(To, io(e)), i.buffers.color.setClear(To.r, To.g, To.b, n, a);
        }
        return {
          getClearColor: function () {
            return o;
          },
          setClearColor: function (e, t = 1) {
            o.set(e), (u = t), A(o, u);
          },
          getClearAlpha: function () {
            return u;
          },
          setClearAlpha: function (e) {
            (u = e), A(o, u);
          },
          render: function (t) {
            let n = !1;
            const r = f(t);
            null === r ? A(o, u) : r && r.isColor && (A(r, 1), (n = !0));
            const s = e.xr.getEnvironmentBlendMode();
            "additive" === s
              ? i.buffers.color.setClear(0, 0, 0, 1, a)
              : "alpha-blend" === s && i.buffers.color.setClear(0, 0, 0, 0, a),
              (e.autoClear || n) &&
                (i.buffers.depth.setTest(!0),
                i.buffers.depth.setMask(!0),
                i.buffers.color.setMask(!0),
                e.clear(
                  e.autoClearColor,
                  e.autoClearDepth,
                  e.autoClearStencil
                ));
          },
          addToRenderList: function (t, n) {
            const i = f(n);
            i && (i.isCubeTexture || i.mapping === Mn)
              ? (void 0 === l &&
                  ((l = new Za(
                    new eo(1, 1, 1),
                    new so({
                      name: "BackgroundCubeMaterial",
                      uniforms: to(Mo.backgroundCube.uniforms),
                      vertexShader: Mo.backgroundCube.vertexShader,
                      fragmentShader: Mo.backgroundCube.fragmentShader,
                      side: ln,
                      depthTest: !1,
                      depthWrite: !1,
                      fog: !1,
                    })
                  )),
                  l.geometry.deleteAttribute("normal"),
                  l.geometry.deleteAttribute("uv"),
                  (l.onBeforeRender = function (e, t, n) {
                    this.matrixWorld.copyPosition(n.matrixWorld);
                  }),
                  Object.defineProperty(l.material, "envMap", {
                    get: function () {
                      return this.uniforms.envMap.value;
                    },
                  }),
                  r.update(l)),
                Bo.copy(n.backgroundRotation),
                (Bo.x *= -1),
                (Bo.y *= -1),
                (Bo.z *= -1),
                i.isCubeTexture &&
                  !1 === i.isRenderTargetTexture &&
                  ((Bo.y *= -1), (Bo.z *= -1)),
                (l.material.uniforms.envMap.value = i),
                (l.material.uniforms.flipEnvMap.value =
                  i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1),
                (l.material.uniforms.backgroundBlurriness.value =
                  n.backgroundBlurriness),
                (l.material.uniforms.backgroundIntensity.value =
                  n.backgroundIntensity),
                l.material.uniforms.backgroundRotation.value.setFromMatrix4(
                  Ro.makeRotationFromEuler(Bo)
                ),
                (l.material.toneMapped = Mr.getTransfer(i.colorSpace) !== tr),
                (h === i && d === i.version && p === e.toneMapping) ||
                  ((l.material.needsUpdate = !0),
                  (h = i),
                  (d = i.version),
                  (p = e.toneMapping)),
                l.layers.enableAll(),
                t.unshift(l, l.geometry, l.material, 0, 0, null))
              : i &&
                i.isTexture &&
                (void 0 === c &&
                  ((c = new Za(
                    new Co(2, 2),
                    new so({
                      name: "BackgroundMaterial",
                      uniforms: to(Mo.background.uniforms),
                      vertexShader: Mo.background.vertexShader,
                      fragmentShader: Mo.background.fragmentShader,
                      side: cn,
                      depthTest: !1,
                      depthWrite: !1,
                      fog: !1,
                    })
                  )),
                  c.geometry.deleteAttribute("normal"),
                  Object.defineProperty(c.material, "map", {
                    get: function () {
                      return this.uniforms.t2D.value;
                    },
                  }),
                  r.update(c)),
                (c.material.uniforms.t2D.value = i),
                (c.material.uniforms.backgroundIntensity.value =
                  n.backgroundIntensity),
                (c.material.toneMapped = Mr.getTransfer(i.colorSpace) !== tr),
                !0 === i.matrixAutoUpdate && i.updateMatrix(),
                c.material.uniforms.uvTransform.value.copy(i.matrix),
                (h === i && d === i.version && p === e.toneMapping) ||
                  ((c.material.needsUpdate = !0),
                  (h = i),
                  (d = i.version),
                  (p = e.toneMapping)),
                c.layers.enableAll(),
                t.unshift(c, c.geometry, c.material, 0, 0, null));
          },
        };
      }
      function Po(e, t) {
        const n = e.getParameter(e.MAX_VERTEX_ATTRIBS),
          i = {},
          r = l(null);
        let s = r,
          a = !1;
        function o(t) {
          return e.bindVertexArray(t);
        }
        function c(t) {
          return e.deleteVertexArray(t);
        }
        function l(e) {
          const t = [],
            i = [],
            r = [];
          for (let e = 0; e < n; e++) (t[e] = 0), (i[e] = 0), (r[e] = 0);
          return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: t,
            enabledAttributes: i,
            attributeDivisors: r,
            object: e,
            attributes: {},
            index: null,
          };
        }
        function u() {
          const e = s.newAttributes;
          for (let t = 0, n = e.length; t < n; t++) e[t] = 0;
        }
        function h(e) {
          d(e, 0);
        }
        function d(t, n) {
          const i = s.newAttributes,
            r = s.enabledAttributes,
            a = s.attributeDivisors;
          (i[t] = 1),
            0 === r[t] && (e.enableVertexAttribArray(t), (r[t] = 1)),
            a[t] !== n && (e.vertexAttribDivisor(t, n), (a[t] = n));
        }
        function p() {
          const t = s.newAttributes,
            n = s.enabledAttributes;
          for (let i = 0, r = n.length; i < r; i++)
            n[i] !== t[i] && (e.disableVertexAttribArray(i), (n[i] = 0));
        }
        function f(t, n, i, r, s, a, o) {
          !0 === o
            ? e.vertexAttribIPointer(t, n, i, s, a)
            : e.vertexAttribPointer(t, n, i, r, s, a);
        }
        function A() {
          g(), (a = !0), s !== r && ((s = r), o(s.object));
        }
        function g() {
          (r.geometry = null), (r.program = null), (r.wireframe = !1);
        }
        return {
          setup: function (n, r, c, A, g) {
            let m = !1;
            const v = (function (t, n, r) {
              const s = !0 === r.wireframe;
              let a = i[t.id];
              void 0 === a && ((a = {}), (i[t.id] = a));
              let o = a[n.id];
              void 0 === o && ((o = {}), (a[n.id] = o));
              let c = o[s];
              void 0 === c && ((c = l(e.createVertexArray())), (o[s] = c));
              return c;
            })(A, c, r);
            s !== v && ((s = v), o(s.object)),
              (m = (function (e, t, n, i) {
                const r = s.attributes,
                  a = t.attributes;
                let o = 0;
                const c = n.getAttributes();
                for (const t in c) {
                  if (c[t].location >= 0) {
                    const n = r[t];
                    let i = a[t];
                    if (
                      (void 0 === i &&
                        ("instanceMatrix" === t &&
                          e.instanceMatrix &&
                          (i = e.instanceMatrix),
                        "instanceColor" === t &&
                          e.instanceColor &&
                          (i = e.instanceColor)),
                      void 0 === n)
                    )
                      return !0;
                    if (n.attribute !== i) return !0;
                    if (i && n.data !== i.data) return !0;
                    o++;
                  }
                }
                return s.attributesNum !== o || s.index !== i;
              })(n, A, c, g)),
              m &&
                (function (e, t, n, i) {
                  const r = {},
                    a = t.attributes;
                  let o = 0;
                  const c = n.getAttributes();
                  for (const t in c) {
                    if (c[t].location >= 0) {
                      let n = a[t];
                      void 0 === n &&
                        ("instanceMatrix" === t &&
                          e.instanceMatrix &&
                          (n = e.instanceMatrix),
                        "instanceColor" === t &&
                          e.instanceColor &&
                          (n = e.instanceColor));
                      const i = {};
                      (i.attribute = n),
                        n && n.data && (i.data = n.data),
                        (r[t] = i),
                        o++;
                    }
                  }
                  (s.attributes = r), (s.attributesNum = o), (s.index = i);
                })(n, A, c, g),
              null !== g && t.update(g, e.ELEMENT_ARRAY_BUFFER),
              (m || a) &&
                ((a = !1),
                (function (n, i, r, s) {
                  u();
                  const a = s.attributes,
                    o = r.getAttributes(),
                    c = i.defaultAttributeValues;
                  for (const i in o) {
                    const r = o[i];
                    if (r.location >= 0) {
                      let o = a[i];
                      if (
                        (void 0 === o &&
                          ("instanceMatrix" === i &&
                            n.instanceMatrix &&
                            (o = n.instanceMatrix),
                          "instanceColor" === i &&
                            n.instanceColor &&
                            (o = n.instanceColor)),
                        void 0 !== o)
                      ) {
                        const i = o.normalized,
                          a = o.itemSize,
                          c = t.get(o);
                        if (void 0 === c) continue;
                        const l = c.buffer,
                          u = c.type,
                          p = c.bytesPerElement,
                          A =
                            u === e.INT ||
                            u === e.UNSIGNED_INT ||
                            o.gpuType === Hn;
                        if (o.isInterleavedBufferAttribute) {
                          const t = o.data,
                            c = t.stride,
                            g = o.offset;
                          if (t.isInstancedInterleavedBuffer) {
                            for (let e = 0; e < r.locationSize; e++)
                              d(r.location + e, t.meshPerAttribute);
                            !0 !== n.isInstancedMesh &&
                              void 0 === s._maxInstanceCount &&
                              (s._maxInstanceCount =
                                t.meshPerAttribute * t.count);
                          } else
                            for (let e = 0; e < r.locationSize; e++)
                              h(r.location + e);
                          e.bindBuffer(e.ARRAY_BUFFER, l);
                          for (let e = 0; e < r.locationSize; e++)
                            f(
                              r.location + e,
                              a / r.locationSize,
                              u,
                              i,
                              c * p,
                              (g + (a / r.locationSize) * e) * p,
                              A
                            );
                        } else {
                          if (o.isInstancedBufferAttribute) {
                            for (let e = 0; e < r.locationSize; e++)
                              d(r.location + e, o.meshPerAttribute);
                            !0 !== n.isInstancedMesh &&
                              void 0 === s._maxInstanceCount &&
                              (s._maxInstanceCount =
                                o.meshPerAttribute * o.count);
                          } else
                            for (let e = 0; e < r.locationSize; e++)
                              h(r.location + e);
                          e.bindBuffer(e.ARRAY_BUFFER, l);
                          for (let e = 0; e < r.locationSize; e++)
                            f(
                              r.location + e,
                              a / r.locationSize,
                              u,
                              i,
                              a * p,
                              (a / r.locationSize) * e * p,
                              A
                            );
                        }
                      } else if (void 0 !== c) {
                        const t = c[i];
                        if (void 0 !== t)
                          switch (t.length) {
                            case 2:
                              e.vertexAttrib2fv(r.location, t);
                              break;
                            case 3:
                              e.vertexAttrib3fv(r.location, t);
                              break;
                            case 4:
                              e.vertexAttrib4fv(r.location, t);
                              break;
                            default:
                              e.vertexAttrib1fv(r.location, t);
                          }
                      }
                    }
                  }
                  p();
                })(n, r, c, A),
                null !== g &&
                  e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t.get(g).buffer));
          },
          reset: A,
          resetDefaultState: g,
          dispose: function () {
            A();
            for (const e in i) {
              const t = i[e];
              for (const e in t) {
                const n = t[e];
                for (const e in n) c(n[e].object), delete n[e];
                delete t[e];
              }
              delete i[e];
            }
          },
          releaseStatesOfGeometry: function (e) {
            if (void 0 === i[e.id]) return;
            const t = i[e.id];
            for (const e in t) {
              const n = t[e];
              for (const e in n) c(n[e].object), delete n[e];
              delete t[e];
            }
            delete i[e.id];
          },
          releaseStatesOfProgram: function (e) {
            for (const t in i) {
              const n = i[t];
              if (void 0 === n[e.id]) continue;
              const r = n[e.id];
              for (const e in r) c(r[e].object), delete r[e];
              delete n[e.id];
            }
          },
          initAttributes: u,
          enableAttribute: h,
          disableUnusedAttributes: p,
        };
      }
      function Lo(e, t, n) {
        let i;
        function r(t, r, s) {
          0 !== s && (e.drawArraysInstanced(i, t, r, s), n.update(r, i, s));
        }
        (this.setMode = function (e) {
          i = e;
        }),
          (this.render = function (t, r) {
            e.drawArrays(i, t, r), n.update(r, i, 1);
          }),
          (this.renderInstances = r),
          (this.renderMultiDraw = function (e, r, s) {
            if (0 === s) return;
            t.get("WEBGL_multi_draw").multiDrawArraysWEBGL(i, e, 0, r, 0, s);
            let a = 0;
            for (let e = 0; e < s; e++) a += r[e];
            n.update(a, i, 1);
          }),
          (this.renderMultiDrawInstances = function (e, s, a, o) {
            if (0 === a) return;
            const c = t.get("WEBGL_multi_draw");
            if (null === c)
              for (let t = 0; t < e.length; t++) r(e[t], s[t], o[t]);
            else {
              c.multiDrawArraysInstancedWEBGL(i, e, 0, s, 0, o, 0, a);
              let t = 0;
              for (let e = 0; e < a; e++) t += s[e] * o[e];
              n.update(t, i, 1);
            }
          });
      }
      function Uo(e, t, n, i) {
        let r;
        function s(t) {
          if ("highp" === t) {
            if (
              e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT)
                .precision > 0 &&
              e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT)
                .precision > 0
            )
              return "highp";
            t = "mediump";
          }
          return "mediump" === t &&
            e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT)
              .precision > 0 &&
            e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT)
              .precision > 0
            ? "mediump"
            : "lowp";
        }
        let a = void 0 !== n.precision ? n.precision : "highp";
        const o = s(a);
        o !== a &&
          (console.warn(
            "THREE.WebGLRenderer:",
            a,
            "not supported, using",
            o,
            "instead."
          ),
          (a = o));
        const c = !0 === n.logarithmicDepthBuffer,
          l = !0 === n.reverseDepthBuffer && t.has("EXT_clip_control"),
          u = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),
          h = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
        return {
          isWebGL2: !0,
          getMaxAnisotropy: function () {
            if (void 0 !== r) return r;
            if (!0 === t.has("EXT_texture_filter_anisotropic")) {
              const n = t.get("EXT_texture_filter_anisotropic");
              r = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
            } else r = 0;
            return r;
          },
          getMaxPrecision: s,
          textureFormatReadable: function (t) {
            return (
              t === Zn ||
              i.convert(t) ===
                e.getParameter(e.IMPLEMENTATION_COLOR_READ_FORMAT)
            );
          },
          textureTypeReadable: function (n) {
            const r =
              n === jn &&
              (t.has("EXT_color_buffer_half_float") ||
                t.has("EXT_color_buffer_float"));
            return !(
              n !== Nn &&
              i.convert(n) !==
                e.getParameter(e.IMPLEMENTATION_COLOR_READ_TYPE) &&
              n !== Vn &&
              !r
            );
          },
          precision: a,
          logarithmicDepthBuffer: c,
          reverseDepthBuffer: l,
          maxTextures: u,
          maxVertexTextures: h,
          maxTextureSize: e.getParameter(e.MAX_TEXTURE_SIZE),
          maxCubemapSize: e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),
          maxAttributes: e.getParameter(e.MAX_VERTEX_ATTRIBS),
          maxVertexUniforms: e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS),
          maxVaryings: e.getParameter(e.MAX_VARYING_VECTORS),
          maxFragmentUniforms: e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS),
          vertexTextures: h > 0,
          maxSamples: e.getParameter(e.MAX_SAMPLES),
        };
      }
      function Fo(e) {
        const t = this;
        let n = null,
          i = 0,
          r = !1,
          s = !1;
        const a = new yo(),
          o = new _r(),
          c = { value: null, needsUpdate: !1 };
        function l(e, n, i, r) {
          const s = null !== e ? e.length : 0;
          let l = null;
          if (0 !== s) {
            if (((l = c.value), !0 !== r || null === l)) {
              const t = i + 4 * s,
                r = n.matrixWorldInverse;
              o.getNormalMatrix(r),
                (null === l || l.length < t) && (l = new Float32Array(t));
              for (let t = 0, n = i; t !== s; ++t, n += 4)
                a.copy(e[t]).applyMatrix4(r, o),
                  a.normal.toArray(l, n),
                  (l[n + 3] = a.constant);
            }
            (c.value = l), (c.needsUpdate = !0);
          }
          return (t.numPlanes = s), (t.numIntersection = 0), l;
        }
        (this.uniform = c),
          (this.numPlanes = 0),
          (this.numIntersection = 0),
          (this.init = function (e, t) {
            const n = 0 !== e.length || t || 0 !== i || r;
            return (r = t), (i = e.length), n;
          }),
          (this.beginShadows = function () {
            (s = !0), l(null);
          }),
          (this.endShadows = function () {
            s = !1;
          }),
          (this.setGlobalState = function (e, t) {
            n = l(e, t, 0);
          }),
          (this.setState = function (a, o, u) {
            const h = a.clippingPlanes,
              d = a.clipIntersection,
              p = a.clipShadows,
              f = e.get(a);
            if (!r || null === h || 0 === h.length || (s && !p))
              s
                ? l(null)
                : (function () {
                    c.value !== n && ((c.value = n), (c.needsUpdate = i > 0));
                    (t.numPlanes = i), (t.numIntersection = 0);
                  })();
            else {
              const e = s ? 0 : i,
                t = 4 * e;
              let r = f.clippingState || null;
              (c.value = r), (r = l(h, o, t, u));
              for (let e = 0; e !== t; ++e) r[e] = n[e];
              (f.clippingState = r),
                (this.numIntersection = d ? this.numPlanes : 0),
                (this.numPlanes += e);
            }
          });
      }
      function Oo(e) {
        let t = new WeakMap();
        function n(e, t) {
          return t === Sn ? (e.mapping = wn) : t === In && (e.mapping = Cn), e;
        }
        function i(e) {
          const n = e.target;
          n.removeEventListener("dispose", i);
          const r = t.get(n);
          void 0 !== r && (t.delete(n), r.dispose());
        }
        return {
          get: function (r) {
            if (r && r.isTexture) {
              const s = r.mapping;
              if (s === Sn || s === In) {
                if (t.has(r)) {
                  return n(t.get(r).texture, r.mapping);
                }
                {
                  const s = r.image;
                  if (s && s.height > 0) {
                    const a = new Ao(s.height);
                    return (
                      a.fromEquirectangularTexture(e, r),
                      t.set(r, a),
                      r.addEventListener("dispose", i),
                      n(a.texture, r.mapping)
                    );
                  }
                  return null;
                }
              }
            }
            return r;
          },
          dispose: function () {
            t = new WeakMap();
          },
        };
      }
      class No extends ao {
        constructor(e = -1, t = 1, n = 1, i = -1, r = 0.1, s = 2e3) {
          super(),
            (this.isOrthographicCamera = !0),
            (this.type = "OrthographicCamera"),
            (this.zoom = 1),
            (this.view = null),
            (this.left = e),
            (this.right = t),
            (this.top = n),
            (this.bottom = i),
            (this.near = r),
            (this.far = s),
            this.updateProjectionMatrix();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.left = e.left),
            (this.right = e.right),
            (this.top = e.top),
            (this.bottom = e.bottom),
            (this.near = e.near),
            (this.far = e.far),
            (this.zoom = e.zoom),
            (this.view = null === e.view ? null : Object.assign({}, e.view)),
            this
          );
        }
        setViewOffset(e, t, n, i, r, s) {
          null === this.view &&
            (this.view = {
              enabled: !0,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1,
            }),
            (this.view.enabled = !0),
            (this.view.fullWidth = e),
            (this.view.fullHeight = t),
            (this.view.offsetX = n),
            (this.view.offsetY = i),
            (this.view.width = r),
            (this.view.height = s),
            this.updateProjectionMatrix();
        }
        clearViewOffset() {
          null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const e = (this.right - this.left) / (2 * this.zoom),
            t = (this.top - this.bottom) / (2 * this.zoom),
            n = (this.right + this.left) / 2,
            i = (this.top + this.bottom) / 2;
          let r = n - e,
            s = n + e,
            a = i + t,
            o = i - t;
          if (null !== this.view && this.view.enabled) {
            const e =
                (this.right - this.left) / this.view.fullWidth / this.zoom,
              t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            (r += e * this.view.offsetX),
              (s = r + e * this.view.width),
              (a -= t * this.view.offsetY),
              (o = a - t * this.view.height);
          }
          this.projectionMatrix.makeOrthographic(
            r,
            s,
            a,
            o,
            this.near,
            this.far,
            this.coordinateSystem
          ),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.zoom = this.zoom),
            (t.object.left = this.left),
            (t.object.right = this.right),
            (t.object.top = this.top),
            (t.object.bottom = this.bottom),
            (t.object.near = this.near),
            (t.object.far = this.far),
            null !== this.view &&
              (t.object.view = Object.assign({}, this.view)),
            t
          );
        }
      }
      const ko = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
        Qo = 20,
        Go = new No(),
        Ho = new ma();
      let zo = null,
        Vo = 0,
        jo = 0,
        Wo = !1;
      const Xo = (1 + Math.sqrt(5)) / 2,
        qo = 1 / Xo,
        Yo = [
          new Yr(-Xo, qo, 0),
          new Yr(Xo, qo, 0),
          new Yr(-qo, 0, Xo),
          new Yr(qo, 0, Xo),
          new Yr(0, Xo, -qo),
          new Yr(0, Xo, qo),
          new Yr(-1, 1, -1),
          new Yr(1, 1, -1),
          new Yr(-1, 1, 1),
          new Yr(1, 1, 1),
        ];
      class Ko {
        constructor(e) {
          (this._renderer = e),
            (this._pingPongRenderTarget = null),
            (this._lodMax = 0),
            (this._cubeSize = 0),
            (this._lodPlanes = []),
            (this._sizeLods = []),
            (this._sigmas = []),
            (this._blurMaterial = null),
            (this._cubemapMaterial = null),
            (this._equirectMaterial = null),
            this._compileMaterial(this._blurMaterial);
        }
        fromScene(e, t = 0, n = 0.1, i = 100) {
          (zo = this._renderer.getRenderTarget()),
            (Vo = this._renderer.getActiveCubeFace()),
            (jo = this._renderer.getActiveMipmapLevel()),
            (Wo = this._renderer.xr.enabled),
            (this._renderer.xr.enabled = !1),
            this._setSize(256);
          const r = this._allocateTargets();
          return (
            (r.depthBuffer = !0),
            this._sceneToCubeUV(e, n, i, r),
            t > 0 && this._blur(r, 0, 0, t),
            this._applyPMREM(r),
            this._cleanup(r),
            r
          );
        }
        fromEquirectangular(e, t = null) {
          return this._fromTexture(e, t);
        }
        fromCubemap(e, t = null) {
          return this._fromTexture(e, t);
        }
        compileCubemapShader() {
          null === this._cubemapMaterial &&
            ((this._cubemapMaterial = ec()),
            this._compileMaterial(this._cubemapMaterial));
        }
        compileEquirectangularShader() {
          null === this._equirectMaterial &&
            ((this._equirectMaterial = $o()),
            this._compileMaterial(this._equirectMaterial));
        }
        dispose() {
          this._dispose(),
            null !== this._cubemapMaterial && this._cubemapMaterial.dispose(),
            null !== this._equirectMaterial && this._equirectMaterial.dispose();
        }
        _setSize(e) {
          (this._lodMax = Math.floor(Math.log2(e))),
            (this._cubeSize = Math.pow(2, this._lodMax));
        }
        _dispose() {
          null !== this._blurMaterial && this._blurMaterial.dispose(),
            null !== this._pingPongRenderTarget &&
              this._pingPongRenderTarget.dispose();
          for (let e = 0; e < this._lodPlanes.length; e++)
            this._lodPlanes[e].dispose();
        }
        _cleanup(e) {
          this._renderer.setRenderTarget(zo, Vo, jo),
            (this._renderer.xr.enabled = Wo),
            (e.scissorTest = !1),
            Zo(e, 0, 0, e.width, e.height);
        }
        _fromTexture(e, t) {
          e.mapping === wn || e.mapping === Cn
            ? this._setSize(
                0 === e.image.length
                  ? 16
                  : e.image[0].width || e.image[0].image.width
              )
            : this._setSize(e.image.width / 4),
            (zo = this._renderer.getRenderTarget()),
            (Vo = this._renderer.getActiveCubeFace()),
            (jo = this._renderer.getActiveMipmapLevel()),
            (Wo = this._renderer.xr.enabled),
            (this._renderer.xr.enabled = !1);
          const n = t || this._allocateTargets();
          return (
            this._textureToCubeUV(e, n),
            this._applyPMREM(n),
            this._cleanup(n),
            n
          );
        }
        _allocateTargets() {
          const e = 3 * Math.max(this._cubeSize, 112),
            t = 4 * this._cubeSize,
            n = {
              magFilter: Un,
              minFilter: Un,
              generateMipmaps: !1,
              type: jn,
              format: Zn,
              colorSpace: $i,
              depthBuffer: !1,
            },
            i = Jo(e, t, n);
          if (
            null === this._pingPongRenderTarget ||
            this._pingPongRenderTarget.width !== e ||
            this._pingPongRenderTarget.height !== t
          ) {
            null !== this._pingPongRenderTarget && this._dispose(),
              (this._pingPongRenderTarget = Jo(e, t, n));
            const { _lodMax: i } = this;
            ({
              sizeLods: this._sizeLods,
              lodPlanes: this._lodPlanes,
              sigmas: this._sigmas,
            } = (function (e) {
              const t = [],
                n = [],
                i = [];
              let r = e;
              const s = e - 4 + 1 + ko.length;
              for (let a = 0; a < s; a++) {
                const s = Math.pow(2, r);
                n.push(s);
                let o = 1 / s;
                a > e - 4 ? (o = ko[a - e + 4 - 1]) : 0 === a && (o = 0),
                  i.push(o);
                const c = 1 / (s - 2),
                  l = -c,
                  u = 1 + c,
                  h = [l, l, u, l, u, u, l, l, u, u, l, u],
                  d = 6,
                  p = 6,
                  f = 3,
                  A = 2,
                  g = 1,
                  m = new Float32Array(f * p * d),
                  v = new Float32Array(A * p * d),
                  y = new Float32Array(g * p * d);
                for (let e = 0; e < d; e++) {
                  const t = ((e % 3) * 2) / 3 - 1,
                    n = e > 2 ? 0 : -1,
                    i = [
                      t,
                      n,
                      0,
                      t + 2 / 3,
                      n,
                      0,
                      t + 2 / 3,
                      n + 1,
                      0,
                      t,
                      n,
                      0,
                      t + 2 / 3,
                      n + 1,
                      0,
                      t,
                      n + 1,
                      0,
                    ];
                  m.set(i, f * p * e), v.set(h, A * p * e);
                  const r = [e, e, e, e, e, e];
                  y.set(r, g * p * e);
                }
                const b = new Qa();
                b.setAttribute("position", new Ta(m, f)),
                  b.setAttribute("uv", new Ta(v, A)),
                  b.setAttribute("faceIndex", new Ta(y, g)),
                  t.push(b),
                  r > 4 && r--;
              }
              return { lodPlanes: t, sizeLods: n, sigmas: i };
            })(i)),
              (this._blurMaterial = (function (e, t, n) {
                const i = new Float32Array(Qo),
                  r = new Yr(0, 1, 0),
                  s = new so({
                    name: "SphericalGaussianBlur",
                    defines: {
                      n: Qo,
                      CUBEUV_TEXEL_WIDTH: 1 / t,
                      CUBEUV_TEXEL_HEIGHT: 1 / n,
                      CUBEUV_MAX_MIP: `${e}.0`,
                    },
                    uniforms: {
                      envMap: { value: null },
                      samples: { value: 1 },
                      weights: { value: i },
                      latitudinal: { value: !1 },
                      dTheta: { value: 0 },
                      mipInt: { value: 0 },
                      poleAxis: { value: r },
                    },
                    vertexShader: tc(),
                    fragmentShader:
                      "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                    blending: 0,
                    depthTest: !1,
                    depthWrite: !1,
                  });
                return s;
              })(i, e, t));
          }
          return i;
        }
        _compileMaterial(e) {
          const t = new Za(this._lodPlanes[0], e);
          this._renderer.compile(t, Go);
        }
        _sceneToCubeUV(e, t, n, i) {
          const r = new uo(90, 1, t, n),
            s = [1, -1, 1, 1, 1, 1],
            a = [1, 1, 1, -1, -1, -1],
            o = this._renderer,
            c = o.autoClear,
            l = o.toneMapping;
          o.getClearColor(Ho), (o.toneMapping = An), (o.autoClear = !1);
          const u = new _a({
              name: "PMREM.Background",
              side: ln,
              depthWrite: !1,
              depthTest: !1,
            }),
            h = new Za(new eo(), u);
          let d = !1;
          const p = e.background;
          p
            ? p.isColor && (u.color.copy(p), (e.background = null), (d = !0))
            : (u.color.copy(Ho), (d = !0));
          for (let t = 0; t < 6; t++) {
            const n = t % 3;
            0 === n
              ? (r.up.set(0, s[t], 0), r.lookAt(a[t], 0, 0))
              : 1 === n
              ? (r.up.set(0, 0, s[t]), r.lookAt(0, a[t], 0))
              : (r.up.set(0, s[t], 0), r.lookAt(0, 0, a[t]));
            const c = this._cubeSize;
            Zo(i, n * c, t > 2 ? c : 0, c, c),
              o.setRenderTarget(i),
              d && o.render(h, r),
              o.render(e, r);
          }
          h.geometry.dispose(),
            h.material.dispose(),
            (o.toneMapping = l),
            (o.autoClear = c),
            (e.background = p);
        }
        _textureToCubeUV(e, t) {
          const n = this._renderer,
            i = e.mapping === wn || e.mapping === Cn;
          i
            ? (null === this._cubemapMaterial && (this._cubemapMaterial = ec()),
              (this._cubemapMaterial.uniforms.flipEnvMap.value =
                !1 === e.isRenderTargetTexture ? -1 : 1))
            : null === this._equirectMaterial &&
              (this._equirectMaterial = $o());
          const r = i ? this._cubemapMaterial : this._equirectMaterial,
            s = new Za(this._lodPlanes[0], r);
          r.uniforms.envMap.value = e;
          const a = this._cubeSize;
          Zo(t, 0, 0, 3 * a, 2 * a), n.setRenderTarget(t), n.render(s, Go);
        }
        _applyPMREM(e) {
          const t = this._renderer,
            n = t.autoClear;
          t.autoClear = !1;
          const i = this._lodPlanes.length;
          for (let t = 1; t < i; t++) {
            const n = Math.sqrt(
                this._sigmas[t] * this._sigmas[t] -
                  this._sigmas[t - 1] * this._sigmas[t - 1]
              ),
              r = Yo[(i - t - 1) % Yo.length];
            this._blur(e, t - 1, t, n, r);
          }
          t.autoClear = n;
        }
        _blur(e, t, n, i, r) {
          const s = this._pingPongRenderTarget;
          this._halfBlur(e, s, t, n, i, "latitudinal", r),
            this._halfBlur(s, e, n, n, i, "longitudinal", r);
        }
        _halfBlur(e, t, n, i, r, s, a) {
          const o = this._renderer,
            c = this._blurMaterial;
          "latitudinal" !== s &&
            "longitudinal" !== s &&
            console.error(
              "blur direction must be either latitudinal or longitudinal!"
            );
          const l = new Za(this._lodPlanes[i], c),
            u = c.uniforms,
            h = this._sizeLods[n] - 1,
            d = isFinite(r) ? Math.PI / (2 * h) : (2 * Math.PI) / 39,
            p = r / d,
            f = isFinite(r) ? 1 + Math.floor(3 * p) : Qo;
          f > Qo &&
            console.warn(
              `sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`
            );
          const A = [];
          let g = 0;
          for (let e = 0; e < Qo; ++e) {
            const t = e / p,
              n = Math.exp((-t * t) / 2);
            A.push(n), 0 === e ? (g += n) : e < f && (g += 2 * n);
          }
          for (let e = 0; e < A.length; e++) A[e] = A[e] / g;
          (u.envMap.value = e.texture),
            (u.samples.value = f),
            (u.weights.value = A),
            (u.latitudinal.value = "latitudinal" === s),
            a && (u.poleAxis.value = a);
          const { _lodMax: m } = this;
          (u.dTheta.value = d), (u.mipInt.value = m - n);
          const v = this._sizeLods[i];
          Zo(
            t,
            3 * v * (i > m - 4 ? i - m + 4 : 0),
            4 * (this._cubeSize - v),
            3 * v,
            2 * v
          ),
            o.setRenderTarget(t),
            o.render(l, Go);
        }
      }
      function Jo(e, t, n) {
        const i = new jr(e, t, n);
        return (
          (i.texture.mapping = Mn),
          (i.texture.name = "PMREM.cubeUv"),
          (i.scissorTest = !0),
          i
        );
      }
      function Zo(e, t, n, i, r) {
        e.viewport.set(t, n, i, r), e.scissor.set(t, n, i, r);
      }
      function $o() {
        return new so({
          name: "EquirectangularToCubeUV",
          uniforms: { envMap: { value: null } },
          vertexShader: tc(),
          fragmentShader:
            "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
          blending: 0,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function ec() {
        return new so({
          name: "CubemapToCubeUV",
          uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
          vertexShader: tc(),
          fragmentShader:
            "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
          blending: 0,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function tc() {
        return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t";
      }
      function nc(e) {
        let t = new WeakMap(),
          n = null;
        function i(e) {
          const n = e.target;
          n.removeEventListener("dispose", i);
          const r = t.get(n);
          void 0 !== r && (t.delete(n), r.dispose());
        }
        return {
          get: function (r) {
            if (r && r.isTexture) {
              const s = r.mapping,
                a = s === Sn || s === In,
                o = s === wn || s === Cn;
              if (a || o) {
                let s = t.get(r);
                const c = void 0 !== s ? s.texture.pmremVersion : 0;
                if (r.isRenderTargetTexture && r.pmremVersion !== c)
                  return (
                    null === n && (n = new Ko(e)),
                    (s = a ? n.fromEquirectangular(r, s) : n.fromCubemap(r, s)),
                    (s.texture.pmremVersion = r.pmremVersion),
                    t.set(r, s),
                    s.texture
                  );
                if (void 0 !== s) return s.texture;
                {
                  const c = r.image;
                  return (a && c && c.height > 0) ||
                    (o &&
                      c &&
                      (function (e) {
                        let t = 0;
                        const n = 6;
                        for (let i = 0; i < n; i++) void 0 !== e[i] && t++;
                        return t === n;
                      })(c))
                    ? (null === n && (n = new Ko(e)),
                      (s = a ? n.fromEquirectangular(r) : n.fromCubemap(r)),
                      (s.texture.pmremVersion = r.pmremVersion),
                      t.set(r, s),
                      r.addEventListener("dispose", i),
                      s.texture)
                    : null;
                }
              }
            }
            return r;
          },
          dispose: function () {
            (t = new WeakMap()), null !== n && (n.dispose(), (n = null));
          },
        };
      }
      function ic(e) {
        const t = {};
        function n(n) {
          if (void 0 !== t[n]) return t[n];
          let i;
          switch (n) {
            case "WEBGL_depth_texture":
              i =
                e.getExtension("WEBGL_depth_texture") ||
                e.getExtension("MOZ_WEBGL_depth_texture") ||
                e.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
            case "EXT_texture_filter_anisotropic":
              i =
                e.getExtension("EXT_texture_filter_anisotropic") ||
                e.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              i =
                e.getExtension("WEBGL_compressed_texture_s3tc") ||
                e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
                e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              i =
                e.getExtension("WEBGL_compressed_texture_pvrtc") ||
                e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            default:
              i = e.getExtension(n);
          }
          return (t[n] = i), i;
        }
        return {
          has: function (e) {
            return null !== n(e);
          },
          init: function () {
            n("EXT_color_buffer_float"),
              n("WEBGL_clip_cull_distance"),
              n("OES_texture_float_linear"),
              n("EXT_color_buffer_half_float"),
              n("WEBGL_multisampled_render_to_texture"),
              n("WEBGL_render_shared_exponent");
          },
          get: function (e) {
            const t = n(e);
            return (
              null === t &&
                Ir("THREE.WebGLRenderer: " + e + " extension not supported."),
              t
            );
          },
        };
      }
      function rc(e, t, n, i) {
        const r = {},
          s = new WeakMap();
        function a(e) {
          const o = e.target;
          null !== o.index && t.remove(o.index);
          for (const e in o.attributes) t.remove(o.attributes[e]);
          for (const e in o.morphAttributes) {
            const n = o.morphAttributes[e];
            for (let e = 0, i = n.length; e < i; e++) t.remove(n[e]);
          }
          o.removeEventListener("dispose", a), delete r[o.id];
          const c = s.get(o);
          c && (t.remove(c), s.delete(o)),
            i.releaseStatesOfGeometry(o),
            !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount,
            n.memory.geometries--;
        }
        function o(e) {
          const n = [],
            i = e.index,
            r = e.attributes.position;
          let a = 0;
          if (null !== i) {
            const e = i.array;
            a = i.version;
            for (let t = 0, i = e.length; t < i; t += 3) {
              const i = e[t + 0],
                r = e[t + 1],
                s = e[t + 2];
              n.push(i, r, r, s, s, i);
            }
          } else {
            if (void 0 === r) return;
            {
              const e = r.array;
              a = r.version;
              for (let t = 0, i = e.length / 3 - 1; t < i; t += 3) {
                const e = t + 0,
                  i = t + 1,
                  r = t + 2;
                n.push(e, i, i, r, r, e);
              }
            }
          }
          const o = new (Er(n) ? Ra : Ba)(n, 1);
          o.version = a;
          const c = s.get(e);
          c && t.remove(c), s.set(e, o);
        }
        return {
          get: function (e, t) {
            return (
              !0 === r[t.id] ||
                (t.addEventListener("dispose", a),
                (r[t.id] = !0),
                n.memory.geometries++),
              t
            );
          },
          update: function (n) {
            const i = n.attributes;
            for (const n in i) t.update(i[n], e.ARRAY_BUFFER);
            const r = n.morphAttributes;
            for (const n in r) {
              const i = r[n];
              for (let n = 0, r = i.length; n < r; n++)
                t.update(i[n], e.ARRAY_BUFFER);
            }
          },
          getWireframeAttribute: function (e) {
            const t = s.get(e);
            if (t) {
              const n = e.index;
              null !== n && t.version < n.version && o(e);
            } else o(e);
            return s.get(e);
          },
        };
      }
      function sc(e, t, n) {
        let i, r, s;
        function a(t, a, o) {
          0 !== o &&
            (e.drawElementsInstanced(i, a, r, t * s, o), n.update(a, i, o));
        }
        (this.setMode = function (e) {
          i = e;
        }),
          (this.setIndex = function (e) {
            (r = e.type), (s = e.bytesPerElement);
          }),
          (this.render = function (t, a) {
            e.drawElements(i, a, r, t * s), n.update(a, i, 1);
          }),
          (this.renderInstances = a),
          (this.renderMultiDraw = function (e, s, a) {
            if (0 === a) return;
            t.get("WEBGL_multi_draw").multiDrawElementsWEBGL(
              i,
              s,
              0,
              r,
              e,
              0,
              a
            );
            let o = 0;
            for (let e = 0; e < a; e++) o += s[e];
            n.update(o, i, 1);
          }),
          (this.renderMultiDrawInstances = function (e, o, c, l) {
            if (0 === c) return;
            const u = t.get("WEBGL_multi_draw");
            if (null === u)
              for (let t = 0; t < e.length; t++) a(e[t] / s, o[t], l[t]);
            else {
              u.multiDrawElementsInstancedWEBGL(i, o, 0, r, e, 0, l, 0, c);
              let t = 0;
              for (let e = 0; e < c; e++) t += o[e] * l[e];
              n.update(t, i, 1);
            }
          });
      }
      function ac(e) {
        const t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
        return {
          memory: { geometries: 0, textures: 0 },
          render: t,
          programs: null,
          autoReset: !0,
          reset: function () {
            (t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0);
          },
          update: function (n, i, r) {
            switch ((t.calls++, i)) {
              case e.TRIANGLES:
                t.triangles += r * (n / 3);
                break;
              case e.LINES:
                t.lines += r * (n / 2);
                break;
              case e.LINE_STRIP:
                t.lines += r * (n - 1);
                break;
              case e.LINE_LOOP:
                t.lines += r * n;
                break;
              case e.POINTS:
                t.points += r * n;
                break;
              default:
                console.error("THREE.WebGLInfo: Unknown draw mode:", i);
            }
          },
        };
      }
      function oc(e, t, n) {
        const i = new WeakMap(),
          r = new zr();
        return {
          update: function (s, a, o) {
            const c = s.morphTargetInfluences,
              l =
                a.morphAttributes.position ||
                a.morphAttributes.normal ||
                a.morphAttributes.color,
              u = void 0 !== l ? l.length : 0;
            let h = i.get(a);
            if (void 0 === h || h.count !== u) {
              void 0 !== h && h.texture.dispose();
              const d = void 0 !== a.morphAttributes.position,
                p = void 0 !== a.morphAttributes.normal,
                f = void 0 !== a.morphAttributes.color,
                A = a.morphAttributes.position || [],
                g = a.morphAttributes.normal || [],
                m = a.morphAttributes.color || [];
              let v = 0;
              !0 === d && (v = 1), !0 === p && (v = 2), !0 === f && (v = 3);
              let y = a.attributes.position.count * v,
                b = 1;
              y > t.maxTextureSize &&
                ((b = Math.ceil(y / t.maxTextureSize)), (y = t.maxTextureSize));
              const _ = new Float32Array(y * b * 4 * u),
                x = new Wr(_, y, b, u);
              (x.type = Vn), (x.needsUpdate = !0);
              const E = 4 * v;
              for (let C = 0; C < u; C++) {
                const S = A[C],
                  I = g[C],
                  M = m[C],
                  T = y * b * 4 * C;
                for (let B = 0; B < S.count; B++) {
                  const R = B * E;
                  !0 === d &&
                    (r.fromBufferAttribute(S, B),
                    (_[T + R + 0] = r.x),
                    (_[T + R + 1] = r.y),
                    (_[T + R + 2] = r.z),
                    (_[T + R + 3] = 0)),
                    !0 === p &&
                      (r.fromBufferAttribute(I, B),
                      (_[T + R + 4] = r.x),
                      (_[T + R + 5] = r.y),
                      (_[T + R + 6] = r.z),
                      (_[T + R + 7] = 0)),
                    !0 === f &&
                      (r.fromBufferAttribute(M, B),
                      (_[T + R + 8] = r.x),
                      (_[T + R + 9] = r.y),
                      (_[T + R + 10] = r.z),
                      (_[T + R + 11] = 4 === M.itemSize ? r.w : 1));
                }
              }
              function w() {
                x.dispose(), i.delete(a), a.removeEventListener("dispose", w);
              }
              (h = { count: u, texture: x, size: new br(y, b) }),
                i.set(a, h),
                a.addEventListener("dispose", w);
            }
            if (!0 === s.isInstancedMesh && null !== s.morphTexture)
              o.getUniforms().setValue(e, "morphTexture", s.morphTexture, n);
            else {
              let D = 0;
              for (let L = 0; L < c.length; L++) D += c[L];
              const P = a.morphTargetsRelative ? 1 : 1 - D;
              o.getUniforms().setValue(e, "morphTargetBaseInfluence", P),
                o.getUniforms().setValue(e, "morphTargetInfluences", c);
            }
            o.getUniforms().setValue(e, "morphTargetsTexture", h.texture, n),
              o.getUniforms().setValue(e, "morphTargetsTextureSize", h.size);
          },
        };
      }
      function cc(e, t, n, i) {
        let r = new WeakMap();
        function s(e) {
          const t = e.target;
          t.removeEventListener("dispose", s),
            n.remove(t.instanceMatrix),
            null !== t.instanceColor && n.remove(t.instanceColor);
        }
        return {
          update: function (a) {
            const o = i.render.frame,
              c = a.geometry,
              l = t.get(a, c);
            if (
              (r.get(l) !== o && (t.update(l), r.set(l, o)),
              a.isInstancedMesh &&
                (!1 === a.hasEventListener("dispose", s) &&
                  a.addEventListener("dispose", s),
                r.get(a) !== o &&
                  (n.update(a.instanceMatrix, e.ARRAY_BUFFER),
                  null !== a.instanceColor &&
                    n.update(a.instanceColor, e.ARRAY_BUFFER),
                  r.set(a, o))),
              a.isSkinnedMesh)
            ) {
              const e = a.skeleton;
              r.get(e) !== o && (e.update(), r.set(e, o));
            }
            return l;
          },
          dispose: function () {
            r = new WeakMap();
          },
        };
      }
      class lc extends Hr {
        constructor(e, t, n, i, r, s, a, o, c, l = 1026) {
          if (l !== ti && l !== ni)
            throw new Error(
              "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
            );
          void 0 === n && l === ti && (n = zn),
            void 0 === n && l === ni && (n = qn),
            super(null, i, r, s, a, o, l, n, c),
            (this.isDepthTexture = !0),
            (this.image = { width: e, height: t }),
            (this.magFilter = void 0 !== a ? a : Dn),
            (this.minFilter = void 0 !== o ? o : Dn),
            (this.flipY = !1),
            (this.generateMipmaps = !1),
            (this.compareFunction = null);
        }
        copy(e) {
          return (
            super.copy(e), (this.compareFunction = e.compareFunction), this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            null !== this.compareFunction &&
              (t.compareFunction = this.compareFunction),
            t
          );
        }
      }
      const uc = new Hr(),
        hc = new lc(1, 1),
        dc = new Wr(),
        pc = new Xr(),
        fc = new fo(),
        Ac = [],
        gc = [],
        mc = new Float32Array(16),
        vc = new Float32Array(9),
        yc = new Float32Array(4);
      function bc(e, t, n) {
        const i = e[0];
        if (i <= 0 || i > 0) return e;
        const r = t * n;
        let s = Ac[r];
        if (
          (void 0 === s && ((s = new Float32Array(r)), (Ac[r] = s)), 0 !== t)
        ) {
          i.toArray(s, 0);
          for (let i = 1, r = 0; i !== t; ++i) (r += n), e[i].toArray(s, r);
        }
        return s;
      }
      function _c(e, t) {
        if (e.length !== t.length) return !1;
        for (let n = 0, i = e.length; n < i; n++) if (e[n] !== t[n]) return !1;
        return !0;
      }
      function xc(e, t) {
        for (let n = 0, i = t.length; n < i; n++) e[n] = t[n];
      }
      function Ec(e, t) {
        let n = gc[t];
        void 0 === n && ((n = new Int32Array(t)), (gc[t] = n));
        for (let i = 0; i !== t; ++i) n[i] = e.allocateTextureUnit();
        return n;
      }
      function wc(e, t) {
        const n = this.cache;
        n[0] !== t && (e.uniform1f(this.addr, t), (n[0] = t));
      }
      function Cc(e, t) {
        const n = this.cache;
        if (void 0 !== t.x)
          (n[0] === t.x && n[1] === t.y) ||
            (e.uniform2f(this.addr, t.x, t.y), (n[0] = t.x), (n[1] = t.y));
        else {
          if (_c(n, t)) return;
          e.uniform2fv(this.addr, t), xc(n, t);
        }
      }
      function Sc(e, t) {
        const n = this.cache;
        if (void 0 !== t.x)
          (n[0] === t.x && n[1] === t.y && n[2] === t.z) ||
            (e.uniform3f(this.addr, t.x, t.y, t.z),
            (n[0] = t.x),
            (n[1] = t.y),
            (n[2] = t.z));
        else if (void 0 !== t.r)
          (n[0] === t.r && n[1] === t.g && n[2] === t.b) ||
            (e.uniform3f(this.addr, t.r, t.g, t.b),
            (n[0] = t.r),
            (n[1] = t.g),
            (n[2] = t.b));
        else {
          if (_c(n, t)) return;
          e.uniform3fv(this.addr, t), xc(n, t);
        }
      }
      function Ic(e, t) {
        const n = this.cache;
        if (void 0 !== t.x)
          (n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w) ||
            (e.uniform4f(this.addr, t.x, t.y, t.z, t.w),
            (n[0] = t.x),
            (n[1] = t.y),
            (n[2] = t.z),
            (n[3] = t.w));
        else {
          if (_c(n, t)) return;
          e.uniform4fv(this.addr, t), xc(n, t);
        }
      }
      function Mc(e, t) {
        const n = this.cache,
          i = t.elements;
        if (void 0 === i) {
          if (_c(n, t)) return;
          e.uniformMatrix2fv(this.addr, !1, t), xc(n, t);
        } else {
          if (_c(n, i)) return;
          yc.set(i), e.uniformMatrix2fv(this.addr, !1, yc), xc(n, i);
        }
      }
      function Tc(e, t) {
        const n = this.cache,
          i = t.elements;
        if (void 0 === i) {
          if (_c(n, t)) return;
          e.uniformMatrix3fv(this.addr, !1, t), xc(n, t);
        } else {
          if (_c(n, i)) return;
          vc.set(i), e.uniformMatrix3fv(this.addr, !1, vc), xc(n, i);
        }
      }
      function Bc(e, t) {
        const n = this.cache,
          i = t.elements;
        if (void 0 === i) {
          if (_c(n, t)) return;
          e.uniformMatrix4fv(this.addr, !1, t), xc(n, t);
        } else {
          if (_c(n, i)) return;
          mc.set(i), e.uniformMatrix4fv(this.addr, !1, mc), xc(n, i);
        }
      }
      function Rc(e, t) {
        const n = this.cache;
        n[0] !== t && (e.uniform1i(this.addr, t), (n[0] = t));
      }
      function Dc(e, t) {
        const n = this.cache;
        if (void 0 !== t.x)
          (n[0] === t.x && n[1] === t.y) ||
            (e.uniform2i(this.addr, t.x, t.y), (n[0] = t.x), (n[1] = t.y));
        else {
          if (_c(n, t)) return;
          e.uniform2iv(this.addr, t), xc(n, t);
        }
      }
      function Pc(e, t) {
        const n = this.cache;
        if (void 0 !== t.x)
          (n[0] === t.x && n[1] === t.y && n[2] === t.z) ||
            (e.uniform3i(this.addr, t.x, t.y, t.z),
            (n[0] = t.x),
            (n[1] = t.y),
            (n[2] = t.z));
        else {
          if (_c(n, t)) return;
          e.uniform3iv(this.addr, t), xc(n, t);
        }
      }
      function Lc(e, t) {
        const n = this.cache;
        if (void 0 !== t.x)
          (n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w) ||
            (e.uniform4i(this.addr, t.x, t.y, t.z, t.w),
            (n[0] = t.x),
            (n[1] = t.y),
            (n[2] = t.z),
            (n[3] = t.w));
        else {
          if (_c(n, t)) return;
          e.uniform4iv(this.addr, t), xc(n, t);
        }
      }
      function Uc(e, t) {
        const n = this.cache;
        n[0] !== t && (e.uniform1ui(this.addr, t), (n[0] = t));
      }
      function Fc(e, t) {
        const n = this.cache;
        if (void 0 !== t.x)
          (n[0] === t.x && n[1] === t.y) ||
            (e.uniform2ui(this.addr, t.x, t.y), (n[0] = t.x), (n[1] = t.y));
        else {
          if (_c(n, t)) return;
          e.uniform2uiv(this.addr, t), xc(n, t);
        }
      }
      function Oc(e, t) {
        const n = this.cache;
        if (void 0 !== t.x)
          (n[0] === t.x && n[1] === t.y && n[2] === t.z) ||
            (e.uniform3ui(this.addr, t.x, t.y, t.z),
            (n[0] = t.x),
            (n[1] = t.y),
            (n[2] = t.z));
        else {
          if (_c(n, t)) return;
          e.uniform3uiv(this.addr, t), xc(n, t);
        }
      }
      function Nc(e, t) {
        const n = this.cache;
        if (void 0 !== t.x)
          (n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w) ||
            (e.uniform4ui(this.addr, t.x, t.y, t.z, t.w),
            (n[0] = t.x),
            (n[1] = t.y),
            (n[2] = t.z),
            (n[3] = t.w));
        else {
          if (_c(n, t)) return;
          e.uniform4uiv(this.addr, t), xc(n, t);
        }
      }
      function kc(e, t, n) {
        const i = this.cache,
          r = n.allocateTextureUnit();
        let s;
        i[0] !== r && (e.uniform1i(this.addr, r), (i[0] = r)),
          this.type === e.SAMPLER_2D_SHADOW
            ? ((hc.compareFunction = ir), (s = hc))
            : (s = uc),
          n.setTexture2D(t || s, r);
      }
      function Qc(e, t, n) {
        const i = this.cache,
          r = n.allocateTextureUnit();
        i[0] !== r && (e.uniform1i(this.addr, r), (i[0] = r)),
          n.setTexture3D(t || pc, r);
      }
      function Gc(e, t, n) {
        const i = this.cache,
          r = n.allocateTextureUnit();
        i[0] !== r && (e.uniform1i(this.addr, r), (i[0] = r)),
          n.setTextureCube(t || fc, r);
      }
      function Hc(e, t, n) {
        const i = this.cache,
          r = n.allocateTextureUnit();
        i[0] !== r && (e.uniform1i(this.addr, r), (i[0] = r)),
          n.setTexture2DArray(t || dc, r);
      }
      function zc(e, t) {
        e.uniform1fv(this.addr, t);
      }
      function Vc(e, t) {
        const n = bc(t, this.size, 2);
        e.uniform2fv(this.addr, n);
      }
      function jc(e, t) {
        const n = bc(t, this.size, 3);
        e.uniform3fv(this.addr, n);
      }
      function Wc(e, t) {
        const n = bc(t, this.size, 4);
        e.uniform4fv(this.addr, n);
      }
      function Xc(e, t) {
        const n = bc(t, this.size, 4);
        e.uniformMatrix2fv(this.addr, !1, n);
      }
      function qc(e, t) {
        const n = bc(t, this.size, 9);
        e.uniformMatrix3fv(this.addr, !1, n);
      }
      function Yc(e, t) {
        const n = bc(t, this.size, 16);
        e.uniformMatrix4fv(this.addr, !1, n);
      }
      function Kc(e, t) {
        e.uniform1iv(this.addr, t);
      }
      function Jc(e, t) {
        e.uniform2iv(this.addr, t);
      }
      function Zc(e, t) {
        e.uniform3iv(this.addr, t);
      }
      function $c(e, t) {
        e.uniform4iv(this.addr, t);
      }
      function el(e, t) {
        e.uniform1uiv(this.addr, t);
      }
      function tl(e, t) {
        e.uniform2uiv(this.addr, t);
      }
      function nl(e, t) {
        e.uniform3uiv(this.addr, t);
      }
      function il(e, t) {
        e.uniform4uiv(this.addr, t);
      }
      function rl(e, t, n) {
        const i = this.cache,
          r = t.length,
          s = Ec(n, r);
        _c(i, s) || (e.uniform1iv(this.addr, s), xc(i, s));
        for (let e = 0; e !== r; ++e) n.setTexture2D(t[e] || uc, s[e]);
      }
      function sl(e, t, n) {
        const i = this.cache,
          r = t.length,
          s = Ec(n, r);
        _c(i, s) || (e.uniform1iv(this.addr, s), xc(i, s));
        for (let e = 0; e !== r; ++e) n.setTexture3D(t[e] || pc, s[e]);
      }
      function al(e, t, n) {
        const i = this.cache,
          r = t.length,
          s = Ec(n, r);
        _c(i, s) || (e.uniform1iv(this.addr, s), xc(i, s));
        for (let e = 0; e !== r; ++e) n.setTextureCube(t[e] || fc, s[e]);
      }
      function ol(e, t, n) {
        const i = this.cache,
          r = t.length,
          s = Ec(n, r);
        _c(i, s) || (e.uniform1iv(this.addr, s), xc(i, s));
        for (let e = 0; e !== r; ++e) n.setTexture2DArray(t[e] || dc, s[e]);
      }
      class cl {
        constructor(e, t, n) {
          (this.id = e),
            (this.addr = n),
            (this.cache = []),
            (this.type = t.type),
            (this.setValue = (function (e) {
              switch (e) {
                case 5126:
                  return wc;
                case 35664:
                  return Cc;
                case 35665:
                  return Sc;
                case 35666:
                  return Ic;
                case 35674:
                  return Mc;
                case 35675:
                  return Tc;
                case 35676:
                  return Bc;
                case 5124:
                case 35670:
                  return Rc;
                case 35667:
                case 35671:
                  return Dc;
                case 35668:
                case 35672:
                  return Pc;
                case 35669:
                case 35673:
                  return Lc;
                case 5125:
                  return Uc;
                case 36294:
                  return Fc;
                case 36295:
                  return Oc;
                case 36296:
                  return Nc;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                  return kc;
                case 35679:
                case 36299:
                case 36307:
                  return Qc;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                  return Gc;
                case 36289:
                case 36303:
                case 36311:
                case 36292:
                  return Hc;
              }
            })(t.type));
        }
      }
      class ll {
        constructor(e, t, n) {
          (this.id = e),
            (this.addr = n),
            (this.cache = []),
            (this.type = t.type),
            (this.size = t.size),
            (this.setValue = (function (e) {
              switch (e) {
                case 5126:
                  return zc;
                case 35664:
                  return Vc;
                case 35665:
                  return jc;
                case 35666:
                  return Wc;
                case 35674:
                  return Xc;
                case 35675:
                  return qc;
                case 35676:
                  return Yc;
                case 5124:
                case 35670:
                  return Kc;
                case 35667:
                case 35671:
                  return Jc;
                case 35668:
                case 35672:
                  return Zc;
                case 35669:
                case 35673:
                  return $c;
                case 5125:
                  return el;
                case 36294:
                  return tl;
                case 36295:
                  return nl;
                case 36296:
                  return il;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                  return rl;
                case 35679:
                case 36299:
                case 36307:
                  return sl;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                  return al;
                case 36289:
                case 36303:
                case 36311:
                case 36292:
                  return ol;
              }
            })(t.type));
        }
      }
      class ul {
        constructor(e) {
          (this.id = e), (this.seq = []), (this.map = {});
        }
        setValue(e, t, n) {
          const i = this.seq;
          for (let r = 0, s = i.length; r !== s; ++r) {
            const s = i[r];
            s.setValue(e, t[s.id], n);
          }
        }
      }
      const hl = /(\w+)(\])?(\[|\.)?/g;
      function dl(e, t) {
        e.seq.push(t), (e.map[t.id] = t);
      }
      function pl(e, t, n) {
        const i = e.name,
          r = i.length;
        for (hl.lastIndex = 0; ; ) {
          const s = hl.exec(i),
            a = hl.lastIndex;
          let o = s[1];
          const c = "]" === s[2],
            l = s[3];
          if ((c && (o |= 0), void 0 === l || ("[" === l && a + 2 === r))) {
            dl(n, void 0 === l ? new cl(o, e, t) : new ll(o, e, t));
            break;
          }
          {
            let e = n.map[o];
            void 0 === e && ((e = new ul(o)), dl(n, e)), (n = e);
          }
        }
      }
      class fl {
        constructor(e, t) {
          (this.seq = []), (this.map = {});
          const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
          for (let i = 0; i < n; ++i) {
            const n = e.getActiveUniform(t, i);
            pl(n, e.getUniformLocation(t, n.name), this);
          }
        }
        setValue(e, t, n, i) {
          const r = this.map[t];
          void 0 !== r && r.setValue(e, n, i);
        }
        setOptional(e, t, n) {
          const i = t[n];
          void 0 !== i && this.setValue(e, n, i);
        }
        static upload(e, t, n, i) {
          for (let r = 0, s = t.length; r !== s; ++r) {
            const s = t[r],
              a = n[s.id];
            !1 !== a.needsUpdate && s.setValue(e, a.value, i);
          }
        }
        static seqWithValue(e, t) {
          const n = [];
          for (let i = 0, r = e.length; i !== r; ++i) {
            const r = e[i];
            r.id in t && n.push(r);
          }
          return n;
        }
      }
      function Al(e, t, n) {
        const i = e.createShader(t);
        return e.shaderSource(i, n), e.compileShader(i), i;
      }
      const gl = 37297;
      let ml = 0;
      const vl = new _r();
      function yl(e, t, n) {
        const i = e.getShaderParameter(t, e.COMPILE_STATUS),
          r = e.getShaderInfoLog(t).trim();
        if (i && "" === r) return "";
        const s = /ERROR: 0:(\d+)/.exec(r);
        if (s) {
          const i = parseInt(s[1]);
          return (
            n.toUpperCase() +
            "\n\n" +
            r +
            "\n\n" +
            (function (e, t) {
              const n = e.split("\n"),
                i = [],
                r = Math.max(t - 6, 0),
                s = Math.min(t + 6, n.length);
              for (let e = r; e < s; e++) {
                const r = e + 1;
                i.push(`${r === t ? ">" : " "} ${r}: ${n[e]}`);
              }
              return i.join("\n");
            })(e.getShaderSource(t), i)
          );
        }
        return r;
      }
      function bl(e, t) {
        const n = (function (e) {
          Mr._getMatrix(vl, Mr.workingColorSpace, e);
          const t = `mat3( ${vl.elements.map((e) => e.toFixed(4))} )`;
          switch (Mr.getTransfer(e)) {
            case er:
              return [t, "LinearTransferOETF"];
            case tr:
              return [t, "sRGBTransferOETF"];
            default:
              return (
                console.warn(
                  "THREE.WebGLProgram: Unsupported color space: ",
                  e
                ),
                [t, "LinearTransferOETF"]
              );
          }
        })(t);
        return [
          `vec4 ${e}( vec4 value ) {`,
          `\treturn ${n[1]}( vec4( value.rgb * ${n[0]}, value.a ) );`,
          "}",
        ].join("\n");
      }
      function _l(e, t) {
        let n;
        switch (t) {
          case gn:
            n = "Linear";
            break;
          case mn:
            n = "Reinhard";
            break;
          case vn:
            n = "Cineon";
            break;
          case yn:
            n = "ACESFilmic";
            break;
          case _n:
            n = "AgX";
            break;
          case xn:
            n = "Neutral";
            break;
          case bn:
            n = "Custom";
            break;
          default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t),
              (n = "Linear");
        }
        return (
          "vec3 " +
          e +
          "( vec3 color ) { return " +
          n +
          "ToneMapping( color ); }"
        );
      }
      const xl = new Yr();
      function El() {
        Mr.getLuminanceCoefficients(xl);
        return [
          "float luminance( const in vec3 rgb ) {",
          `\tconst vec3 weights = vec3( ${xl.x.toFixed(4)}, ${xl.y.toFixed(
            4
          )}, ${xl.z.toFixed(4)} );`,
          "\treturn dot( weights, rgb );",
          "}",
        ].join("\n");
      }
      function wl(e) {
        return "" !== e;
      }
      function Cl(e, t) {
        const n =
          t.numSpotLightShadows +
          t.numSpotLightMaps -
          t.numSpotLightShadowsWithMaps;
        return e
          .replace(/NUM_DIR_LIGHTS/g, t.numDirLights)
          .replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights)
          .replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps)
          .replace(/NUM_SPOT_LIGHT_COORDS/g, n)
          .replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights)
          .replace(/NUM_POINT_LIGHTS/g, t.numPointLights)
          .replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights)
          .replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows)
          .replace(
            /NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,
            t.numSpotLightShadowsWithMaps
          )
          .replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows)
          .replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows);
      }
      function Sl(e, t) {
        return e
          .replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes)
          .replace(
            /UNION_CLIPPING_PLANES/g,
            t.numClippingPlanes - t.numClipIntersection
          );
      }
      const Il = /^[ \t]*#include +<([\w\d./]+)>/gm;
      function Ml(e) {
        return e.replace(Il, Bl);
      }
      const Tl = new Map();
      function Bl(e, t) {
        let n = So[t];
        if (void 0 === n) {
          const e = Tl.get(t);
          if (void 0 === e)
            throw new Error("Can not resolve #include <" + t + ">");
          (n = So[e]),
            console.warn(
              'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
              t,
              e
            );
        }
        return Ml(n);
      }
      const Rl =
        /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
      function Dl(e) {
        return e.replace(Rl, Pl);
      }
      function Pl(e, t, n, i) {
        let r = "";
        for (let e = parseInt(t); e < parseInt(n); e++)
          r += i
            .replace(/\[\s*i\s*\]/g, "[ " + e + " ]")
            .replace(/UNROLLED_LOOP_INDEX/g, e);
        return r;
      }
      function Ll(e) {
        let t = `precision ${e.precision} float;\n\tprecision ${e.precision} int;\n\tprecision ${e.precision} sampler2D;\n\tprecision ${e.precision} samplerCube;\n\tprecision ${e.precision} sampler3D;\n\tprecision ${e.precision} sampler2DArray;\n\tprecision ${e.precision} sampler2DShadow;\n\tprecision ${e.precision} samplerCubeShadow;\n\tprecision ${e.precision} sampler2DArrayShadow;\n\tprecision ${e.precision} isampler2D;\n\tprecision ${e.precision} isampler3D;\n\tprecision ${e.precision} isamplerCube;\n\tprecision ${e.precision} isampler2DArray;\n\tprecision ${e.precision} usampler2D;\n\tprecision ${e.precision} usampler3D;\n\tprecision ${e.precision} usamplerCube;\n\tprecision ${e.precision} usampler2DArray;\n\t`;
        return (
          "highp" === e.precision
            ? (t += "\n#define HIGH_PRECISION")
            : "mediump" === e.precision
            ? (t += "\n#define MEDIUM_PRECISION")
            : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"),
          t
        );
      }
      function Ul(e, t, n, i) {
        const r = e.getContext(),
          s = n.defines;
        let a = n.vertexShader,
          o = n.fragmentShader;
        const c = (function (e) {
            let t = "SHADOWMAP_TYPE_BASIC";
            return (
              e.shadowMapType === sn
                ? (t = "SHADOWMAP_TYPE_PCF")
                : e.shadowMapType === an
                ? (t = "SHADOWMAP_TYPE_PCF_SOFT")
                : e.shadowMapType === on && (t = "SHADOWMAP_TYPE_VSM"),
              t
            );
          })(n),
          l = (function (e) {
            let t = "ENVMAP_TYPE_CUBE";
            if (e.envMap)
              switch (e.envMapMode) {
                case wn:
                case Cn:
                  t = "ENVMAP_TYPE_CUBE";
                  break;
                case Mn:
                  t = "ENVMAP_TYPE_CUBE_UV";
              }
            return t;
          })(n),
          u = (function (e) {
            let t = "ENVMAP_MODE_REFLECTION";
            e.envMap && e.envMapMode === Cn && (t = "ENVMAP_MODE_REFRACTION");
            return t;
          })(n),
          h = (function (e) {
            let t = "ENVMAP_BLENDING_NONE";
            if (e.envMap)
              switch (e.combine) {
                case dn:
                  t = "ENVMAP_BLENDING_MULTIPLY";
                  break;
                case pn:
                  t = "ENVMAP_BLENDING_MIX";
                  break;
                case fn:
                  t = "ENVMAP_BLENDING_ADD";
              }
            return t;
          })(n),
          d = (function (e) {
            const t = e.envMapCubeUVHeight;
            if (null === t) return null;
            const n = Math.log2(t) - 2,
              i = 1 / t;
            return {
              texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
              texelHeight: i,
              maxMip: n,
            };
          })(n),
          p = (function (e) {
            return [
              e.extensionClipCullDistance
                ? "#extension GL_ANGLE_clip_cull_distance : require"
                : "",
              e.extensionMultiDraw
                ? "#extension GL_ANGLE_multi_draw : require"
                : "",
            ]
              .filter(wl)
              .join("\n");
          })(n),
          f = (function (e) {
            const t = [];
            for (const n in e) {
              const i = e[n];
              !1 !== i && t.push("#define " + n + " " + i);
            }
            return t.join("\n");
          })(s),
          A = r.createProgram();
        let g,
          m,
          v = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
        n.isRawShaderMaterial
          ? ((g = [
              "#define SHADER_TYPE " + n.shaderType,
              "#define SHADER_NAME " + n.shaderName,
              f,
            ]
              .filter(wl)
              .join("\n")),
            g.length > 0 && (g += "\n"),
            (m = [
              "#define SHADER_TYPE " + n.shaderType,
              "#define SHADER_NAME " + n.shaderName,
              f,
            ]
              .filter(wl)
              .join("\n")),
            m.length > 0 && (m += "\n"))
          : ((g = [
              Ll(n),
              "#define SHADER_TYPE " + n.shaderType,
              "#define SHADER_NAME " + n.shaderName,
              f,
              n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
              n.batching ? "#define USE_BATCHING" : "",
              n.batchingColor ? "#define USE_BATCHING_COLOR" : "",
              n.instancing ? "#define USE_INSTANCING" : "",
              n.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
              n.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
              n.useFog && n.fog ? "#define USE_FOG" : "",
              n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
              n.map ? "#define USE_MAP" : "",
              n.envMap ? "#define USE_ENVMAP" : "",
              n.envMap ? "#define " + u : "",
              n.lightMap ? "#define USE_LIGHTMAP" : "",
              n.aoMap ? "#define USE_AOMAP" : "",
              n.bumpMap ? "#define USE_BUMPMAP" : "",
              n.normalMap ? "#define USE_NORMALMAP" : "",
              n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
              n.normalMapTangentSpace
                ? "#define USE_NORMALMAP_TANGENTSPACE"
                : "",
              n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
              n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              n.anisotropy ? "#define USE_ANISOTROPY" : "",
              n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
              n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              n.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
              n.iridescenceThicknessMap
                ? "#define USE_IRIDESCENCE_THICKNESSMAP"
                : "",
              n.specularMap ? "#define USE_SPECULARMAP" : "",
              n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
              n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
              n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              n.metalnessMap ? "#define USE_METALNESSMAP" : "",
              n.alphaMap ? "#define USE_ALPHAMAP" : "",
              n.alphaHash ? "#define USE_ALPHAHASH" : "",
              n.transmission ? "#define USE_TRANSMISSION" : "",
              n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
              n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
              n.mapUv ? "#define MAP_UV " + n.mapUv : "",
              n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "",
              n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "",
              n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "",
              n.emissiveMapUv
                ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv
                : "",
              n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "",
              n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "",
              n.displacementMapUv
                ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv
                : "",
              n.metalnessMapUv
                ? "#define METALNESSMAP_UV " + n.metalnessMapUv
                : "",
              n.roughnessMapUv
                ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv
                : "",
              n.anisotropyMapUv
                ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv
                : "",
              n.clearcoatMapUv
                ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv
                : "",
              n.clearcoatNormalMapUv
                ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv
                : "",
              n.clearcoatRoughnessMapUv
                ? "#define CLEARCOAT_ROUGHNESSMAP_UV " +
                  n.clearcoatRoughnessMapUv
                : "",
              n.iridescenceMapUv
                ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv
                : "",
              n.iridescenceThicknessMapUv
                ? "#define IRIDESCENCE_THICKNESSMAP_UV " +
                  n.iridescenceThicknessMapUv
                : "",
              n.sheenColorMapUv
                ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv
                : "",
              n.sheenRoughnessMapUv
                ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv
                : "",
              n.specularMapUv
                ? "#define SPECULARMAP_UV " + n.specularMapUv
                : "",
              n.specularColorMapUv
                ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv
                : "",
              n.specularIntensityMapUv
                ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv
                : "",
              n.transmissionMapUv
                ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv
                : "",
              n.thicknessMapUv
                ? "#define THICKNESSMAP_UV " + n.thicknessMapUv
                : "",
              n.vertexTangents && !1 === n.flatShading
                ? "#define USE_TANGENT"
                : "",
              n.vertexColors ? "#define USE_COLOR" : "",
              n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              n.vertexUv1s ? "#define USE_UV1" : "",
              n.vertexUv2s ? "#define USE_UV2" : "",
              n.vertexUv3s ? "#define USE_UV3" : "",
              n.pointsUvs ? "#define USE_POINTS_UV" : "",
              n.flatShading ? "#define FLAT_SHADED" : "",
              n.skinning ? "#define USE_SKINNING" : "",
              n.morphTargets ? "#define USE_MORPHTARGETS" : "",
              n.morphNormals && !1 === n.flatShading
                ? "#define USE_MORPHNORMALS"
                : "",
              n.morphColors ? "#define USE_MORPHCOLORS" : "",
              n.morphTargetsCount > 0
                ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride
                : "",
              n.morphTargetsCount > 0
                ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount
                : "",
              n.doubleSided ? "#define DOUBLE_SIDED" : "",
              n.flipSided ? "#define FLIP_SIDED" : "",
              n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              n.shadowMapEnabled ? "#define " + c : "",
              n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
              n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
              n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              n.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
              "uniform mat4 modelMatrix;",
              "uniform mat4 modelViewMatrix;",
              "uniform mat4 projectionMatrix;",
              "uniform mat4 viewMatrix;",
              "uniform mat3 normalMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              "#ifdef USE_INSTANCING",
              "\tattribute mat4 instanceMatrix;",
              "#endif",
              "#ifdef USE_INSTANCING_COLOR",
              "\tattribute vec3 instanceColor;",
              "#endif",
              "#ifdef USE_INSTANCING_MORPH",
              "\tuniform sampler2D morphTexture;",
              "#endif",
              "attribute vec3 position;",
              "attribute vec3 normal;",
              "attribute vec2 uv;",
              "#ifdef USE_UV1",
              "\tattribute vec2 uv1;",
              "#endif",
              "#ifdef USE_UV2",
              "\tattribute vec2 uv2;",
              "#endif",
              "#ifdef USE_UV3",
              "\tattribute vec2 uv3;",
              "#endif",
              "#ifdef USE_TANGENT",
              "\tattribute vec4 tangent;",
              "#endif",
              "#if defined( USE_COLOR_ALPHA )",
              "\tattribute vec4 color;",
              "#elif defined( USE_COLOR )",
              "\tattribute vec3 color;",
              "#endif",
              "#ifdef USE_SKINNING",
              "\tattribute vec4 skinIndex;",
              "\tattribute vec4 skinWeight;",
              "#endif",
              "\n",
            ]
              .filter(wl)
              .join("\n")),
            (m = [
              Ll(n),
              "#define SHADER_TYPE " + n.shaderType,
              "#define SHADER_NAME " + n.shaderName,
              f,
              n.useFog && n.fog ? "#define USE_FOG" : "",
              n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
              n.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
              n.map ? "#define USE_MAP" : "",
              n.matcap ? "#define USE_MATCAP" : "",
              n.envMap ? "#define USE_ENVMAP" : "",
              n.envMap ? "#define " + l : "",
              n.envMap ? "#define " + u : "",
              n.envMap ? "#define " + h : "",
              d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "",
              d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "",
              d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "",
              n.lightMap ? "#define USE_LIGHTMAP" : "",
              n.aoMap ? "#define USE_AOMAP" : "",
              n.bumpMap ? "#define USE_BUMPMAP" : "",
              n.normalMap ? "#define USE_NORMALMAP" : "",
              n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
              n.normalMapTangentSpace
                ? "#define USE_NORMALMAP_TANGENTSPACE"
                : "",
              n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              n.anisotropy ? "#define USE_ANISOTROPY" : "",
              n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
              n.clearcoat ? "#define USE_CLEARCOAT" : "",
              n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              n.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              n.dispersion ? "#define USE_DISPERSION" : "",
              n.iridescence ? "#define USE_IRIDESCENCE" : "",
              n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
              n.iridescenceThicknessMap
                ? "#define USE_IRIDESCENCE_THICKNESSMAP"
                : "",
              n.specularMap ? "#define USE_SPECULARMAP" : "",
              n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
              n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
              n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              n.metalnessMap ? "#define USE_METALNESSMAP" : "",
              n.alphaMap ? "#define USE_ALPHAMAP" : "",
              n.alphaTest ? "#define USE_ALPHATEST" : "",
              n.alphaHash ? "#define USE_ALPHAHASH" : "",
              n.sheen ? "#define USE_SHEEN" : "",
              n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
              n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
              n.transmission ? "#define USE_TRANSMISSION" : "",
              n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              n.vertexTangents && !1 === n.flatShading
                ? "#define USE_TANGENT"
                : "",
              n.vertexColors || n.instancingColor || n.batchingColor
                ? "#define USE_COLOR"
                : "",
              n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              n.vertexUv1s ? "#define USE_UV1" : "",
              n.vertexUv2s ? "#define USE_UV2" : "",
              n.vertexUv3s ? "#define USE_UV3" : "",
              n.pointsUvs ? "#define USE_POINTS_UV" : "",
              n.gradientMap ? "#define USE_GRADIENTMAP" : "",
              n.flatShading ? "#define FLAT_SHADED" : "",
              n.doubleSided ? "#define DOUBLE_SIDED" : "",
              n.flipSided ? "#define FLIP_SIDED" : "",
              n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              n.shadowMapEnabled ? "#define " + c : "",
              n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
              n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
              n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
              n.decodeVideoTextureEmissive
                ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE"
                : "",
              n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              n.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
              "uniform mat4 viewMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              n.toneMapping !== An ? "#define TONE_MAPPING" : "",
              n.toneMapping !== An ? So.tonemapping_pars_fragment : "",
              n.toneMapping !== An ? _l("toneMapping", n.toneMapping) : "",
              n.dithering ? "#define DITHERING" : "",
              n.opaque ? "#define OPAQUE" : "",
              So.colorspace_pars_fragment,
              bl("linearToOutputTexel", n.outputColorSpace),
              El(),
              n.useDepthPacking
                ? "#define DEPTH_PACKING " + n.depthPacking
                : "",
              "\n",
            ]
              .filter(wl)
              .join("\n"))),
          (a = Ml(a)),
          (a = Cl(a, n)),
          (a = Sl(a, n)),
          (o = Ml(o)),
          (o = Cl(o, n)),
          (o = Sl(o, n)),
          (a = Dl(a)),
          (o = Dl(o)),
          !0 !== n.isRawShaderMaterial &&
            ((v = "#version 300 es\n"),
            (g =
              [
                p,
                "#define attribute in",
                "#define varying out",
                "#define texture2D texture",
              ].join("\n") +
              "\n" +
              g),
            (m =
              [
                "#define varying in",
                n.glslVersion === sr
                  ? ""
                  : "layout(location = 0) out highp vec4 pc_fragColor;",
                n.glslVersion === sr ? "" : "#define gl_FragColor pc_fragColor",
                "#define gl_FragDepthEXT gl_FragDepth",
                "#define texture2D texture",
                "#define textureCube texture",
                "#define texture2DProj textureProj",
                "#define texture2DLodEXT textureLod",
                "#define texture2DProjLodEXT textureProjLod",
                "#define textureCubeLodEXT textureLod",
                "#define texture2DGradEXT textureGrad",
                "#define texture2DProjGradEXT textureProjGrad",
                "#define textureCubeGradEXT textureGrad",
              ].join("\n") +
              "\n" +
              m));
        const y = v + g + a,
          b = v + m + o,
          _ = Al(r, r.VERTEX_SHADER, y),
          x = Al(r, r.FRAGMENT_SHADER, b);
        function E(t) {
          if (e.debug.checkShaderErrors) {
            const n = r.getProgramInfoLog(A).trim(),
              i = r.getShaderInfoLog(_).trim(),
              s = r.getShaderInfoLog(x).trim();
            let a = !0,
              o = !0;
            if (!1 === r.getProgramParameter(A, r.LINK_STATUS))
              if (((a = !1), "function" == typeof e.debug.onShaderError))
                e.debug.onShaderError(r, A, _, x);
              else {
                const e = yl(r, _, "vertex"),
                  i = yl(r, x, "fragment");
                console.error(
                  "THREE.WebGLProgram: Shader Error " +
                    r.getError() +
                    " - VALIDATE_STATUS " +
                    r.getProgramParameter(A, r.VALIDATE_STATUS) +
                    "\n\nMaterial Name: " +
                    t.name +
                    "\nMaterial Type: " +
                    t.type +
                    "\n\nProgram Info Log: " +
                    n +
                    "\n" +
                    e +
                    "\n" +
                    i
                );
              }
            else
              "" !== n
                ? console.warn("THREE.WebGLProgram: Program Info Log:", n)
                : ("" !== i && "" !== s) || (o = !1);
            o &&
              (t.diagnostics = {
                runnable: a,
                programLog: n,
                vertexShader: { log: i, prefix: g },
                fragmentShader: { log: s, prefix: m },
              });
          }
          r.deleteShader(_),
            r.deleteShader(x),
            (w = new fl(r, A)),
            (C = (function (e, t) {
              const n = {},
                i = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES);
              for (let r = 0; r < i; r++) {
                const i = e.getActiveAttrib(t, r),
                  s = i.name;
                let a = 1;
                i.type === e.FLOAT_MAT2 && (a = 2),
                  i.type === e.FLOAT_MAT3 && (a = 3),
                  i.type === e.FLOAT_MAT4 && (a = 4),
                  (n[s] = {
                    type: i.type,
                    location: e.getAttribLocation(t, s),
                    locationSize: a,
                  });
              }
              return n;
            })(r, A));
        }
        let w, C;
        r.attachShader(A, _),
          r.attachShader(A, x),
          void 0 !== n.index0AttributeName
            ? r.bindAttribLocation(A, 0, n.index0AttributeName)
            : !0 === n.morphTargets && r.bindAttribLocation(A, 0, "position"),
          r.linkProgram(A),
          (this.getUniforms = function () {
            return void 0 === w && E(this), w;
          }),
          (this.getAttributes = function () {
            return void 0 === C && E(this), C;
          });
        let S = !1 === n.rendererExtensionParallelShaderCompile;
        return (
          (this.isReady = function () {
            return !1 === S && (S = r.getProgramParameter(A, gl)), S;
          }),
          (this.destroy = function () {
            i.releaseStatesOfProgram(this),
              r.deleteProgram(A),
              (this.program = void 0);
          }),
          (this.type = n.shaderType),
          (this.name = n.shaderName),
          (this.id = ml++),
          (this.cacheKey = t),
          (this.usedTimes = 1),
          (this.program = A),
          (this.vertexShader = _),
          (this.fragmentShader = x),
          this
        );
      }
      let Fl = 0;
      class Ol {
        constructor() {
          (this.shaderCache = new Map()), (this.materialCache = new Map());
        }
        update(e) {
          const t = e.vertexShader,
            n = e.fragmentShader,
            i = this._getShaderStage(t),
            r = this._getShaderStage(n),
            s = this._getShaderCacheForMaterial(e);
          return (
            !1 === s.has(i) && (s.add(i), i.usedTimes++),
            !1 === s.has(r) && (s.add(r), r.usedTimes++),
            this
          );
        }
        remove(e) {
          const t = this.materialCache.get(e);
          for (const e of t)
            e.usedTimes--, 0 === e.usedTimes && this.shaderCache.delete(e.code);
          return this.materialCache.delete(e), this;
        }
        getVertexShaderID(e) {
          return this._getShaderStage(e.vertexShader).id;
        }
        getFragmentShaderID(e) {
          return this._getShaderStage(e.fragmentShader).id;
        }
        dispose() {
          this.shaderCache.clear(), this.materialCache.clear();
        }
        _getShaderCacheForMaterial(e) {
          const t = this.materialCache;
          let n = t.get(e);
          return void 0 === n && ((n = new Set()), t.set(e, n)), n;
        }
        _getShaderStage(e) {
          const t = this.shaderCache;
          let n = t.get(e);
          return void 0 === n && ((n = new Nl(e)), t.set(e, n)), n;
        }
      }
      class Nl {
        constructor(e) {
          (this.id = Fl++), (this.code = e), (this.usedTimes = 0);
        }
      }
      function kl(e, t, n, i, r, s, a) {
        const o = new Fs(),
          c = new Ol(),
          l = new Set(),
          u = [],
          h = r.logarithmicDepthBuffer,
          d = r.vertexTextures;
        let p = r.precision;
        const f = {
          MeshDepthMaterial: "depth",
          MeshDistanceMaterial: "distanceRGBA",
          MeshNormalMaterial: "normal",
          MeshBasicMaterial: "basic",
          MeshLambertMaterial: "lambert",
          MeshPhongMaterial: "phong",
          MeshToonMaterial: "toon",
          MeshStandardMaterial: "physical",
          MeshPhysicalMaterial: "physical",
          MeshMatcapMaterial: "matcap",
          LineBasicMaterial: "basic",
          LineDashedMaterial: "dashed",
          PointsMaterial: "points",
          ShadowMaterial: "shadow",
          SpriteMaterial: "sprite",
        };
        function A(e) {
          return l.add(e), 0 === e ? "uv" : `uv${e}`;
        }
        return {
          getParameters: function (s, o, u, g, m) {
            const v = g.fog,
              y = m.geometry,
              b = s.isMeshStandardMaterial ? g.environment : null,
              _ = (s.isMeshStandardMaterial ? n : t).get(s.envMap || b),
              x = _ && _.mapping === Mn ? _.image.height : null,
              E = f[s.type];
            null !== s.precision &&
              ((p = r.getMaxPrecision(s.precision)),
              p !== s.precision &&
                console.warn(
                  "THREE.WebGLProgram.getParameters:",
                  s.precision,
                  "not supported, using",
                  p,
                  "instead."
                ));
            const w =
                y.morphAttributes.position ||
                y.morphAttributes.normal ||
                y.morphAttributes.color,
              C = void 0 !== w ? w.length : 0;
            let S,
              I,
              M,
              T,
              B = 0;
            if (
              (void 0 !== y.morphAttributes.position && (B = 1),
              void 0 !== y.morphAttributes.normal && (B = 2),
              void 0 !== y.morphAttributes.color && (B = 3),
              E)
            ) {
              const e = Mo[E];
              (S = e.vertexShader), (I = e.fragmentShader);
            } else
              (S = s.vertexShader),
                (I = s.fragmentShader),
                c.update(s),
                (M = c.getVertexShaderID(s)),
                (T = c.getFragmentShaderID(s));
            const R = e.getRenderTarget(),
              D = e.state.buffers.depth.getReversed(),
              P = !0 === m.isInstancedMesh,
              L = !0 === m.isBatchedMesh,
              U = !!s.map,
              F = !!s.matcap,
              O = !!_,
              N = !!s.aoMap,
              k = !!s.lightMap,
              Q = !!s.bumpMap,
              G = !!s.normalMap,
              H = !!s.displacementMap,
              z = !!s.emissiveMap,
              V = !!s.metalnessMap,
              j = !!s.roughnessMap,
              W = s.anisotropy > 0,
              X = s.clearcoat > 0,
              q = s.dispersion > 0,
              Y = s.iridescence > 0,
              K = s.sheen > 0,
              J = s.transmission > 0,
              Z = W && !!s.anisotropyMap,
              $ = X && !!s.clearcoatMap,
              ee = X && !!s.clearcoatNormalMap,
              te = X && !!s.clearcoatRoughnessMap,
              ne = Y && !!s.iridescenceMap,
              ie = Y && !!s.iridescenceThicknessMap,
              re = K && !!s.sheenColorMap,
              se = K && !!s.sheenRoughnessMap,
              ae = !!s.specularMap,
              oe = !!s.specularColorMap,
              ce = !!s.specularIntensityMap,
              le = J && !!s.transmissionMap,
              ue = J && !!s.thicknessMap,
              he = !!s.gradientMap,
              de = !!s.alphaMap,
              pe = s.alphaTest > 0,
              fe = !!s.alphaHash,
              Ae = !!s.extensions;
            let ge = An;
            s.toneMapped &&
              ((null !== R && !0 !== R.isXRRenderTarget) ||
                (ge = e.toneMapping));
            const me = {
              shaderID: E,
              shaderType: s.type,
              shaderName: s.name,
              vertexShader: S,
              fragmentShader: I,
              defines: s.defines,
              customVertexShaderID: M,
              customFragmentShaderID: T,
              isRawShaderMaterial: !0 === s.isRawShaderMaterial,
              glslVersion: s.glslVersion,
              precision: p,
              batching: L,
              batchingColor: L && null !== m._colorsTexture,
              instancing: P,
              instancingColor: P && null !== m.instanceColor,
              instancingMorph: P && null !== m.morphTexture,
              supportsVertexTextures: d,
              outputColorSpace:
                null === R
                  ? e.outputColorSpace
                  : !0 === R.isXRRenderTarget
                  ? R.texture.colorSpace
                  : $i,
              alphaToCoverage: !!s.alphaToCoverage,
              map: U,
              matcap: F,
              envMap: O,
              envMapMode: O && _.mapping,
              envMapCubeUVHeight: x,
              aoMap: N,
              lightMap: k,
              bumpMap: Q,
              normalMap: G,
              displacementMap: d && H,
              emissiveMap: z,
              normalMapObjectSpace: G && 1 === s.normalMapType,
              normalMapTangentSpace: G && 0 === s.normalMapType,
              metalnessMap: V,
              roughnessMap: j,
              anisotropy: W,
              anisotropyMap: Z,
              clearcoat: X,
              clearcoatMap: $,
              clearcoatNormalMap: ee,
              clearcoatRoughnessMap: te,
              dispersion: q,
              iridescence: Y,
              iridescenceMap: ne,
              iridescenceThicknessMap: ie,
              sheen: K,
              sheenColorMap: re,
              sheenRoughnessMap: se,
              specularMap: ae,
              specularColorMap: oe,
              specularIntensityMap: ce,
              transmission: J,
              transmissionMap: le,
              thicknessMap: ue,
              gradientMap: he,
              opaque:
                !1 === s.transparent &&
                1 === s.blending &&
                !1 === s.alphaToCoverage,
              alphaMap: de,
              alphaTest: pe,
              alphaHash: fe,
              combine: s.combine,
              mapUv: U && A(s.map.channel),
              aoMapUv: N && A(s.aoMap.channel),
              lightMapUv: k && A(s.lightMap.channel),
              bumpMapUv: Q && A(s.bumpMap.channel),
              normalMapUv: G && A(s.normalMap.channel),
              displacementMapUv: H && A(s.displacementMap.channel),
              emissiveMapUv: z && A(s.emissiveMap.channel),
              metalnessMapUv: V && A(s.metalnessMap.channel),
              roughnessMapUv: j && A(s.roughnessMap.channel),
              anisotropyMapUv: Z && A(s.anisotropyMap.channel),
              clearcoatMapUv: $ && A(s.clearcoatMap.channel),
              clearcoatNormalMapUv: ee && A(s.clearcoatNormalMap.channel),
              clearcoatRoughnessMapUv: te && A(s.clearcoatRoughnessMap.channel),
              iridescenceMapUv: ne && A(s.iridescenceMap.channel),
              iridescenceThicknessMapUv:
                ie && A(s.iridescenceThicknessMap.channel),
              sheenColorMapUv: re && A(s.sheenColorMap.channel),
              sheenRoughnessMapUv: se && A(s.sheenRoughnessMap.channel),
              specularMapUv: ae && A(s.specularMap.channel),
              specularColorMapUv: oe && A(s.specularColorMap.channel),
              specularIntensityMapUv: ce && A(s.specularIntensityMap.channel),
              transmissionMapUv: le && A(s.transmissionMap.channel),
              thicknessMapUv: ue && A(s.thicknessMap.channel),
              alphaMapUv: de && A(s.alphaMap.channel),
              vertexTangents: !!y.attributes.tangent && (G || W),
              vertexColors: s.vertexColors,
              vertexAlphas:
                !0 === s.vertexColors &&
                !!y.attributes.color &&
                4 === y.attributes.color.itemSize,
              pointsUvs: !0 === m.isPoints && !!y.attributes.uv && (U || de),
              fog: !!v,
              useFog: !0 === s.fog,
              fogExp2: !!v && v.isFogExp2,
              flatShading: !0 === s.flatShading,
              sizeAttenuation: !0 === s.sizeAttenuation,
              logarithmicDepthBuffer: h,
              reverseDepthBuffer: D,
              skinning: !0 === m.isSkinnedMesh,
              morphTargets: void 0 !== y.morphAttributes.position,
              morphNormals: void 0 !== y.morphAttributes.normal,
              morphColors: void 0 !== y.morphAttributes.color,
              morphTargetsCount: C,
              morphTextureStride: B,
              numDirLights: o.directional.length,
              numPointLights: o.point.length,
              numSpotLights: o.spot.length,
              numSpotLightMaps: o.spotLightMap.length,
              numRectAreaLights: o.rectArea.length,
              numHemiLights: o.hemi.length,
              numDirLightShadows: o.directionalShadowMap.length,
              numPointLightShadows: o.pointShadowMap.length,
              numSpotLightShadows: o.spotShadowMap.length,
              numSpotLightShadowsWithMaps: o.numSpotLightShadowsWithMaps,
              numLightProbes: o.numLightProbes,
              numClippingPlanes: a.numPlanes,
              numClipIntersection: a.numIntersection,
              dithering: s.dithering,
              shadowMapEnabled: e.shadowMap.enabled && u.length > 0,
              shadowMapType: e.shadowMap.type,
              toneMapping: ge,
              decodeVideoTexture:
                U &&
                !0 === s.map.isVideoTexture &&
                Mr.getTransfer(s.map.colorSpace) === tr,
              decodeVideoTextureEmissive:
                z &&
                !0 === s.emissiveMap.isVideoTexture &&
                Mr.getTransfer(s.emissiveMap.colorSpace) === tr,
              premultipliedAlpha: s.premultipliedAlpha,
              doubleSided: s.side === un,
              flipSided: s.side === ln,
              useDepthPacking: s.depthPacking >= 0,
              depthPacking: s.depthPacking || 0,
              index0AttributeName: s.index0AttributeName,
              extensionClipCullDistance:
                Ae &&
                !0 === s.extensions.clipCullDistance &&
                i.has("WEBGL_clip_cull_distance"),
              extensionMultiDraw:
                ((Ae && !0 === s.extensions.multiDraw) || L) &&
                i.has("WEBGL_multi_draw"),
              rendererExtensionParallelShaderCompile: i.has(
                "KHR_parallel_shader_compile"
              ),
              customProgramCacheKey: s.customProgramCacheKey(),
            };
            return (
              (me.vertexUv1s = l.has(1)),
              (me.vertexUv2s = l.has(2)),
              (me.vertexUv3s = l.has(3)),
              l.clear(),
              me
            );
          },
          getProgramCacheKey: function (t) {
            const n = [];
            if (
              (t.shaderID
                ? n.push(t.shaderID)
                : (n.push(t.customVertexShaderID),
                  n.push(t.customFragmentShaderID)),
              void 0 !== t.defines)
            )
              for (const e in t.defines) n.push(e), n.push(t.defines[e]);
            return (
              !1 === t.isRawShaderMaterial &&
                (!(function (e, t) {
                  e.push(t.precision),
                    e.push(t.outputColorSpace),
                    e.push(t.envMapMode),
                    e.push(t.envMapCubeUVHeight),
                    e.push(t.mapUv),
                    e.push(t.alphaMapUv),
                    e.push(t.lightMapUv),
                    e.push(t.aoMapUv),
                    e.push(t.bumpMapUv),
                    e.push(t.normalMapUv),
                    e.push(t.displacementMapUv),
                    e.push(t.emissiveMapUv),
                    e.push(t.metalnessMapUv),
                    e.push(t.roughnessMapUv),
                    e.push(t.anisotropyMapUv),
                    e.push(t.clearcoatMapUv),
                    e.push(t.clearcoatNormalMapUv),
                    e.push(t.clearcoatRoughnessMapUv),
                    e.push(t.iridescenceMapUv),
                    e.push(t.iridescenceThicknessMapUv),
                    e.push(t.sheenColorMapUv),
                    e.push(t.sheenRoughnessMapUv),
                    e.push(t.specularMapUv),
                    e.push(t.specularColorMapUv),
                    e.push(t.specularIntensityMapUv),
                    e.push(t.transmissionMapUv),
                    e.push(t.thicknessMapUv),
                    e.push(t.combine),
                    e.push(t.fogExp2),
                    e.push(t.sizeAttenuation),
                    e.push(t.morphTargetsCount),
                    e.push(t.morphAttributeCount),
                    e.push(t.numDirLights),
                    e.push(t.numPointLights),
                    e.push(t.numSpotLights),
                    e.push(t.numSpotLightMaps),
                    e.push(t.numHemiLights),
                    e.push(t.numRectAreaLights),
                    e.push(t.numDirLightShadows),
                    e.push(t.numPointLightShadows),
                    e.push(t.numSpotLightShadows),
                    e.push(t.numSpotLightShadowsWithMaps),
                    e.push(t.numLightProbes),
                    e.push(t.shadowMapType),
                    e.push(t.toneMapping),
                    e.push(t.numClippingPlanes),
                    e.push(t.numClipIntersection),
                    e.push(t.depthPacking);
                })(n, t),
                (function (e, t) {
                  o.disableAll(), t.supportsVertexTextures && o.enable(0);
                  t.instancing && o.enable(1);
                  t.instancingColor && o.enable(2);
                  t.instancingMorph && o.enable(3);
                  t.matcap && o.enable(4);
                  t.envMap && o.enable(5);
                  t.normalMapObjectSpace && o.enable(6);
                  t.normalMapTangentSpace && o.enable(7);
                  t.clearcoat && o.enable(8);
                  t.iridescence && o.enable(9);
                  t.alphaTest && o.enable(10);
                  t.vertexColors && o.enable(11);
                  t.vertexAlphas && o.enable(12);
                  t.vertexUv1s && o.enable(13);
                  t.vertexUv2s && o.enable(14);
                  t.vertexUv3s && o.enable(15);
                  t.vertexTangents && o.enable(16);
                  t.anisotropy && o.enable(17);
                  t.alphaHash && o.enable(18);
                  t.batching && o.enable(19);
                  t.dispersion && o.enable(20);
                  t.batchingColor && o.enable(21);
                  e.push(o.mask), o.disableAll(), t.fog && o.enable(0);
                  t.useFog && o.enable(1);
                  t.flatShading && o.enable(2);
                  t.logarithmicDepthBuffer && o.enable(3);
                  t.reverseDepthBuffer && o.enable(4);
                  t.skinning && o.enable(5);
                  t.morphTargets && o.enable(6);
                  t.morphNormals && o.enable(7);
                  t.morphColors && o.enable(8);
                  t.premultipliedAlpha && o.enable(9);
                  t.shadowMapEnabled && o.enable(10);
                  t.doubleSided && o.enable(11);
                  t.flipSided && o.enable(12);
                  t.useDepthPacking && o.enable(13);
                  t.dithering && o.enable(14);
                  t.transmission && o.enable(15);
                  t.sheen && o.enable(16);
                  t.opaque && o.enable(17);
                  t.pointsUvs && o.enable(18);
                  t.decodeVideoTexture && o.enable(19);
                  t.decodeVideoTextureEmissive && o.enable(20);
                  t.alphaToCoverage && o.enable(21);
                  e.push(o.mask);
                })(n, t),
                n.push(e.outputColorSpace)),
              n.push(t.customProgramCacheKey),
              n.join()
            );
          },
          getUniforms: function (e) {
            const t = f[e.type];
            let n;
            if (t) {
              const e = Mo[t];
              n = ro.clone(e.uniforms);
            } else n = e.uniforms;
            return n;
          },
          acquireProgram: function (t, n) {
            let i;
            for (let e = 0, t = u.length; e < t; e++) {
              const t = u[e];
              if (t.cacheKey === n) {
                (i = t), ++i.usedTimes;
                break;
              }
            }
            return void 0 === i && ((i = new Ul(e, n, t, s)), u.push(i)), i;
          },
          releaseProgram: function (e) {
            if (0 == --e.usedTimes) {
              const t = u.indexOf(e);
              (u[t] = u[u.length - 1]), u.pop(), e.destroy();
            }
          },
          releaseShaderCache: function (e) {
            c.remove(e);
          },
          programs: u,
          dispose: function () {
            c.dispose();
          },
        };
      }
      function Ql() {
        let e = new WeakMap();
        return {
          has: function (t) {
            return e.has(t);
          },
          get: function (t) {
            let n = e.get(t);
            return void 0 === n && ((n = {}), e.set(t, n)), n;
          },
          remove: function (t) {
            e.delete(t);
          },
          update: function (t, n, i) {
            e.get(t)[n] = i;
          },
          dispose: function () {
            e = new WeakMap();
          },
        };
      }
      function Gl(e, t) {
        return e.groupOrder !== t.groupOrder
          ? e.groupOrder - t.groupOrder
          : e.renderOrder !== t.renderOrder
          ? e.renderOrder - t.renderOrder
          : e.material.id !== t.material.id
          ? e.material.id - t.material.id
          : e.z !== t.z
          ? e.z - t.z
          : e.id - t.id;
      }
      function Hl(e, t) {
        return e.groupOrder !== t.groupOrder
          ? e.groupOrder - t.groupOrder
          : e.renderOrder !== t.renderOrder
          ? e.renderOrder - t.renderOrder
          : e.z !== t.z
          ? t.z - e.z
          : e.id - t.id;
      }
      function zl() {
        const e = [];
        let t = 0;
        const n = [],
          i = [],
          r = [];
        function s(n, i, r, s, a, o) {
          let c = e[t];
          return (
            void 0 === c
              ? ((c = {
                  id: n.id,
                  object: n,
                  geometry: i,
                  material: r,
                  groupOrder: s,
                  renderOrder: n.renderOrder,
                  z: a,
                  group: o,
                }),
                (e[t] = c))
              : ((c.id = n.id),
                (c.object = n),
                (c.geometry = i),
                (c.material = r),
                (c.groupOrder = s),
                (c.renderOrder = n.renderOrder),
                (c.z = a),
                (c.group = o)),
            t++,
            c
          );
        }
        return {
          opaque: n,
          transmissive: i,
          transparent: r,
          init: function () {
            (t = 0), (n.length = 0), (i.length = 0), (r.length = 0);
          },
          push: function (e, t, a, o, c, l) {
            const u = s(e, t, a, o, c, l);
            a.transmission > 0
              ? i.push(u)
              : !0 === a.transparent
              ? r.push(u)
              : n.push(u);
          },
          unshift: function (e, t, a, o, c, l) {
            const u = s(e, t, a, o, c, l);
            a.transmission > 0
              ? i.unshift(u)
              : !0 === a.transparent
              ? r.unshift(u)
              : n.unshift(u);
          },
          finish: function () {
            for (let n = t, i = e.length; n < i; n++) {
              const t = e[n];
              if (null === t.id) break;
              (t.id = null),
                (t.object = null),
                (t.geometry = null),
                (t.material = null),
                (t.group = null);
            }
          },
          sort: function (e, t) {
            n.length > 1 && n.sort(e || Gl),
              i.length > 1 && i.sort(t || Hl),
              r.length > 1 && r.sort(t || Hl);
          },
        };
      }
      function Vl() {
        let e = new WeakMap();
        return {
          get: function (t, n) {
            const i = e.get(t);
            let r;
            return (
              void 0 === i
                ? ((r = new zl()), e.set(t, [r]))
                : n >= i.length
                ? ((r = new zl()), i.push(r))
                : (r = i[n]),
              r
            );
          },
          dispose: function () {
            e = new WeakMap();
          },
        };
      }
      function jl() {
        const e = {};
        return {
          get: function (t) {
            if (void 0 !== e[t.id]) return e[t.id];
            let n;
            switch (t.type) {
              case "DirectionalLight":
                n = { direction: new Yr(), color: new ma() };
                break;
              case "SpotLight":
                n = {
                  position: new Yr(),
                  direction: new Yr(),
                  color: new ma(),
                  distance: 0,
                  coneCos: 0,
                  penumbraCos: 0,
                  decay: 0,
                };
                break;
              case "PointLight":
                n = {
                  position: new Yr(),
                  color: new ma(),
                  distance: 0,
                  decay: 0,
                };
                break;
              case "HemisphereLight":
                n = {
                  direction: new Yr(),
                  skyColor: new ma(),
                  groundColor: new ma(),
                };
                break;
              case "RectAreaLight":
                n = {
                  color: new ma(),
                  position: new Yr(),
                  halfWidth: new Yr(),
                  halfHeight: new Yr(),
                };
            }
            return (e[t.id] = n), n;
          },
        };
      }
      let Wl = 0;
      function Xl(e, t) {
        return (
          (t.castShadow ? 2 : 0) -
          (e.castShadow ? 2 : 0) +
          (t.map ? 1 : 0) -
          (e.map ? 1 : 0)
        );
      }
      function ql(e) {
        const t = new jl(),
          n = (function () {
            const e = {};
            return {
              get: function (t) {
                if (void 0 !== e[t.id]) return e[t.id];
                let n;
                switch (t.type) {
                  case "DirectionalLight":
                  case "SpotLight":
                    n = {
                      shadowIntensity: 1,
                      shadowBias: 0,
                      shadowNormalBias: 0,
                      shadowRadius: 1,
                      shadowMapSize: new br(),
                    };
                    break;
                  case "PointLight":
                    n = {
                      shadowIntensity: 1,
                      shadowBias: 0,
                      shadowNormalBias: 0,
                      shadowRadius: 1,
                      shadowMapSize: new br(),
                      shadowCameraNear: 1,
                      shadowCameraFar: 1e3,
                    };
                }
                return (e[t.id] = n), n;
              },
            };
          })(),
          i = {
            version: 0,
            hash: {
              directionalLength: -1,
              pointLength: -1,
              spotLength: -1,
              rectAreaLength: -1,
              hemiLength: -1,
              numDirectionalShadows: -1,
              numPointShadows: -1,
              numSpotShadows: -1,
              numSpotMaps: -1,
              numLightProbes: -1,
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotLightMap: [],
            spotShadow: [],
            spotShadowMap: [],
            spotLightMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
            numSpotLightShadowsWithMaps: 0,
            numLightProbes: 0,
          };
        for (let e = 0; e < 9; e++) i.probe.push(new Yr());
        const r = new Yr(),
          s = new Cs(),
          a = new Cs();
        return {
          setup: function (r) {
            let s = 0,
              a = 0,
              o = 0;
            for (let e = 0; e < 9; e++) i.probe[e].set(0, 0, 0);
            let c = 0,
              l = 0,
              u = 0,
              h = 0,
              d = 0,
              p = 0,
              f = 0,
              A = 0,
              g = 0,
              m = 0,
              v = 0;
            r.sort(Xl);
            for (let e = 0, y = r.length; e < y; e++) {
              const y = r[e],
                b = y.color,
                _ = y.intensity,
                x = y.distance,
                E = y.shadow && y.shadow.map ? y.shadow.map.texture : null;
              if (y.isAmbientLight)
                (s += b.r * _), (a += b.g * _), (o += b.b * _);
              else if (y.isLightProbe) {
                for (let e = 0; e < 9; e++)
                  i.probe[e].addScaledVector(y.sh.coefficients[e], _);
                v++;
              } else if (y.isDirectionalLight) {
                const e = t.get(y);
                if (
                  (e.color.copy(y.color).multiplyScalar(y.intensity),
                  y.castShadow)
                ) {
                  const e = y.shadow,
                    t = n.get(y);
                  (t.shadowIntensity = e.intensity),
                    (t.shadowBias = e.bias),
                    (t.shadowNormalBias = e.normalBias),
                    (t.shadowRadius = e.radius),
                    (t.shadowMapSize = e.mapSize),
                    (i.directionalShadow[c] = t),
                    (i.directionalShadowMap[c] = E),
                    (i.directionalShadowMatrix[c] = y.shadow.matrix),
                    p++;
                }
                (i.directional[c] = e), c++;
              } else if (y.isSpotLight) {
                const e = t.get(y);
                e.position.setFromMatrixPosition(y.matrixWorld),
                  e.color.copy(b).multiplyScalar(_),
                  (e.distance = x),
                  (e.coneCos = Math.cos(y.angle)),
                  (e.penumbraCos = Math.cos(y.angle * (1 - y.penumbra))),
                  (e.decay = y.decay),
                  (i.spot[u] = e);
                const r = y.shadow;
                if (
                  (y.map &&
                    ((i.spotLightMap[g] = y.map),
                    g++,
                    r.updateMatrices(y),
                    y.castShadow && m++),
                  (i.spotLightMatrix[u] = r.matrix),
                  y.castShadow)
                ) {
                  const e = n.get(y);
                  (e.shadowIntensity = r.intensity),
                    (e.shadowBias = r.bias),
                    (e.shadowNormalBias = r.normalBias),
                    (e.shadowRadius = r.radius),
                    (e.shadowMapSize = r.mapSize),
                    (i.spotShadow[u] = e),
                    (i.spotShadowMap[u] = E),
                    A++;
                }
                u++;
              } else if (y.isRectAreaLight) {
                const e = t.get(y);
                e.color.copy(b).multiplyScalar(_),
                  e.halfWidth.set(0.5 * y.width, 0, 0),
                  e.halfHeight.set(0, 0.5 * y.height, 0),
                  (i.rectArea[h] = e),
                  h++;
              } else if (y.isPointLight) {
                const e = t.get(y);
                if (
                  (e.color.copy(y.color).multiplyScalar(y.intensity),
                  (e.distance = y.distance),
                  (e.decay = y.decay),
                  y.castShadow)
                ) {
                  const e = y.shadow,
                    t = n.get(y);
                  (t.shadowIntensity = e.intensity),
                    (t.shadowBias = e.bias),
                    (t.shadowNormalBias = e.normalBias),
                    (t.shadowRadius = e.radius),
                    (t.shadowMapSize = e.mapSize),
                    (t.shadowCameraNear = e.camera.near),
                    (t.shadowCameraFar = e.camera.far),
                    (i.pointShadow[l] = t),
                    (i.pointShadowMap[l] = E),
                    (i.pointShadowMatrix[l] = y.shadow.matrix),
                    f++;
                }
                (i.point[l] = e), l++;
              } else if (y.isHemisphereLight) {
                const e = t.get(y);
                e.skyColor.copy(y.color).multiplyScalar(_),
                  e.groundColor.copy(y.groundColor).multiplyScalar(_),
                  (i.hemi[d] = e),
                  d++;
              }
            }
            h > 0 &&
              (!0 === e.has("OES_texture_float_linear")
                ? ((i.rectAreaLTC1 = Io.LTC_FLOAT_1),
                  (i.rectAreaLTC2 = Io.LTC_FLOAT_2))
                : ((i.rectAreaLTC1 = Io.LTC_HALF_1),
                  (i.rectAreaLTC2 = Io.LTC_HALF_2))),
              (i.ambient[0] = s),
              (i.ambient[1] = a),
              (i.ambient[2] = o);
            const y = i.hash;
            (y.directionalLength === c &&
              y.pointLength === l &&
              y.spotLength === u &&
              y.rectAreaLength === h &&
              y.hemiLength === d &&
              y.numDirectionalShadows === p &&
              y.numPointShadows === f &&
              y.numSpotShadows === A &&
              y.numSpotMaps === g &&
              y.numLightProbes === v) ||
              ((i.directional.length = c),
              (i.spot.length = u),
              (i.rectArea.length = h),
              (i.point.length = l),
              (i.hemi.length = d),
              (i.directionalShadow.length = p),
              (i.directionalShadowMap.length = p),
              (i.pointShadow.length = f),
              (i.pointShadowMap.length = f),
              (i.spotShadow.length = A),
              (i.spotShadowMap.length = A),
              (i.directionalShadowMatrix.length = p),
              (i.pointShadowMatrix.length = f),
              (i.spotLightMatrix.length = A + g - m),
              (i.spotLightMap.length = g),
              (i.numSpotLightShadowsWithMaps = m),
              (i.numLightProbes = v),
              (y.directionalLength = c),
              (y.pointLength = l),
              (y.spotLength = u),
              (y.rectAreaLength = h),
              (y.hemiLength = d),
              (y.numDirectionalShadows = p),
              (y.numPointShadows = f),
              (y.numSpotShadows = A),
              (y.numSpotMaps = g),
              (y.numLightProbes = v),
              (i.version = Wl++));
          },
          setupView: function (e, t) {
            let n = 0,
              o = 0,
              c = 0,
              l = 0,
              u = 0;
            const h = t.matrixWorldInverse;
            for (let t = 0, d = e.length; t < d; t++) {
              const d = e[t];
              if (d.isDirectionalLight) {
                const e = i.directional[n];
                e.direction.setFromMatrixPosition(d.matrixWorld),
                  r.setFromMatrixPosition(d.target.matrixWorld),
                  e.direction.sub(r),
                  e.direction.transformDirection(h),
                  n++;
              } else if (d.isSpotLight) {
                const e = i.spot[c];
                e.position.setFromMatrixPosition(d.matrixWorld),
                  e.position.applyMatrix4(h),
                  e.direction.setFromMatrixPosition(d.matrixWorld),
                  r.setFromMatrixPosition(d.target.matrixWorld),
                  e.direction.sub(r),
                  e.direction.transformDirection(h),
                  c++;
              } else if (d.isRectAreaLight) {
                const e = i.rectArea[l];
                e.position.setFromMatrixPosition(d.matrixWorld),
                  e.position.applyMatrix4(h),
                  a.identity(),
                  s.copy(d.matrixWorld),
                  s.premultiply(h),
                  a.extractRotation(s),
                  e.halfWidth.set(0.5 * d.width, 0, 0),
                  e.halfHeight.set(0, 0.5 * d.height, 0),
                  e.halfWidth.applyMatrix4(a),
                  e.halfHeight.applyMatrix4(a),
                  l++;
              } else if (d.isPointLight) {
                const e = i.point[o];
                e.position.setFromMatrixPosition(d.matrixWorld),
                  e.position.applyMatrix4(h),
                  o++;
              } else if (d.isHemisphereLight) {
                const e = i.hemi[u];
                e.direction.setFromMatrixPosition(d.matrixWorld),
                  e.direction.transformDirection(h),
                  u++;
              }
            }
          },
          state: i,
        };
      }
      function Yl(e) {
        const t = new ql(e),
          n = [],
          i = [];
        const r = {
          lightsArray: n,
          shadowsArray: i,
          camera: null,
          lights: t,
          transmissionRenderTarget: {},
        };
        return {
          init: function (e) {
            (r.camera = e), (n.length = 0), (i.length = 0);
          },
          state: r,
          setupLights: function () {
            t.setup(n);
          },
          setupLightsView: function (e) {
            t.setupView(n, e);
          },
          pushLight: function (e) {
            n.push(e);
          },
          pushShadow: function (e) {
            i.push(e);
          },
        };
      }
      function Kl(e) {
        let t = new WeakMap();
        return {
          get: function (n, i = 0) {
            const r = t.get(n);
            let s;
            return (
              void 0 === r
                ? ((s = new Yl(e)), t.set(n, [s]))
                : i >= r.length
                ? ((s = new Yl(e)), r.push(s))
                : (s = r[i]),
              s
            );
          },
          dispose: function () {
            t = new WeakMap();
          },
        };
      }
      class Jl extends ba {
        static get type() {
          return "MeshDepthMaterial";
        }
        constructor(e) {
          super(),
            (this.isMeshDepthMaterial = !0),
            (this.depthPacking = Yi),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.depthPacking = e.depthPacking),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            this
          );
        }
      }
      class Zl extends ba {
        static get type() {
          return "MeshDistanceMaterial";
        }
        constructor(e) {
          super(),
            (this.isMeshDistanceMaterial = !0),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            this
          );
        }
      }
      function $l(e, t, n) {
        let i = new xo();
        const r = new br(),
          s = new br(),
          a = new zr(),
          o = new Jl({ depthPacking: Ki }),
          c = new Zl(),
          l = {},
          u = n.maxTextureSize,
          h = { [cn]: ln, [ln]: cn, [un]: un },
          d = new so({
            defines: { VSM_SAMPLES: 8 },
            uniforms: {
              shadow_pass: { value: null },
              resolution: { value: new br() },
              radius: { value: 4 },
            },
            vertexShader:
              "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
            fragmentShader:
              "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
          }),
          p = d.clone();
        p.defines.HORIZONTAL_PASS = 1;
        const f = new Qa();
        f.setAttribute(
          "position",
          new Ta(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
        );
        const A = new Za(f, d),
          g = this;
        (this.enabled = !1),
          (this.autoUpdate = !0),
          (this.needsUpdate = !1),
          (this.type = sn);
        let m = this.type;
        function v(n, i) {
          const s = t.update(A);
          d.defines.VSM_SAMPLES !== n.blurSamples &&
            ((d.defines.VSM_SAMPLES = n.blurSamples),
            (p.defines.VSM_SAMPLES = n.blurSamples),
            (d.needsUpdate = !0),
            (p.needsUpdate = !0)),
            null === n.mapPass && (n.mapPass = new jr(r.x, r.y)),
            (d.uniforms.shadow_pass.value = n.map.texture),
            (d.uniforms.resolution.value = n.mapSize),
            (d.uniforms.radius.value = n.radius),
            e.setRenderTarget(n.mapPass),
            e.clear(),
            e.renderBufferDirect(i, null, s, d, A, null),
            (p.uniforms.shadow_pass.value = n.mapPass.texture),
            (p.uniforms.resolution.value = n.mapSize),
            (p.uniforms.radius.value = n.radius),
            e.setRenderTarget(n.map),
            e.clear(),
            e.renderBufferDirect(i, null, s, p, A, null);
        }
        function y(t, n, i, r) {
          let s = null;
          const a =
            !0 === i.isPointLight
              ? t.customDistanceMaterial
              : t.customDepthMaterial;
          if (void 0 !== a) s = a;
          else if (
            ((s = !0 === i.isPointLight ? c : o),
            (e.localClippingEnabled &&
              !0 === n.clipShadows &&
              Array.isArray(n.clippingPlanes) &&
              0 !== n.clippingPlanes.length) ||
              (n.displacementMap && 0 !== n.displacementScale) ||
              (n.alphaMap && n.alphaTest > 0) ||
              (n.map && n.alphaTest > 0))
          ) {
            const e = s.uuid,
              t = n.uuid;
            let i = l[e];
            void 0 === i && ((i = {}), (l[e] = i));
            let r = i[t];
            void 0 === r &&
              ((r = s.clone()), (i[t] = r), n.addEventListener("dispose", _)),
              (s = r);
          }
          if (
            ((s.visible = n.visible),
            (s.wireframe = n.wireframe),
            (s.side =
              r === on
                ? null !== n.shadowSide
                  ? n.shadowSide
                  : n.side
                : null !== n.shadowSide
                ? n.shadowSide
                : h[n.side]),
            (s.alphaMap = n.alphaMap),
            (s.alphaTest = n.alphaTest),
            (s.map = n.map),
            (s.clipShadows = n.clipShadows),
            (s.clippingPlanes = n.clippingPlanes),
            (s.clipIntersection = n.clipIntersection),
            (s.displacementMap = n.displacementMap),
            (s.displacementScale = n.displacementScale),
            (s.displacementBias = n.displacementBias),
            (s.wireframeLinewidth = n.wireframeLinewidth),
            (s.linewidth = n.linewidth),
            !0 === i.isPointLight && !0 === s.isMeshDistanceMaterial)
          ) {
            e.properties.get(s).light = i;
          }
          return s;
        }
        function b(n, r, s, a, o) {
          if (!1 === n.visible) return;
          if (
            n.layers.test(r.layers) &&
            (n.isMesh || n.isLine || n.isPoints) &&
            (n.castShadow || (n.receiveShadow && o === on)) &&
            (!n.frustumCulled || i.intersectsObject(n))
          ) {
            n.modelViewMatrix.multiplyMatrices(
              s.matrixWorldInverse,
              n.matrixWorld
            );
            const i = t.update(n),
              c = n.material;
            if (Array.isArray(c)) {
              const t = i.groups;
              for (let l = 0, u = t.length; l < u; l++) {
                const u = t[l],
                  h = c[u.materialIndex];
                if (h && h.visible) {
                  const t = y(n, h, a, o);
                  n.onBeforeShadow(e, n, r, s, i, t, u),
                    e.renderBufferDirect(s, null, i, t, n, u),
                    n.onAfterShadow(e, n, r, s, i, t, u);
                }
              }
            } else if (c.visible) {
              const t = y(n, c, a, o);
              n.onBeforeShadow(e, n, r, s, i, t, null),
                e.renderBufferDirect(s, null, i, t, n, null),
                n.onAfterShadow(e, n, r, s, i, t, null);
            }
          }
          const c = n.children;
          for (let e = 0, t = c.length; e < t; e++) b(c[e], r, s, a, o);
        }
        function _(e) {
          e.target.removeEventListener("dispose", _);
          for (const t in l) {
            const n = l[t],
              i = e.target.uuid;
            if (i in n) {
              n[i].dispose(), delete n[i];
            }
          }
        }
        this.render = function (t, n, o) {
          if (!1 === g.enabled) return;
          if (!1 === g.autoUpdate && !1 === g.needsUpdate) return;
          if (0 === t.length) return;
          const c = e.getRenderTarget(),
            l = e.getActiveCubeFace(),
            h = e.getActiveMipmapLevel(),
            d = e.state;
          d.setBlending(0),
            d.buffers.color.setClear(1, 1, 1, 1),
            d.buffers.depth.setTest(!0),
            d.setScissorTest(!1);
          const p = m !== on && this.type === on,
            f = m === on && this.type !== on;
          for (let c = 0, l = t.length; c < l; c++) {
            const l = t[c],
              h = l.shadow;
            if (void 0 === h) {
              console.warn("THREE.WebGLShadowMap:", l, "has no shadow.");
              continue;
            }
            if (!1 === h.autoUpdate && !1 === h.needsUpdate) continue;
            r.copy(h.mapSize);
            const A = h.getFrameExtents();
            if (
              (r.multiply(A),
              s.copy(h.mapSize),
              (r.x > u || r.y > u) &&
                (r.x > u &&
                  ((s.x = Math.floor(u / A.x)),
                  (r.x = s.x * A.x),
                  (h.mapSize.x = s.x)),
                r.y > u &&
                  ((s.y = Math.floor(u / A.y)),
                  (r.y = s.y * A.y),
                  (h.mapSize.y = s.y))),
              null === h.map || !0 === p || !0 === f)
            ) {
              const e =
                this.type !== on ? { minFilter: Dn, magFilter: Dn } : {};
              null !== h.map && h.map.dispose(),
                (h.map = new jr(r.x, r.y, e)),
                (h.map.texture.name = l.name + ".shadowMap"),
                h.camera.updateProjectionMatrix();
            }
            e.setRenderTarget(h.map), e.clear();
            const g = h.getViewportCount();
            for (let e = 0; e < g; e++) {
              const t = h.getViewport(e);
              a.set(s.x * t.x, s.y * t.y, s.x * t.z, s.y * t.w),
                d.viewport(a),
                h.updateMatrices(l, e),
                (i = h.getFrustum()),
                b(n, o, h.camera, l, this.type);
            }
            !0 !== h.isPointLightShadow && this.type === on && v(h, o),
              (h.needsUpdate = !1);
          }
          (m = this.type), (g.needsUpdate = !1), e.setRenderTarget(c, l, h);
        };
      }
      const eu = { 0: 1, 2: 6, 4: 7, 3: 5, 1: 0, 6: 2, 7: 4, 5: 3 };
      function tu(e, t) {
        const n = new (function () {
            let t = !1;
            const n = new zr();
            let i = null;
            const r = new zr(0, 0, 0, 0);
            return {
              setMask: function (n) {
                i === n || t || (e.colorMask(n, n, n, n), (i = n));
              },
              setLocked: function (e) {
                t = e;
              },
              setClear: function (t, i, s, a, o) {
                !0 === o && ((t *= a), (i *= a), (s *= a)),
                  n.set(t, i, s, a),
                  !1 === r.equals(n) && (e.clearColor(t, i, s, a), r.copy(n));
              },
              reset: function () {
                (t = !1), (i = null), r.set(-1, 0, 0, 0);
              },
            };
          })(),
          i = new (function () {
            let n = !1,
              i = !1,
              r = null,
              s = null,
              a = null;
            return {
              setReversed: function (e) {
                if (i !== e) {
                  const e = t.get("EXT_clip_control");
                  i
                    ? e.clipControlEXT(e.LOWER_LEFT_EXT, e.ZERO_TO_ONE_EXT)
                    : e.clipControlEXT(
                        e.LOWER_LEFT_EXT,
                        e.NEGATIVE_ONE_TO_ONE_EXT
                      );
                  const n = a;
                  (a = null), this.setClear(n);
                }
                i = e;
              },
              getReversed: function () {
                return i;
              },
              setTest: function (t) {
                t ? Q(e.DEPTH_TEST) : G(e.DEPTH_TEST);
              },
              setMask: function (t) {
                r === t || n || (e.depthMask(t), (r = t));
              },
              setFunc: function (t) {
                if ((i && (t = eu[t]), s !== t)) {
                  switch (t) {
                    case 0:
                      e.depthFunc(e.NEVER);
                      break;
                    case 1:
                      e.depthFunc(e.ALWAYS);
                      break;
                    case 2:
                      e.depthFunc(e.LESS);
                      break;
                    case 3:
                    default:
                      e.depthFunc(e.LEQUAL);
                      break;
                    case 4:
                      e.depthFunc(e.EQUAL);
                      break;
                    case 5:
                      e.depthFunc(e.GEQUAL);
                      break;
                    case 6:
                      e.depthFunc(e.GREATER);
                      break;
                    case 7:
                      e.depthFunc(e.NOTEQUAL);
                  }
                  s = t;
                }
              },
              setLocked: function (e) {
                n = e;
              },
              setClear: function (t) {
                a !== t && (i && (t = 1 - t), e.clearDepth(t), (a = t));
              },
              reset: function () {
                (n = !1), (r = null), (s = null), (a = null), (i = !1);
              },
            };
          })(),
          r = new (function () {
            let t = !1,
              n = null,
              i = null,
              r = null,
              s = null,
              a = null,
              o = null,
              c = null,
              l = null;
            return {
              setTest: function (n) {
                t || (n ? Q(e.STENCIL_TEST) : G(e.STENCIL_TEST));
              },
              setMask: function (i) {
                n === i || t || (e.stencilMask(i), (n = i));
              },
              setFunc: function (t, n, a) {
                (i === t && r === n && s === a) ||
                  (e.stencilFunc(t, n, a), (i = t), (r = n), (s = a));
              },
              setOp: function (t, n, i) {
                (a === t && o === n && c === i) ||
                  (e.stencilOp(t, n, i), (a = t), (o = n), (c = i));
              },
              setLocked: function (e) {
                t = e;
              },
              setClear: function (t) {
                l !== t && (e.clearStencil(t), (l = t));
              },
              reset: function () {
                (t = !1),
                  (n = null),
                  (i = null),
                  (r = null),
                  (s = null),
                  (a = null),
                  (o = null),
                  (c = null),
                  (l = null);
              },
            };
          })(),
          s = new WeakMap(),
          a = new WeakMap();
        let o = {},
          c = {},
          l = new WeakMap(),
          u = [],
          h = null,
          d = !1,
          p = null,
          f = null,
          A = null,
          g = null,
          m = null,
          v = null,
          y = null,
          b = new ma(0, 0, 0),
          _ = 0,
          x = !1,
          E = null,
          w = null,
          C = null,
          S = null,
          I = null;
        const M = e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        let T = !1,
          B = 0;
        const R = e.getParameter(e.VERSION);
        -1 !== R.indexOf("WebGL")
          ? ((B = parseFloat(/^WebGL (\d)/.exec(R)[1])), (T = B >= 1))
          : -1 !== R.indexOf("OpenGL ES") &&
            ((B = parseFloat(/^OpenGL ES (\d)/.exec(R)[1])), (T = B >= 2));
        let D = null,
          P = {};
        const L = e.getParameter(e.SCISSOR_BOX),
          U = e.getParameter(e.VIEWPORT),
          F = new zr().fromArray(L),
          O = new zr().fromArray(U);
        function N(t, n, i, r) {
          const s = new Uint8Array(4),
            a = e.createTexture();
          e.bindTexture(t, a),
            e.texParameteri(t, e.TEXTURE_MIN_FILTER, e.NEAREST),
            e.texParameteri(t, e.TEXTURE_MAG_FILTER, e.NEAREST);
          for (let a = 0; a < i; a++)
            t === e.TEXTURE_3D || t === e.TEXTURE_2D_ARRAY
              ? e.texImage3D(
                  n,
                  0,
                  e.RGBA,
                  1,
                  1,
                  r,
                  0,
                  e.RGBA,
                  e.UNSIGNED_BYTE,
                  s
                )
              : e.texImage2D(
                  n + a,
                  0,
                  e.RGBA,
                  1,
                  1,
                  0,
                  e.RGBA,
                  e.UNSIGNED_BYTE,
                  s
                );
          return a;
        }
        const k = {};
        function Q(t) {
          !0 !== o[t] && (e.enable(t), (o[t] = !0));
        }
        function G(t) {
          !1 !== o[t] && (e.disable(t), (o[t] = !1));
        }
        (k[e.TEXTURE_2D] = N(e.TEXTURE_2D, e.TEXTURE_2D, 1)),
          (k[e.TEXTURE_CUBE_MAP] = N(
            e.TEXTURE_CUBE_MAP,
            e.TEXTURE_CUBE_MAP_POSITIVE_X,
            6
          )),
          (k[e.TEXTURE_2D_ARRAY] = N(
            e.TEXTURE_2D_ARRAY,
            e.TEXTURE_2D_ARRAY,
            1,
            1
          )),
          (k[e.TEXTURE_3D] = N(e.TEXTURE_3D, e.TEXTURE_3D, 1, 1)),
          n.setClear(0, 0, 0, 1),
          i.setClear(1),
          r.setClear(0),
          Q(e.DEPTH_TEST),
          i.setFunc(3),
          j(!1),
          W(1),
          Q(e.CULL_FACE),
          V(0);
        const H = {
          [hn]: e.FUNC_ADD,
          101: e.FUNC_SUBTRACT,
          102: e.FUNC_REVERSE_SUBTRACT,
        };
        (H[103] = e.MIN), (H[104] = e.MAX);
        const z = {
          200: e.ZERO,
          201: e.ONE,
          202: e.SRC_COLOR,
          204: e.SRC_ALPHA,
          210: e.SRC_ALPHA_SATURATE,
          208: e.DST_COLOR,
          206: e.DST_ALPHA,
          203: e.ONE_MINUS_SRC_COLOR,
          205: e.ONE_MINUS_SRC_ALPHA,
          209: e.ONE_MINUS_DST_COLOR,
          207: e.ONE_MINUS_DST_ALPHA,
          211: e.CONSTANT_COLOR,
          212: e.ONE_MINUS_CONSTANT_COLOR,
          213: e.CONSTANT_ALPHA,
          214: e.ONE_MINUS_CONSTANT_ALPHA,
        };
        function V(t, n, i, r, s, a, o, c, l, u) {
          if (0 !== t) {
            if ((!1 === d && (Q(e.BLEND), (d = !0)), 5 === t))
              (s = s || n),
                (a = a || i),
                (o = o || r),
                (n === f && s === m) ||
                  (e.blendEquationSeparate(H[n], H[s]), (f = n), (m = s)),
                (i === A && r === g && a === v && o === y) ||
                  (e.blendFuncSeparate(z[i], z[r], z[a], z[o]),
                  (A = i),
                  (g = r),
                  (v = a),
                  (y = o)),
                (!1 !== c.equals(b) && l === _) ||
                  (e.blendColor(c.r, c.g, c.b, l), b.copy(c), (_ = l)),
                (p = t),
                (x = !1);
            else if (t !== p || u !== x) {
              if (
                ((f === hn && m === hn) ||
                  (e.blendEquation(e.FUNC_ADD), (f = hn), (m = hn)),
                u)
              )
                switch (t) {
                  case 1:
                    e.blendFuncSeparate(
                      e.ONE,
                      e.ONE_MINUS_SRC_ALPHA,
                      e.ONE,
                      e.ONE_MINUS_SRC_ALPHA
                    );
                    break;
                  case 2:
                    e.blendFunc(e.ONE, e.ONE);
                    break;
                  case 3:
                    e.blendFuncSeparate(
                      e.ZERO,
                      e.ONE_MINUS_SRC_COLOR,
                      e.ZERO,
                      e.ONE
                    );
                    break;
                  case 4:
                    e.blendFuncSeparate(
                      e.ZERO,
                      e.SRC_COLOR,
                      e.ZERO,
                      e.SRC_ALPHA
                    );
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", t);
                }
              else
                switch (t) {
                  case 1:
                    e.blendFuncSeparate(
                      e.SRC_ALPHA,
                      e.ONE_MINUS_SRC_ALPHA,
                      e.ONE,
                      e.ONE_MINUS_SRC_ALPHA
                    );
                    break;
                  case 2:
                    e.blendFunc(e.SRC_ALPHA, e.ONE);
                    break;
                  case 3:
                    e.blendFuncSeparate(
                      e.ZERO,
                      e.ONE_MINUS_SRC_COLOR,
                      e.ZERO,
                      e.ONE
                    );
                    break;
                  case 4:
                    e.blendFunc(e.ZERO, e.SRC_COLOR);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", t);
                }
              (A = null),
                (g = null),
                (v = null),
                (y = null),
                b.set(0, 0, 0),
                (_ = 0),
                (p = t),
                (x = u);
            }
          } else !0 === d && (G(e.BLEND), (d = !1));
        }
        function j(t) {
          E !== t && (t ? e.frontFace(e.CW) : e.frontFace(e.CCW), (E = t));
        }
        function W(t) {
          0 !== t
            ? (Q(e.CULL_FACE),
              t !== w &&
                (1 === t
                  ? e.cullFace(e.BACK)
                  : 2 === t
                  ? e.cullFace(e.FRONT)
                  : e.cullFace(e.FRONT_AND_BACK)))
            : G(e.CULL_FACE),
            (w = t);
        }
        function X(t, n, i) {
          t
            ? (Q(e.POLYGON_OFFSET_FILL),
              (S === n && I === i) || (e.polygonOffset(n, i), (S = n), (I = i)))
            : G(e.POLYGON_OFFSET_FILL);
        }
        return {
          buffers: { color: n, depth: i, stencil: r },
          enable: Q,
          disable: G,
          bindFramebuffer: function (t, n) {
            return (
              c[t] !== n &&
              (e.bindFramebuffer(t, n),
              (c[t] = n),
              t === e.DRAW_FRAMEBUFFER && (c[e.FRAMEBUFFER] = n),
              t === e.FRAMEBUFFER && (c[e.DRAW_FRAMEBUFFER] = n),
              !0)
            );
          },
          drawBuffers: function (t, n) {
            let i = u,
              r = !1;
            if (t) {
              (i = l.get(n)), void 0 === i && ((i = []), l.set(n, i));
              const s = t.textures;
              if (i.length !== s.length || i[0] !== e.COLOR_ATTACHMENT0) {
                for (let t = 0, n = s.length; t < n; t++)
                  i[t] = e.COLOR_ATTACHMENT0 + t;
                (i.length = s.length), (r = !0);
              }
            } else i[0] !== e.BACK && ((i[0] = e.BACK), (r = !0));
            r && e.drawBuffers(i);
          },
          useProgram: function (t) {
            return h !== t && (e.useProgram(t), (h = t), !0);
          },
          setBlending: V,
          setMaterial: function (t, s) {
            t.side === un ? G(e.CULL_FACE) : Q(e.CULL_FACE);
            let a = t.side === ln;
            s && (a = !a),
              j(a),
              1 === t.blending && !1 === t.transparent
                ? V(0)
                : V(
                    t.blending,
                    t.blendEquation,
                    t.blendSrc,
                    t.blendDst,
                    t.blendEquationAlpha,
                    t.blendSrcAlpha,
                    t.blendDstAlpha,
                    t.blendColor,
                    t.blendAlpha,
                    t.premultipliedAlpha
                  ),
              i.setFunc(t.depthFunc),
              i.setTest(t.depthTest),
              i.setMask(t.depthWrite),
              n.setMask(t.colorWrite);
            const o = t.stencilWrite;
            r.setTest(o),
              o &&
                (r.setMask(t.stencilWriteMask),
                r.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),
                r.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
              X(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits),
              !0 === t.alphaToCoverage
                ? Q(e.SAMPLE_ALPHA_TO_COVERAGE)
                : G(e.SAMPLE_ALPHA_TO_COVERAGE);
          },
          setFlipSided: j,
          setCullFace: W,
          setLineWidth: function (t) {
            t !== C && (T && e.lineWidth(t), (C = t));
          },
          setPolygonOffset: X,
          setScissorTest: function (t) {
            t ? Q(e.SCISSOR_TEST) : G(e.SCISSOR_TEST);
          },
          activeTexture: function (t) {
            void 0 === t && (t = e.TEXTURE0 + M - 1),
              D !== t && (e.activeTexture(t), (D = t));
          },
          bindTexture: function (t, n, i) {
            void 0 === i && (i = null === D ? e.TEXTURE0 + M - 1 : D);
            let r = P[i];
            void 0 === r &&
              ((r = { type: void 0, texture: void 0 }), (P[i] = r)),
              (r.type === t && r.texture === n) ||
                (D !== i && (e.activeTexture(i), (D = i)),
                e.bindTexture(t, n || k[t]),
                (r.type = t),
                (r.texture = n));
          },
          unbindTexture: function () {
            const t = P[D];
            void 0 !== t &&
              void 0 !== t.type &&
              (e.bindTexture(t.type, null),
              (t.type = void 0),
              (t.texture = void 0));
          },
          compressedTexImage2D: function () {
            try {
              e.compressedTexImage2D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          compressedTexImage3D: function () {
            try {
              e.compressedTexImage3D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          texImage2D: function () {
            try {
              e.texImage2D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          texImage3D: function () {
            try {
              e.texImage3D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          updateUBOMapping: function (t, n) {
            let i = a.get(n);
            void 0 === i && ((i = new WeakMap()), a.set(n, i));
            let r = i.get(t);
            void 0 === r &&
              ((r = e.getUniformBlockIndex(n, t.name)), i.set(t, r));
          },
          uniformBlockBinding: function (t, n) {
            const i = a.get(n).get(t);
            s.get(n) !== i &&
              (e.uniformBlockBinding(n, i, t.__bindingPointIndex), s.set(n, i));
          },
          texStorage2D: function () {
            try {
              e.texStorage2D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          texStorage3D: function () {
            try {
              e.texStorage3D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          texSubImage2D: function () {
            try {
              e.texSubImage2D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          texSubImage3D: function () {
            try {
              e.texSubImage3D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          compressedTexSubImage2D: function () {
            try {
              e.compressedTexSubImage2D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          compressedTexSubImage3D: function () {
            try {
              e.compressedTexSubImage3D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          scissor: function (t) {
            !1 === F.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), F.copy(t));
          },
          viewport: function (t) {
            !1 === O.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), O.copy(t));
          },
          reset: function () {
            e.disable(e.BLEND),
              e.disable(e.CULL_FACE),
              e.disable(e.DEPTH_TEST),
              e.disable(e.POLYGON_OFFSET_FILL),
              e.disable(e.SCISSOR_TEST),
              e.disable(e.STENCIL_TEST),
              e.disable(e.SAMPLE_ALPHA_TO_COVERAGE),
              e.blendEquation(e.FUNC_ADD),
              e.blendFunc(e.ONE, e.ZERO),
              e.blendFuncSeparate(e.ONE, e.ZERO, e.ONE, e.ZERO),
              e.blendColor(0, 0, 0, 0),
              e.colorMask(!0, !0, !0, !0),
              e.clearColor(0, 0, 0, 0),
              e.depthMask(!0),
              e.depthFunc(e.LESS),
              i.setReversed(!1),
              e.clearDepth(1),
              e.stencilMask(4294967295),
              e.stencilFunc(e.ALWAYS, 0, 4294967295),
              e.stencilOp(e.KEEP, e.KEEP, e.KEEP),
              e.clearStencil(0),
              e.cullFace(e.BACK),
              e.frontFace(e.CCW),
              e.polygonOffset(0, 0),
              e.activeTexture(e.TEXTURE0),
              e.bindFramebuffer(e.FRAMEBUFFER, null),
              e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
              e.bindFramebuffer(e.READ_FRAMEBUFFER, null),
              e.useProgram(null),
              e.lineWidth(1),
              e.scissor(0, 0, e.canvas.width, e.canvas.height),
              e.viewport(0, 0, e.canvas.width, e.canvas.height),
              (o = {}),
              (D = null),
              (P = {}),
              (c = {}),
              (l = new WeakMap()),
              (u = []),
              (h = null),
              (d = !1),
              (p = null),
              (f = null),
              (A = null),
              (g = null),
              (m = null),
              (v = null),
              (y = null),
              (b = new ma(0, 0, 0)),
              (_ = 0),
              (x = !1),
              (E = null),
              (w = null),
              (C = null),
              (S = null),
              (I = null),
              F.set(0, 0, e.canvas.width, e.canvas.height),
              O.set(0, 0, e.canvas.width, e.canvas.height),
              n.reset(),
              i.reset(),
              r.reset();
          },
        };
      }
      function nu(e, t, n, i) {
        const r = (function (e) {
          switch (e) {
            case Nn:
            case kn:
              return { byteLength: 1, components: 1 };
            case Gn:
            case Qn:
            case jn:
              return { byteLength: 2, components: 1 };
            case Wn:
            case Xn:
              return { byteLength: 2, components: 4 };
            case zn:
            case Hn:
            case Vn:
              return { byteLength: 4, components: 1 };
            case Yn:
              return { byteLength: 4, components: 3 };
          }
          throw new Error(`Unknown texture type ${e}.`);
        })(i);
        switch (n) {
          case Kn:
          case $n:
            return e * t;
          case ei:
            return e * t * 2;
          case ii:
          case ri:
            return ((e * t) / r.components) * r.byteLength;
          case si:
          case ai:
            return ((e * t * 2) / r.components) * r.byteLength;
          case Jn:
            return ((e * t * 3) / r.components) * r.byteLength;
          case Zn:
          case oi:
            return ((e * t * 4) / r.components) * r.byteLength;
          case ci:
          case li:
            return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 8;
          case ui:
          case hi:
            return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16;
          case pi:
          case Ai:
            return (Math.max(e, 16) * Math.max(t, 8)) / 4;
          case di:
          case fi:
            return (Math.max(e, 8) * Math.max(t, 8)) / 2;
          case gi:
          case mi:
            return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 8;
          case vi:
          case yi:
            return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16;
          case bi:
            return Math.floor((e + 4) / 5) * Math.floor((t + 3) / 4) * 16;
          case _i:
            return Math.floor((e + 4) / 5) * Math.floor((t + 4) / 5) * 16;
          case xi:
            return Math.floor((e + 5) / 6) * Math.floor((t + 4) / 5) * 16;
          case Ei:
            return Math.floor((e + 5) / 6) * Math.floor((t + 5) / 6) * 16;
          case wi:
            return Math.floor((e + 7) / 8) * Math.floor((t + 4) / 5) * 16;
          case Ci:
            return Math.floor((e + 7) / 8) * Math.floor((t + 5) / 6) * 16;
          case Si:
            return Math.floor((e + 7) / 8) * Math.floor((t + 7) / 8) * 16;
          case Ii:
            return Math.floor((e + 9) / 10) * Math.floor((t + 4) / 5) * 16;
          case Mi:
            return Math.floor((e + 9) / 10) * Math.floor((t + 5) / 6) * 16;
          case Ti:
            return Math.floor((e + 9) / 10) * Math.floor((t + 7) / 8) * 16;
          case Bi:
            return Math.floor((e + 9) / 10) * Math.floor((t + 9) / 10) * 16;
          case Ri:
            return Math.floor((e + 11) / 12) * Math.floor((t + 9) / 10) * 16;
          case Di:
            return Math.floor((e + 11) / 12) * Math.floor((t + 11) / 12) * 16;
          case Pi:
          case Li:
          case Ui:
            return Math.ceil(e / 4) * Math.ceil(t / 4) * 16;
          case Fi:
          case Oi:
            return Math.ceil(e / 4) * Math.ceil(t / 4) * 8;
          case Ni:
          case ki:
            return Math.ceil(e / 4) * Math.ceil(t / 4) * 16;
        }
        throw new Error(
          `Unable to determine texture byte length for ${n} format.`
        );
      }
      function iu(e, t, n, i, r, s, a) {
        const o = t.has("WEBGL_multisampled_render_to_texture")
            ? t.get("WEBGL_multisampled_render_to_texture")
            : null,
          c =
            "undefined" != typeof navigator &&
            /OculusBrowser/g.test(navigator.userAgent),
          l = new br(),
          u = new WeakMap();
        let h;
        const d = new WeakMap();
        let p = !1;
        try {
          p =
            "undefined" != typeof OffscreenCanvas &&
            null !== new OffscreenCanvas(1, 1).getContext("2d");
        } catch (e) {}
        function f(e, t) {
          return p ? new OffscreenCanvas(e, t) : wr("canvas");
        }
        function A(e, t, n) {
          let i = 1;
          const r = G(e);
          if (
            ((r.width > n || r.height > n) &&
              (i = n / Math.max(r.width, r.height)),
            i < 1)
          ) {
            if (
              ("undefined" != typeof HTMLImageElement &&
                e instanceof HTMLImageElement) ||
              ("undefined" != typeof HTMLCanvasElement &&
                e instanceof HTMLCanvasElement) ||
              ("undefined" != typeof ImageBitmap && e instanceof ImageBitmap) ||
              ("undefined" != typeof VideoFrame && e instanceof VideoFrame)
            ) {
              const n = Math.floor(i * r.width),
                s = Math.floor(i * r.height);
              void 0 === h && (h = f(n, s));
              const a = t ? f(n, s) : h;
              (a.width = n), (a.height = s);
              return (
                a.getContext("2d").drawImage(e, 0, 0, n, s),
                console.warn(
                  "THREE.WebGLRenderer: Texture has been resized from (" +
                    r.width +
                    "x" +
                    r.height +
                    ") to (" +
                    n +
                    "x" +
                    s +
                    ")."
                ),
                a
              );
            }
            return (
              "data" in e &&
                console.warn(
                  "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                    r.width +
                    "x" +
                    r.height +
                    ")."
                ),
              e
            );
          }
          return e;
        }
        function g(e) {
          return e.generateMipmaps;
        }
        function m(t) {
          e.generateMipmap(t);
        }
        function v(t) {
          return t.isWebGLCubeRenderTarget
            ? e.TEXTURE_CUBE_MAP
            : t.isWebGL3DRenderTarget
            ? e.TEXTURE_3D
            : t.isWebGLArrayRenderTarget || t.isCompressedArrayTexture
            ? e.TEXTURE_2D_ARRAY
            : e.TEXTURE_2D;
        }
        function y(n, i, r, s, a = !1) {
          if (null !== n) {
            if (void 0 !== e[n]) return e[n];
            console.warn(
              "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
                n +
                "'"
            );
          }
          let o = i;
          if (
            (i === e.RED &&
              (r === e.FLOAT && (o = e.R32F),
              r === e.HALF_FLOAT && (o = e.R16F),
              r === e.UNSIGNED_BYTE && (o = e.R8)),
            i === e.RED_INTEGER &&
              (r === e.UNSIGNED_BYTE && (o = e.R8UI),
              r === e.UNSIGNED_SHORT && (o = e.R16UI),
              r === e.UNSIGNED_INT && (o = e.R32UI),
              r === e.BYTE && (o = e.R8I),
              r === e.SHORT && (o = e.R16I),
              r === e.INT && (o = e.R32I)),
            i === e.RG &&
              (r === e.FLOAT && (o = e.RG32F),
              r === e.HALF_FLOAT && (o = e.RG16F),
              r === e.UNSIGNED_BYTE && (o = e.RG8)),
            i === e.RG_INTEGER &&
              (r === e.UNSIGNED_BYTE && (o = e.RG8UI),
              r === e.UNSIGNED_SHORT && (o = e.RG16UI),
              r === e.UNSIGNED_INT && (o = e.RG32UI),
              r === e.BYTE && (o = e.RG8I),
              r === e.SHORT && (o = e.RG16I),
              r === e.INT && (o = e.RG32I)),
            i === e.RGB_INTEGER &&
              (r === e.UNSIGNED_BYTE && (o = e.RGB8UI),
              r === e.UNSIGNED_SHORT && (o = e.RGB16UI),
              r === e.UNSIGNED_INT && (o = e.RGB32UI),
              r === e.BYTE && (o = e.RGB8I),
              r === e.SHORT && (o = e.RGB16I),
              r === e.INT && (o = e.RGB32I)),
            i === e.RGBA_INTEGER &&
              (r === e.UNSIGNED_BYTE && (o = e.RGBA8UI),
              r === e.UNSIGNED_SHORT && (o = e.RGBA16UI),
              r === e.UNSIGNED_INT && (o = e.RGBA32UI),
              r === e.BYTE && (o = e.RGBA8I),
              r === e.SHORT && (o = e.RGBA16I),
              r === e.INT && (o = e.RGBA32I)),
            i === e.RGB && r === e.UNSIGNED_INT_5_9_9_9_REV && (o = e.RGB9_E5),
            i === e.RGBA)
          ) {
            const t = a ? er : Mr.getTransfer(s);
            r === e.FLOAT && (o = e.RGBA32F),
              r === e.HALF_FLOAT && (o = e.RGBA16F),
              r === e.UNSIGNED_BYTE &&
                (o = t === tr ? e.SRGB8_ALPHA8 : e.RGBA8),
              r === e.UNSIGNED_SHORT_4_4_4_4 && (o = e.RGBA4),
              r === e.UNSIGNED_SHORT_5_5_5_1 && (o = e.RGB5_A1);
          }
          return (
            (o !== e.R16F &&
              o !== e.R32F &&
              o !== e.RG16F &&
              o !== e.RG32F &&
              o !== e.RGBA16F &&
              o !== e.RGBA32F) ||
              t.get("EXT_color_buffer_float"),
            o
          );
        }
        function b(t, n) {
          let i;
          return (
            t
              ? null === n || n === zn || n === qn
                ? (i = e.DEPTH24_STENCIL8)
                : n === Vn
                ? (i = e.DEPTH32F_STENCIL8)
                : n === Gn &&
                  ((i = e.DEPTH24_STENCIL8),
                  console.warn(
                    "DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment."
                  ))
              : null === n || n === zn || n === qn
              ? (i = e.DEPTH_COMPONENT24)
              : n === Vn
              ? (i = e.DEPTH_COMPONENT32F)
              : n === Gn && (i = e.DEPTH_COMPONENT16),
            i
          );
        }
        function _(e, t) {
          return !0 === g(e) ||
            (e.isFramebufferTexture && e.minFilter !== Dn && e.minFilter !== Un)
            ? Math.log2(Math.max(t.width, t.height)) + 1
            : void 0 !== e.mipmaps && e.mipmaps.length > 0
            ? e.mipmaps.length
            : e.isCompressedTexture && Array.isArray(e.image)
            ? t.mipmaps.length
            : 1;
        }
        function x(e) {
          const t = e.target;
          t.removeEventListener("dispose", x),
            (function (e) {
              const t = i.get(e);
              if (void 0 === t.__webglInit) return;
              const n = e.source,
                r = d.get(n);
              if (r) {
                const i = r[t.__cacheKey];
                i.usedTimes--,
                  0 === i.usedTimes && w(e),
                  0 === Object.keys(r).length && d.delete(n);
              }
              i.remove(e);
            })(t),
            t.isVideoTexture && u.delete(t);
        }
        function E(t) {
          const n = t.target;
          n.removeEventListener("dispose", E),
            (function (t) {
              const n = i.get(t);
              t.depthTexture &&
                (t.depthTexture.dispose(), i.remove(t.depthTexture));
              if (t.isWebGLCubeRenderTarget)
                for (let t = 0; t < 6; t++) {
                  if (Array.isArray(n.__webglFramebuffer[t]))
                    for (let i = 0; i < n.__webglFramebuffer[t].length; i++)
                      e.deleteFramebuffer(n.__webglFramebuffer[t][i]);
                  else e.deleteFramebuffer(n.__webglFramebuffer[t]);
                  n.__webglDepthbuffer &&
                    e.deleteRenderbuffer(n.__webglDepthbuffer[t]);
                }
              else {
                if (Array.isArray(n.__webglFramebuffer))
                  for (let t = 0; t < n.__webglFramebuffer.length; t++)
                    e.deleteFramebuffer(n.__webglFramebuffer[t]);
                else e.deleteFramebuffer(n.__webglFramebuffer);
                if (
                  (n.__webglDepthbuffer &&
                    e.deleteRenderbuffer(n.__webglDepthbuffer),
                  n.__webglMultisampledFramebuffer &&
                    e.deleteFramebuffer(n.__webglMultisampledFramebuffer),
                  n.__webglColorRenderbuffer)
                )
                  for (let t = 0; t < n.__webglColorRenderbuffer.length; t++)
                    n.__webglColorRenderbuffer[t] &&
                      e.deleteRenderbuffer(n.__webglColorRenderbuffer[t]);
                n.__webglDepthRenderbuffer &&
                  e.deleteRenderbuffer(n.__webglDepthRenderbuffer);
              }
              const r = t.textures;
              for (let t = 0, n = r.length; t < n; t++) {
                const n = i.get(r[t]);
                n.__webglTexture &&
                  (e.deleteTexture(n.__webglTexture), a.memory.textures--),
                  i.remove(r[t]);
              }
              i.remove(t);
            })(n);
        }
        function w(t) {
          const n = i.get(t);
          e.deleteTexture(n.__webglTexture);
          const r = t.source;
          delete d.get(r)[n.__cacheKey], a.memory.textures--;
        }
        let C = 0;
        function S(t, r) {
          const s = i.get(t);
          if (
            (t.isVideoTexture &&
              (function (e) {
                const t = a.render.frame;
                u.get(e) !== t && (u.set(e, t), e.update());
              })(t),
            !1 === t.isRenderTargetTexture &&
              t.version > 0 &&
              s.__version !== t.version)
          ) {
            const e = t.image;
            if (null === e)
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but no image data found."
              );
            else {
              if (!1 !== e.complete) return void D(s, t, r);
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
              );
            }
          }
          n.bindTexture(e.TEXTURE_2D, s.__webglTexture, e.TEXTURE0 + r);
        }
        const I = {
            [Tn]: e.REPEAT,
            [Bn]: e.CLAMP_TO_EDGE,
            [Rn]: e.MIRRORED_REPEAT,
          },
          M = {
            [Dn]: e.NEAREST,
            [Pn]: e.NEAREST_MIPMAP_NEAREST,
            [Ln]: e.NEAREST_MIPMAP_LINEAR,
            [Un]: e.LINEAR,
            [Fn]: e.LINEAR_MIPMAP_NEAREST,
            [On]: e.LINEAR_MIPMAP_LINEAR,
          },
          T = {
            512: e.NEVER,
            519: e.ALWAYS,
            513: e.LESS,
            [ir]: e.LEQUAL,
            514: e.EQUAL,
            518: e.GEQUAL,
            516: e.GREATER,
            517: e.NOTEQUAL,
          };
        function B(n, s) {
          if (
            (s.type !== Vn ||
              !1 !== t.has("OES_texture_float_linear") ||
              (s.magFilter !== Un &&
                s.magFilter !== Fn &&
                s.magFilter !== Ln &&
                s.magFilter !== On &&
                s.minFilter !== Un &&
                s.minFilter !== Fn &&
                s.minFilter !== Ln &&
                s.minFilter !== On) ||
              console.warn(
                "THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."
              ),
            e.texParameteri(n, e.TEXTURE_WRAP_S, I[s.wrapS]),
            e.texParameteri(n, e.TEXTURE_WRAP_T, I[s.wrapT]),
            (n !== e.TEXTURE_3D && n !== e.TEXTURE_2D_ARRAY) ||
              e.texParameteri(n, e.TEXTURE_WRAP_R, I[s.wrapR]),
            e.texParameteri(n, e.TEXTURE_MAG_FILTER, M[s.magFilter]),
            e.texParameteri(n, e.TEXTURE_MIN_FILTER, M[s.minFilter]),
            s.compareFunction &&
              (e.texParameteri(
                n,
                e.TEXTURE_COMPARE_MODE,
                e.COMPARE_REF_TO_TEXTURE
              ),
              e.texParameteri(n, e.TEXTURE_COMPARE_FUNC, T[s.compareFunction])),
            !0 === t.has("EXT_texture_filter_anisotropic"))
          ) {
            if (s.magFilter === Dn) return;
            if (s.minFilter !== Ln && s.minFilter !== On) return;
            if (s.type === Vn && !1 === t.has("OES_texture_float_linear"))
              return;
            if (s.anisotropy > 1 || i.get(s).__currentAnisotropy) {
              const a = t.get("EXT_texture_filter_anisotropic");
              e.texParameterf(
                n,
                a.TEXTURE_MAX_ANISOTROPY_EXT,
                Math.min(s.anisotropy, r.getMaxAnisotropy())
              ),
                (i.get(s).__currentAnisotropy = s.anisotropy);
            }
          }
        }
        function R(t, n) {
          let i = !1;
          void 0 === t.__webglInit &&
            ((t.__webglInit = !0), n.addEventListener("dispose", x));
          const r = n.source;
          let s = d.get(r);
          void 0 === s && ((s = {}), d.set(r, s));
          const o = (function (e) {
            const t = [];
            return (
              t.push(e.wrapS),
              t.push(e.wrapT),
              t.push(e.wrapR || 0),
              t.push(e.magFilter),
              t.push(e.minFilter),
              t.push(e.anisotropy),
              t.push(e.internalFormat),
              t.push(e.format),
              t.push(e.type),
              t.push(e.generateMipmaps),
              t.push(e.premultiplyAlpha),
              t.push(e.flipY),
              t.push(e.unpackAlignment),
              t.push(e.colorSpace),
              t.join()
            );
          })(n);
          if (o !== t.__cacheKey) {
            void 0 === s[o] &&
              ((s[o] = { texture: e.createTexture(), usedTimes: 0 }),
              a.memory.textures++,
              (i = !0)),
              s[o].usedTimes++;
            const r = s[t.__cacheKey];
            void 0 !== r &&
              (s[t.__cacheKey].usedTimes--, 0 === r.usedTimes && w(n)),
              (t.__cacheKey = o),
              (t.__webglTexture = s[o].texture);
          }
          return i;
        }
        function D(t, a, o) {
          let c = e.TEXTURE_2D;
          (a.isDataArrayTexture || a.isCompressedArrayTexture) &&
            (c = e.TEXTURE_2D_ARRAY),
            a.isData3DTexture && (c = e.TEXTURE_3D);
          const l = R(t, a),
            u = a.source;
          n.bindTexture(c, t.__webglTexture, e.TEXTURE0 + o);
          const h = i.get(u);
          if (u.version !== h.__version || !0 === l) {
            n.activeTexture(e.TEXTURE0 + o);
            const t = Mr.getPrimaries(Mr.workingColorSpace),
              i = a.colorSpace === Ji ? null : Mr.getPrimaries(a.colorSpace),
              d =
                a.colorSpace === Ji || t === i
                  ? e.NONE
                  : e.BROWSER_DEFAULT_WEBGL;
            e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, a.flipY),
              e.pixelStorei(
                e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                a.premultiplyAlpha
              ),
              e.pixelStorei(e.UNPACK_ALIGNMENT, a.unpackAlignment),
              e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, d);
            let p = A(a.image, !1, r.maxTextureSize);
            p = Q(a, p);
            const f = s.convert(a.format, a.colorSpace),
              v = s.convert(a.type);
            let x,
              E = y(a.internalFormat, f, v, a.colorSpace, a.isVideoTexture);
            B(c, a);
            const w = a.mipmaps,
              C = !0 !== a.isVideoTexture,
              S = void 0 === h.__version || !0 === l,
              I = u.dataReady,
              M = _(a, p);
            if (a.isDepthTexture)
              (E = b(a.format === ni, a.type)),
                S &&
                  (C
                    ? n.texStorage2D(e.TEXTURE_2D, 1, E, p.width, p.height)
                    : n.texImage2D(
                        e.TEXTURE_2D,
                        0,
                        E,
                        p.width,
                        p.height,
                        0,
                        f,
                        v,
                        null
                      ));
            else if (a.isDataTexture)
              if (w.length > 0) {
                C &&
                  S &&
                  n.texStorage2D(e.TEXTURE_2D, M, E, w[0].width, w[0].height);
                for (let t = 0, i = w.length; t < i; t++)
                  (x = w[t]),
                    C
                      ? I &&
                        n.texSubImage2D(
                          e.TEXTURE_2D,
                          t,
                          0,
                          0,
                          x.width,
                          x.height,
                          f,
                          v,
                          x.data
                        )
                      : n.texImage2D(
                          e.TEXTURE_2D,
                          t,
                          E,
                          x.width,
                          x.height,
                          0,
                          f,
                          v,
                          x.data
                        );
                a.generateMipmaps = !1;
              } else
                C
                  ? (S && n.texStorage2D(e.TEXTURE_2D, M, E, p.width, p.height),
                    I &&
                      n.texSubImage2D(
                        e.TEXTURE_2D,
                        0,
                        0,
                        0,
                        p.width,
                        p.height,
                        f,
                        v,
                        p.data
                      ))
                  : n.texImage2D(
                      e.TEXTURE_2D,
                      0,
                      E,
                      p.width,
                      p.height,
                      0,
                      f,
                      v,
                      p.data
                    );
            else if (a.isCompressedTexture)
              if (a.isCompressedArrayTexture) {
                C &&
                  S &&
                  n.texStorage3D(
                    e.TEXTURE_2D_ARRAY,
                    M,
                    E,
                    w[0].width,
                    w[0].height,
                    p.depth
                  );
                for (let t = 0, i = w.length; t < i; t++)
                  if (((x = w[t]), a.format !== Zn))
                    if (null !== f)
                      if (C) {
                        if (I)
                          if (a.layerUpdates.size > 0) {
                            const i = nu(x.width, x.height, a.format, a.type);
                            for (const r of a.layerUpdates) {
                              const s = x.data.subarray(
                                (r * i) / x.data.BYTES_PER_ELEMENT,
                                ((r + 1) * i) / x.data.BYTES_PER_ELEMENT
                              );
                              n.compressedTexSubImage3D(
                                e.TEXTURE_2D_ARRAY,
                                t,
                                0,
                                0,
                                r,
                                x.width,
                                x.height,
                                1,
                                f,
                                s
                              );
                            }
                            a.clearLayerUpdates();
                          } else
                            n.compressedTexSubImage3D(
                              e.TEXTURE_2D_ARRAY,
                              t,
                              0,
                              0,
                              0,
                              x.width,
                              x.height,
                              p.depth,
                              f,
                              x.data
                            );
                      } else
                        n.compressedTexImage3D(
                          e.TEXTURE_2D_ARRAY,
                          t,
                          E,
                          x.width,
                          x.height,
                          p.depth,
                          0,
                          x.data,
                          0,
                          0
                        );
                    else
                      console.warn(
                        "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                      );
                  else
                    C
                      ? I &&
                        n.texSubImage3D(
                          e.TEXTURE_2D_ARRAY,
                          t,
                          0,
                          0,
                          0,
                          x.width,
                          x.height,
                          p.depth,
                          f,
                          v,
                          x.data
                        )
                      : n.texImage3D(
                          e.TEXTURE_2D_ARRAY,
                          t,
                          E,
                          x.width,
                          x.height,
                          p.depth,
                          0,
                          f,
                          v,
                          x.data
                        );
              } else {
                C &&
                  S &&
                  n.texStorage2D(e.TEXTURE_2D, M, E, w[0].width, w[0].height);
                for (let t = 0, i = w.length; t < i; t++)
                  (x = w[t]),
                    a.format !== Zn
                      ? null !== f
                        ? C
                          ? I &&
                            n.compressedTexSubImage2D(
                              e.TEXTURE_2D,
                              t,
                              0,
                              0,
                              x.width,
                              x.height,
                              f,
                              x.data
                            )
                          : n.compressedTexImage2D(
                              e.TEXTURE_2D,
                              t,
                              E,
                              x.width,
                              x.height,
                              0,
                              x.data
                            )
                        : console.warn(
                            "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                          )
                      : C
                      ? I &&
                        n.texSubImage2D(
                          e.TEXTURE_2D,
                          t,
                          0,
                          0,
                          x.width,
                          x.height,
                          f,
                          v,
                          x.data
                        )
                      : n.texImage2D(
                          e.TEXTURE_2D,
                          t,
                          E,
                          x.width,
                          x.height,
                          0,
                          f,
                          v,
                          x.data
                        );
              }
            else if (a.isDataArrayTexture)
              if (C) {
                if (
                  (S &&
                    n.texStorage3D(
                      e.TEXTURE_2D_ARRAY,
                      M,
                      E,
                      p.width,
                      p.height,
                      p.depth
                    ),
                  I)
                )
                  if (a.layerUpdates.size > 0) {
                    const t = nu(p.width, p.height, a.format, a.type);
                    for (const i of a.layerUpdates) {
                      const r = p.data.subarray(
                        (i * t) / p.data.BYTES_PER_ELEMENT,
                        ((i + 1) * t) / p.data.BYTES_PER_ELEMENT
                      );
                      n.texSubImage3D(
                        e.TEXTURE_2D_ARRAY,
                        0,
                        0,
                        0,
                        i,
                        p.width,
                        p.height,
                        1,
                        f,
                        v,
                        r
                      );
                    }
                    a.clearLayerUpdates();
                  } else
                    n.texSubImage3D(
                      e.TEXTURE_2D_ARRAY,
                      0,
                      0,
                      0,
                      0,
                      p.width,
                      p.height,
                      p.depth,
                      f,
                      v,
                      p.data
                    );
              } else
                n.texImage3D(
                  e.TEXTURE_2D_ARRAY,
                  0,
                  E,
                  p.width,
                  p.height,
                  p.depth,
                  0,
                  f,
                  v,
                  p.data
                );
            else if (a.isData3DTexture)
              C
                ? (S &&
                    n.texStorage3D(
                      e.TEXTURE_3D,
                      M,
                      E,
                      p.width,
                      p.height,
                      p.depth
                    ),
                  I &&
                    n.texSubImage3D(
                      e.TEXTURE_3D,
                      0,
                      0,
                      0,
                      0,
                      p.width,
                      p.height,
                      p.depth,
                      f,
                      v,
                      p.data
                    ))
                : n.texImage3D(
                    e.TEXTURE_3D,
                    0,
                    E,
                    p.width,
                    p.height,
                    p.depth,
                    0,
                    f,
                    v,
                    p.data
                  );
            else if (a.isFramebufferTexture) {
              if (S)
                if (C) n.texStorage2D(e.TEXTURE_2D, M, E, p.width, p.height);
                else {
                  let t = p.width,
                    i = p.height;
                  for (let r = 0; r < M; r++)
                    n.texImage2D(e.TEXTURE_2D, r, E, t, i, 0, f, v, null),
                      (t >>= 1),
                      (i >>= 1);
                }
            } else if (w.length > 0) {
              if (C && S) {
                const t = G(w[0]);
                n.texStorage2D(e.TEXTURE_2D, M, E, t.width, t.height);
              }
              for (let t = 0, i = w.length; t < i; t++)
                (x = w[t]),
                  C
                    ? I && n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, f, v, x)
                    : n.texImage2D(e.TEXTURE_2D, t, E, f, v, x);
              a.generateMipmaps = !1;
            } else if (C) {
              if (S) {
                const t = G(p);
                n.texStorage2D(e.TEXTURE_2D, M, E, t.width, t.height);
              }
              I && n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, f, v, p);
            } else n.texImage2D(e.TEXTURE_2D, 0, E, f, v, p);
            g(a) && m(c),
              (h.__version = u.version),
              a.onUpdate && a.onUpdate(a);
          }
          t.__version = a.version;
        }
        function P(t, r, a, c, l, u) {
          const h = s.convert(a.format, a.colorSpace),
            d = s.convert(a.type),
            p = y(a.internalFormat, h, d, a.colorSpace),
            f = i.get(r),
            A = i.get(a);
          if (((A.__renderTarget = r), !f.__hasExternalTextures)) {
            const t = Math.max(1, r.width >> u),
              i = Math.max(1, r.height >> u);
            l === e.TEXTURE_3D || l === e.TEXTURE_2D_ARRAY
              ? n.texImage3D(l, u, p, t, i, r.depth, 0, h, d, null)
              : n.texImage2D(l, u, p, t, i, 0, h, d, null);
          }
          n.bindFramebuffer(e.FRAMEBUFFER, t),
            k(r)
              ? o.framebufferTexture2DMultisampleEXT(
                  e.FRAMEBUFFER,
                  c,
                  l,
                  A.__webglTexture,
                  0,
                  N(r)
                )
              : (l === e.TEXTURE_2D ||
                  (l >= e.TEXTURE_CUBE_MAP_POSITIVE_X &&
                    l <= e.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
                e.framebufferTexture2D(
                  e.FRAMEBUFFER,
                  c,
                  l,
                  A.__webglTexture,
                  u
                ),
            n.bindFramebuffer(e.FRAMEBUFFER, null);
        }
        function L(t, n, i) {
          if ((e.bindRenderbuffer(e.RENDERBUFFER, t), n.depthBuffer)) {
            const r = n.depthTexture,
              s = r && r.isDepthTexture ? r.type : null,
              a = b(n.stencilBuffer, s),
              c = n.stencilBuffer
                ? e.DEPTH_STENCIL_ATTACHMENT
                : e.DEPTH_ATTACHMENT,
              l = N(n);
            k(n)
              ? o.renderbufferStorageMultisampleEXT(
                  e.RENDERBUFFER,
                  l,
                  a,
                  n.width,
                  n.height
                )
              : i
              ? e.renderbufferStorageMultisample(
                  e.RENDERBUFFER,
                  l,
                  a,
                  n.width,
                  n.height
                )
              : e.renderbufferStorage(e.RENDERBUFFER, a, n.width, n.height),
              e.framebufferRenderbuffer(e.FRAMEBUFFER, c, e.RENDERBUFFER, t);
          } else {
            const t = n.textures;
            for (let r = 0; r < t.length; r++) {
              const a = t[r],
                c = s.convert(a.format, a.colorSpace),
                l = s.convert(a.type),
                u = y(a.internalFormat, c, l, a.colorSpace),
                h = N(n);
              i && !1 === k(n)
                ? e.renderbufferStorageMultisample(
                    e.RENDERBUFFER,
                    h,
                    u,
                    n.width,
                    n.height
                  )
                : k(n)
                ? o.renderbufferStorageMultisampleEXT(
                    e.RENDERBUFFER,
                    h,
                    u,
                    n.width,
                    n.height
                  )
                : e.renderbufferStorage(e.RENDERBUFFER, u, n.width, n.height);
            }
          }
          e.bindRenderbuffer(e.RENDERBUFFER, null);
        }
        function U(t) {
          const r = i.get(t),
            s = !0 === t.isWebGLCubeRenderTarget;
          if (r.__boundDepthTexture !== t.depthTexture) {
            const e = t.depthTexture;
            if ((r.__depthDisposeCallback && r.__depthDisposeCallback(), e)) {
              const t = () => {
                delete r.__boundDepthTexture,
                  delete r.__depthDisposeCallback,
                  e.removeEventListener("dispose", t);
              };
              e.addEventListener("dispose", t), (r.__depthDisposeCallback = t);
            }
            r.__boundDepthTexture = e;
          }
          if (t.depthTexture && !r.__autoAllocateDepthBuffer) {
            if (s)
              throw new Error(
                "target.depthTexture not supported in Cube render targets"
              );
            !(function (t, r) {
              if (r && r.isWebGLCubeRenderTarget)
                throw new Error(
                  "Depth Texture with cube render targets is not supported"
                );
              if (
                (n.bindFramebuffer(e.FRAMEBUFFER, t),
                !r.depthTexture || !r.depthTexture.isDepthTexture)
              )
                throw new Error(
                  "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
                );
              const s = i.get(r.depthTexture);
              (s.__renderTarget = r),
                (s.__webglTexture &&
                  r.depthTexture.image.width === r.width &&
                  r.depthTexture.image.height === r.height) ||
                  ((r.depthTexture.image.width = r.width),
                  (r.depthTexture.image.height = r.height),
                  (r.depthTexture.needsUpdate = !0)),
                S(r.depthTexture, 0);
              const a = s.__webglTexture,
                c = N(r);
              if (r.depthTexture.format === ti)
                k(r)
                  ? o.framebufferTexture2DMultisampleEXT(
                      e.FRAMEBUFFER,
                      e.DEPTH_ATTACHMENT,
                      e.TEXTURE_2D,
                      a,
                      0,
                      c
                    )
                  : e.framebufferTexture2D(
                      e.FRAMEBUFFER,
                      e.DEPTH_ATTACHMENT,
                      e.TEXTURE_2D,
                      a,
                      0
                    );
              else {
                if (r.depthTexture.format !== ni)
                  throw new Error("Unknown depthTexture format");
                k(r)
                  ? o.framebufferTexture2DMultisampleEXT(
                      e.FRAMEBUFFER,
                      e.DEPTH_STENCIL_ATTACHMENT,
                      e.TEXTURE_2D,
                      a,
                      0,
                      c
                    )
                  : e.framebufferTexture2D(
                      e.FRAMEBUFFER,
                      e.DEPTH_STENCIL_ATTACHMENT,
                      e.TEXTURE_2D,
                      a,
                      0
                    );
              }
            })(r.__webglFramebuffer, t);
          } else if (s) {
            r.__webglDepthbuffer = [];
            for (let i = 0; i < 6; i++)
              if (
                (n.bindFramebuffer(e.FRAMEBUFFER, r.__webglFramebuffer[i]),
                void 0 === r.__webglDepthbuffer[i])
              )
                (r.__webglDepthbuffer[i] = e.createRenderbuffer()),
                  L(r.__webglDepthbuffer[i], t, !1);
              else {
                const n = t.stencilBuffer
                    ? e.DEPTH_STENCIL_ATTACHMENT
                    : e.DEPTH_ATTACHMENT,
                  s = r.__webglDepthbuffer[i];
                e.bindRenderbuffer(e.RENDERBUFFER, s),
                  e.framebufferRenderbuffer(
                    e.FRAMEBUFFER,
                    n,
                    e.RENDERBUFFER,
                    s
                  );
              }
          } else if (
            (n.bindFramebuffer(e.FRAMEBUFFER, r.__webglFramebuffer),
            void 0 === r.__webglDepthbuffer)
          )
            (r.__webglDepthbuffer = e.createRenderbuffer()),
              L(r.__webglDepthbuffer, t, !1);
          else {
            const n = t.stencilBuffer
                ? e.DEPTH_STENCIL_ATTACHMENT
                : e.DEPTH_ATTACHMENT,
              i = r.__webglDepthbuffer;
            e.bindRenderbuffer(e.RENDERBUFFER, i),
              e.framebufferRenderbuffer(e.FRAMEBUFFER, n, e.RENDERBUFFER, i);
          }
          n.bindFramebuffer(e.FRAMEBUFFER, null);
        }
        const F = [],
          O = [];
        function N(e) {
          return Math.min(r.maxSamples, e.samples);
        }
        function k(e) {
          const n = i.get(e);
          return (
            e.samples > 0 &&
            !0 === t.has("WEBGL_multisampled_render_to_texture") &&
            !1 !== n.__useRenderToTexture
          );
        }
        function Q(e, t) {
          const n = e.colorSpace,
            i = e.format,
            r = e.type;
          return (
            !0 === e.isCompressedTexture ||
              !0 === e.isVideoTexture ||
              (n !== $i &&
                n !== Ji &&
                (Mr.getTransfer(n) === tr
                  ? (i === Zn && r === Nn) ||
                    console.warn(
                      "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                    )
                  : console.error(
                      "THREE.WebGLTextures: Unsupported texture color space:",
                      n
                    ))),
            t
          );
        }
        function G(e) {
          return (
            "undefined" != typeof HTMLImageElement &&
            e instanceof HTMLImageElement
              ? ((l.width = e.naturalWidth || e.width),
                (l.height = e.naturalHeight || e.height))
              : "undefined" != typeof VideoFrame && e instanceof VideoFrame
              ? ((l.width = e.displayWidth), (l.height = e.displayHeight))
              : ((l.width = e.width), (l.height = e.height)),
            l
          );
        }
        (this.allocateTextureUnit = function () {
          const e = C;
          return (
            e >= r.maxTextures &&
              console.warn(
                "THREE.WebGLTextures: Trying to use " +
                  e +
                  " texture units while this GPU supports only " +
                  r.maxTextures
              ),
            (C += 1),
            e
          );
        }),
          (this.resetTextureUnits = function () {
            C = 0;
          }),
          (this.setTexture2D = S),
          (this.setTexture2DArray = function (t, r) {
            const s = i.get(t);
            t.version > 0 && s.__version !== t.version
              ? D(s, t, r)
              : n.bindTexture(
                  e.TEXTURE_2D_ARRAY,
                  s.__webglTexture,
                  e.TEXTURE0 + r
                );
          }),
          (this.setTexture3D = function (t, r) {
            const s = i.get(t);
            t.version > 0 && s.__version !== t.version
              ? D(s, t, r)
              : n.bindTexture(e.TEXTURE_3D, s.__webglTexture, e.TEXTURE0 + r);
          }),
          (this.setTextureCube = function (t, a) {
            const o = i.get(t);
            t.version > 0 && o.__version !== t.version
              ? (function (t, a, o) {
                  if (6 !== a.image.length) return;
                  const c = R(t, a),
                    l = a.source;
                  n.bindTexture(
                    e.TEXTURE_CUBE_MAP,
                    t.__webglTexture,
                    e.TEXTURE0 + o
                  );
                  const u = i.get(l);
                  if (l.version !== u.__version || !0 === c) {
                    n.activeTexture(e.TEXTURE0 + o);
                    const t = Mr.getPrimaries(Mr.workingColorSpace),
                      i =
                        a.colorSpace === Ji
                          ? null
                          : Mr.getPrimaries(a.colorSpace),
                      h =
                        a.colorSpace === Ji || t === i
                          ? e.NONE
                          : e.BROWSER_DEFAULT_WEBGL;
                    e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, a.flipY),
                      e.pixelStorei(
                        e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                        a.premultiplyAlpha
                      ),
                      e.pixelStorei(e.UNPACK_ALIGNMENT, a.unpackAlignment),
                      e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, h);
                    const d =
                        a.isCompressedTexture || a.image[0].isCompressedTexture,
                      p = a.image[0] && a.image[0].isDataTexture,
                      f = [];
                    for (let e = 0; e < 6; e++)
                      (f[e] =
                        d || p
                          ? p
                            ? a.image[e].image
                            : a.image[e]
                          : A(a.image[e], !0, r.maxCubemapSize)),
                        (f[e] = Q(a, f[e]));
                    const v = f[0],
                      b = s.convert(a.format, a.colorSpace),
                      x = s.convert(a.type),
                      E = y(a.internalFormat, b, x, a.colorSpace),
                      w = !0 !== a.isVideoTexture,
                      C = void 0 === u.__version || !0 === c,
                      S = l.dataReady;
                    let I,
                      M = _(a, v);
                    if ((B(e.TEXTURE_CUBE_MAP, a), d)) {
                      w &&
                        C &&
                        n.texStorage2D(
                          e.TEXTURE_CUBE_MAP,
                          M,
                          E,
                          v.width,
                          v.height
                        );
                      for (let t = 0; t < 6; t++) {
                        I = f[t].mipmaps;
                        for (let i = 0; i < I.length; i++) {
                          const r = I[i];
                          a.format !== Zn
                            ? null !== b
                              ? w
                                ? S &&
                                  n.compressedTexSubImage2D(
                                    e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                                    i,
                                    0,
                                    0,
                                    r.width,
                                    r.height,
                                    b,
                                    r.data
                                  )
                                : n.compressedTexImage2D(
                                    e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                                    i,
                                    E,
                                    r.width,
                                    r.height,
                                    0,
                                    r.data
                                  )
                              : console.warn(
                                  "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                                )
                            : w
                            ? S &&
                              n.texSubImage2D(
                                e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                                i,
                                0,
                                0,
                                r.width,
                                r.height,
                                b,
                                x,
                                r.data
                              )
                            : n.texImage2D(
                                e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                                i,
                                E,
                                r.width,
                                r.height,
                                0,
                                b,
                                x,
                                r.data
                              );
                        }
                      }
                    } else {
                      if (((I = a.mipmaps), w && C)) {
                        I.length > 0 && M++;
                        const t = G(f[0]);
                        n.texStorage2D(
                          e.TEXTURE_CUBE_MAP,
                          M,
                          E,
                          t.width,
                          t.height
                        );
                      }
                      for (let t = 0; t < 6; t++)
                        if (p) {
                          w
                            ? S &&
                              n.texSubImage2D(
                                e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                                0,
                                0,
                                0,
                                f[t].width,
                                f[t].height,
                                b,
                                x,
                                f[t].data
                              )
                            : n.texImage2D(
                                e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                                0,
                                E,
                                f[t].width,
                                f[t].height,
                                0,
                                b,
                                x,
                                f[t].data
                              );
                          for (let i = 0; i < I.length; i++) {
                            const r = I[i].image[t].image;
                            w
                              ? S &&
                                n.texSubImage2D(
                                  e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                                  i + 1,
                                  0,
                                  0,
                                  r.width,
                                  r.height,
                                  b,
                                  x,
                                  r.data
                                )
                              : n.texImage2D(
                                  e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                                  i + 1,
                                  E,
                                  r.width,
                                  r.height,
                                  0,
                                  b,
                                  x,
                                  r.data
                                );
                          }
                        } else {
                          w
                            ? S &&
                              n.texSubImage2D(
                                e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                                0,
                                0,
                                0,
                                b,
                                x,
                                f[t]
                              )
                            : n.texImage2D(
                                e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                                0,
                                E,
                                b,
                                x,
                                f[t]
                              );
                          for (let i = 0; i < I.length; i++) {
                            const r = I[i];
                            w
                              ? S &&
                                n.texSubImage2D(
                                  e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                                  i + 1,
                                  0,
                                  0,
                                  b,
                                  x,
                                  r.image[t]
                                )
                              : n.texImage2D(
                                  e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                                  i + 1,
                                  E,
                                  b,
                                  x,
                                  r.image[t]
                                );
                          }
                        }
                    }
                    g(a) && m(e.TEXTURE_CUBE_MAP),
                      (u.__version = l.version),
                      a.onUpdate && a.onUpdate(a);
                  }
                  t.__version = a.version;
                })(o, t, a)
              : n.bindTexture(
                  e.TEXTURE_CUBE_MAP,
                  o.__webglTexture,
                  e.TEXTURE0 + a
                );
          }),
          (this.rebindTextures = function (t, n, r) {
            const s = i.get(t);
            void 0 !== n &&
              P(
                s.__webglFramebuffer,
                t,
                t.texture,
                e.COLOR_ATTACHMENT0,
                e.TEXTURE_2D,
                0
              ),
              void 0 !== r && U(t);
          }),
          (this.setupRenderTarget = function (t) {
            const r = t.texture,
              o = i.get(t),
              c = i.get(r);
            t.addEventListener("dispose", E);
            const l = t.textures,
              u = !0 === t.isWebGLCubeRenderTarget,
              h = l.length > 1;
            if (
              (h ||
                (void 0 === c.__webglTexture &&
                  (c.__webglTexture = e.createTexture()),
                (c.__version = r.version),
                a.memory.textures++),
              u)
            ) {
              o.__webglFramebuffer = [];
              for (let t = 0; t < 6; t++)
                if (r.mipmaps && r.mipmaps.length > 0) {
                  o.__webglFramebuffer[t] = [];
                  for (let n = 0; n < r.mipmaps.length; n++)
                    o.__webglFramebuffer[t][n] = e.createFramebuffer();
                } else o.__webglFramebuffer[t] = e.createFramebuffer();
            } else {
              if (r.mipmaps && r.mipmaps.length > 0) {
                o.__webglFramebuffer = [];
                for (let t = 0; t < r.mipmaps.length; t++)
                  o.__webglFramebuffer[t] = e.createFramebuffer();
              } else o.__webglFramebuffer = e.createFramebuffer();
              if (h)
                for (let t = 0, n = l.length; t < n; t++) {
                  const n = i.get(l[t]);
                  void 0 === n.__webglTexture &&
                    ((n.__webglTexture = e.createTexture()),
                    a.memory.textures++);
                }
              if (t.samples > 0 && !1 === k(t)) {
                (o.__webglMultisampledFramebuffer = e.createFramebuffer()),
                  (o.__webglColorRenderbuffer = []),
                  n.bindFramebuffer(
                    e.FRAMEBUFFER,
                    o.__webglMultisampledFramebuffer
                  );
                for (let n = 0; n < l.length; n++) {
                  const i = l[n];
                  (o.__webglColorRenderbuffer[n] = e.createRenderbuffer()),
                    e.bindRenderbuffer(
                      e.RENDERBUFFER,
                      o.__webglColorRenderbuffer[n]
                    );
                  const r = s.convert(i.format, i.colorSpace),
                    a = s.convert(i.type),
                    c = y(
                      i.internalFormat,
                      r,
                      a,
                      i.colorSpace,
                      !0 === t.isXRRenderTarget
                    ),
                    u = N(t);
                  e.renderbufferStorageMultisample(
                    e.RENDERBUFFER,
                    u,
                    c,
                    t.width,
                    t.height
                  ),
                    e.framebufferRenderbuffer(
                      e.FRAMEBUFFER,
                      e.COLOR_ATTACHMENT0 + n,
                      e.RENDERBUFFER,
                      o.__webglColorRenderbuffer[n]
                    );
                }
                e.bindRenderbuffer(e.RENDERBUFFER, null),
                  t.depthBuffer &&
                    ((o.__webglDepthRenderbuffer = e.createRenderbuffer()),
                    L(o.__webglDepthRenderbuffer, t, !0)),
                  n.bindFramebuffer(e.FRAMEBUFFER, null);
              }
            }
            if (u) {
              n.bindTexture(e.TEXTURE_CUBE_MAP, c.__webglTexture),
                B(e.TEXTURE_CUBE_MAP, r);
              for (let n = 0; n < 6; n++)
                if (r.mipmaps && r.mipmaps.length > 0)
                  for (let i = 0; i < r.mipmaps.length; i++)
                    P(
                      o.__webglFramebuffer[n][i],
                      t,
                      r,
                      e.COLOR_ATTACHMENT0,
                      e.TEXTURE_CUBE_MAP_POSITIVE_X + n,
                      i
                    );
                else
                  P(
                    o.__webglFramebuffer[n],
                    t,
                    r,
                    e.COLOR_ATTACHMENT0,
                    e.TEXTURE_CUBE_MAP_POSITIVE_X + n,
                    0
                  );
              g(r) && m(e.TEXTURE_CUBE_MAP), n.unbindTexture();
            } else if (h) {
              for (let r = 0, s = l.length; r < s; r++) {
                const s = l[r],
                  a = i.get(s);
                n.bindTexture(e.TEXTURE_2D, a.__webglTexture),
                  B(e.TEXTURE_2D, s),
                  P(
                    o.__webglFramebuffer,
                    t,
                    s,
                    e.COLOR_ATTACHMENT0 + r,
                    e.TEXTURE_2D,
                    0
                  ),
                  g(s) && m(e.TEXTURE_2D);
              }
              n.unbindTexture();
            } else {
              let i = e.TEXTURE_2D;
              if (
                ((t.isWebGL3DRenderTarget || t.isWebGLArrayRenderTarget) &&
                  (i = t.isWebGL3DRenderTarget
                    ? e.TEXTURE_3D
                    : e.TEXTURE_2D_ARRAY),
                n.bindTexture(i, c.__webglTexture),
                B(i, r),
                r.mipmaps && r.mipmaps.length > 0)
              )
                for (let n = 0; n < r.mipmaps.length; n++)
                  P(o.__webglFramebuffer[n], t, r, e.COLOR_ATTACHMENT0, i, n);
              else P(o.__webglFramebuffer, t, r, e.COLOR_ATTACHMENT0, i, 0);
              g(r) && m(i), n.unbindTexture();
            }
            t.depthBuffer && U(t);
          }),
          (this.updateRenderTargetMipmap = function (e) {
            const t = e.textures;
            for (let r = 0, s = t.length; r < s; r++) {
              const s = t[r];
              if (g(s)) {
                const t = v(e),
                  r = i.get(s).__webglTexture;
                n.bindTexture(t, r), m(t), n.unbindTexture();
              }
            }
          }),
          (this.updateMultisampleRenderTarget = function (t) {
            if (t.samples > 0)
              if (!1 === k(t)) {
                const r = t.textures,
                  s = t.width,
                  a = t.height;
                let o = e.COLOR_BUFFER_BIT;
                const l = t.stencilBuffer
                    ? e.DEPTH_STENCIL_ATTACHMENT
                    : e.DEPTH_ATTACHMENT,
                  u = i.get(t),
                  h = r.length > 1;
                if (h)
                  for (let t = 0; t < r.length; t++)
                    n.bindFramebuffer(
                      e.FRAMEBUFFER,
                      u.__webglMultisampledFramebuffer
                    ),
                      e.framebufferRenderbuffer(
                        e.FRAMEBUFFER,
                        e.COLOR_ATTACHMENT0 + t,
                        e.RENDERBUFFER,
                        null
                      ),
                      n.bindFramebuffer(e.FRAMEBUFFER, u.__webglFramebuffer),
                      e.framebufferTexture2D(
                        e.DRAW_FRAMEBUFFER,
                        e.COLOR_ATTACHMENT0 + t,
                        e.TEXTURE_2D,
                        null,
                        0
                      );
                n.bindFramebuffer(
                  e.READ_FRAMEBUFFER,
                  u.__webglMultisampledFramebuffer
                ),
                  n.bindFramebuffer(e.DRAW_FRAMEBUFFER, u.__webglFramebuffer);
                for (let n = 0; n < r.length; n++) {
                  if (
                    (t.resolveDepthBuffer &&
                      (t.depthBuffer && (o |= e.DEPTH_BUFFER_BIT),
                      t.stencilBuffer &&
                        t.resolveStencilBuffer &&
                        (o |= e.STENCIL_BUFFER_BIT)),
                    h)
                  ) {
                    e.framebufferRenderbuffer(
                      e.READ_FRAMEBUFFER,
                      e.COLOR_ATTACHMENT0,
                      e.RENDERBUFFER,
                      u.__webglColorRenderbuffer[n]
                    );
                    const t = i.get(r[n]).__webglTexture;
                    e.framebufferTexture2D(
                      e.DRAW_FRAMEBUFFER,
                      e.COLOR_ATTACHMENT0,
                      e.TEXTURE_2D,
                      t,
                      0
                    );
                  }
                  e.blitFramebuffer(0, 0, s, a, 0, 0, s, a, o, e.NEAREST),
                    !0 === c &&
                      ((F.length = 0),
                      (O.length = 0),
                      F.push(e.COLOR_ATTACHMENT0 + n),
                      t.depthBuffer &&
                        !1 === t.resolveDepthBuffer &&
                        (F.push(l),
                        O.push(l),
                        e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, O)),
                      e.invalidateFramebuffer(e.READ_FRAMEBUFFER, F));
                }
                if (
                  (n.bindFramebuffer(e.READ_FRAMEBUFFER, null),
                  n.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
                  h)
                )
                  for (let t = 0; t < r.length; t++) {
                    n.bindFramebuffer(
                      e.FRAMEBUFFER,
                      u.__webglMultisampledFramebuffer
                    ),
                      e.framebufferRenderbuffer(
                        e.FRAMEBUFFER,
                        e.COLOR_ATTACHMENT0 + t,
                        e.RENDERBUFFER,
                        u.__webglColorRenderbuffer[t]
                      );
                    const s = i.get(r[t]).__webglTexture;
                    n.bindFramebuffer(e.FRAMEBUFFER, u.__webglFramebuffer),
                      e.framebufferTexture2D(
                        e.DRAW_FRAMEBUFFER,
                        e.COLOR_ATTACHMENT0 + t,
                        e.TEXTURE_2D,
                        s,
                        0
                      );
                  }
                n.bindFramebuffer(
                  e.DRAW_FRAMEBUFFER,
                  u.__webglMultisampledFramebuffer
                );
              } else if (t.depthBuffer && !1 === t.resolveDepthBuffer && c) {
                const n = t.stencilBuffer
                  ? e.DEPTH_STENCIL_ATTACHMENT
                  : e.DEPTH_ATTACHMENT;
                e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, [n]);
              }
          }),
          (this.setupDepthRenderbuffer = U),
          (this.setupFrameBufferTexture = P),
          (this.useMultisampledRTT = k);
      }
      function ru(e, t) {
        return {
          convert: function (n, i = Ji) {
            let r;
            const s = Mr.getTransfer(i);
            if (n === Nn) return e.UNSIGNED_BYTE;
            if (n === Wn) return e.UNSIGNED_SHORT_4_4_4_4;
            if (n === Xn) return e.UNSIGNED_SHORT_5_5_5_1;
            if (n === Yn) return e.UNSIGNED_INT_5_9_9_9_REV;
            if (n === kn) return e.BYTE;
            if (n === Qn) return e.SHORT;
            if (n === Gn) return e.UNSIGNED_SHORT;
            if (n === Hn) return e.INT;
            if (n === zn) return e.UNSIGNED_INT;
            if (n === Vn) return e.FLOAT;
            if (n === jn) return e.HALF_FLOAT;
            if (n === Kn) return e.ALPHA;
            if (n === Jn) return e.RGB;
            if (n === Zn) return e.RGBA;
            if (n === $n) return e.LUMINANCE;
            if (n === ei) return e.LUMINANCE_ALPHA;
            if (n === ti) return e.DEPTH_COMPONENT;
            if (n === ni) return e.DEPTH_STENCIL;
            if (n === ii) return e.RED;
            if (n === ri) return e.RED_INTEGER;
            if (n === si) return e.RG;
            if (n === ai) return e.RG_INTEGER;
            if (n === oi) return e.RGBA_INTEGER;
            if (n === ci || n === li || n === ui || n === hi)
              if (s === tr) {
                if (
                  ((r = t.get("WEBGL_compressed_texture_s3tc_srgb")),
                  null === r)
                )
                  return null;
                if (n === ci) return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                if (n === li) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                if (n === ui) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                if (n === hi) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
              } else {
                if (((r = t.get("WEBGL_compressed_texture_s3tc")), null === r))
                  return null;
                if (n === ci) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (n === li) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (n === ui) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (n === hi) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT;
              }
            if (n === di || n === pi || n === fi || n === Ai) {
              if (((r = t.get("WEBGL_compressed_texture_pvrtc")), null === r))
                return null;
              if (n === di) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
              if (n === pi) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
              if (n === fi) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
              if (n === Ai) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            }
            if (n === gi || n === mi || n === vi) {
              if (((r = t.get("WEBGL_compressed_texture_etc")), null === r))
                return null;
              if (n === gi || n === mi)
                return s === tr
                  ? r.COMPRESSED_SRGB8_ETC2
                  : r.COMPRESSED_RGB8_ETC2;
              if (n === vi)
                return s === tr
                  ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
                  : r.COMPRESSED_RGBA8_ETC2_EAC;
            }
            if (
              n === yi ||
              n === bi ||
              n === _i ||
              n === xi ||
              n === Ei ||
              n === wi ||
              n === Ci ||
              n === Si ||
              n === Ii ||
              n === Mi ||
              n === Ti ||
              n === Bi ||
              n === Ri ||
              n === Di
            ) {
              if (((r = t.get("WEBGL_compressed_texture_astc")), null === r))
                return null;
              if (n === yi)
                return s === tr
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
                  : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
              if (n === bi)
                return s === tr
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
                  : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
              if (n === _i)
                return s === tr
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
                  : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
              if (n === xi)
                return s === tr
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
                  : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
              if (n === Ei)
                return s === tr
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
                  : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
              if (n === wi)
                return s === tr
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
                  : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
              if (n === Ci)
                return s === tr
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
                  : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
              if (n === Si)
                return s === tr
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
                  : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
              if (n === Ii)
                return s === tr
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
                  : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
              if (n === Mi)
                return s === tr
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
                  : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
              if (n === Ti)
                return s === tr
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
                  : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
              if (n === Bi)
                return s === tr
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
                  : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
              if (n === Ri)
                return s === tr
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
                  : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
              if (n === Di)
                return s === tr
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
                  : r.COMPRESSED_RGBA_ASTC_12x12_KHR;
            }
            if (n === Pi || n === Li || n === Ui) {
              if (((r = t.get("EXT_texture_compression_bptc")), null === r))
                return null;
              if (n === Pi)
                return s === tr
                  ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
                  : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
              if (n === Li) return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
              if (n === Ui) return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
            }
            if (n === Fi || n === Oi || n === Ni || n === ki) {
              if (((r = t.get("EXT_texture_compression_rgtc")), null === r))
                return null;
              if (n === Pi) return r.COMPRESSED_RED_RGTC1_EXT;
              if (n === Oi) return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
              if (n === Ni) return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
              if (n === ki) return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
            }
            return n === qn
              ? e.UNSIGNED_INT_24_8
              : void 0 !== e[n]
              ? e[n]
              : null;
          },
        };
      }
      class su extends uo {
        constructor(e = []) {
          super(), (this.isArrayCamera = !0), (this.cameras = e);
        }
      }
      class au extends Zs {
        constructor() {
          super(), (this.isGroup = !0), (this.type = "Group");
        }
      }
      const ou = { type: "move" };
      class cu {
        constructor() {
          (this._targetRay = null), (this._grip = null), (this._hand = null);
        }
        getHandSpace() {
          return (
            null === this._hand &&
              ((this._hand = new au()),
              (this._hand.matrixAutoUpdate = !1),
              (this._hand.visible = !1),
              (this._hand.joints = {}),
              (this._hand.inputState = { pinching: !1 })),
            this._hand
          );
        }
        getTargetRaySpace() {
          return (
            null === this._targetRay &&
              ((this._targetRay = new au()),
              (this._targetRay.matrixAutoUpdate = !1),
              (this._targetRay.visible = !1),
              (this._targetRay.hasLinearVelocity = !1),
              (this._targetRay.linearVelocity = new Yr()),
              (this._targetRay.hasAngularVelocity = !1),
              (this._targetRay.angularVelocity = new Yr())),
            this._targetRay
          );
        }
        getGripSpace() {
          return (
            null === this._grip &&
              ((this._grip = new au()),
              (this._grip.matrixAutoUpdate = !1),
              (this._grip.visible = !1),
              (this._grip.hasLinearVelocity = !1),
              (this._grip.linearVelocity = new Yr()),
              (this._grip.hasAngularVelocity = !1),
              (this._grip.angularVelocity = new Yr())),
            this._grip
          );
        }
        dispatchEvent(e) {
          return (
            null !== this._targetRay && this._targetRay.dispatchEvent(e),
            null !== this._grip && this._grip.dispatchEvent(e),
            null !== this._hand && this._hand.dispatchEvent(e),
            this
          );
        }
        connect(e) {
          if (e && e.hand) {
            const t = this._hand;
            if (t) for (const n of e.hand.values()) this._getHandJoint(t, n);
          }
          return this.dispatchEvent({ type: "connected", data: e }), this;
        }
        disconnect(e) {
          return (
            this.dispatchEvent({ type: "disconnected", data: e }),
            null !== this._targetRay && (this._targetRay.visible = !1),
            null !== this._grip && (this._grip.visible = !1),
            null !== this._hand && (this._hand.visible = !1),
            this
          );
        }
        update(e, t, n) {
          let i = null,
            r = null,
            s = null;
          const a = this._targetRay,
            o = this._grip,
            c = this._hand;
          if (e && "visible-blurred" !== t.session.visibilityState) {
            if (c && e.hand) {
              s = !0;
              for (const i of e.hand.values()) {
                const e = t.getJointPose(i, n),
                  r = this._getHandJoint(c, i);
                null !== e &&
                  (r.matrix.fromArray(e.transform.matrix),
                  r.matrix.decompose(r.position, r.rotation, r.scale),
                  (r.matrixWorldNeedsUpdate = !0),
                  (r.jointRadius = e.radius)),
                  (r.visible = null !== e);
              }
              const i = c.joints["index-finger-tip"],
                r = c.joints["thumb-tip"],
                a = i.position.distanceTo(r.position),
                o = 0.02,
                l = 0.005;
              c.inputState.pinching && a > o + l
                ? ((c.inputState.pinching = !1),
                  this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this,
                  }))
                : !c.inputState.pinching &&
                  a <= o - l &&
                  ((c.inputState.pinching = !0),
                  this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this,
                  }));
            } else
              null !== o &&
                e.gripSpace &&
                ((r = t.getPose(e.gripSpace, n)),
                null !== r &&
                  (o.matrix.fromArray(r.transform.matrix),
                  o.matrix.decompose(o.position, o.rotation, o.scale),
                  (o.matrixWorldNeedsUpdate = !0),
                  r.linearVelocity
                    ? ((o.hasLinearVelocity = !0),
                      o.linearVelocity.copy(r.linearVelocity))
                    : (o.hasLinearVelocity = !1),
                  r.angularVelocity
                    ? ((o.hasAngularVelocity = !0),
                      o.angularVelocity.copy(r.angularVelocity))
                    : (o.hasAngularVelocity = !1)));
            null !== a &&
              ((i = t.getPose(e.targetRaySpace, n)),
              null === i && null !== r && (i = r),
              null !== i &&
                (a.matrix.fromArray(i.transform.matrix),
                a.matrix.decompose(a.position, a.rotation, a.scale),
                (a.matrixWorldNeedsUpdate = !0),
                i.linearVelocity
                  ? ((a.hasLinearVelocity = !0),
                    a.linearVelocity.copy(i.linearVelocity))
                  : (a.hasLinearVelocity = !1),
                i.angularVelocity
                  ? ((a.hasAngularVelocity = !0),
                    a.angularVelocity.copy(i.angularVelocity))
                  : (a.hasAngularVelocity = !1),
                this.dispatchEvent(ou)));
          }
          return (
            null !== a && (a.visible = null !== i),
            null !== o && (o.visible = null !== r),
            null !== c && (c.visible = null !== s),
            this
          );
        }
        _getHandJoint(e, t) {
          if (void 0 === e.joints[t.jointName]) {
            const n = new au();
            (n.matrixAutoUpdate = !1),
              (n.visible = !1),
              (e.joints[t.jointName] = n),
              e.add(n);
          }
          return e.joints[t.jointName];
        }
      }
      class lu {
        constructor() {
          (this.texture = null),
            (this.mesh = null),
            (this.depthNear = 0),
            (this.depthFar = 0);
        }
        init(e, t, n) {
          if (null === this.texture) {
            const i = new Hr();
            (e.properties.get(i).__webglTexture = t.texture),
              (t.depthNear == n.depthNear && t.depthFar == n.depthFar) ||
                ((this.depthNear = t.depthNear), (this.depthFar = t.depthFar)),
              (this.texture = i);
          }
        }
        getMesh(e) {
          if (null !== this.texture && null === this.mesh) {
            const t = e.cameras[0].viewport,
              n = new so({
                vertexShader:
                  "\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}",
                fragmentShader:
                  "\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}",
                uniforms: {
                  depthColor: { value: this.texture },
                  depthWidth: { value: t.z },
                  depthHeight: { value: t.w },
                },
              });
            this.mesh = new Za(new Co(20, 20), n);
          }
          return this.mesh;
        }
        reset() {
          (this.texture = null), (this.mesh = null);
        }
        getDepthTexture() {
          return this.texture;
        }
      }
      class uu extends cr {
        constructor(e, t) {
          super();
          const n = this;
          let i = null,
            r = 1,
            s = null,
            a = "local-floor",
            o = 1,
            c = null,
            l = null,
            u = null,
            h = null,
            d = null,
            p = null;
          const f = new lu(),
            A = t.getContextAttributes();
          let g = null,
            m = null;
          const v = [],
            y = [],
            b = new br();
          let _ = null;
          const x = new uo();
          x.viewport = new zr();
          const E = new uo();
          E.viewport = new zr();
          const w = [x, E],
            C = new su();
          let S = null,
            I = null;
          function M(e) {
            const t = y.indexOf(e.inputSource);
            if (-1 === t) return;
            const n = v[t];
            void 0 !== n &&
              (n.update(e.inputSource, e.frame, c || s),
              n.dispatchEvent({ type: e.type, data: e.inputSource }));
          }
          function T() {
            i.removeEventListener("select", M),
              i.removeEventListener("selectstart", M),
              i.removeEventListener("selectend", M),
              i.removeEventListener("squeeze", M),
              i.removeEventListener("squeezestart", M),
              i.removeEventListener("squeezeend", M),
              i.removeEventListener("end", T),
              i.removeEventListener("inputsourceschange", B);
            for (let e = 0; e < v.length; e++) {
              const t = y[e];
              null !== t && ((y[e] = null), v[e].disconnect(t));
            }
            (S = null),
              (I = null),
              f.reset(),
              e.setRenderTarget(g),
              (d = null),
              (h = null),
              (u = null),
              (i = null),
              (m = null),
              U.stop(),
              (n.isPresenting = !1),
              e.setPixelRatio(_),
              e.setSize(b.width, b.height, !1),
              n.dispatchEvent({ type: "sessionend" });
          }
          function B(e) {
            for (let t = 0; t < e.removed.length; t++) {
              const n = e.removed[t],
                i = y.indexOf(n);
              i >= 0 && ((y[i] = null), v[i].disconnect(n));
            }
            for (let t = 0; t < e.added.length; t++) {
              const n = e.added[t];
              let i = y.indexOf(n);
              if (-1 === i) {
                for (let e = 0; e < v.length; e++) {
                  if (e >= y.length) {
                    y.push(n), (i = e);
                    break;
                  }
                  if (null === y[e]) {
                    (y[e] = n), (i = e);
                    break;
                  }
                }
                if (-1 === i) break;
              }
              const r = v[i];
              r && r.connect(n);
            }
          }
          (this.cameraAutoUpdate = !0),
            (this.enabled = !1),
            (this.isPresenting = !1),
            (this.getController = function (e) {
              let t = v[e];
              return (
                void 0 === t && ((t = new cu()), (v[e] = t)),
                t.getTargetRaySpace()
              );
            }),
            (this.getControllerGrip = function (e) {
              let t = v[e];
              return (
                void 0 === t && ((t = new cu()), (v[e] = t)), t.getGripSpace()
              );
            }),
            (this.getHand = function (e) {
              let t = v[e];
              return (
                void 0 === t && ((t = new cu()), (v[e] = t)), t.getHandSpace()
              );
            }),
            (this.setFramebufferScaleFactor = function (e) {
              (r = e),
                !0 === n.isPresenting &&
                  console.warn(
                    "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
                  );
            }),
            (this.setReferenceSpaceType = function (e) {
              (a = e),
                !0 === n.isPresenting &&
                  console.warn(
                    "THREE.WebXRManager: Cannot change reference space type while presenting."
                  );
            }),
            (this.getReferenceSpace = function () {
              return c || s;
            }),
            (this.setReferenceSpace = function (e) {
              c = e;
            }),
            (this.getBaseLayer = function () {
              return null !== h ? h : d;
            }),
            (this.getBinding = function () {
              return u;
            }),
            (this.getFrame = function () {
              return p;
            }),
            (this.getSession = function () {
              return i;
            }),
            (this.setSession = async function (l) {
              if (((i = l), null !== i)) {
                if (
                  ((g = e.getRenderTarget()),
                  i.addEventListener("select", M),
                  i.addEventListener("selectstart", M),
                  i.addEventListener("selectend", M),
                  i.addEventListener("squeeze", M),
                  i.addEventListener("squeezestart", M),
                  i.addEventListener("squeezeend", M),
                  i.addEventListener("end", T),
                  i.addEventListener("inputsourceschange", B),
                  !0 !== A.xrCompatible && (await t.makeXRCompatible()),
                  (_ = e.getPixelRatio()),
                  e.getSize(b),
                  void 0 === i.renderState.layers)
                ) {
                  const n = {
                    antialias: A.antialias,
                    alpha: !0,
                    depth: A.depth,
                    stencil: A.stencil,
                    framebufferScaleFactor: r,
                  };
                  (d = new XRWebGLLayer(i, t, n)),
                    i.updateRenderState({ baseLayer: d }),
                    e.setPixelRatio(1),
                    e.setSize(d.framebufferWidth, d.framebufferHeight, !1),
                    (m = new jr(d.framebufferWidth, d.framebufferHeight, {
                      format: Zn,
                      type: Nn,
                      colorSpace: e.outputColorSpace,
                      stencilBuffer: A.stencil,
                    }));
                } else {
                  let n = null,
                    s = null,
                    a = null;
                  A.depth &&
                    ((a = A.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24),
                    (n = A.stencil ? ni : ti),
                    (s = A.stencil ? qn : zn));
                  const o = {
                    colorFormat: t.RGBA8,
                    depthFormat: a,
                    scaleFactor: r,
                  };
                  (u = new XRWebGLBinding(i, t)),
                    (h = u.createProjectionLayer(o)),
                    i.updateRenderState({ layers: [h] }),
                    e.setPixelRatio(1),
                    e.setSize(h.textureWidth, h.textureHeight, !1),
                    (m = new jr(h.textureWidth, h.textureHeight, {
                      format: Zn,
                      type: Nn,
                      depthTexture: new lc(
                        h.textureWidth,
                        h.textureHeight,
                        s,
                        void 0,
                        void 0,
                        void 0,
                        void 0,
                        void 0,
                        void 0,
                        n
                      ),
                      stencilBuffer: A.stencil,
                      colorSpace: e.outputColorSpace,
                      samples: A.antialias ? 4 : 0,
                      resolveDepthBuffer: !1 === h.ignoreDepthValues,
                    }));
                }
                (m.isXRRenderTarget = !0),
                  this.setFoveation(o),
                  (c = null),
                  (s = await i.requestReferenceSpace(a)),
                  U.setContext(i),
                  U.start(),
                  (n.isPresenting = !0),
                  n.dispatchEvent({ type: "sessionstart" });
              }
            }),
            (this.getEnvironmentBlendMode = function () {
              if (null !== i) return i.environmentBlendMode;
            }),
            (this.getDepthTexture = function () {
              return f.getDepthTexture();
            });
          const R = new Yr(),
            D = new Yr();
          function P(e, t) {
            null === t
              ? e.matrixWorld.copy(e.matrix)
              : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix),
              e.matrixWorldInverse.copy(e.matrixWorld).invert();
          }
          (this.updateCamera = function (e) {
            if (null === i) return;
            let t = e.near,
              n = e.far;
            null !== f.texture &&
              (f.depthNear > 0 && (t = f.depthNear),
              f.depthFar > 0 && (n = f.depthFar)),
              (C.near = E.near = x.near = t),
              (C.far = E.far = x.far = n),
              (S === C.near && I === C.far) ||
                (i.updateRenderState({ depthNear: C.near, depthFar: C.far }),
                (S = C.near),
                (I = C.far)),
              (x.layers.mask = 2 | e.layers.mask),
              (E.layers.mask = 4 | e.layers.mask),
              (C.layers.mask = x.layers.mask | E.layers.mask);
            const r = e.parent,
              s = C.cameras;
            P(C, r);
            for (let e = 0; e < s.length; e++) P(s[e], r);
            2 === s.length
              ? (function (e, t, n) {
                  R.setFromMatrixPosition(t.matrixWorld),
                    D.setFromMatrixPosition(n.matrixWorld);
                  const i = R.distanceTo(D),
                    r = t.projectionMatrix.elements,
                    s = n.projectionMatrix.elements,
                    a = r[14] / (r[10] - 1),
                    o = r[14] / (r[10] + 1),
                    c = (r[9] + 1) / r[5],
                    l = (r[9] - 1) / r[5],
                    u = (r[8] - 1) / r[0],
                    h = (s[8] + 1) / s[0],
                    d = a * u,
                    p = a * h,
                    f = i / (-u + h),
                    A = f * -u;
                  if (
                    (t.matrixWorld.decompose(e.position, e.quaternion, e.scale),
                    e.translateX(A),
                    e.translateZ(f),
                    e.matrixWorld.compose(e.position, e.quaternion, e.scale),
                    e.matrixWorldInverse.copy(e.matrixWorld).invert(),
                    -1 === r[10])
                  )
                    e.projectionMatrix.copy(t.projectionMatrix),
                      e.projectionMatrixInverse.copy(t.projectionMatrixInverse);
                  else {
                    const t = a + f,
                      n = o + f,
                      r = d - A,
                      s = p + (i - A),
                      u = ((c * o) / n) * t,
                      h = ((l * o) / n) * t;
                    e.projectionMatrix.makePerspective(r, s, u, h, t, n),
                      e.projectionMatrixInverse
                        .copy(e.projectionMatrix)
                        .invert();
                  }
                })(C, x, E)
              : C.projectionMatrix.copy(x.projectionMatrix),
              (function (e, t, n) {
                null === n
                  ? e.matrix.copy(t.matrixWorld)
                  : (e.matrix.copy(n.matrixWorld),
                    e.matrix.invert(),
                    e.matrix.multiply(t.matrixWorld));
                e.matrix.decompose(e.position, e.quaternion, e.scale),
                  e.updateMatrixWorld(!0),
                  e.projectionMatrix.copy(t.projectionMatrix),
                  e.projectionMatrixInverse.copy(t.projectionMatrixInverse),
                  e.isPerspectiveCamera &&
                    ((e.fov =
                      2 * dr * Math.atan(1 / e.projectionMatrix.elements[5])),
                    (e.zoom = 1));
              })(e, C, r);
          }),
            (this.getCamera = function () {
              return C;
            }),
            (this.getFoveation = function () {
              if (null !== h || null !== d) return o;
            }),
            (this.setFoveation = function (e) {
              (o = e),
                null !== h && (h.fixedFoveation = e),
                null !== d &&
                  void 0 !== d.fixedFoveation &&
                  (d.fixedFoveation = e);
            }),
            (this.hasDepthSensing = function () {
              return null !== f.texture;
            }),
            (this.getDepthSensingMesh = function () {
              return f.getMesh(C);
            });
          let L = null;
          const U = new Eo();
          U.setAnimationLoop(function (t, r) {
            if (((l = r.getViewerPose(c || s)), (p = r), null !== l)) {
              const t = l.views;
              null !== d &&
                (e.setRenderTargetFramebuffer(m, d.framebuffer),
                e.setRenderTarget(m));
              let n = !1;
              t.length !== C.cameras.length &&
                ((C.cameras.length = 0), (n = !0));
              for (let i = 0; i < t.length; i++) {
                const r = t[i];
                let s = null;
                if (null !== d) s = d.getViewport(r);
                else {
                  const t = u.getViewSubImage(h, r);
                  (s = t.viewport),
                    0 === i &&
                      (e.setRenderTargetTextures(
                        m,
                        t.colorTexture,
                        h.ignoreDepthValues ? void 0 : t.depthStencilTexture
                      ),
                      e.setRenderTarget(m));
                }
                let a = w[i];
                void 0 === a &&
                  ((a = new uo()),
                  a.layers.enable(i),
                  (a.viewport = new zr()),
                  (w[i] = a)),
                  a.matrix.fromArray(r.transform.matrix),
                  a.matrix.decompose(a.position, a.quaternion, a.scale),
                  a.projectionMatrix.fromArray(r.projectionMatrix),
                  a.projectionMatrixInverse.copy(a.projectionMatrix).invert(),
                  a.viewport.set(s.x, s.y, s.width, s.height),
                  0 === i &&
                    (C.matrix.copy(a.matrix),
                    C.matrix.decompose(C.position, C.quaternion, C.scale)),
                  !0 === n && C.cameras.push(a);
              }
              const r = i.enabledFeatures;
              if (r && r.includes("depth-sensing")) {
                const n = u.getDepthInformation(t[0]);
                n && n.isValid && n.texture && f.init(e, n, i.renderState);
              }
            }
            for (let e = 0; e < v.length; e++) {
              const t = y[e],
                n = v[e];
              null !== t && void 0 !== n && n.update(t, r, c || s);
            }
            L && L(t, r),
              r.detectedPlanes &&
                n.dispatchEvent({ type: "planesdetected", data: r }),
              (p = null);
          }),
            (this.setAnimationLoop = function (e) {
              L = e;
            }),
            (this.dispose = function () {});
        }
      }
      const hu = new Us(),
        du = new Cs();
      function pu(e, t) {
        function n(e, t) {
          !0 === e.matrixAutoUpdate && e.updateMatrix(), t.value.copy(e.matrix);
        }
        function i(e, i) {
          (e.opacity.value = i.opacity),
            i.color && e.diffuse.value.copy(i.color),
            i.emissive &&
              e.emissive.value
                .copy(i.emissive)
                .multiplyScalar(i.emissiveIntensity),
            i.map && ((e.map.value = i.map), n(i.map, e.mapTransform)),
            i.alphaMap &&
              ((e.alphaMap.value = i.alphaMap),
              n(i.alphaMap, e.alphaMapTransform)),
            i.bumpMap &&
              ((e.bumpMap.value = i.bumpMap),
              n(i.bumpMap, e.bumpMapTransform),
              (e.bumpScale.value = i.bumpScale),
              i.side === ln && (e.bumpScale.value *= -1)),
            i.normalMap &&
              ((e.normalMap.value = i.normalMap),
              n(i.normalMap, e.normalMapTransform),
              e.normalScale.value.copy(i.normalScale),
              i.side === ln && e.normalScale.value.negate()),
            i.displacementMap &&
              ((e.displacementMap.value = i.displacementMap),
              n(i.displacementMap, e.displacementMapTransform),
              (e.displacementScale.value = i.displacementScale),
              (e.displacementBias.value = i.displacementBias)),
            i.emissiveMap &&
              ((e.emissiveMap.value = i.emissiveMap),
              n(i.emissiveMap, e.emissiveMapTransform)),
            i.specularMap &&
              ((e.specularMap.value = i.specularMap),
              n(i.specularMap, e.specularMapTransform)),
            i.alphaTest > 0 && (e.alphaTest.value = i.alphaTest);
          const r = t.get(i),
            s = r.envMap,
            a = r.envMapRotation;
          s &&
            ((e.envMap.value = s),
            hu.copy(a),
            (hu.x *= -1),
            (hu.y *= -1),
            (hu.z *= -1),
            s.isCubeTexture &&
              !1 === s.isRenderTargetTexture &&
              ((hu.y *= -1), (hu.z *= -1)),
            e.envMapRotation.value.setFromMatrix4(du.makeRotationFromEuler(hu)),
            (e.flipEnvMap.value =
              s.isCubeTexture && !1 === s.isRenderTargetTexture ? -1 : 1),
            (e.reflectivity.value = i.reflectivity),
            (e.ior.value = i.ior),
            (e.refractionRatio.value = i.refractionRatio)),
            i.lightMap &&
              ((e.lightMap.value = i.lightMap),
              (e.lightMapIntensity.value = i.lightMapIntensity),
              n(i.lightMap, e.lightMapTransform)),
            i.aoMap &&
              ((e.aoMap.value = i.aoMap),
              (e.aoMapIntensity.value = i.aoMapIntensity),
              n(i.aoMap, e.aoMapTransform));
        }
        return {
          refreshFogUniforms: function (t, n) {
            n.color.getRGB(t.fogColor.value, io(e)),
              n.isFog
                ? ((t.fogNear.value = n.near), (t.fogFar.value = n.far))
                : n.isFogExp2 && (t.fogDensity.value = n.density);
          },
          refreshMaterialUniforms: function (e, r, s, a, o) {
            r.isMeshBasicMaterial || r.isMeshLambertMaterial
              ? i(e, r)
              : r.isMeshToonMaterial
              ? (i(e, r),
                (function (e, t) {
                  t.gradientMap && (e.gradientMap.value = t.gradientMap);
                })(e, r))
              : r.isMeshPhongMaterial
              ? (i(e, r),
                (function (e, t) {
                  e.specular.value.copy(t.specular),
                    (e.shininess.value = Math.max(t.shininess, 1e-4));
                })(e, r))
              : r.isMeshStandardMaterial
              ? (i(e, r),
                (function (e, t) {
                  (e.metalness.value = t.metalness),
                    t.metalnessMap &&
                      ((e.metalnessMap.value = t.metalnessMap),
                      n(t.metalnessMap, e.metalnessMapTransform));
                  (e.roughness.value = t.roughness),
                    t.roughnessMap &&
                      ((e.roughnessMap.value = t.roughnessMap),
                      n(t.roughnessMap, e.roughnessMapTransform));
                  t.envMap && (e.envMapIntensity.value = t.envMapIntensity);
                })(e, r),
                r.isMeshPhysicalMaterial &&
                  (function (e, t, i) {
                    (e.ior.value = t.ior),
                      t.sheen > 0 &&
                        (e.sheenColor.value
                          .copy(t.sheenColor)
                          .multiplyScalar(t.sheen),
                        (e.sheenRoughness.value = t.sheenRoughness),
                        t.sheenColorMap &&
                          ((e.sheenColorMap.value = t.sheenColorMap),
                          n(t.sheenColorMap, e.sheenColorMapTransform)),
                        t.sheenRoughnessMap &&
                          ((e.sheenRoughnessMap.value = t.sheenRoughnessMap),
                          n(
                            t.sheenRoughnessMap,
                            e.sheenRoughnessMapTransform
                          )));
                    t.clearcoat > 0 &&
                      ((e.clearcoat.value = t.clearcoat),
                      (e.clearcoatRoughness.value = t.clearcoatRoughness),
                      t.clearcoatMap &&
                        ((e.clearcoatMap.value = t.clearcoatMap),
                        n(t.clearcoatMap, e.clearcoatMapTransform)),
                      t.clearcoatRoughnessMap &&
                        ((e.clearcoatRoughnessMap.value =
                          t.clearcoatRoughnessMap),
                        n(
                          t.clearcoatRoughnessMap,
                          e.clearcoatRoughnessMapTransform
                        )),
                      t.clearcoatNormalMap &&
                        ((e.clearcoatNormalMap.value = t.clearcoatNormalMap),
                        n(t.clearcoatNormalMap, e.clearcoatNormalMapTransform),
                        e.clearcoatNormalScale.value.copy(
                          t.clearcoatNormalScale
                        ),
                        t.side === ln &&
                          e.clearcoatNormalScale.value.negate()));
                    t.dispersion > 0 && (e.dispersion.value = t.dispersion);
                    t.iridescence > 0 &&
                      ((e.iridescence.value = t.iridescence),
                      (e.iridescenceIOR.value = t.iridescenceIOR),
                      (e.iridescenceThicknessMinimum.value =
                        t.iridescenceThicknessRange[0]),
                      (e.iridescenceThicknessMaximum.value =
                        t.iridescenceThicknessRange[1]),
                      t.iridescenceMap &&
                        ((e.iridescenceMap.value = t.iridescenceMap),
                        n(t.iridescenceMap, e.iridescenceMapTransform)),
                      t.iridescenceThicknessMap &&
                        ((e.iridescenceThicknessMap.value =
                          t.iridescenceThicknessMap),
                        n(
                          t.iridescenceThicknessMap,
                          e.iridescenceThicknessMapTransform
                        )));
                    t.transmission > 0 &&
                      ((e.transmission.value = t.transmission),
                      (e.transmissionSamplerMap.value = i.texture),
                      e.transmissionSamplerSize.value.set(i.width, i.height),
                      t.transmissionMap &&
                        ((e.transmissionMap.value = t.transmissionMap),
                        n(t.transmissionMap, e.transmissionMapTransform)),
                      (e.thickness.value = t.thickness),
                      t.thicknessMap &&
                        ((e.thicknessMap.value = t.thicknessMap),
                        n(t.thicknessMap, e.thicknessMapTransform)),
                      (e.attenuationDistance.value = t.attenuationDistance),
                      e.attenuationColor.value.copy(t.attenuationColor));
                    t.anisotropy > 0 &&
                      (e.anisotropyVector.value.set(
                        t.anisotropy * Math.cos(t.anisotropyRotation),
                        t.anisotropy * Math.sin(t.anisotropyRotation)
                      ),
                      t.anisotropyMap &&
                        ((e.anisotropyMap.value = t.anisotropyMap),
                        n(t.anisotropyMap, e.anisotropyMapTransform)));
                    (e.specularIntensity.value = t.specularIntensity),
                      e.specularColor.value.copy(t.specularColor),
                      t.specularColorMap &&
                        ((e.specularColorMap.value = t.specularColorMap),
                        n(t.specularColorMap, e.specularColorMapTransform));
                    t.specularIntensityMap &&
                      ((e.specularIntensityMap.value = t.specularIntensityMap),
                      n(
                        t.specularIntensityMap,
                        e.specularIntensityMapTransform
                      ));
                  })(e, r, o))
              : r.isMeshMatcapMaterial
              ? (i(e, r),
                (function (e, t) {
                  t.matcap && (e.matcap.value = t.matcap);
                })(e, r))
              : r.isMeshDepthMaterial
              ? i(e, r)
              : r.isMeshDistanceMaterial
              ? (i(e, r),
                (function (e, n) {
                  const i = t.get(n).light;
                  e.referencePosition.value.setFromMatrixPosition(
                    i.matrixWorld
                  ),
                    (e.nearDistance.value = i.shadow.camera.near),
                    (e.farDistance.value = i.shadow.camera.far);
                })(e, r))
              : r.isMeshNormalMaterial
              ? i(e, r)
              : r.isLineBasicMaterial
              ? ((function (e, t) {
                  e.diffuse.value.copy(t.color),
                    (e.opacity.value = t.opacity),
                    t.map && ((e.map.value = t.map), n(t.map, e.mapTransform));
                })(e, r),
                r.isLineDashedMaterial &&
                  (function (e, t) {
                    (e.dashSize.value = t.dashSize),
                      (e.totalSize.value = t.dashSize + t.gapSize),
                      (e.scale.value = t.scale);
                  })(e, r))
              : r.isPointsMaterial
              ? (function (e, t, i, r) {
                  e.diffuse.value.copy(t.color),
                    (e.opacity.value = t.opacity),
                    (e.size.value = t.size * i),
                    (e.scale.value = 0.5 * r),
                    t.map && ((e.map.value = t.map), n(t.map, e.uvTransform));
                  t.alphaMap &&
                    ((e.alphaMap.value = t.alphaMap),
                    n(t.alphaMap, e.alphaMapTransform));
                  t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest);
                })(e, r, s, a)
              : r.isSpriteMaterial
              ? (function (e, t) {
                  e.diffuse.value.copy(t.color),
                    (e.opacity.value = t.opacity),
                    (e.rotation.value = t.rotation),
                    t.map && ((e.map.value = t.map), n(t.map, e.mapTransform));
                  t.alphaMap &&
                    ((e.alphaMap.value = t.alphaMap),
                    n(t.alphaMap, e.alphaMapTransform));
                  t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest);
                })(e, r)
              : r.isShadowMaterial
              ? (e.color.value.copy(r.color), (e.opacity.value = r.opacity))
              : r.isShaderMaterial && (r.uniformsNeedUpdate = !1);
          },
        };
      }
      function fu(e, t, n, i) {
        let r = {},
          s = {},
          a = [];
        const o = e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS);
        function c(e, t, n, i) {
          const r = e.value,
            s = t + "_" + n;
          if (void 0 === i[s])
            return (
              (i[s] =
                "number" == typeof r || "boolean" == typeof r ? r : r.clone()),
              !0
            );
          {
            const e = i[s];
            if ("number" == typeof r || "boolean" == typeof r) {
              if (e !== r) return (i[s] = r), !0;
            } else if (!1 === e.equals(r)) return e.copy(r), !0;
          }
          return !1;
        }
        function l(e) {
          const t = { boundary: 0, storage: 0 };
          return (
            "number" == typeof e || "boolean" == typeof e
              ? ((t.boundary = 4), (t.storage = 4))
              : e.isVector2
              ? ((t.boundary = 8), (t.storage = 8))
              : e.isVector3 || e.isColor
              ? ((t.boundary = 16), (t.storage = 12))
              : e.isVector4
              ? ((t.boundary = 16), (t.storage = 16))
              : e.isMatrix3
              ? ((t.boundary = 48), (t.storage = 48))
              : e.isMatrix4
              ? ((t.boundary = 64), (t.storage = 64))
              : e.isTexture
              ? console.warn(
                  "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
                )
              : console.warn(
                  "THREE.WebGLRenderer: Unsupported uniform value type.",
                  e
                ),
            t
          );
        }
        function u(t) {
          const n = t.target;
          n.removeEventListener("dispose", u);
          const i = a.indexOf(n.__bindingPointIndex);
          a.splice(i, 1),
            e.deleteBuffer(r[n.id]),
            delete r[n.id],
            delete s[n.id];
        }
        return {
          bind: function (e, t) {
            const n = t.program;
            i.uniformBlockBinding(e, n);
          },
          update: function (n, h) {
            let d = r[n.id];
            void 0 === d &&
              (!(function (e) {
                const t = e.uniforms;
                let n = 0;
                const i = 16;
                for (let e = 0, r = t.length; e < r; e++) {
                  const r = Array.isArray(t[e]) ? t[e] : [t[e]];
                  for (let e = 0, t = r.length; e < t; e++) {
                    const t = r[e],
                      s = Array.isArray(t.value) ? t.value : [t.value];
                    for (let e = 0, r = s.length; e < r; e++) {
                      const r = l(s[e]),
                        a = n % i,
                        o = a % r.boundary,
                        c = a + o;
                      (n += o),
                        0 !== c && i - c < r.storage && (n += i - c),
                        (t.__data = new Float32Array(
                          r.storage / Float32Array.BYTES_PER_ELEMENT
                        )),
                        (t.__offset = n),
                        (n += r.storage);
                    }
                  }
                }
                const r = n % i;
                r > 0 && (n += i - r);
                (e.__size = n), (e.__cache = {});
              })(n),
              (d = (function (t) {
                const n = (function () {
                  for (let e = 0; e < o; e++)
                    if (-1 === a.indexOf(e)) return a.push(e), e;
                  return (
                    console.error(
                      "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
                    ),
                    0
                  );
                })();
                t.__bindingPointIndex = n;
                const i = e.createBuffer(),
                  r = t.__size,
                  s = t.usage;
                return (
                  e.bindBuffer(e.UNIFORM_BUFFER, i),
                  e.bufferData(e.UNIFORM_BUFFER, r, s),
                  e.bindBuffer(e.UNIFORM_BUFFER, null),
                  e.bindBufferBase(e.UNIFORM_BUFFER, n, i),
                  i
                );
              })(n)),
              (r[n.id] = d),
              n.addEventListener("dispose", u));
            const p = h.program;
            i.updateUBOMapping(n, p);
            const f = t.render.frame;
            s[n.id] !== f &&
              (!(function (t) {
                const n = r[t.id],
                  i = t.uniforms,
                  s = t.__cache;
                e.bindBuffer(e.UNIFORM_BUFFER, n);
                for (let t = 0, n = i.length; t < n; t++) {
                  const n = Array.isArray(i[t]) ? i[t] : [i[t]];
                  for (let i = 0, r = n.length; i < r; i++) {
                    const r = n[i];
                    if (!0 === c(r, t, i, s)) {
                      const t = r.__offset,
                        n = Array.isArray(r.value) ? r.value : [r.value];
                      let i = 0;
                      for (let s = 0; s < n.length; s++) {
                        const a = n[s],
                          o = l(a);
                        "number" == typeof a || "boolean" == typeof a
                          ? ((r.__data[0] = a),
                            e.bufferSubData(e.UNIFORM_BUFFER, t + i, r.__data))
                          : a.isMatrix3
                          ? ((r.__data[0] = a.elements[0]),
                            (r.__data[1] = a.elements[1]),
                            (r.__data[2] = a.elements[2]),
                            (r.__data[3] = 0),
                            (r.__data[4] = a.elements[3]),
                            (r.__data[5] = a.elements[4]),
                            (r.__data[6] = a.elements[5]),
                            (r.__data[7] = 0),
                            (r.__data[8] = a.elements[6]),
                            (r.__data[9] = a.elements[7]),
                            (r.__data[10] = a.elements[8]),
                            (r.__data[11] = 0))
                          : (a.toArray(r.__data, i),
                            (i += o.storage / Float32Array.BYTES_PER_ELEMENT));
                      }
                      e.bufferSubData(e.UNIFORM_BUFFER, t, r.__data);
                    }
                  }
                }
                e.bindBuffer(e.UNIFORM_BUFFER, null);
              })(n),
              (s[n.id] = f));
          },
          dispose: function () {
            for (const t in r) e.deleteBuffer(r[t]);
            (a = []), (r = {}), (s = {});
          },
        };
      }
      class Au {
        constructor(e = {}) {
          const {
            canvas: t = Cr(),
            context: n = null,
            depth: i = !0,
            stencil: r = !1,
            alpha: s = !1,
            antialias: a = !1,
            premultipliedAlpha: o = !0,
            preserveDrawingBuffer: c = !1,
            powerPreference: l = "default",
            failIfMajorPerformanceCaveat: u = !1,
            reverseDepthBuffer: h = !1,
          } = e;
          let d;
          if (((this.isWebGLRenderer = !0), null !== n)) {
            if (
              "undefined" != typeof WebGLRenderingContext &&
              n instanceof WebGLRenderingContext
            )
              throw new Error(
                "THREE.WebGLRenderer: WebGL 1 is not supported since r163."
              );
            d = n.getContextAttributes().alpha;
          } else d = s;
          const p = new Uint32Array(4),
            f = new Int32Array(4);
          let A = null,
            g = null;
          const m = [],
            v = [];
          (this.domElement = t),
            (this.debug = { checkShaderErrors: !0, onShaderError: null }),
            (this.autoClear = !0),
            (this.autoClearColor = !0),
            (this.autoClearDepth = !0),
            (this.autoClearStencil = !0),
            (this.sortObjects = !0),
            (this.clippingPlanes = []),
            (this.localClippingEnabled = !1),
            (this._outputColorSpace = Zi),
            (this.toneMapping = An),
            (this.toneMappingExposure = 1);
          const y = this;
          let b = !1,
            _ = 0,
            x = 0,
            E = null,
            w = -1,
            C = null;
          const S = new zr(),
            I = new zr();
          let M = null;
          const T = new ma(0);
          let B = 0,
            R = t.width,
            D = t.height,
            P = 1,
            L = null,
            U = null;
          const F = new zr(0, 0, R, D),
            O = new zr(0, 0, R, D);
          let N = !1;
          const k = new xo();
          let Q = !1,
            G = !1;
          const H = new Cs(),
            z = new Cs(),
            V = new Yr(),
            j = new zr(),
            W = {
              background: null,
              fog: null,
              environment: null,
              overrideMaterial: null,
              isScene: !0,
            };
          let X = !1;
          function q() {
            return null === E ? P : 1;
          }
          let Y,
            K,
            J,
            Z,
            $,
            ee,
            te,
            ne,
            ie,
            re,
            se,
            ae,
            oe,
            ce,
            le,
            ue,
            he,
            de,
            pe,
            fe,
            Ae,
            ge,
            me,
            ve,
            ye = n;
          function be(e, n) {
            return t.getContext(e, n);
          }
          try {
            const e = {
              alpha: !0,
              depth: i,
              stencil: r,
              antialias: a,
              premultipliedAlpha: o,
              preserveDrawingBuffer: c,
              powerPreference: l,
              failIfMajorPerformanceCaveat: u,
            };
            if (
              ("setAttribute" in t &&
                t.setAttribute("data-engine", `three.js r${rn}`),
              t.addEventListener("webglcontextlost", Ee, !1),
              t.addEventListener("webglcontextrestored", we, !1),
              t.addEventListener("webglcontextcreationerror", Ce, !1),
              null === ye)
            ) {
              const t = "webgl2";
              if (((ye = be(t, e)), null === ye))
                throw be(t)
                  ? new Error(
                      "Error creating WebGL context with your selected attributes."
                    )
                  : new Error("Error creating WebGL context.");
            }
          } catch (e) {
            throw (console.error("THREE.WebGLRenderer: " + e.message), e);
          }
          function _e() {
            (Y = new ic(ye)),
              Y.init(),
              (ge = new ru(ye, Y)),
              (K = new Uo(ye, Y, e, ge)),
              (J = new tu(ye, Y)),
              K.reverseDepthBuffer && h && J.buffers.depth.setReversed(!0),
              (Z = new ac(ye)),
              ($ = new Ql()),
              (ee = new iu(ye, Y, J, $, K, ge, Z)),
              (te = new Oo(y)),
              (ne = new nc(y)),
              (ie = new wo(ye)),
              (me = new Po(ye, ie)),
              (re = new rc(ye, ie, Z, me)),
              (se = new cc(ye, re, ie, Z)),
              (pe = new oc(ye, K, ee)),
              (ue = new Fo($)),
              (ae = new kl(y, te, ne, Y, K, me, ue)),
              (oe = new pu(y, $)),
              (ce = new Vl()),
              (le = new Kl(Y)),
              (de = new Do(y, te, ne, J, se, d, o)),
              (he = new $l(y, se, K)),
              (ve = new fu(ye, Z, K, J)),
              (fe = new Lo(ye, Y, Z)),
              (Ae = new sc(ye, Y, Z)),
              (Z.programs = ae.programs),
              (y.capabilities = K),
              (y.extensions = Y),
              (y.properties = $),
              (y.renderLists = ce),
              (y.shadowMap = he),
              (y.state = J),
              (y.info = Z);
          }
          _e();
          const xe = new uu(y, ye);
          function Ee(e) {
            e.preventDefault(),
              console.log("THREE.WebGLRenderer: Context Lost."),
              (b = !0);
          }
          function we() {
            console.log("THREE.WebGLRenderer: Context Restored."), (b = !1);
            const e = Z.autoReset,
              t = he.enabled,
              n = he.autoUpdate,
              i = he.needsUpdate,
              r = he.type;
            _e(),
              (Z.autoReset = e),
              (he.enabled = t),
              (he.autoUpdate = n),
              (he.needsUpdate = i),
              (he.type = r);
          }
          function Ce(e) {
            console.error(
              "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
              e.statusMessage
            );
          }
          function Se(e) {
            const t = e.target;
            t.removeEventListener("dispose", Se),
              (function (e) {
                (function (e) {
                  const t = $.get(e).programs;
                  void 0 !== t &&
                    (t.forEach(function (e) {
                      ae.releaseProgram(e);
                    }),
                    e.isShaderMaterial && ae.releaseShaderCache(e));
                })(e),
                  $.remove(e);
              })(t);
          }
          function Ie(e, t, n) {
            !0 === e.transparent && e.side === un && !1 === e.forceSinglePass
              ? ((e.side = ln),
                (e.needsUpdate = !0),
                Oe(e, t, n),
                (e.side = cn),
                (e.needsUpdate = !0),
                Oe(e, t, n),
                (e.side = un))
              : Oe(e, t, n);
          }
          (this.xr = xe),
            (this.getContext = function () {
              return ye;
            }),
            (this.getContextAttributes = function () {
              return ye.getContextAttributes();
            }),
            (this.forceContextLoss = function () {
              const e = Y.get("WEBGL_lose_context");
              e && e.loseContext();
            }),
            (this.forceContextRestore = function () {
              const e = Y.get("WEBGL_lose_context");
              e && e.restoreContext();
            }),
            (this.getPixelRatio = function () {
              return P;
            }),
            (this.setPixelRatio = function (e) {
              void 0 !== e && ((P = e), this.setSize(R, D, !1));
            }),
            (this.getSize = function (e) {
              return e.set(R, D);
            }),
            (this.setSize = function (e, n, i = !0) {
              xe.isPresenting
                ? console.warn(
                    "THREE.WebGLRenderer: Can't change size while VR device is presenting."
                  )
                : ((R = e),
                  (D = n),
                  (t.width = Math.floor(e * P)),
                  (t.height = Math.floor(n * P)),
                  !0 === i &&
                    ((t.style.width = e + "px"), (t.style.height = n + "px")),
                  this.setViewport(0, 0, e, n));
            }),
            (this.getDrawingBufferSize = function (e) {
              return e.set(R * P, D * P).floor();
            }),
            (this.setDrawingBufferSize = function (e, n, i) {
              (R = e),
                (D = n),
                (P = i),
                (t.width = Math.floor(e * i)),
                (t.height = Math.floor(n * i)),
                this.setViewport(0, 0, e, n);
            }),
            (this.getCurrentViewport = function (e) {
              return e.copy(S);
            }),
            (this.getViewport = function (e) {
              return e.copy(F);
            }),
            (this.setViewport = function (e, t, n, i) {
              e.isVector4 ? F.set(e.x, e.y, e.z, e.w) : F.set(e, t, n, i),
                J.viewport(S.copy(F).multiplyScalar(P).round());
            }),
            (this.getScissor = function (e) {
              return e.copy(O);
            }),
            (this.setScissor = function (e, t, n, i) {
              e.isVector4 ? O.set(e.x, e.y, e.z, e.w) : O.set(e, t, n, i),
                J.scissor(I.copy(O).multiplyScalar(P).round());
            }),
            (this.getScissorTest = function () {
              return N;
            }),
            (this.setScissorTest = function (e) {
              J.setScissorTest((N = e));
            }),
            (this.setOpaqueSort = function (e) {
              L = e;
            }),
            (this.setTransparentSort = function (e) {
              U = e;
            }),
            (this.getClearColor = function (e) {
              return e.copy(de.getClearColor());
            }),
            (this.setClearColor = function () {
              de.setClearColor.apply(de, arguments);
            }),
            (this.getClearAlpha = function () {
              return de.getClearAlpha();
            }),
            (this.setClearAlpha = function () {
              de.setClearAlpha.apply(de, arguments);
            }),
            (this.clear = function (e = !0, t = !0, n = !0) {
              let i = 0;
              if (e) {
                let e = !1;
                if (null !== E) {
                  const t = E.texture.format;
                  e = t === oi || t === ai || t === ri;
                }
                if (e) {
                  const e = E.texture.type,
                    t =
                      e === Nn ||
                      e === zn ||
                      e === Gn ||
                      e === qn ||
                      e === Wn ||
                      e === Xn,
                    n = de.getClearColor(),
                    i = de.getClearAlpha(),
                    r = n.r,
                    s = n.g,
                    a = n.b;
                  t
                    ? ((p[0] = r),
                      (p[1] = s),
                      (p[2] = a),
                      (p[3] = i),
                      ye.clearBufferuiv(ye.COLOR, 0, p))
                    : ((f[0] = r),
                      (f[1] = s),
                      (f[2] = a),
                      (f[3] = i),
                      ye.clearBufferiv(ye.COLOR, 0, f));
                } else i |= ye.COLOR_BUFFER_BIT;
              }
              t && (i |= ye.DEPTH_BUFFER_BIT),
                n &&
                  ((i |= ye.STENCIL_BUFFER_BIT),
                  this.state.buffers.stencil.setMask(4294967295)),
                ye.clear(i);
            }),
            (this.clearColor = function () {
              this.clear(!0, !1, !1);
            }),
            (this.clearDepth = function () {
              this.clear(!1, !0, !1);
            }),
            (this.clearStencil = function () {
              this.clear(!1, !1, !0);
            }),
            (this.dispose = function () {
              t.removeEventListener("webglcontextlost", Ee, !1),
                t.removeEventListener("webglcontextrestored", we, !1),
                t.removeEventListener("webglcontextcreationerror", Ce, !1),
                ce.dispose(),
                le.dispose(),
                $.dispose(),
                te.dispose(),
                ne.dispose(),
                se.dispose(),
                me.dispose(),
                ve.dispose(),
                ae.dispose(),
                xe.dispose(),
                xe.removeEventListener("sessionstart", Te),
                xe.removeEventListener("sessionend", Be),
                Re.stop();
            }),
            (this.renderBufferDirect = function (e, t, n, i, r, s) {
              null === t && (t = W);
              const a = r.isMesh && r.matrixWorld.determinant() < 0,
                o = (function (e, t, n, i, r) {
                  !0 !== t.isScene && (t = W);
                  ee.resetTextureUnits();
                  const s = t.fog,
                    a = i.isMeshStandardMaterial ? t.environment : null,
                    o =
                      null === E
                        ? y.outputColorSpace
                        : !0 === E.isXRRenderTarget
                        ? E.texture.colorSpace
                        : $i,
                    c = (i.isMeshStandardMaterial ? ne : te).get(i.envMap || a),
                    l =
                      !0 === i.vertexColors &&
                      !!n.attributes.color &&
                      4 === n.attributes.color.itemSize,
                    u =
                      !!n.attributes.tangent &&
                      (!!i.normalMap || i.anisotropy > 0),
                    h = !!n.morphAttributes.position,
                    d = !!n.morphAttributes.normal,
                    p = !!n.morphAttributes.color;
                  let f = An;
                  i.toneMapped &&
                    ((null !== E && !0 !== E.isXRRenderTarget) ||
                      (f = y.toneMapping));
                  const A =
                      n.morphAttributes.position ||
                      n.morphAttributes.normal ||
                      n.morphAttributes.color,
                    m = void 0 !== A ? A.length : 0,
                    v = $.get(i),
                    b = g.state.lights;
                  if (!0 === Q && (!0 === G || e !== C)) {
                    const t = e === C && i.id === w;
                    ue.setState(i, e, t);
                  }
                  let _ = !1;
                  i.version === v.__version
                    ? (v.needsLights &&
                        v.lightsStateVersion !== b.state.version) ||
                      v.outputColorSpace !== o ||
                      (r.isBatchedMesh && !1 === v.batching)
                      ? (_ = !0)
                      : r.isBatchedMesh || !0 !== v.batching
                      ? (r.isBatchedMesh &&
                          !0 === v.batchingColor &&
                          null === r.colorTexture) ||
                        (r.isBatchedMesh &&
                          !1 === v.batchingColor &&
                          null !== r.colorTexture) ||
                        (r.isInstancedMesh && !1 === v.instancing)
                        ? (_ = !0)
                        : r.isInstancedMesh || !0 !== v.instancing
                        ? r.isSkinnedMesh && !1 === v.skinning
                          ? (_ = !0)
                          : r.isSkinnedMesh || !0 !== v.skinning
                          ? (r.isInstancedMesh &&
                              !0 === v.instancingColor &&
                              null === r.instanceColor) ||
                            (r.isInstancedMesh &&
                              !1 === v.instancingColor &&
                              null !== r.instanceColor) ||
                            (r.isInstancedMesh &&
                              !0 === v.instancingMorph &&
                              null === r.morphTexture) ||
                            (r.isInstancedMesh &&
                              !1 === v.instancingMorph &&
                              null !== r.morphTexture) ||
                            v.envMap !== c ||
                            (!0 === i.fog && v.fog !== s)
                            ? (_ = !0)
                            : void 0 === v.numClippingPlanes ||
                              (v.numClippingPlanes === ue.numPlanes &&
                                v.numIntersection === ue.numIntersection)
                            ? (v.vertexAlphas !== l ||
                                v.vertexTangents !== u ||
                                v.morphTargets !== h ||
                                v.morphNormals !== d ||
                                v.morphColors !== p ||
                                v.toneMapping !== f ||
                                v.morphTargetsCount !== m) &&
                              (_ = !0)
                            : (_ = !0)
                          : (_ = !0)
                        : (_ = !0)
                      : (_ = !0)
                    : ((_ = !0), (v.__version = i.version));
                  let x = v.currentProgram;
                  !0 === _ && (x = Oe(i, t, r));
                  let S = !1,
                    I = !1,
                    M = !1;
                  const T = x.getUniforms(),
                    B = v.uniforms;
                  J.useProgram(x.program) && ((S = !0), (I = !0), (M = !0));
                  i.id !== w && ((w = i.id), (I = !0));
                  if (S || C !== e) {
                    J.buffers.depth.getReversed()
                      ? (H.copy(e.projectionMatrix),
                        (function (e) {
                          const t = e.elements;
                          (t[2] = 0.5 * t[2] + 0.5 * t[3]),
                            (t[6] = 0.5 * t[6] + 0.5 * t[7]),
                            (t[10] = 0.5 * t[10] + 0.5 * t[11]),
                            (t[14] = 0.5 * t[14] + 0.5 * t[15]);
                        })(H),
                        (function (e) {
                          const t = e.elements;
                          -1 === t[11]
                            ? ((t[10] = -t[10] - 1), (t[14] = -t[14]))
                            : ((t[10] = -t[10]), (t[14] = 1 - t[14]));
                        })(H),
                        T.setValue(ye, "projectionMatrix", H))
                      : T.setValue(ye, "projectionMatrix", e.projectionMatrix),
                      T.setValue(ye, "viewMatrix", e.matrixWorldInverse);
                    const t = T.map.cameraPosition;
                    void 0 !== t &&
                      t.setValue(ye, V.setFromMatrixPosition(e.matrixWorld)),
                      K.logarithmicDepthBuffer &&
                        T.setValue(
                          ye,
                          "logDepthBufFC",
                          2 / (Math.log(e.far + 1) / Math.LN2)
                        ),
                      (i.isMeshPhongMaterial ||
                        i.isMeshToonMaterial ||
                        i.isMeshLambertMaterial ||
                        i.isMeshBasicMaterial ||
                        i.isMeshStandardMaterial ||
                        i.isShaderMaterial) &&
                        T.setValue(
                          ye,
                          "isOrthographic",
                          !0 === e.isOrthographicCamera
                        ),
                      C !== e && ((C = e), (I = !0), (M = !0));
                  }
                  if (r.isSkinnedMesh) {
                    T.setOptional(ye, r, "bindMatrix"),
                      T.setOptional(ye, r, "bindMatrixInverse");
                    const e = r.skeleton;
                    e &&
                      (null === e.boneTexture && e.computeBoneTexture(),
                      T.setValue(ye, "boneTexture", e.boneTexture, ee));
                  }
                  r.isBatchedMesh &&
                    (T.setOptional(ye, r, "batchingTexture"),
                    T.setValue(ye, "batchingTexture", r._matricesTexture, ee),
                    T.setOptional(ye, r, "batchingIdTexture"),
                    T.setValue(ye, "batchingIdTexture", r._indirectTexture, ee),
                    T.setOptional(ye, r, "batchingColorTexture"),
                    null !== r._colorsTexture &&
                      T.setValue(
                        ye,
                        "batchingColorTexture",
                        r._colorsTexture,
                        ee
                      ));
                  const R = n.morphAttributes;
                  (void 0 === R.position &&
                    void 0 === R.normal &&
                    void 0 === R.color) ||
                    pe.update(r, n, x);
                  (I || v.receiveShadow !== r.receiveShadow) &&
                    ((v.receiveShadow = r.receiveShadow),
                    T.setValue(ye, "receiveShadow", r.receiveShadow));
                  i.isMeshGouraudMaterial &&
                    null !== i.envMap &&
                    ((B.envMap.value = c),
                    (B.flipEnvMap.value =
                      c.isCubeTexture && !1 === c.isRenderTargetTexture
                        ? -1
                        : 1));
                  i.isMeshStandardMaterial &&
                    null === i.envMap &&
                    null !== t.environment &&
                    (B.envMapIntensity.value = t.environmentIntensity);
                  I &&
                    (T.setValue(
                      ye,
                      "toneMappingExposure",
                      y.toneMappingExposure
                    ),
                    v.needsLights &&
                      ((U = M),
                      ((L = B).ambientLightColor.needsUpdate = U),
                      (L.lightProbe.needsUpdate = U),
                      (L.directionalLights.needsUpdate = U),
                      (L.directionalLightShadows.needsUpdate = U),
                      (L.pointLights.needsUpdate = U),
                      (L.pointLightShadows.needsUpdate = U),
                      (L.spotLights.needsUpdate = U),
                      (L.spotLightShadows.needsUpdate = U),
                      (L.rectAreaLights.needsUpdate = U),
                      (L.hemisphereLights.needsUpdate = U)),
                    s && !0 === i.fog && oe.refreshFogUniforms(B, s),
                    oe.refreshMaterialUniforms(
                      B,
                      i,
                      P,
                      D,
                      g.state.transmissionRenderTarget[e.id]
                    ),
                    fl.upload(ye, Ne(v), B, ee));
                  var L, U;
                  i.isShaderMaterial &&
                    !0 === i.uniformsNeedUpdate &&
                    (fl.upload(ye, Ne(v), B, ee), (i.uniformsNeedUpdate = !1));
                  i.isSpriteMaterial && T.setValue(ye, "center", r.center);
                  if (
                    (T.setValue(ye, "modelViewMatrix", r.modelViewMatrix),
                    T.setValue(ye, "normalMatrix", r.normalMatrix),
                    T.setValue(ye, "modelMatrix", r.matrixWorld),
                    i.isShaderMaterial || i.isRawShaderMaterial)
                  ) {
                    const e = i.uniformsGroups;
                    for (let t = 0, n = e.length; t < n; t++) {
                      const n = e[t];
                      ve.update(n, x), ve.bind(n, x);
                    }
                  }
                  return x;
                })(e, t, n, i, r);
              J.setMaterial(i, a);
              let c = n.index,
                l = 1;
              if (!0 === i.wireframe) {
                if (((c = re.getWireframeAttribute(n)), void 0 === c)) return;
                l = 2;
              }
              const u = n.drawRange,
                h = n.attributes.position;
              let d = u.start * l,
                p = (u.start + u.count) * l;
              null !== s &&
                ((d = Math.max(d, s.start * l)),
                (p = Math.min(p, (s.start + s.count) * l))),
                null !== c
                  ? ((d = Math.max(d, 0)), (p = Math.min(p, c.count)))
                  : null != h &&
                    ((d = Math.max(d, 0)), (p = Math.min(p, h.count)));
              const f = p - d;
              if (f < 0 || f === 1 / 0) return;
              let A;
              me.setup(r, i, o, n, c);
              let m = fe;
              if (
                (null !== c && ((A = ie.get(c)), (m = Ae), m.setIndex(A)),
                r.isMesh)
              )
                !0 === i.wireframe
                  ? (J.setLineWidth(i.wireframeLinewidth * q()),
                    m.setMode(ye.LINES))
                  : m.setMode(ye.TRIANGLES);
              else if (r.isLine) {
                let e = i.linewidth;
                void 0 === e && (e = 1),
                  J.setLineWidth(e * q()),
                  r.isLineSegments
                    ? m.setMode(ye.LINES)
                    : r.isLineLoop
                    ? m.setMode(ye.LINE_LOOP)
                    : m.setMode(ye.LINE_STRIP);
              } else
                r.isPoints
                  ? m.setMode(ye.POINTS)
                  : r.isSprite && m.setMode(ye.TRIANGLES);
              if (r.isBatchedMesh)
                if (null !== r._multiDrawInstances)
                  m.renderMultiDrawInstances(
                    r._multiDrawStarts,
                    r._multiDrawCounts,
                    r._multiDrawCount,
                    r._multiDrawInstances
                  );
                else if (Y.get("WEBGL_multi_draw"))
                  m.renderMultiDraw(
                    r._multiDrawStarts,
                    r._multiDrawCounts,
                    r._multiDrawCount
                  );
                else {
                  const e = r._multiDrawStarts,
                    t = r._multiDrawCounts,
                    n = r._multiDrawCount,
                    s = c ? ie.get(c).bytesPerElement : 1,
                    a = $.get(i).currentProgram.getUniforms();
                  for (let i = 0; i < n; i++)
                    a.setValue(ye, "_gl_DrawID", i), m.render(e[i] / s, t[i]);
                }
              else if (r.isInstancedMesh) m.renderInstances(d, f, r.count);
              else if (n.isInstancedBufferGeometry) {
                const e =
                    void 0 !== n._maxInstanceCount
                      ? n._maxInstanceCount
                      : 1 / 0,
                  t = Math.min(n.instanceCount, e);
                m.renderInstances(d, f, t);
              } else m.render(d, f);
            }),
            (this.compile = function (e, t, n = null) {
              null === n && (n = e),
                (g = le.get(n)),
                g.init(t),
                v.push(g),
                n.traverseVisible(function (e) {
                  e.isLight &&
                    e.layers.test(t.layers) &&
                    (g.pushLight(e), e.castShadow && g.pushShadow(e));
                }),
                e !== n &&
                  e.traverseVisible(function (e) {
                    e.isLight &&
                      e.layers.test(t.layers) &&
                      (g.pushLight(e), e.castShadow && g.pushShadow(e));
                  }),
                g.setupLights();
              const i = new Set();
              return (
                e.traverse(function (e) {
                  if (!(e.isMesh || e.isPoints || e.isLine || e.isSprite))
                    return;
                  const t = e.material;
                  if (t)
                    if (Array.isArray(t))
                      for (let r = 0; r < t.length; r++) {
                        const s = t[r];
                        Ie(s, n, e), i.add(s);
                      }
                    else Ie(t, n, e), i.add(t);
                }),
                v.pop(),
                (g = null),
                i
              );
            }),
            (this.compileAsync = function (e, t, n = null) {
              const i = this.compile(e, t, n);
              return new Promise((t) => {
                function n() {
                  i.forEach(function (e) {
                    $.get(e).currentProgram.isReady() && i.delete(e);
                  }),
                    0 !== i.size ? setTimeout(n, 10) : t(e);
                }
                null !== Y.get("KHR_parallel_shader_compile")
                  ? n()
                  : setTimeout(n, 10);
              });
            });
          let Me = null;
          function Te() {
            Re.stop();
          }
          function Be() {
            Re.start();
          }
          const Re = new Eo();
          function De(e, t, n, i) {
            if (!1 === e.visible) return;
            if (e.layers.test(t.layers))
              if (e.isGroup) n = e.renderOrder;
              else if (e.isLOD) !0 === e.autoUpdate && e.update(t);
              else if (e.isLight)
                g.pushLight(e), e.castShadow && g.pushShadow(e);
              else if (e.isSprite) {
                if (!e.frustumCulled || k.intersectsSprite(e)) {
                  i && j.setFromMatrixPosition(e.matrixWorld).applyMatrix4(z);
                  const t = se.update(e),
                    r = e.material;
                  r.visible && A.push(e, t, r, n, j.z, null);
                }
              } else if (
                (e.isMesh || e.isLine || e.isPoints) &&
                (!e.frustumCulled || k.intersectsObject(e))
              ) {
                const t = se.update(e),
                  r = e.material;
                if (
                  (i &&
                    (void 0 !== e.boundingSphere
                      ? (null === e.boundingSphere && e.computeBoundingSphere(),
                        j.copy(e.boundingSphere.center))
                      : (null === t.boundingSphere && t.computeBoundingSphere(),
                        j.copy(t.boundingSphere.center)),
                    j.applyMatrix4(e.matrixWorld).applyMatrix4(z)),
                  Array.isArray(r))
                ) {
                  const i = t.groups;
                  for (let s = 0, a = i.length; s < a; s++) {
                    const a = i[s],
                      o = r[a.materialIndex];
                    o && o.visible && A.push(e, t, o, n, j.z, a);
                  }
                } else r.visible && A.push(e, t, r, n, j.z, null);
              }
            const r = e.children;
            for (let e = 0, s = r.length; e < s; e++) De(r[e], t, n, i);
          }
          function Pe(e, t, n, i) {
            const r = e.opaque,
              s = e.transmissive,
              a = e.transparent;
            g.setupLightsView(n),
              !0 === Q && ue.setGlobalState(y.clippingPlanes, n),
              i && J.viewport(S.copy(i)),
              r.length > 0 && Ue(r, t, n),
              s.length > 0 && Ue(s, t, n),
              a.length > 0 && Ue(a, t, n),
              J.buffers.depth.setTest(!0),
              J.buffers.depth.setMask(!0),
              J.buffers.color.setMask(!0),
              J.setPolygonOffset(!1);
          }
          function Le(e, t, n, i) {
            if (null !== (!0 === n.isScene ? n.overrideMaterial : null)) return;
            void 0 === g.state.transmissionRenderTarget[i.id] &&
              (g.state.transmissionRenderTarget[i.id] = new jr(1, 1, {
                generateMipmaps: !0,
                type:
                  Y.has("EXT_color_buffer_half_float") ||
                  Y.has("EXT_color_buffer_float")
                    ? jn
                    : Nn,
                minFilter: On,
                samples: 4,
                stencilBuffer: r,
                resolveDepthBuffer: !1,
                resolveStencilBuffer: !1,
                colorSpace: Mr.workingColorSpace,
              }));
            const s = g.state.transmissionRenderTarget[i.id],
              a = i.viewport || S;
            s.setSize(a.z, a.w);
            const o = y.getRenderTarget();
            y.setRenderTarget(s),
              y.getClearColor(T),
              (B = y.getClearAlpha()),
              B < 1 && y.setClearColor(16777215, 0.5),
              y.clear(),
              X && de.render(n);
            const c = y.toneMapping;
            y.toneMapping = An;
            const l = i.viewport;
            if (
              (void 0 !== i.viewport && (i.viewport = void 0),
              g.setupLightsView(i),
              !0 === Q && ue.setGlobalState(y.clippingPlanes, i),
              Ue(e, n, i),
              ee.updateMultisampleRenderTarget(s),
              ee.updateRenderTargetMipmap(s),
              !1 === Y.has("WEBGL_multisampled_render_to_texture"))
            ) {
              let e = !1;
              for (let r = 0, s = t.length; r < s; r++) {
                const s = t[r],
                  a = s.object,
                  o = s.geometry,
                  c = s.material,
                  l = s.group;
                if (c.side === un && a.layers.test(i.layers)) {
                  const t = c.side;
                  (c.side = ln),
                    (c.needsUpdate = !0),
                    Fe(a, n, i, o, c, l),
                    (c.side = t),
                    (c.needsUpdate = !0),
                    (e = !0);
                }
              }
              !0 === e &&
                (ee.updateMultisampleRenderTarget(s),
                ee.updateRenderTargetMipmap(s));
            }
            y.setRenderTarget(o),
              y.setClearColor(T, B),
              void 0 !== l && (i.viewport = l),
              (y.toneMapping = c);
          }
          function Ue(e, t, n) {
            const i = !0 === t.isScene ? t.overrideMaterial : null;
            for (let r = 0, s = e.length; r < s; r++) {
              const s = e[r],
                a = s.object,
                o = s.geometry,
                c = null === i ? s.material : i,
                l = s.group;
              a.layers.test(n.layers) && Fe(a, t, n, o, c, l);
            }
          }
          function Fe(e, t, n, i, r, s) {
            e.onBeforeRender(y, t, n, i, r, s),
              e.modelViewMatrix.multiplyMatrices(
                n.matrixWorldInverse,
                e.matrixWorld
              ),
              e.normalMatrix.getNormalMatrix(e.modelViewMatrix),
              r.onBeforeRender(y, t, n, i, e, s),
              !0 === r.transparent && r.side === un && !1 === r.forceSinglePass
                ? ((r.side = ln),
                  (r.needsUpdate = !0),
                  y.renderBufferDirect(n, t, i, r, e, s),
                  (r.side = cn),
                  (r.needsUpdate = !0),
                  y.renderBufferDirect(n, t, i, r, e, s),
                  (r.side = un))
                : y.renderBufferDirect(n, t, i, r, e, s),
              e.onAfterRender(y, t, n, i, r, s);
          }
          function Oe(e, t, n) {
            !0 !== t.isScene && (t = W);
            const i = $.get(e),
              r = g.state.lights,
              s = g.state.shadowsArray,
              a = r.state.version,
              o = ae.getParameters(e, r.state, s, t, n),
              c = ae.getProgramCacheKey(o);
            let l = i.programs;
            (i.environment = e.isMeshStandardMaterial ? t.environment : null),
              (i.fog = t.fog),
              (i.envMap = (e.isMeshStandardMaterial ? ne : te).get(
                e.envMap || i.environment
              )),
              (i.envMapRotation =
                null !== i.environment && null === e.envMap
                  ? t.environmentRotation
                  : e.envMapRotation),
              void 0 === l &&
                (e.addEventListener("dispose", Se),
                (l = new Map()),
                (i.programs = l));
            let u = l.get(c);
            if (void 0 !== u) {
              if (i.currentProgram === u && i.lightsStateVersion === a)
                return ke(e, o), u;
            } else
              (o.uniforms = ae.getUniforms(e)),
                e.onBeforeCompile(o, y),
                (u = ae.acquireProgram(o, c)),
                l.set(c, u),
                (i.uniforms = o.uniforms);
            const h = i.uniforms;
            return (
              ((e.isShaderMaterial || e.isRawShaderMaterial) &&
                !0 !== e.clipping) ||
                (h.clippingPlanes = ue.uniform),
              ke(e, o),
              (i.needsLights = (function (e) {
                return (
                  e.isMeshLambertMaterial ||
                  e.isMeshToonMaterial ||
                  e.isMeshPhongMaterial ||
                  e.isMeshStandardMaterial ||
                  e.isShadowMaterial ||
                  (e.isShaderMaterial && !0 === e.lights)
                );
              })(e)),
              (i.lightsStateVersion = a),
              i.needsLights &&
                ((h.ambientLightColor.value = r.state.ambient),
                (h.lightProbe.value = r.state.probe),
                (h.directionalLights.value = r.state.directional),
                (h.directionalLightShadows.value = r.state.directionalShadow),
                (h.spotLights.value = r.state.spot),
                (h.spotLightShadows.value = r.state.spotShadow),
                (h.rectAreaLights.value = r.state.rectArea),
                (h.ltc_1.value = r.state.rectAreaLTC1),
                (h.ltc_2.value = r.state.rectAreaLTC2),
                (h.pointLights.value = r.state.point),
                (h.pointLightShadows.value = r.state.pointShadow),
                (h.hemisphereLights.value = r.state.hemi),
                (h.directionalShadowMap.value = r.state.directionalShadowMap),
                (h.directionalShadowMatrix.value =
                  r.state.directionalShadowMatrix),
                (h.spotShadowMap.value = r.state.spotShadowMap),
                (h.spotLightMatrix.value = r.state.spotLightMatrix),
                (h.spotLightMap.value = r.state.spotLightMap),
                (h.pointShadowMap.value = r.state.pointShadowMap),
                (h.pointShadowMatrix.value = r.state.pointShadowMatrix)),
              (i.currentProgram = u),
              (i.uniformsList = null),
              u
            );
          }
          function Ne(e) {
            if (null === e.uniformsList) {
              const t = e.currentProgram.getUniforms();
              e.uniformsList = fl.seqWithValue(t.seq, e.uniforms);
            }
            return e.uniformsList;
          }
          function ke(e, t) {
            const n = $.get(e);
            (n.outputColorSpace = t.outputColorSpace),
              (n.batching = t.batching),
              (n.batchingColor = t.batchingColor),
              (n.instancing = t.instancing),
              (n.instancingColor = t.instancingColor),
              (n.instancingMorph = t.instancingMorph),
              (n.skinning = t.skinning),
              (n.morphTargets = t.morphTargets),
              (n.morphNormals = t.morphNormals),
              (n.morphColors = t.morphColors),
              (n.morphTargetsCount = t.morphTargetsCount),
              (n.numClippingPlanes = t.numClippingPlanes),
              (n.numIntersection = t.numClipIntersection),
              (n.vertexAlphas = t.vertexAlphas),
              (n.vertexTangents = t.vertexTangents),
              (n.toneMapping = t.toneMapping);
          }
          Re.setAnimationLoop(function (e) {
            Me && Me(e);
          }),
            "undefined" != typeof self && Re.setContext(self),
            (this.setAnimationLoop = function (e) {
              (Me = e),
                xe.setAnimationLoop(e),
                null === e ? Re.stop() : Re.start();
            }),
            xe.addEventListener("sessionstart", Te),
            xe.addEventListener("sessionend", Be),
            (this.render = function (e, t) {
              if (void 0 !== t && !0 !== t.isCamera)
                return void console.error(
                  "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
                );
              if (!0 === b) return;
              if (
                (!0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(),
                null === t.parent &&
                  !0 === t.matrixWorldAutoUpdate &&
                  t.updateMatrixWorld(),
                !0 === xe.enabled &&
                  !0 === xe.isPresenting &&
                  (!0 === xe.cameraAutoUpdate && xe.updateCamera(t),
                  (t = xe.getCamera())),
                !0 === e.isScene && e.onBeforeRender(y, e, t, E),
                (g = le.get(e, v.length)),
                g.init(t),
                v.push(g),
                z.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
                k.setFromProjectionMatrix(z),
                (G = this.localClippingEnabled),
                (Q = ue.init(this.clippingPlanes, G)),
                (A = ce.get(e, m.length)),
                A.init(),
                m.push(A),
                !0 === xe.enabled && !0 === xe.isPresenting)
              ) {
                const e = y.xr.getDepthSensingMesh();
                null !== e && De(e, t, -1 / 0, y.sortObjects);
              }
              De(e, t, 0, y.sortObjects),
                A.finish(),
                !0 === y.sortObjects && A.sort(L, U),
                (X =
                  !1 === xe.enabled ||
                  !1 === xe.isPresenting ||
                  !1 === xe.hasDepthSensing()),
                X && de.addToRenderList(A, e),
                this.info.render.frame++,
                !0 === Q && ue.beginShadows();
              const n = g.state.shadowsArray;
              he.render(n, e, t),
                !0 === Q && ue.endShadows(),
                !0 === this.info.autoReset && this.info.reset();
              const i = A.opaque,
                r = A.transmissive;
              if ((g.setupLights(), t.isArrayCamera)) {
                const n = t.cameras;
                if (r.length > 0)
                  for (let t = 0, s = n.length; t < s; t++) {
                    Le(i, r, e, n[t]);
                  }
                X && de.render(e);
                for (let t = 0, i = n.length; t < i; t++) {
                  const i = n[t];
                  Pe(A, e, i, i.viewport);
                }
              } else
                r.length > 0 && Le(i, r, e, t), X && de.render(e), Pe(A, e, t);
              null !== E &&
                (ee.updateMultisampleRenderTarget(E),
                ee.updateRenderTargetMipmap(E)),
                !0 === e.isScene && e.onAfterRender(y, e, t),
                me.resetDefaultState(),
                (w = -1),
                (C = null),
                v.pop(),
                v.length > 0
                  ? ((g = v[v.length - 1]),
                    !0 === Q &&
                      ue.setGlobalState(y.clippingPlanes, g.state.camera))
                  : (g = null),
                m.pop(),
                (A = m.length > 0 ? m[m.length - 1] : null);
            }),
            (this.getActiveCubeFace = function () {
              return _;
            }),
            (this.getActiveMipmapLevel = function () {
              return x;
            }),
            (this.getRenderTarget = function () {
              return E;
            }),
            (this.setRenderTargetTextures = function (e, t, n) {
              ($.get(e.texture).__webglTexture = t),
                ($.get(e.depthTexture).__webglTexture = n);
              const i = $.get(e);
              (i.__hasExternalTextures = !0),
                (i.__autoAllocateDepthBuffer = void 0 === n),
                i.__autoAllocateDepthBuffer ||
                  (!0 === Y.has("WEBGL_multisampled_render_to_texture") &&
                    (console.warn(
                      "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
                    ),
                    (i.__useRenderToTexture = !1)));
            }),
            (this.setRenderTargetFramebuffer = function (e, t) {
              const n = $.get(e);
              (n.__webglFramebuffer = t),
                (n.__useDefaultFramebuffer = void 0 === t);
            }),
            (this.setRenderTarget = function (e, t = 0, n = 0) {
              (E = e), (_ = t), (x = n);
              let i = !0,
                r = null,
                s = !1,
                a = !1;
              if (e) {
                const o = $.get(e);
                if (void 0 !== o.__useDefaultFramebuffer)
                  J.bindFramebuffer(ye.FRAMEBUFFER, null), (i = !1);
                else if (void 0 === o.__webglFramebuffer)
                  ee.setupRenderTarget(e);
                else if (o.__hasExternalTextures)
                  ee.rebindTextures(
                    e,
                    $.get(e.texture).__webglTexture,
                    $.get(e.depthTexture).__webglTexture
                  );
                else if (e.depthBuffer) {
                  const t = e.depthTexture;
                  if (o.__boundDepthTexture !== t) {
                    if (
                      null !== t &&
                      $.has(t) &&
                      (e.width !== t.image.width || e.height !== t.image.height)
                    )
                      throw new Error(
                        "WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size."
                      );
                    ee.setupDepthRenderbuffer(e);
                  }
                }
                const c = e.texture;
                (c.isData3DTexture ||
                  c.isDataArrayTexture ||
                  c.isCompressedArrayTexture) &&
                  (a = !0);
                const l = $.get(e).__webglFramebuffer;
                e.isWebGLCubeRenderTarget
                  ? ((r = Array.isArray(l[t]) ? l[t][n] : l[t]), (s = !0))
                  : (r =
                      e.samples > 0 && !1 === ee.useMultisampledRTT(e)
                        ? $.get(e).__webglMultisampledFramebuffer
                        : Array.isArray(l)
                        ? l[n]
                        : l),
                  S.copy(e.viewport),
                  I.copy(e.scissor),
                  (M = e.scissorTest);
              } else
                S.copy(F).multiplyScalar(P).floor(),
                  I.copy(O).multiplyScalar(P).floor(),
                  (M = N);
              if (
                (J.bindFramebuffer(ye.FRAMEBUFFER, r) &&
                  i &&
                  J.drawBuffers(e, r),
                J.viewport(S),
                J.scissor(I),
                J.setScissorTest(M),
                s)
              ) {
                const i = $.get(e.texture);
                ye.framebufferTexture2D(
                  ye.FRAMEBUFFER,
                  ye.COLOR_ATTACHMENT0,
                  ye.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                  i.__webglTexture,
                  n
                );
              } else if (a) {
                const i = $.get(e.texture),
                  r = t || 0;
                ye.framebufferTextureLayer(
                  ye.FRAMEBUFFER,
                  ye.COLOR_ATTACHMENT0,
                  i.__webglTexture,
                  n || 0,
                  r
                );
              }
              w = -1;
            }),
            (this.readRenderTargetPixels = function (e, t, n, i, r, s, a) {
              if (!e || !e.isWebGLRenderTarget)
                return void console.error(
                  "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
                );
              let o = $.get(e).__webglFramebuffer;
              if (
                (e.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o)
              ) {
                J.bindFramebuffer(ye.FRAMEBUFFER, o);
                try {
                  const a = e.texture,
                    o = a.format,
                    c = a.type;
                  if (!K.textureFormatReadable(o))
                    return void console.error(
                      "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                    );
                  if (!K.textureTypeReadable(c))
                    return void console.error(
                      "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                    );
                  t >= 0 &&
                    t <= e.width - i &&
                    n >= 0 &&
                    n <= e.height - r &&
                    ye.readPixels(t, n, i, r, ge.convert(o), ge.convert(c), s);
                } finally {
                  const e = null !== E ? $.get(E).__webglFramebuffer : null;
                  J.bindFramebuffer(ye.FRAMEBUFFER, e);
                }
              }
            }),
            (this.readRenderTargetPixelsAsync = async function (
              e,
              t,
              n,
              i,
              r,
              s,
              a
            ) {
              if (!e || !e.isWebGLRenderTarget)
                throw new Error(
                  "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
                );
              let o = $.get(e).__webglFramebuffer;
              if (
                (e.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o)
              ) {
                const a = e.texture,
                  c = a.format,
                  l = a.type;
                if (!K.textureFormatReadable(c))
                  throw new Error(
                    "THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format."
                  );
                if (!K.textureTypeReadable(l))
                  throw new Error(
                    "THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type."
                  );
                if (t >= 0 && t <= e.width - i && n >= 0 && n <= e.height - r) {
                  J.bindFramebuffer(ye.FRAMEBUFFER, o);
                  const e = ye.createBuffer();
                  ye.bindBuffer(ye.PIXEL_PACK_BUFFER, e),
                    ye.bufferData(
                      ye.PIXEL_PACK_BUFFER,
                      s.byteLength,
                      ye.STREAM_READ
                    ),
                    ye.readPixels(t, n, i, r, ge.convert(c), ge.convert(l), 0);
                  const a = null !== E ? $.get(E).__webglFramebuffer : null;
                  J.bindFramebuffer(ye.FRAMEBUFFER, a);
                  const u = ye.fenceSync(ye.SYNC_GPU_COMMANDS_COMPLETE, 0);
                  return (
                    ye.flush(),
                    await (function (e, t, n) {
                      return new Promise(function (i, r) {
                        setTimeout(function s() {
                          switch (
                            e.clientWaitSync(t, e.SYNC_FLUSH_COMMANDS_BIT, 0)
                          ) {
                            case e.WAIT_FAILED:
                              r();
                              break;
                            case e.TIMEOUT_EXPIRED:
                              setTimeout(s, n);
                              break;
                            default:
                              i();
                          }
                        }, n);
                      });
                    })(ye, u, 4),
                    ye.bindBuffer(ye.PIXEL_PACK_BUFFER, e),
                    ye.getBufferSubData(ye.PIXEL_PACK_BUFFER, 0, s),
                    ye.deleteBuffer(e),
                    ye.deleteSync(u),
                    s
                  );
                }
                throw new Error(
                  "THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range."
                );
              }
            }),
            (this.copyFramebufferToTexture = function (e, t = null, n = 0) {
              !0 !== e.isTexture &&
                (Ir(
                  "WebGLRenderer: copyFramebufferToTexture function signature has changed."
                ),
                (t = arguments[0] || null),
                (e = arguments[1]));
              const i = Math.pow(2, -n),
                r = Math.floor(e.image.width * i),
                s = Math.floor(e.image.height * i),
                a = null !== t ? t.x : 0,
                o = null !== t ? t.y : 0;
              ee.setTexture2D(e, 0),
                ye.copyTexSubImage2D(ye.TEXTURE_2D, n, 0, 0, a, o, r, s),
                J.unbindTexture();
            }),
            (this.copyTextureToTexture = function (
              e,
              t,
              n = null,
              i = null,
              r = 0
            ) {
              let s, a, o, c, l, u, h, d, p;
              !0 !== e.isTexture &&
                (Ir(
                  "WebGLRenderer: copyTextureToTexture function signature has changed."
                ),
                (i = arguments[0] || null),
                (e = arguments[1]),
                (t = arguments[2]),
                (r = arguments[3] || 0),
                (n = null));
              const f = e.isCompressedTexture ? e.mipmaps[r] : e.image;
              null !== n
                ? ((s = n.max.x - n.min.x),
                  (a = n.max.y - n.min.y),
                  (o = n.isBox3 ? n.max.z - n.min.z : 1),
                  (c = n.min.x),
                  (l = n.min.y),
                  (u = n.isBox3 ? n.min.z : 0))
                : ((s = f.width),
                  (a = f.height),
                  (o = f.depth || 1),
                  (c = 0),
                  (l = 0),
                  (u = 0)),
                null !== i
                  ? ((h = i.x), (d = i.y), (p = i.z))
                  : ((h = 0), (d = 0), (p = 0));
              const A = ge.convert(t.format),
                g = ge.convert(t.type);
              let m;
              t.isData3DTexture
                ? (ee.setTexture3D(t, 0), (m = ye.TEXTURE_3D))
                : t.isDataArrayTexture || t.isCompressedArrayTexture
                ? (ee.setTexture2DArray(t, 0), (m = ye.TEXTURE_2D_ARRAY))
                : (ee.setTexture2D(t, 0), (m = ye.TEXTURE_2D)),
                ye.pixelStorei(ye.UNPACK_FLIP_Y_WEBGL, t.flipY),
                ye.pixelStorei(
                  ye.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                  t.premultiplyAlpha
                ),
                ye.pixelStorei(ye.UNPACK_ALIGNMENT, t.unpackAlignment);
              const v = ye.getParameter(ye.UNPACK_ROW_LENGTH),
                y = ye.getParameter(ye.UNPACK_IMAGE_HEIGHT),
                b = ye.getParameter(ye.UNPACK_SKIP_PIXELS),
                _ = ye.getParameter(ye.UNPACK_SKIP_ROWS),
                x = ye.getParameter(ye.UNPACK_SKIP_IMAGES);
              ye.pixelStorei(ye.UNPACK_ROW_LENGTH, f.width),
                ye.pixelStorei(ye.UNPACK_IMAGE_HEIGHT, f.height),
                ye.pixelStorei(ye.UNPACK_SKIP_PIXELS, c),
                ye.pixelStorei(ye.UNPACK_SKIP_ROWS, l),
                ye.pixelStorei(ye.UNPACK_SKIP_IMAGES, u);
              const E = e.isDataArrayTexture || e.isData3DTexture,
                w = t.isDataArrayTexture || t.isData3DTexture;
              if (e.isRenderTargetTexture || e.isDepthTexture) {
                const n = $.get(e),
                  i = $.get(t),
                  f = $.get(n.__renderTarget),
                  A = $.get(i.__renderTarget);
                J.bindFramebuffer(ye.READ_FRAMEBUFFER, f.__webglFramebuffer),
                  J.bindFramebuffer(ye.DRAW_FRAMEBUFFER, A.__webglFramebuffer);
                for (let n = 0; n < o; n++)
                  E &&
                    ye.framebufferTextureLayer(
                      ye.READ_FRAMEBUFFER,
                      ye.COLOR_ATTACHMENT0,
                      $.get(e).__webglTexture,
                      r,
                      u + n
                    ),
                    e.isDepthTexture
                      ? (w &&
                          ye.framebufferTextureLayer(
                            ye.DRAW_FRAMEBUFFER,
                            ye.COLOR_ATTACHMENT0,
                            $.get(t).__webglTexture,
                            r,
                            p + n
                          ),
                        ye.blitFramebuffer(
                          c,
                          l,
                          s,
                          a,
                          h,
                          d,
                          s,
                          a,
                          ye.DEPTH_BUFFER_BIT,
                          ye.NEAREST
                        ))
                      : w
                      ? ye.copyTexSubImage3D(m, r, h, d, p + n, c, l, s, a)
                      : ye.copyTexSubImage2D(m, r, h, d, p + n, c, l, s, a);
                J.bindFramebuffer(ye.READ_FRAMEBUFFER, null),
                  J.bindFramebuffer(ye.DRAW_FRAMEBUFFER, null);
              } else
                w
                  ? e.isDataTexture || e.isData3DTexture
                    ? ye.texSubImage3D(m, r, h, d, p, s, a, o, A, g, f.data)
                    : t.isCompressedArrayTexture
                    ? ye.compressedTexSubImage3D(
                        m,
                        r,
                        h,
                        d,
                        p,
                        s,
                        a,
                        o,
                        A,
                        f.data
                      )
                    : ye.texSubImage3D(m, r, h, d, p, s, a, o, A, g, f)
                  : e.isDataTexture
                  ? ye.texSubImage2D(ye.TEXTURE_2D, r, h, d, s, a, A, g, f.data)
                  : e.isCompressedTexture
                  ? ye.compressedTexSubImage2D(
                      ye.TEXTURE_2D,
                      r,
                      h,
                      d,
                      f.width,
                      f.height,
                      A,
                      f.data
                    )
                  : ye.texSubImage2D(ye.TEXTURE_2D, r, h, d, s, a, A, g, f);
              ye.pixelStorei(ye.UNPACK_ROW_LENGTH, v),
                ye.pixelStorei(ye.UNPACK_IMAGE_HEIGHT, y),
                ye.pixelStorei(ye.UNPACK_SKIP_PIXELS, b),
                ye.pixelStorei(ye.UNPACK_SKIP_ROWS, _),
                ye.pixelStorei(ye.UNPACK_SKIP_IMAGES, x),
                0 === r && t.generateMipmaps && ye.generateMipmap(m),
                J.unbindTexture();
            }),
            (this.copyTextureToTexture3D = function (
              e,
              t,
              n = null,
              i = null,
              r = 0
            ) {
              return (
                !0 !== e.isTexture &&
                  (Ir(
                    "WebGLRenderer: copyTextureToTexture3D function signature has changed."
                  ),
                  (n = arguments[0] || null),
                  (i = arguments[1] || null),
                  (e = arguments[2]),
                  (t = arguments[3]),
                  (r = arguments[4] || 0)),
                Ir(
                  'WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'
                ),
                this.copyTextureToTexture(e, t, n, i, r)
              );
            }),
            (this.initRenderTarget = function (e) {
              void 0 === $.get(e).__webglFramebuffer && ee.setupRenderTarget(e);
            }),
            (this.initTexture = function (e) {
              e.isCubeTexture
                ? ee.setTextureCube(e, 0)
                : e.isData3DTexture
                ? ee.setTexture3D(e, 0)
                : e.isDataArrayTexture || e.isCompressedArrayTexture
                ? ee.setTexture2DArray(e, 0)
                : ee.setTexture2D(e, 0),
                J.unbindTexture();
            }),
            (this.resetState = function () {
              (_ = 0), (x = 0), (E = null), J.reset(), me.reset();
            }),
            "undefined" != typeof __THREE_DEVTOOLS__ &&
              __THREE_DEVTOOLS__.dispatchEvent(
                new CustomEvent("observe", { detail: this })
              );
        }
        get coordinateSystem() {
          return ar;
        }
        get outputColorSpace() {
          return this._outputColorSpace;
        }
        set outputColorSpace(e) {
          this._outputColorSpace = e;
          const t = this.getContext();
          (t.drawingBufferColorspace = Mr._getDrawingBufferColorSpace(e)),
            (t.unpackColorSpace = Mr._getUnpackColorSpace());
        }
      }
      class gu {
        constructor(e, t = 1, n = 1e3) {
          (this.isFog = !0),
            (this.name = ""),
            (this.color = new ma(e)),
            (this.near = t),
            (this.far = n);
        }
        clone() {
          return new gu(this.color, this.near, this.far);
        }
        toJSON() {
          return {
            type: "Fog",
            name: this.name,
            color: this.color.getHex(),
            near: this.near,
            far: this.far,
          };
        }
      }
      class mu extends Zs {
        constructor() {
          super(),
            (this.isScene = !0),
            (this.type = "Scene"),
            (this.background = null),
            (this.environment = null),
            (this.fog = null),
            (this.backgroundBlurriness = 0),
            (this.backgroundIntensity = 1),
            (this.backgroundRotation = new Us()),
            (this.environmentIntensity = 1),
            (this.environmentRotation = new Us()),
            (this.overrideMaterial = null),
            "undefined" != typeof __THREE_DEVTOOLS__ &&
              __THREE_DEVTOOLS__.dispatchEvent(
                new CustomEvent("observe", { detail: this })
              );
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            null !== e.background && (this.background = e.background.clone()),
            null !== e.environment &&
              (this.environment = e.environment.clone()),
            null !== e.fog && (this.fog = e.fog.clone()),
            (this.backgroundBlurriness = e.backgroundBlurriness),
            (this.backgroundIntensity = e.backgroundIntensity),
            this.backgroundRotation.copy(e.backgroundRotation),
            (this.environmentIntensity = e.environmentIntensity),
            this.environmentRotation.copy(e.environmentRotation),
            null !== e.overrideMaterial &&
              (this.overrideMaterial = e.overrideMaterial.clone()),
            (this.matrixAutoUpdate = e.matrixAutoUpdate),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            null !== this.fog && (t.object.fog = this.fog.toJSON()),
            this.backgroundBlurriness > 0 &&
              (t.object.backgroundBlurriness = this.backgroundBlurriness),
            1 !== this.backgroundIntensity &&
              (t.object.backgroundIntensity = this.backgroundIntensity),
            (t.object.backgroundRotation = this.backgroundRotation.toArray()),
            1 !== this.environmentIntensity &&
              (t.object.environmentIntensity = this.environmentIntensity),
            (t.object.environmentRotation = this.environmentRotation.toArray()),
            t
          );
        }
      }
      class vu {
        constructor(e, t) {
          (this.isInterleavedBuffer = !0),
            (this.array = e),
            (this.stride = t),
            (this.count = void 0 !== e ? e.length / t : 0),
            (this.usage = rr),
            (this.updateRanges = []),
            (this.version = 0),
            (this.uuid = pr());
        }
        onUploadCallback() {}
        set needsUpdate(e) {
          !0 === e && this.version++;
        }
        setUsage(e) {
          return (this.usage = e), this;
        }
        addUpdateRange(e, t) {
          this.updateRanges.push({ start: e, count: t });
        }
        clearUpdateRanges() {
          this.updateRanges.length = 0;
        }
        copy(e) {
          return (
            (this.array = new e.array.constructor(e.array)),
            (this.count = e.count),
            (this.stride = e.stride),
            (this.usage = e.usage),
            this
          );
        }
        copyAt(e, t, n) {
          (e *= this.stride), (n *= t.stride);
          for (let i = 0, r = this.stride; i < r; i++)
            this.array[e + i] = t.array[n + i];
          return this;
        }
        set(e, t = 0) {
          return this.array.set(e, t), this;
        }
        clone(e) {
          void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
            void 0 === this.array.buffer._uuid &&
              (this.array.buffer._uuid = pr()),
            void 0 === e.arrayBuffers[this.array.buffer._uuid] &&
              (e.arrayBuffers[this.array.buffer._uuid] =
                this.array.slice(0).buffer);
          const t = new this.array.constructor(
              e.arrayBuffers[this.array.buffer._uuid]
            ),
            n = new this.constructor(t, this.stride);
          return n.setUsage(this.usage), n;
        }
        onUpload(e) {
          return (this.onUploadCallback = e), this;
        }
        toJSON(e) {
          return (
            void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
            void 0 === this.array.buffer._uuid &&
              (this.array.buffer._uuid = pr()),
            void 0 === e.arrayBuffers[this.array.buffer._uuid] &&
              (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
                new Uint32Array(this.array.buffer)
              )),
            {
              uuid: this.uuid,
              buffer: this.array.buffer._uuid,
              type: this.array.constructor.name,
              stride: this.stride,
            }
          );
        }
      }
      const yu = new Yr();
      class bu {
        constructor(e, t, n, i = !1) {
          (this.isInterleavedBufferAttribute = !0),
            (this.name = ""),
            (this.data = e),
            (this.itemSize = t),
            (this.offset = n),
            (this.normalized = i);
        }
        get count() {
          return this.data.count;
        }
        get array() {
          return this.data.array;
        }
        set needsUpdate(e) {
          this.data.needsUpdate = e;
        }
        applyMatrix4(e) {
          for (let t = 0, n = this.data.count; t < n; t++)
            yu.fromBufferAttribute(this, t),
              yu.applyMatrix4(e),
              this.setXYZ(t, yu.x, yu.y, yu.z);
          return this;
        }
        applyNormalMatrix(e) {
          for (let t = 0, n = this.count; t < n; t++)
            yu.fromBufferAttribute(this, t),
              yu.applyNormalMatrix(e),
              this.setXYZ(t, yu.x, yu.y, yu.z);
          return this;
        }
        transformDirection(e) {
          for (let t = 0, n = this.count; t < n; t++)
            yu.fromBufferAttribute(this, t),
              yu.transformDirection(e),
              this.setXYZ(t, yu.x, yu.y, yu.z);
          return this;
        }
        getComponent(e, t) {
          let n = this.array[e * this.data.stride + this.offset + t];
          return this.normalized && (n = mr(n, this.array)), n;
        }
        setComponent(e, t, n) {
          return (
            this.normalized && (n = vr(n, this.array)),
            (this.data.array[e * this.data.stride + this.offset + t] = n),
            this
          );
        }
        setX(e, t) {
          return (
            this.normalized && (t = vr(t, this.array)),
            (this.data.array[e * this.data.stride + this.offset] = t),
            this
          );
        }
        setY(e, t) {
          return (
            this.normalized && (t = vr(t, this.array)),
            (this.data.array[e * this.data.stride + this.offset + 1] = t),
            this
          );
        }
        setZ(e, t) {
          return (
            this.normalized && (t = vr(t, this.array)),
            (this.data.array[e * this.data.stride + this.offset + 2] = t),
            this
          );
        }
        setW(e, t) {
          return (
            this.normalized && (t = vr(t, this.array)),
            (this.data.array[e * this.data.stride + this.offset + 3] = t),
            this
          );
        }
        getX(e) {
          let t = this.data.array[e * this.data.stride + this.offset];
          return this.normalized && (t = mr(t, this.array)), t;
        }
        getY(e) {
          let t = this.data.array[e * this.data.stride + this.offset + 1];
          return this.normalized && (t = mr(t, this.array)), t;
        }
        getZ(e) {
          let t = this.data.array[e * this.data.stride + this.offset + 2];
          return this.normalized && (t = mr(t, this.array)), t;
        }
        getW(e) {
          let t = this.data.array[e * this.data.stride + this.offset + 3];
          return this.normalized && (t = mr(t, this.array)), t;
        }
        setXY(e, t, n) {
          return (
            (e = e * this.data.stride + this.offset),
            this.normalized &&
              ((t = vr(t, this.array)), (n = vr(n, this.array))),
            (this.data.array[e + 0] = t),
            (this.data.array[e + 1] = n),
            this
          );
        }
        setXYZ(e, t, n, i) {
          return (
            (e = e * this.data.stride + this.offset),
            this.normalized &&
              ((t = vr(t, this.array)),
              (n = vr(n, this.array)),
              (i = vr(i, this.array))),
            (this.data.array[e + 0] = t),
            (this.data.array[e + 1] = n),
            (this.data.array[e + 2] = i),
            this
          );
        }
        setXYZW(e, t, n, i, r) {
          return (
            (e = e * this.data.stride + this.offset),
            this.normalized &&
              ((t = vr(t, this.array)),
              (n = vr(n, this.array)),
              (i = vr(i, this.array)),
              (r = vr(r, this.array))),
            (this.data.array[e + 0] = t),
            (this.data.array[e + 1] = n),
            (this.data.array[e + 2] = i),
            (this.data.array[e + 3] = r),
            this
          );
        }
        clone(e) {
          if (void 0 === e) {
            console.log(
              "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
            );
            const e = [];
            for (let t = 0; t < this.count; t++) {
              const n = t * this.data.stride + this.offset;
              for (let t = 0; t < this.itemSize; t++)
                e.push(this.data.array[n + t]);
            }
            return new Ta(
              new this.array.constructor(e),
              this.itemSize,
              this.normalized
            );
          }
          return (
            void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
            void 0 === e.interleavedBuffers[this.data.uuid] &&
              (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
            new bu(
              e.interleavedBuffers[this.data.uuid],
              this.itemSize,
              this.offset,
              this.normalized
            )
          );
        }
        toJSON(e) {
          if (void 0 === e) {
            console.log(
              "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
            );
            const e = [];
            for (let t = 0; t < this.count; t++) {
              const n = t * this.data.stride + this.offset;
              for (let t = 0; t < this.itemSize; t++)
                e.push(this.data.array[n + t]);
            }
            return {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array: e,
              normalized: this.normalized,
            };
          }
          return (
            void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
            void 0 === e.interleavedBuffers[this.data.uuid] &&
              (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
            {
              isInterleavedBufferAttribute: !0,
              itemSize: this.itemSize,
              data: this.data.uuid,
              offset: this.offset,
              normalized: this.normalized,
            }
          );
        }
      }
      const _u = new Yr(),
        xu = new zr(),
        Eu = new zr(),
        wu = new Yr(),
        Cu = new Cs(),
        Su = new Yr(),
        Iu = new gs(),
        Mu = new Cs(),
        Tu = new ws();
      class Bu extends Za {
        constructor(e, t) {
          super(e, t),
            (this.isSkinnedMesh = !0),
            (this.type = "SkinnedMesh"),
            (this.bindMode = En),
            (this.bindMatrix = new Cs()),
            (this.bindMatrixInverse = new Cs()),
            (this.boundingBox = null),
            (this.boundingSphere = null);
        }
        computeBoundingBox() {
          const e = this.geometry;
          null === this.boundingBox && (this.boundingBox = new Zr()),
            this.boundingBox.makeEmpty();
          const t = e.getAttribute("position");
          for (let e = 0; e < t.count; e++)
            this.getVertexPosition(e, Su), this.boundingBox.expandByPoint(Su);
        }
        computeBoundingSphere() {
          const e = this.geometry;
          null === this.boundingSphere && (this.boundingSphere = new gs()),
            this.boundingSphere.makeEmpty();
          const t = e.getAttribute("position");
          for (let e = 0; e < t.count; e++)
            this.getVertexPosition(e, Su),
              this.boundingSphere.expandByPoint(Su);
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.bindMode = e.bindMode),
            this.bindMatrix.copy(e.bindMatrix),
            this.bindMatrixInverse.copy(e.bindMatrixInverse),
            (this.skeleton = e.skeleton),
            null !== e.boundingBox &&
              (this.boundingBox = e.boundingBox.clone()),
            null !== e.boundingSphere &&
              (this.boundingSphere = e.boundingSphere.clone()),
            this
          );
        }
        raycast(e, t) {
          const n = this.material,
            i = this.matrixWorld;
          void 0 !== n &&
            (null === this.boundingSphere && this.computeBoundingSphere(),
            Iu.copy(this.boundingSphere),
            Iu.applyMatrix4(i),
            !1 !== e.ray.intersectsSphere(Iu) &&
              (Mu.copy(i).invert(),
              Tu.copy(e.ray).applyMatrix4(Mu),
              (null !== this.boundingBox &&
                !1 === Tu.intersectsBox(this.boundingBox)) ||
                this._computeIntersections(e, t, Tu)));
        }
        getVertexPosition(e, t) {
          return (
            super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t
          );
        }
        bind(e, t) {
          (this.skeleton = e),
            void 0 === t &&
              (this.updateMatrixWorld(!0),
              this.skeleton.calculateInverses(),
              (t = this.matrixWorld)),
            this.bindMatrix.copy(t),
            this.bindMatrixInverse.copy(t).invert();
        }
        pose() {
          this.skeleton.pose();
        }
        normalizeSkinWeights() {
          const e = new zr(),
            t = this.geometry.attributes.skinWeight;
          for (let n = 0, i = t.count; n < i; n++) {
            e.fromBufferAttribute(t, n);
            const i = 1 / e.manhattanLength();
            i !== 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0),
              t.setXYZW(n, e.x, e.y, e.z, e.w);
          }
        }
        updateMatrixWorld(e) {
          super.updateMatrixWorld(e),
            this.bindMode === En
              ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
              : "detached" === this.bindMode
              ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
              : console.warn(
                  "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
                );
        }
        applyBoneTransform(e, t) {
          const n = this.skeleton,
            i = this.geometry;
          xu.fromBufferAttribute(i.attributes.skinIndex, e),
            Eu.fromBufferAttribute(i.attributes.skinWeight, e),
            _u.copy(t).applyMatrix4(this.bindMatrix),
            t.set(0, 0, 0);
          for (let e = 0; e < 4; e++) {
            const i = Eu.getComponent(e);
            if (0 !== i) {
              const r = xu.getComponent(e);
              Cu.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]),
                t.addScaledVector(wu.copy(_u).applyMatrix4(Cu), i);
            }
          }
          return t.applyMatrix4(this.bindMatrixInverse);
        }
      }
      class Ru extends Zs {
        constructor() {
          super(), (this.isBone = !0), (this.type = "Bone");
        }
      }
      class Du extends Hr {
        constructor(
          e = null,
          t = 1,
          n = 1,
          i,
          r,
          s,
          a,
          o,
          c = 1003,
          l = 1003,
          u,
          h
        ) {
          super(null, s, a, o, c, l, i, r, u, h),
            (this.isDataTexture = !0),
            (this.image = { data: e, width: t, height: n }),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1);
        }
      }
      const Pu = new Cs(),
        Lu = new Cs();
      class Uu {
        constructor(e = [], t = []) {
          (this.uuid = pr()),
            (this.bones = e.slice(0)),
            (this.boneInverses = t),
            (this.boneMatrices = null),
            (this.boneTexture = null),
            this.init();
        }
        init() {
          const e = this.bones,
            t = this.boneInverses;
          if (
            ((this.boneMatrices = new Float32Array(16 * e.length)),
            0 === t.length)
          )
            this.calculateInverses();
          else if (e.length !== t.length) {
            console.warn(
              "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
            ),
              (this.boneInverses = []);
            for (let e = 0, t = this.bones.length; e < t; e++)
              this.boneInverses.push(new Cs());
          }
        }
        calculateInverses() {
          this.boneInverses.length = 0;
          for (let e = 0, t = this.bones.length; e < t; e++) {
            const t = new Cs();
            this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(),
              this.boneInverses.push(t);
          }
        }
        pose() {
          for (let e = 0, t = this.bones.length; e < t; e++) {
            const t = this.bones[e];
            t && t.matrixWorld.copy(this.boneInverses[e]).invert();
          }
          for (let e = 0, t = this.bones.length; e < t; e++) {
            const t = this.bones[e];
            t &&
              (t.parent && t.parent.isBone
                ? (t.matrix.copy(t.parent.matrixWorld).invert(),
                  t.matrix.multiply(t.matrixWorld))
                : t.matrix.copy(t.matrixWorld),
              t.matrix.decompose(t.position, t.quaternion, t.scale));
          }
        }
        update() {
          const e = this.bones,
            t = this.boneInverses,
            n = this.boneMatrices,
            i = this.boneTexture;
          for (let i = 0, r = e.length; i < r; i++) {
            const r = e[i] ? e[i].matrixWorld : Lu;
            Pu.multiplyMatrices(r, t[i]), Pu.toArray(n, 16 * i);
          }
          null !== i && (i.needsUpdate = !0);
        }
        clone() {
          return new Uu(this.bones, this.boneInverses);
        }
        computeBoneTexture() {
          let e = Math.sqrt(4 * this.bones.length);
          (e = 4 * Math.ceil(e / 4)), (e = Math.max(e, 4));
          const t = new Float32Array(e * e * 4);
          t.set(this.boneMatrices);
          const n = new Du(t, e, e, Zn, Vn);
          return (
            (n.needsUpdate = !0),
            (this.boneMatrices = t),
            (this.boneTexture = n),
            this
          );
        }
        getBoneByName(e) {
          for (let t = 0, n = this.bones.length; t < n; t++) {
            const n = this.bones[t];
            if (n.name === e) return n;
          }
        }
        dispose() {
          null !== this.boneTexture &&
            (this.boneTexture.dispose(), (this.boneTexture = null));
        }
        fromJSON(e, t) {
          this.uuid = e.uuid;
          for (let n = 0, i = e.bones.length; n < i; n++) {
            const i = e.bones[n];
            let r = t[i];
            void 0 === r &&
              (console.warn("THREE.Skeleton: No bone found with UUID:", i),
              (r = new Ru())),
              this.bones.push(r),
              this.boneInverses.push(new Cs().fromArray(e.boneInverses[n]));
          }
          return this.init(), this;
        }
        toJSON() {
          const e = {
            metadata: {
              version: 4.6,
              type: "Skeleton",
              generator: "Skeleton.toJSON",
            },
            bones: [],
            boneInverses: [],
          };
          e.uuid = this.uuid;
          const t = this.bones,
            n = this.boneInverses;
          for (let i = 0, r = t.length; i < r; i++) {
            const r = t[i];
            e.bones.push(r.uuid);
            const s = n[i];
            e.boneInverses.push(s.toArray());
          }
          return e;
        }
      }
      class Fu extends Ta {
        constructor(e, t, n, i = 1) {
          super(e, t, n),
            (this.isInstancedBufferAttribute = !0),
            (this.meshPerAttribute = i);
        }
        copy(e) {
          return (
            super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this
          );
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.meshPerAttribute = this.meshPerAttribute),
            (e.isInstancedBufferAttribute = !0),
            e
          );
        }
      }
      const Ou = new Cs(),
        Nu = new Cs(),
        ku = [],
        Qu = new Zr(),
        Gu = new Cs(),
        Hu = new Za(),
        zu = new gs();
      class Vu extends Za {
        constructor(e, t, n) {
          super(e, t),
            (this.isInstancedMesh = !0),
            (this.instanceMatrix = new Fu(new Float32Array(16 * n), 16)),
            (this.instanceColor = null),
            (this.morphTexture = null),
            (this.count = n),
            (this.boundingBox = null),
            (this.boundingSphere = null);
          for (let e = 0; e < n; e++) this.setMatrixAt(e, Gu);
        }
        computeBoundingBox() {
          const e = this.geometry,
            t = this.count;
          null === this.boundingBox && (this.boundingBox = new Zr()),
            null === e.boundingBox && e.computeBoundingBox(),
            this.boundingBox.makeEmpty();
          for (let n = 0; n < t; n++)
            this.getMatrixAt(n, Ou),
              Qu.copy(e.boundingBox).applyMatrix4(Ou),
              this.boundingBox.union(Qu);
        }
        computeBoundingSphere() {
          const e = this.geometry,
            t = this.count;
          null === this.boundingSphere && (this.boundingSphere = new gs()),
            null === e.boundingSphere && e.computeBoundingSphere(),
            this.boundingSphere.makeEmpty();
          for (let n = 0; n < t; n++)
            this.getMatrixAt(n, Ou),
              zu.copy(e.boundingSphere).applyMatrix4(Ou),
              this.boundingSphere.union(zu);
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            this.instanceMatrix.copy(e.instanceMatrix),
            null !== e.morphTexture &&
              (this.morphTexture = e.morphTexture.clone()),
            null !== e.instanceColor &&
              (this.instanceColor = e.instanceColor.clone()),
            (this.count = e.count),
            null !== e.boundingBox &&
              (this.boundingBox = e.boundingBox.clone()),
            null !== e.boundingSphere &&
              (this.boundingSphere = e.boundingSphere.clone()),
            this
          );
        }
        getColorAt(e, t) {
          t.fromArray(this.instanceColor.array, 3 * e);
        }
        getMatrixAt(e, t) {
          t.fromArray(this.instanceMatrix.array, 16 * e);
        }
        getMorphAt(e, t) {
          const n = t.morphTargetInfluences,
            i = this.morphTexture.source.data.data,
            r = e * (n.length + 1) + 1;
          for (let e = 0; e < n.length; e++) n[e] = i[r + e];
        }
        raycast(e, t) {
          const n = this.matrixWorld,
            i = this.count;
          if (
            ((Hu.geometry = this.geometry),
            (Hu.material = this.material),
            void 0 !== Hu.material &&
              (null === this.boundingSphere && this.computeBoundingSphere(),
              zu.copy(this.boundingSphere),
              zu.applyMatrix4(n),
              !1 !== e.ray.intersectsSphere(zu)))
          )
            for (let r = 0; r < i; r++) {
              this.getMatrixAt(r, Ou),
                Nu.multiplyMatrices(n, Ou),
                (Hu.matrixWorld = Nu),
                Hu.raycast(e, ku);
              for (let e = 0, n = ku.length; e < n; e++) {
                const n = ku[e];
                (n.instanceId = r), (n.object = this), t.push(n);
              }
              ku.length = 0;
            }
        }
        setColorAt(e, t) {
          null === this.instanceColor &&
            (this.instanceColor = new Fu(
              new Float32Array(3 * this.instanceMatrix.count).fill(1),
              3
            )),
            t.toArray(this.instanceColor.array, 3 * e);
        }
        setMatrixAt(e, t) {
          t.toArray(this.instanceMatrix.array, 16 * e);
        }
        setMorphAt(e, t) {
          const n = t.morphTargetInfluences,
            i = n.length + 1;
          null === this.morphTexture &&
            (this.morphTexture = new Du(
              new Float32Array(i * this.count),
              i,
              this.count,
              ii,
              Vn
            ));
          const r = this.morphTexture.source.data.data;
          let s = 0;
          for (let e = 0; e < n.length; e++) s += n[e];
          const a = this.geometry.morphTargetsRelative ? 1 : 1 - s,
            o = i * e;
          (r[o] = a), r.set(n, o + 1);
        }
        updateMorphTargets() {}
        dispose() {
          return (
            this.dispatchEvent({ type: "dispose" }),
            null !== this.morphTexture &&
              (this.morphTexture.dispose(), (this.morphTexture = null)),
            this
          );
        }
      }
      class ju extends ba {
        static get type() {
          return "LineBasicMaterial";
        }
        constructor(e) {
          super(),
            (this.isLineBasicMaterial = !0),
            (this.color = new ma(16777215)),
            (this.map = null),
            (this.linewidth = 1),
            (this.linecap = "round"),
            (this.linejoin = "round"),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.linewidth = e.linewidth),
            (this.linecap = e.linecap),
            (this.linejoin = e.linejoin),
            (this.fog = e.fog),
            this
          );
        }
      }
      const Wu = new Yr(),
        Xu = new Yr(),
        qu = new Cs(),
        Yu = new ws(),
        Ku = new gs(),
        Ju = new Yr(),
        Zu = new Yr();
      class $u extends Zs {
        constructor(e = new Qa(), t = new ju()) {
          super(),
            (this.isLine = !0),
            (this.type = "Line"),
            (this.geometry = e),
            (this.material = t),
            this.updateMorphTargets();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.material = Array.isArray(e.material)
              ? e.material.slice()
              : e.material),
            (this.geometry = e.geometry),
            this
          );
        }
        computeLineDistances() {
          const e = this.geometry;
          if (null === e.index) {
            const t = e.attributes.position,
              n = [0];
            for (let e = 1, i = t.count; e < i; e++)
              Wu.fromBufferAttribute(t, e - 1),
                Xu.fromBufferAttribute(t, e),
                (n[e] = n[e - 1]),
                (n[e] += Wu.distanceTo(Xu));
            e.setAttribute("lineDistance", new Da(n, 1));
          } else
            console.warn(
              "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
            );
          return this;
        }
        raycast(e, t) {
          const n = this.geometry,
            i = this.matrixWorld,
            r = e.params.Line.threshold,
            s = n.drawRange;
          if (
            (null === n.boundingSphere && n.computeBoundingSphere(),
            Ku.copy(n.boundingSphere),
            Ku.applyMatrix4(i),
            (Ku.radius += r),
            !1 === e.ray.intersectsSphere(Ku))
          )
            return;
          qu.copy(i).invert(), Yu.copy(e.ray).applyMatrix4(qu);
          const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            o = a * a,
            c = this.isLineSegments ? 2 : 1,
            l = n.index,
            u = n.attributes.position;
          if (null !== l) {
            const n = Math.max(0, s.start),
              i = Math.min(l.count, s.start + s.count);
            for (let r = n, s = i - 1; r < s; r += c) {
              const n = l.getX(r),
                i = l.getX(r + 1),
                s = eh(this, e, Yu, o, n, i);
              s && t.push(s);
            }
            if (this.isLineLoop) {
              const r = l.getX(i - 1),
                s = l.getX(n),
                a = eh(this, e, Yu, o, r, s);
              a && t.push(a);
            }
          } else {
            const n = Math.max(0, s.start),
              i = Math.min(u.count, s.start + s.count);
            for (let r = n, s = i - 1; r < s; r += c) {
              const n = eh(this, e, Yu, o, r, r + 1);
              n && t.push(n);
            }
            if (this.isLineLoop) {
              const r = eh(this, e, Yu, o, i - 1, n);
              r && t.push(r);
            }
          }
        }
        updateMorphTargets() {
          const e = this.geometry.morphAttributes,
            t = Object.keys(e);
          if (t.length > 0) {
            const n = e[t[0]];
            if (void 0 !== n) {
              (this.morphTargetInfluences = []),
                (this.morphTargetDictionary = {});
              for (let e = 0, t = n.length; e < t; e++) {
                const t = n[e].name || String(e);
                this.morphTargetInfluences.push(0),
                  (this.morphTargetDictionary[t] = e);
              }
            }
          }
        }
      }
      function eh(e, t, n, i, r, s) {
        const a = e.geometry.attributes.position;
        Wu.fromBufferAttribute(a, r), Xu.fromBufferAttribute(a, s);
        if (n.distanceSqToSegment(Wu, Xu, Ju, Zu) > i) return;
        Ju.applyMatrix4(e.matrixWorld);
        const o = t.ray.origin.distanceTo(Ju);
        return o < t.near || o > t.far
          ? void 0
          : {
              distance: o,
              point: Zu.clone().applyMatrix4(e.matrixWorld),
              index: r,
              face: null,
              faceIndex: null,
              barycoord: null,
              object: e,
            };
      }
      const th = new Yr(),
        nh = new Yr();
      class ih extends $u {
        constructor(e, t) {
          super(e, t), (this.isLineSegments = !0), (this.type = "LineSegments");
        }
        computeLineDistances() {
          const e = this.geometry;
          if (null === e.index) {
            const t = e.attributes.position,
              n = [];
            for (let e = 0, i = t.count; e < i; e += 2)
              th.fromBufferAttribute(t, e),
                nh.fromBufferAttribute(t, e + 1),
                (n[e] = 0 === e ? 0 : n[e - 1]),
                (n[e + 1] = n[e] + th.distanceTo(nh));
            e.setAttribute("lineDistance", new Da(n, 1));
          } else
            console.warn(
              "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
            );
          return this;
        }
      }
      class rh extends $u {
        constructor(e, t) {
          super(e, t), (this.isLineLoop = !0), (this.type = "LineLoop");
        }
      }
      class sh extends ba {
        static get type() {
          return "PointsMaterial";
        }
        constructor(e) {
          super(),
            (this.isPointsMaterial = !0),
            (this.color = new ma(16777215)),
            (this.map = null),
            (this.alphaMap = null),
            (this.size = 1),
            (this.sizeAttenuation = !0),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.size = e.size),
            (this.sizeAttenuation = e.sizeAttenuation),
            (this.fog = e.fog),
            this
          );
        }
      }
      const ah = new Cs(),
        oh = new ws(),
        ch = new gs(),
        lh = new Yr();
      class uh extends Zs {
        constructor(e = new Qa(), t = new sh()) {
          super(),
            (this.isPoints = !0),
            (this.type = "Points"),
            (this.geometry = e),
            (this.material = t),
            this.updateMorphTargets();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.material = Array.isArray(e.material)
              ? e.material.slice()
              : e.material),
            (this.geometry = e.geometry),
            this
          );
        }
        raycast(e, t) {
          const n = this.geometry,
            i = this.matrixWorld,
            r = e.params.Points.threshold,
            s = n.drawRange;
          if (
            (null === n.boundingSphere && n.computeBoundingSphere(),
            ch.copy(n.boundingSphere),
            ch.applyMatrix4(i),
            (ch.radius += r),
            !1 === e.ray.intersectsSphere(ch))
          )
            return;
          ah.copy(i).invert(), oh.copy(e.ray).applyMatrix4(ah);
          const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            o = a * a,
            c = n.index,
            l = n.attributes.position;
          if (null !== c) {
            for (
              let n = Math.max(0, s.start),
                r = Math.min(c.count, s.start + s.count);
              n < r;
              n++
            ) {
              const r = c.getX(n);
              lh.fromBufferAttribute(l, r), hh(lh, r, o, i, e, t, this);
            }
          } else {
            for (
              let n = Math.max(0, s.start),
                r = Math.min(l.count, s.start + s.count);
              n < r;
              n++
            )
              lh.fromBufferAttribute(l, n), hh(lh, n, o, i, e, t, this);
          }
        }
        updateMorphTargets() {
          const e = this.geometry.morphAttributes,
            t = Object.keys(e);
          if (t.length > 0) {
            const n = e[t[0]];
            if (void 0 !== n) {
              (this.morphTargetInfluences = []),
                (this.morphTargetDictionary = {});
              for (let e = 0, t = n.length; e < t; e++) {
                const t = n[e].name || String(e);
                this.morphTargetInfluences.push(0),
                  (this.morphTargetDictionary[t] = e);
              }
            }
          }
        }
      }
      function hh(e, t, n, i, r, s, a) {
        const o = oh.distanceSqToPoint(e);
        if (o < n) {
          const n = new Yr();
          oh.closestPointToPoint(e, n), n.applyMatrix4(i);
          const c = r.ray.origin.distanceTo(n);
          if (c < r.near || c > r.far) return;
          s.push({
            distance: c,
            distanceToRay: Math.sqrt(o),
            point: n,
            index: t,
            face: null,
            faceIndex: null,
            barycoord: null,
            object: a,
          });
        }
      }
      class dh extends Hr {
        constructor(e, t, n, i, r, s, a, o, c) {
          super(e, t, n, i, r, s, a, o, c),
            (this.isVideoTexture = !0),
            (this.minFilter = void 0 !== s ? s : Un),
            (this.magFilter = void 0 !== r ? r : Un),
            (this.generateMipmaps = !1);
          const l = this;
          "requestVideoFrameCallback" in e &&
            e.requestVideoFrameCallback(function t() {
              (l.needsUpdate = !0), e.requestVideoFrameCallback(t);
            });
        }
        clone() {
          return new this.constructor(this.image).copy(this);
        }
        update() {
          const e = this.image;
          !1 === "requestVideoFrameCallback" in e &&
            e.readyState >= e.HAVE_CURRENT_DATA &&
            (this.needsUpdate = !0);
        }
      }
      class ph extends Hr {
        constructor(e, t, n, i, r, s, a, o, c, l, u, h) {
          super(null, s, a, o, c, l, i, r, u, h),
            (this.isCompressedTexture = !0),
            (this.image = { width: t, height: n }),
            (this.mipmaps = e),
            (this.flipY = !1),
            (this.generateMipmaps = !1);
        }
      }
      class fh extends ph {
        constructor(e, t, n, i, r, s) {
          super(e, t, n, r, s),
            (this.isCompressedArrayTexture = !0),
            (this.image.depth = i),
            (this.wrapR = Bn),
            (this.layerUpdates = new Set());
        }
        addLayerUpdate(e) {
          this.layerUpdates.add(e);
        }
        clearLayerUpdates() {
          this.layerUpdates.clear();
        }
      }
      class Ah extends ph {
        constructor(e, t, n) {
          super(void 0, e[0].width, e[0].height, t, n, wn),
            (this.isCompressedCubeTexture = !0),
            (this.isCubeTexture = !0),
            (this.image = e);
        }
      }
      class gh {
        constructor() {
          (this.type = "Curve"), (this.arcLengthDivisions = 200);
        }
        getPoint() {
          return (
            console.warn("THREE.Curve: .getPoint() not implemented."), null
          );
        }
        getPointAt(e, t) {
          const n = this.getUtoTmapping(e);
          return this.getPoint(n, t);
        }
        getPoints(e = 5) {
          const t = [];
          for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
          return t;
        }
        getSpacedPoints(e = 5) {
          const t = [];
          for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
          return t;
        }
        getLength() {
          const e = this.getLengths();
          return e[e.length - 1];
        }
        getLengths(e = this.arcLengthDivisions) {
          if (
            this.cacheArcLengths &&
            this.cacheArcLengths.length === e + 1 &&
            !this.needsUpdate
          )
            return this.cacheArcLengths;
          this.needsUpdate = !1;
          const t = [];
          let n,
            i = this.getPoint(0),
            r = 0;
          t.push(0);
          for (let s = 1; s <= e; s++)
            (n = this.getPoint(s / e)),
              (r += n.distanceTo(i)),
              t.push(r),
              (i = n);
          return (this.cacheArcLengths = t), t;
        }
        updateArcLengths() {
          (this.needsUpdate = !0), this.getLengths();
        }
        getUtoTmapping(e, t) {
          const n = this.getLengths();
          let i = 0;
          const r = n.length;
          let s;
          s = t || e * n[r - 1];
          let a,
            o = 0,
            c = r - 1;
          for (; o <= c; )
            if (((i = Math.floor(o + (c - o) / 2)), (a = n[i] - s), a < 0))
              o = i + 1;
            else {
              if (!(a > 0)) {
                c = i;
                break;
              }
              c = i - 1;
            }
          if (((i = c), n[i] === s)) return i / (r - 1);
          const l = n[i];
          return (i + (s - l) / (n[i + 1] - l)) / (r - 1);
        }
        getTangent(e, t) {
          const n = 1e-4;
          let i = e - n,
            r = e + n;
          i < 0 && (i = 0), r > 1 && (r = 1);
          const s = this.getPoint(i),
            a = this.getPoint(r),
            o = t || (s.isVector2 ? new br() : new Yr());
          return o.copy(a).sub(s).normalize(), o;
        }
        getTangentAt(e, t) {
          const n = this.getUtoTmapping(e);
          return this.getTangent(n, t);
        }
        computeFrenetFrames(e, t) {
          const n = new Yr(),
            i = [],
            r = [],
            s = [],
            a = new Yr(),
            o = new Cs();
          for (let t = 0; t <= e; t++) {
            const n = t / e;
            i[t] = this.getTangentAt(n, new Yr());
          }
          (r[0] = new Yr()), (s[0] = new Yr());
          let c = Number.MAX_VALUE;
          const l = Math.abs(i[0].x),
            u = Math.abs(i[0].y),
            h = Math.abs(i[0].z);
          l <= c && ((c = l), n.set(1, 0, 0)),
            u <= c && ((c = u), n.set(0, 1, 0)),
            h <= c && n.set(0, 0, 1),
            a.crossVectors(i[0], n).normalize(),
            r[0].crossVectors(i[0], a),
            s[0].crossVectors(i[0], r[0]);
          for (let t = 1; t <= e; t++) {
            if (
              ((r[t] = r[t - 1].clone()),
              (s[t] = s[t - 1].clone()),
              a.crossVectors(i[t - 1], i[t]),
              a.length() > Number.EPSILON)
            ) {
              a.normalize();
              const e = Math.acos(fr(i[t - 1].dot(i[t]), -1, 1));
              r[t].applyMatrix4(o.makeRotationAxis(a, e));
            }
            s[t].crossVectors(i[t], r[t]);
          }
          if (!0 === t) {
            let t = Math.acos(fr(r[0].dot(r[e]), -1, 1));
            (t /= e), i[0].dot(a.crossVectors(r[0], r[e])) > 0 && (t = -t);
            for (let n = 1; n <= e; n++)
              r[n].applyMatrix4(o.makeRotationAxis(i[n], t * n)),
                s[n].crossVectors(i[n], r[n]);
          }
          return { tangents: i, normals: r, binormals: s };
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return (this.arcLengthDivisions = e.arcLengthDivisions), this;
        }
        toJSON() {
          const e = {
            metadata: {
              version: 4.6,
              type: "Curve",
              generator: "Curve.toJSON",
            },
          };
          return (
            (e.arcLengthDivisions = this.arcLengthDivisions),
            (e.type = this.type),
            e
          );
        }
        fromJSON(e) {
          return (this.arcLengthDivisions = e.arcLengthDivisions), this;
        }
      }
      class mh extends Qa {
        constructor(
          e = 1,
          t = 1,
          n = 1,
          i = 32,
          r = 1,
          s = !1,
          a = 0,
          o = 2 * Math.PI
        ) {
          super(),
            (this.type = "CylinderGeometry"),
            (this.parameters = {
              radiusTop: e,
              radiusBottom: t,
              height: n,
              radialSegments: i,
              heightSegments: r,
              openEnded: s,
              thetaStart: a,
              thetaLength: o,
            });
          const c = this;
          (i = Math.floor(i)), (r = Math.floor(r));
          const l = [],
            u = [],
            h = [],
            d = [];
          let p = 0;
          const f = [],
            A = n / 2;
          let g = 0;
          function m(n) {
            const r = p,
              s = new br(),
              f = new Yr();
            let m = 0;
            const v = !0 === n ? e : t,
              y = !0 === n ? 1 : -1;
            for (let e = 1; e <= i; e++)
              u.push(0, A * y, 0), h.push(0, y, 0), d.push(0.5, 0.5), p++;
            const b = p;
            for (let e = 0; e <= i; e++) {
              const t = (e / i) * o + a,
                n = Math.cos(t),
                r = Math.sin(t);
              (f.x = v * r),
                (f.y = A * y),
                (f.z = v * n),
                u.push(f.x, f.y, f.z),
                h.push(0, y, 0),
                (s.x = 0.5 * n + 0.5),
                (s.y = 0.5 * r * y + 0.5),
                d.push(s.x, s.y),
                p++;
            }
            for (let e = 0; e < i; e++) {
              const t = r + e,
                i = b + e;
              !0 === n ? l.push(i, i + 1, t) : l.push(i + 1, i, t), (m += 3);
            }
            c.addGroup(g, m, !0 === n ? 1 : 2), (g += m);
          }
          !(function () {
            const s = new Yr(),
              m = new Yr();
            let v = 0;
            const y = (t - e) / n;
            for (let c = 0; c <= r; c++) {
              const l = [],
                g = c / r,
                v = g * (t - e) + e;
              for (let e = 0; e <= i; e++) {
                const t = e / i,
                  r = t * o + a,
                  c = Math.sin(r),
                  f = Math.cos(r);
                (m.x = v * c),
                  (m.y = -g * n + A),
                  (m.z = v * f),
                  u.push(m.x, m.y, m.z),
                  s.set(c, y, f).normalize(),
                  h.push(s.x, s.y, s.z),
                  d.push(t, 1 - g),
                  l.push(p++);
              }
              f.push(l);
            }
            for (let n = 0; n < i; n++)
              for (let i = 0; i < r; i++) {
                const s = f[i][n],
                  a = f[i + 1][n],
                  o = f[i + 1][n + 1],
                  c = f[i][n + 1];
                (e > 0 || 0 !== i) && (l.push(s, a, c), (v += 3)),
                  (t > 0 || i !== r - 1) && (l.push(a, o, c), (v += 3));
              }
            c.addGroup(g, v, 0), (g += v);
          })(),
            !1 === s && (e > 0 && m(!0), t > 0 && m(!1)),
            this.setIndex(l),
            this.setAttribute("position", new Da(u, 3)),
            this.setAttribute("normal", new Da(h, 3)),
            this.setAttribute("uv", new Da(d, 2));
        }
        copy(e) {
          return (
            super.copy(e),
            (this.parameters = Object.assign({}, e.parameters)),
            this
          );
        }
        static fromJSON(e) {
          return new mh(
            e.radiusTop,
            e.radiusBottom,
            e.height,
            e.radialSegments,
            e.heightSegments,
            e.openEnded,
            e.thetaStart,
            e.thetaLength
          );
        }
      }
      class vh extends mh {
        constructor(
          e = 1,
          t = 1,
          n = 32,
          i = 1,
          r = !1,
          s = 0,
          a = 2 * Math.PI
        ) {
          super(0, e, t, n, i, r, s, a),
            (this.type = "ConeGeometry"),
            (this.parameters = {
              radius: e,
              height: t,
              radialSegments: n,
              heightSegments: i,
              openEnded: r,
              thetaStart: s,
              thetaLength: a,
            });
        }
        static fromJSON(e) {
          return new vh(
            e.radius,
            e.height,
            e.radialSegments,
            e.heightSegments,
            e.openEnded,
            e.thetaStart,
            e.thetaLength
          );
        }
      }
      const yh = function (e, t, n = 2) {
        const i = t && t.length,
          r = i ? t[0] * n : e.length;
        let s = bh(e, 0, r, n, !0);
        const a = [];
        if (!s || s.next === s.prev) return a;
        let o, c, l, u, h, d, p;
        if (
          (i &&
            (s = (function (e, t, n, i) {
              const r = [];
              let s, a, o, c, l;
              for (s = 0, a = t.length; s < a; s++)
                (o = t[s] * i),
                  (c = s < a - 1 ? t[s + 1] * i : e.length),
                  (l = bh(e, o, c, i, !1)),
                  l === l.next && (l.steiner = !0),
                  r.push(Rh(l));
              for (r.sort(Ih), s = 0; s < r.length; s++) n = Mh(r[s], n);
              return n;
            })(e, t, s, n)),
          e.length > 80 * n)
        ) {
          (o = l = e[0]), (c = u = e[1]);
          for (let t = n; t < r; t += n)
            (h = e[t]),
              (d = e[t + 1]),
              h < o && (o = h),
              d < c && (c = d),
              h > l && (l = h),
              d > u && (u = d);
          (p = Math.max(l - o, u - c)), (p = 0 !== p ? 32767 / p : 0);
        }
        return xh(s, a, n, o, c, p, 0), a;
      };
      function bh(e, t, n, i, r) {
        let s, a;
        if (
          r ===
          (function (e, t, n, i) {
            let r = 0;
            for (let s = t, a = n - i; s < n; s += i)
              (r += (e[a] - e[s]) * (e[s + 1] + e[a + 1])), (a = s);
            return r;
          })(e, t, n, i) >
            0
        )
          for (s = t; s < n; s += i) a = Gh(s, e[s], e[s + 1], a);
        else for (s = n - i; s >= t; s -= i) a = Gh(s, e[s], e[s + 1], a);
        return a && Uh(a, a.next) && (Hh(a), (a = a.next)), a;
      }
      function _h(e, t) {
        if (!e) return e;
        t || (t = e);
        let n,
          i = e;
        do {
          if (
            ((n = !1),
            i.steiner || (!Uh(i, i.next) && 0 !== Lh(i.prev, i, i.next)))
          )
            i = i.next;
          else {
            if ((Hh(i), (i = t = i.prev), i === i.next)) break;
            n = !0;
          }
        } while (n || i !== t);
        return t;
      }
      function xh(e, t, n, i, r, s, a) {
        if (!e) return;
        !a &&
          s &&
          (function (e, t, n, i) {
            let r = e;
            do {
              0 === r.z && (r.z = Bh(r.x, r.y, t, n, i)),
                (r.prevZ = r.prev),
                (r.nextZ = r.next),
                (r = r.next);
            } while (r !== e);
            (r.prevZ.nextZ = null),
              (r.prevZ = null),
              (function (e) {
                let t,
                  n,
                  i,
                  r,
                  s,
                  a,
                  o,
                  c,
                  l = 1;
                do {
                  for (n = e, e = null, s = null, a = 0; n; ) {
                    for (
                      a++, i = n, o = 0, t = 0;
                      t < l && (o++, (i = i.nextZ), i);
                      t++
                    );
                    for (c = l; o > 0 || (c > 0 && i); )
                      0 !== o && (0 === c || !i || n.z <= i.z)
                        ? ((r = n), (n = n.nextZ), o--)
                        : ((r = i), (i = i.nextZ), c--),
                        s ? (s.nextZ = r) : (e = r),
                        (r.prevZ = s),
                        (s = r);
                    n = i;
                  }
                  (s.nextZ = null), (l *= 2);
                } while (a > 1);
              })(r);
          })(e, i, r, s);
        let o,
          c,
          l = e;
        for (; e.prev !== e.next; )
          if (((o = e.prev), (c = e.next), s ? wh(e, i, r, s) : Eh(e)))
            t.push((o.i / n) | 0),
              t.push((e.i / n) | 0),
              t.push((c.i / n) | 0),
              Hh(e),
              (e = c.next),
              (l = c.next);
          else if ((e = c) === l) {
            a
              ? 1 === a
                ? xh((e = Ch(_h(e), t, n)), t, n, i, r, s, 2)
                : 2 === a && Sh(e, t, n, i, r, s)
              : xh(_h(e), t, n, i, r, s, 1);
            break;
          }
      }
      function Eh(e) {
        const t = e.prev,
          n = e,
          i = e.next;
        if (Lh(t, n, i) >= 0) return !1;
        const r = t.x,
          s = n.x,
          a = i.x,
          o = t.y,
          c = n.y,
          l = i.y,
          u = r < s ? (r < a ? r : a) : s < a ? s : a,
          h = o < c ? (o < l ? o : l) : c < l ? c : l,
          d = r > s ? (r > a ? r : a) : s > a ? s : a,
          p = o > c ? (o > l ? o : l) : c > l ? c : l;
        let f = i.next;
        for (; f !== t; ) {
          if (
            f.x >= u &&
            f.x <= d &&
            f.y >= h &&
            f.y <= p &&
            Dh(r, o, s, c, a, l, f.x, f.y) &&
            Lh(f.prev, f, f.next) >= 0
          )
            return !1;
          f = f.next;
        }
        return !0;
      }
      function wh(e, t, n, i) {
        const r = e.prev,
          s = e,
          a = e.next;
        if (Lh(r, s, a) >= 0) return !1;
        const o = r.x,
          c = s.x,
          l = a.x,
          u = r.y,
          h = s.y,
          d = a.y,
          p = o < c ? (o < l ? o : l) : c < l ? c : l,
          f = u < h ? (u < d ? u : d) : h < d ? h : d,
          A = o > c ? (o > l ? o : l) : c > l ? c : l,
          g = u > h ? (u > d ? u : d) : h > d ? h : d,
          m = Bh(p, f, t, n, i),
          v = Bh(A, g, t, n, i);
        let y = e.prevZ,
          b = e.nextZ;
        for (; y && y.z >= m && b && b.z <= v; ) {
          if (
            y.x >= p &&
            y.x <= A &&
            y.y >= f &&
            y.y <= g &&
            y !== r &&
            y !== a &&
            Dh(o, u, c, h, l, d, y.x, y.y) &&
            Lh(y.prev, y, y.next) >= 0
          )
            return !1;
          if (
            ((y = y.prevZ),
            b.x >= p &&
              b.x <= A &&
              b.y >= f &&
              b.y <= g &&
              b !== r &&
              b !== a &&
              Dh(o, u, c, h, l, d, b.x, b.y) &&
              Lh(b.prev, b, b.next) >= 0)
          )
            return !1;
          b = b.nextZ;
        }
        for (; y && y.z >= m; ) {
          if (
            y.x >= p &&
            y.x <= A &&
            y.y >= f &&
            y.y <= g &&
            y !== r &&
            y !== a &&
            Dh(o, u, c, h, l, d, y.x, y.y) &&
            Lh(y.prev, y, y.next) >= 0
          )
            return !1;
          y = y.prevZ;
        }
        for (; b && b.z <= v; ) {
          if (
            b.x >= p &&
            b.x <= A &&
            b.y >= f &&
            b.y <= g &&
            b !== r &&
            b !== a &&
            Dh(o, u, c, h, l, d, b.x, b.y) &&
            Lh(b.prev, b, b.next) >= 0
          )
            return !1;
          b = b.nextZ;
        }
        return !0;
      }
      function Ch(e, t, n) {
        let i = e;
        do {
          const r = i.prev,
            s = i.next.next;
          !Uh(r, s) &&
            Fh(r, i, i.next, s) &&
            kh(r, s) &&
            kh(s, r) &&
            (t.push((r.i / n) | 0),
            t.push((i.i / n) | 0),
            t.push((s.i / n) | 0),
            Hh(i),
            Hh(i.next),
            (i = e = s)),
            (i = i.next);
        } while (i !== e);
        return _h(i);
      }
      function Sh(e, t, n, i, r, s) {
        let a = e;
        do {
          let e = a.next.next;
          for (; e !== a.prev; ) {
            if (a.i !== e.i && Ph(a, e)) {
              let o = Qh(a, e);
              return (
                (a = _h(a, a.next)),
                (o = _h(o, o.next)),
                xh(a, t, n, i, r, s, 0),
                void xh(o, t, n, i, r, s, 0)
              );
            }
            e = e.next;
          }
          a = a.next;
        } while (a !== e);
      }
      function Ih(e, t) {
        return e.x - t.x;
      }
      function Mh(e, t) {
        const n = (function (e, t) {
          let n,
            i = t,
            r = -1 / 0;
          const s = e.x,
            a = e.y;
          do {
            if (a <= i.y && a >= i.next.y && i.next.y !== i.y) {
              const e = i.x + ((a - i.y) * (i.next.x - i.x)) / (i.next.y - i.y);
              if (
                e <= s &&
                e > r &&
                ((r = e), (n = i.x < i.next.x ? i : i.next), e === s)
              )
                return n;
            }
            i = i.next;
          } while (i !== t);
          if (!n) return null;
          const o = n,
            c = n.x,
            l = n.y;
          let u,
            h = 1 / 0;
          i = n;
          do {
            s >= i.x &&
              i.x >= c &&
              s !== i.x &&
              Dh(a < l ? s : r, a, c, l, a < l ? r : s, a, i.x, i.y) &&
              ((u = Math.abs(a - i.y) / (s - i.x)),
              kh(i, e) &&
                (u < h ||
                  (u === h && (i.x > n.x || (i.x === n.x && Th(n, i))))) &&
                ((n = i), (h = u))),
              (i = i.next);
          } while (i !== o);
          return n;
        })(e, t);
        if (!n) return t;
        const i = Qh(n, e);
        return _h(i, i.next), _h(n, n.next);
      }
      function Th(e, t) {
        return Lh(e.prev, e, t.prev) < 0 && Lh(t.next, e, e.next) < 0;
      }
      function Bh(e, t, n, i, r) {
        return (
          (e =
            1431655765 &
            ((e =
              858993459 &
              ((e =
                252645135 &
                ((e = 16711935 & ((e = ((e - n) * r) | 0) | (e << 8))) |
                  (e << 4))) |
                (e << 2))) |
              (e << 1))) |
          ((t =
            1431655765 &
            ((t =
              858993459 &
              ((t =
                252645135 &
                ((t = 16711935 & ((t = ((t - i) * r) | 0) | (t << 8))) |
                  (t << 4))) |
                (t << 2))) |
              (t << 1))) <<
            1)
        );
      }
      function Rh(e) {
        let t = e,
          n = e;
        do {
          (t.x < n.x || (t.x === n.x && t.y < n.y)) && (n = t), (t = t.next);
        } while (t !== e);
        return n;
      }
      function Dh(e, t, n, i, r, s, a, o) {
        return (
          (r - a) * (t - o) >= (e - a) * (s - o) &&
          (e - a) * (i - o) >= (n - a) * (t - o) &&
          (n - a) * (s - o) >= (r - a) * (i - o)
        );
      }
      function Ph(e, t) {
        return (
          e.next.i !== t.i &&
          e.prev.i !== t.i &&
          !(function (e, t) {
            let n = e;
            do {
              if (
                n.i !== e.i &&
                n.next.i !== e.i &&
                n.i !== t.i &&
                n.next.i !== t.i &&
                Fh(n, n.next, e, t)
              )
                return !0;
              n = n.next;
            } while (n !== e);
            return !1;
          })(e, t) &&
          ((kh(e, t) &&
            kh(t, e) &&
            (function (e, t) {
              let n = e,
                i = !1;
              const r = (e.x + t.x) / 2,
                s = (e.y + t.y) / 2;
              do {
                n.y > s != n.next.y > s &&
                  n.next.y !== n.y &&
                  r < ((n.next.x - n.x) * (s - n.y)) / (n.next.y - n.y) + n.x &&
                  (i = !i),
                  (n = n.next);
              } while (n !== e);
              return i;
            })(e, t) &&
            (Lh(e.prev, e, t.prev) || Lh(e, t.prev, t))) ||
            (Uh(e, t) &&
              Lh(e.prev, e, e.next) > 0 &&
              Lh(t.prev, t, t.next) > 0))
        );
      }
      function Lh(e, t, n) {
        return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y);
      }
      function Uh(e, t) {
        return e.x === t.x && e.y === t.y;
      }
      function Fh(e, t, n, i) {
        const r = Nh(Lh(e, t, n)),
          s = Nh(Lh(e, t, i)),
          a = Nh(Lh(n, i, e)),
          o = Nh(Lh(n, i, t));
        return (
          (r !== s && a !== o) ||
          !(0 !== r || !Oh(e, n, t)) ||
          !(0 !== s || !Oh(e, i, t)) ||
          !(0 !== a || !Oh(n, e, i)) ||
          !(0 !== o || !Oh(n, t, i))
        );
      }
      function Oh(e, t, n) {
        return (
          t.x <= Math.max(e.x, n.x) &&
          t.x >= Math.min(e.x, n.x) &&
          t.y <= Math.max(e.y, n.y) &&
          t.y >= Math.min(e.y, n.y)
        );
      }
      function Nh(e) {
        return e > 0 ? 1 : e < 0 ? -1 : 0;
      }
      function kh(e, t) {
        return Lh(e.prev, e, e.next) < 0
          ? Lh(e, t, e.next) >= 0 && Lh(e, e.prev, t) >= 0
          : Lh(e, t, e.prev) < 0 || Lh(e, e.next, t) < 0;
      }
      function Qh(e, t) {
        const n = new zh(e.i, e.x, e.y),
          i = new zh(t.i, t.x, t.y),
          r = e.next,
          s = t.prev;
        return (
          (e.next = t),
          (t.prev = e),
          (n.next = r),
          (r.prev = n),
          (i.next = n),
          (n.prev = i),
          (s.next = i),
          (i.prev = s),
          i
        );
      }
      function Gh(e, t, n, i) {
        const r = new zh(e, t, n);
        return (
          i
            ? ((r.next = i.next), (r.prev = i), (i.next.prev = r), (i.next = r))
            : ((r.prev = r), (r.next = r)),
          r
        );
      }
      function Hh(e) {
        (e.next.prev = e.prev),
          (e.prev.next = e.next),
          e.prevZ && (e.prevZ.nextZ = e.nextZ),
          e.nextZ && (e.nextZ.prevZ = e.prevZ);
      }
      function zh(e, t, n) {
        (this.i = e),
          (this.x = t),
          (this.y = n),
          (this.prev = null),
          (this.next = null),
          (this.z = 0),
          (this.prevZ = null),
          (this.nextZ = null),
          (this.steiner = !1);
      }
      class Vh {
        static area(e) {
          const t = e.length;
          let n = 0;
          for (let i = t - 1, r = 0; r < t; i = r++)
            n += e[i].x * e[r].y - e[r].x * e[i].y;
          return 0.5 * n;
        }
        static isClockWise(e) {
          return Vh.area(e) < 0;
        }
        static triangulateShape(e, t) {
          const n = [],
            i = [],
            r = [];
          jh(e), Wh(n, e);
          let s = e.length;
          t.forEach(jh);
          for (let e = 0; e < t.length; e++)
            i.push(s), (s += t[e].length), Wh(n, t[e]);
          const a = yh(n, i);
          for (let e = 0; e < a.length; e += 3) r.push(a.slice(e, e + 3));
          return r;
        }
      }
      function jh(e) {
        const t = e.length;
        t > 2 && e[t - 1].equals(e[0]) && e.pop();
      }
      function Wh(e, t) {
        for (let n = 0; n < t.length; n++) e.push(t[n].x), e.push(t[n].y);
      }
      class Xh extends Qa {
        constructor(
          e = 1,
          t = 32,
          n = 16,
          i = 0,
          r = 2 * Math.PI,
          s = 0,
          a = Math.PI
        ) {
          super(),
            (this.type = "SphereGeometry"),
            (this.parameters = {
              radius: e,
              widthSegments: t,
              heightSegments: n,
              phiStart: i,
              phiLength: r,
              thetaStart: s,
              thetaLength: a,
            }),
            (t = Math.max(3, Math.floor(t))),
            (n = Math.max(2, Math.floor(n)));
          const o = Math.min(s + a, Math.PI);
          let c = 0;
          const l = [],
            u = new Yr(),
            h = new Yr(),
            d = [],
            p = [],
            f = [],
            A = [];
          for (let d = 0; d <= n; d++) {
            const g = [],
              m = d / n;
            let v = 0;
            0 === d && 0 === s
              ? (v = 0.5 / t)
              : d === n && o === Math.PI && (v = -0.5 / t);
            for (let n = 0; n <= t; n++) {
              const o = n / t;
              (u.x = -e * Math.cos(i + o * r) * Math.sin(s + m * a)),
                (u.y = e * Math.cos(s + m * a)),
                (u.z = e * Math.sin(i + o * r) * Math.sin(s + m * a)),
                p.push(u.x, u.y, u.z),
                h.copy(u).normalize(),
                f.push(h.x, h.y, h.z),
                A.push(o + v, 1 - m),
                g.push(c++);
            }
            l.push(g);
          }
          for (let e = 0; e < n; e++)
            for (let i = 0; i < t; i++) {
              const t = l[e][i + 1],
                r = l[e][i],
                a = l[e + 1][i],
                c = l[e + 1][i + 1];
              (0 !== e || s > 0) && d.push(t, r, c),
                (e !== n - 1 || o < Math.PI) && d.push(r, a, c);
            }
          this.setIndex(d),
            this.setAttribute("position", new Da(p, 3)),
            this.setAttribute("normal", new Da(f, 3)),
            this.setAttribute("uv", new Da(A, 2));
        }
        copy(e) {
          return (
            super.copy(e),
            (this.parameters = Object.assign({}, e.parameters)),
            this
          );
        }
        static fromJSON(e) {
          return new Xh(
            e.radius,
            e.widthSegments,
            e.heightSegments,
            e.phiStart,
            e.phiLength,
            e.thetaStart,
            e.thetaLength
          );
        }
      }
      class qh extends Qa {
        constructor(e = 1, t = 0.4, n = 12, i = 48, r = 2 * Math.PI) {
          super(),
            (this.type = "TorusGeometry"),
            (this.parameters = {
              radius: e,
              tube: t,
              radialSegments: n,
              tubularSegments: i,
              arc: r,
            }),
            (n = Math.floor(n)),
            (i = Math.floor(i));
          const s = [],
            a = [],
            o = [],
            c = [],
            l = new Yr(),
            u = new Yr(),
            h = new Yr();
          for (let s = 0; s <= n; s++)
            for (let d = 0; d <= i; d++) {
              const p = (d / i) * r,
                f = (s / n) * Math.PI * 2;
              (u.x = (e + t * Math.cos(f)) * Math.cos(p)),
                (u.y = (e + t * Math.cos(f)) * Math.sin(p)),
                (u.z = t * Math.sin(f)),
                a.push(u.x, u.y, u.z),
                (l.x = e * Math.cos(p)),
                (l.y = e * Math.sin(p)),
                h.subVectors(u, l).normalize(),
                o.push(h.x, h.y, h.z),
                c.push(d / i),
                c.push(s / n);
            }
          for (let e = 1; e <= n; e++)
            for (let t = 1; t <= i; t++) {
              const n = (i + 1) * e + t - 1,
                r = (i + 1) * (e - 1) + t - 1,
                a = (i + 1) * (e - 1) + t,
                o = (i + 1) * e + t;
              s.push(n, r, o), s.push(r, a, o);
            }
          this.setIndex(s),
            this.setAttribute("position", new Da(a, 3)),
            this.setAttribute("normal", new Da(o, 3)),
            this.setAttribute("uv", new Da(c, 2));
        }
        copy(e) {
          return (
            super.copy(e),
            (this.parameters = Object.assign({}, e.parameters)),
            this
          );
        }
        static fromJSON(e) {
          return new qh(
            e.radius,
            e.tube,
            e.radialSegments,
            e.tubularSegments,
            e.arc
          );
        }
      }
      class Yh extends ba {
        static get type() {
          return "MeshStandardMaterial";
        }
        constructor(e) {
          super(),
            (this.isMeshStandardMaterial = !0),
            (this.defines = { STANDARD: "" }),
            (this.color = new ma(16777215)),
            (this.roughness = 1),
            (this.metalness = 0),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new ma(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = 0),
            (this.normalScale = new br(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.roughnessMap = null),
            (this.metalnessMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.envMapRotation = new Us()),
            (this.envMapIntensity = 1),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.flatShading = !1),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.defines = { STANDARD: "" }),
            this.color.copy(e.color),
            (this.roughness = e.roughness),
            (this.metalness = e.metalness),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.roughnessMap = e.roughnessMap),
            (this.metalnessMap = e.metalnessMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            this.envMapRotation.copy(e.envMapRotation),
            (this.envMapIntensity = e.envMapIntensity),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.flatShading = e.flatShading),
            (this.fog = e.fog),
            this
          );
        }
      }
      class Kh extends Yh {
        static get type() {
          return "MeshPhysicalMaterial";
        }
        constructor(e) {
          super(),
            (this.isMeshPhysicalMaterial = !0),
            (this.defines = { STANDARD: "", PHYSICAL: "" }),
            (this.anisotropyRotation = 0),
            (this.anisotropyMap = null),
            (this.clearcoatMap = null),
            (this.clearcoatRoughness = 0),
            (this.clearcoatRoughnessMap = null),
            (this.clearcoatNormalScale = new br(1, 1)),
            (this.clearcoatNormalMap = null),
            (this.ior = 1.5),
            Object.defineProperty(this, "reflectivity", {
              get: function () {
                return fr((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
              },
              set: function (e) {
                this.ior = (1 + 0.4 * e) / (1 - 0.4 * e);
              },
            }),
            (this.iridescenceMap = null),
            (this.iridescenceIOR = 1.3),
            (this.iridescenceThicknessRange = [100, 400]),
            (this.iridescenceThicknessMap = null),
            (this.sheenColor = new ma(0)),
            (this.sheenColorMap = null),
            (this.sheenRoughness = 1),
            (this.sheenRoughnessMap = null),
            (this.transmissionMap = null),
            (this.thickness = 0),
            (this.thicknessMap = null),
            (this.attenuationDistance = 1 / 0),
            (this.attenuationColor = new ma(1, 1, 1)),
            (this.specularIntensity = 1),
            (this.specularIntensityMap = null),
            (this.specularColor = new ma(1, 1, 1)),
            (this.specularColorMap = null),
            (this._anisotropy = 0),
            (this._clearcoat = 0),
            (this._dispersion = 0),
            (this._iridescence = 0),
            (this._sheen = 0),
            (this._transmission = 0),
            this.setValues(e);
        }
        get anisotropy() {
          return this._anisotropy;
        }
        set anisotropy(e) {
          this._anisotropy > 0 != e > 0 && this.version++,
            (this._anisotropy = e);
        }
        get clearcoat() {
          return this._clearcoat;
        }
        set clearcoat(e) {
          this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
        }
        get iridescence() {
          return this._iridescence;
        }
        set iridescence(e) {
          this._iridescence > 0 != e > 0 && this.version++,
            (this._iridescence = e);
        }
        get dispersion() {
          return this._dispersion;
        }
        set dispersion(e) {
          this._dispersion > 0 != e > 0 && this.version++,
            (this._dispersion = e);
        }
        get sheen() {
          return this._sheen;
        }
        set sheen(e) {
          this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
        }
        get transmission() {
          return this._transmission;
        }
        set transmission(e) {
          this._transmission > 0 != e > 0 && this.version++,
            (this._transmission = e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.defines = { STANDARD: "", PHYSICAL: "" }),
            (this.anisotropy = e.anisotropy),
            (this.anisotropyRotation = e.anisotropyRotation),
            (this.anisotropyMap = e.anisotropyMap),
            (this.clearcoat = e.clearcoat),
            (this.clearcoatMap = e.clearcoatMap),
            (this.clearcoatRoughness = e.clearcoatRoughness),
            (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
            (this.clearcoatNormalMap = e.clearcoatNormalMap),
            this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
            (this.dispersion = e.dispersion),
            (this.ior = e.ior),
            (this.iridescence = e.iridescence),
            (this.iridescenceMap = e.iridescenceMap),
            (this.iridescenceIOR = e.iridescenceIOR),
            (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
            (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
            (this.sheen = e.sheen),
            this.sheenColor.copy(e.sheenColor),
            (this.sheenColorMap = e.sheenColorMap),
            (this.sheenRoughness = e.sheenRoughness),
            (this.sheenRoughnessMap = e.sheenRoughnessMap),
            (this.transmission = e.transmission),
            (this.transmissionMap = e.transmissionMap),
            (this.thickness = e.thickness),
            (this.thicknessMap = e.thicknessMap),
            (this.attenuationDistance = e.attenuationDistance),
            this.attenuationColor.copy(e.attenuationColor),
            (this.specularIntensity = e.specularIntensity),
            (this.specularIntensityMap = e.specularIntensityMap),
            this.specularColor.copy(e.specularColor),
            (this.specularColorMap = e.specularColorMap),
            this
          );
        }
      }
      class Jh extends ba {
        static get type() {
          return "MeshPhongMaterial";
        }
        constructor(e) {
          super(),
            (this.isMeshPhongMaterial = !0),
            (this.color = new ma(16777215)),
            (this.specular = new ma(1118481)),
            (this.shininess = 30),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new ma(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = 0),
            (this.normalScale = new br(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.envMapRotation = new Us()),
            (this.combine = dn),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.flatShading = !1),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            this.specular.copy(e.specular),
            (this.shininess = e.shininess),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            this.envMapRotation.copy(e.envMapRotation),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.flatShading = e.flatShading),
            (this.fog = e.fog),
            this
          );
        }
      }
      class Zh extends ba {
        static get type() {
          return "MeshLambertMaterial";
        }
        constructor(e) {
          super(),
            (this.isMeshLambertMaterial = !0),
            (this.color = new ma(16777215)),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new ma(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = 0),
            (this.normalScale = new br(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.envMapRotation = new Us()),
            (this.combine = dn),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.flatShading = !1),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            this.envMapRotation.copy(e.envMapRotation),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.flatShading = e.flatShading),
            (this.fog = e.fog),
            this
          );
        }
      }
      function $h(e, t, n) {
        return !e || (!n && e.constructor === t)
          ? e
          : "number" == typeof t.BYTES_PER_ELEMENT
          ? new t(e)
          : Array.prototype.slice.call(e);
      }
      function ed(e) {
        return ArrayBuffer.isView(e) && !(e instanceof DataView);
      }
      function td(e) {
        const t = e.length,
          n = new Array(t);
        for (let e = 0; e !== t; ++e) n[e] = e;
        return (
          n.sort(function (t, n) {
            return e[t] - e[n];
          }),
          n
        );
      }
      function nd(e, t, n) {
        const i = e.length,
          r = new e.constructor(i);
        for (let s = 0, a = 0; a !== i; ++s) {
          const i = n[s] * t;
          for (let n = 0; n !== t; ++n) r[a++] = e[i + n];
        }
        return r;
      }
      function id(e, t, n, i) {
        let r = 1,
          s = e[0];
        for (; void 0 !== s && void 0 === s[i]; ) s = e[r++];
        if (void 0 === s) return;
        let a = s[i];
        if (void 0 !== a)
          if (Array.isArray(a))
            do {
              (a = s[i]),
                void 0 !== a && (t.push(s.time), n.push.apply(n, a)),
                (s = e[r++]);
            } while (void 0 !== s);
          else if (void 0 !== a.toArray)
            do {
              (a = s[i]),
                void 0 !== a && (t.push(s.time), a.toArray(n, n.length)),
                (s = e[r++]);
            } while (void 0 !== s);
          else
            do {
              (a = s[i]),
                void 0 !== a && (t.push(s.time), n.push(a)),
                (s = e[r++]);
            } while (void 0 !== s);
      }
      class rd {
        constructor(e, t, n, i) {
          (this.parameterPositions = e),
            (this._cachedIndex = 0),
            (this.resultBuffer = void 0 !== i ? i : new t.constructor(n)),
            (this.sampleValues = t),
            (this.valueSize = n),
            (this.settings = null),
            (this.DefaultSettings_ = {});
        }
        evaluate(e) {
          const t = this.parameterPositions;
          let n = this._cachedIndex,
            i = t[n],
            r = t[n - 1];
          e: {
            t: {
              let s;
              n: {
                i: if (!(e < i)) {
                  for (let s = n + 2; ; ) {
                    if (void 0 === i) {
                      if (e < r) break i;
                      return (
                        (n = t.length),
                        (this._cachedIndex = n),
                        this.copySampleValue_(n - 1)
                      );
                    }
                    if (n === s) break;
                    if (((r = i), (i = t[++n]), e < i)) break t;
                  }
                  s = t.length;
                  break n;
                }
                if (e >= r) break e;
                {
                  const a = t[1];
                  e < a && ((n = 2), (r = a));
                  for (let s = n - 2; ; ) {
                    if (void 0 === r)
                      return (this._cachedIndex = 0), this.copySampleValue_(0);
                    if (n === s) break;
                    if (((i = r), (r = t[--n - 1]), e >= r)) break t;
                  }
                  (s = n), (n = 0);
                }
              }
              for (; n < s; ) {
                const i = (n + s) >>> 1;
                e < t[i] ? (s = i) : (n = i + 1);
              }
              if (((i = t[n]), (r = t[n - 1]), void 0 === r))
                return (this._cachedIndex = 0), this.copySampleValue_(0);
              if (void 0 === i)
                return (
                  (n = t.length),
                  (this._cachedIndex = n),
                  this.copySampleValue_(n - 1)
                );
            }
            (this._cachedIndex = n), this.intervalChanged_(n, r, i);
          }
          return this.interpolate_(n, r, e, i);
        }
        getSettings_() {
          return this.settings || this.DefaultSettings_;
        }
        copySampleValue_(e) {
          const t = this.resultBuffer,
            n = this.sampleValues,
            i = this.valueSize,
            r = e * i;
          for (let e = 0; e !== i; ++e) t[e] = n[r + e];
          return t;
        }
        interpolate_() {
          throw new Error("call to abstract method");
        }
        intervalChanged_() {}
      }
      class sd extends rd {
        constructor(e, t, n, i) {
          super(e, t, n, i),
            (this._weightPrev = -0),
            (this._offsetPrev = -0),
            (this._weightNext = -0),
            (this._offsetNext = -0),
            (this.DefaultSettings_ = { endingStart: ji, endingEnd: ji });
        }
        intervalChanged_(e, t, n) {
          const i = this.parameterPositions;
          let r = e - 2,
            s = e + 1,
            a = i[r],
            o = i[s];
          if (void 0 === a)
            switch (this.getSettings_().endingStart) {
              case Wi:
                (r = e), (a = 2 * t - n);
                break;
              case Xi:
                (r = i.length - 2), (a = t + i[r] - i[r + 1]);
                break;
              default:
                (r = e), (a = n);
            }
          if (void 0 === o)
            switch (this.getSettings_().endingEnd) {
              case Wi:
                (s = e), (o = 2 * n - t);
                break;
              case Xi:
                (s = 1), (o = n + i[1] - i[0]);
                break;
              default:
                (s = e - 1), (o = t);
            }
          const c = 0.5 * (n - t),
            l = this.valueSize;
          (this._weightPrev = c / (t - a)),
            (this._weightNext = c / (o - n)),
            (this._offsetPrev = r * l),
            (this._offsetNext = s * l);
        }
        interpolate_(e, t, n, i) {
          const r = this.resultBuffer,
            s = this.sampleValues,
            a = this.valueSize,
            o = e * a,
            c = o - a,
            l = this._offsetPrev,
            u = this._offsetNext,
            h = this._weightPrev,
            d = this._weightNext,
            p = (n - t) / (i - t),
            f = p * p,
            A = f * p,
            g = -h * A + 2 * h * f - h * p,
            m = (1 + h) * A + (-1.5 - 2 * h) * f + (-0.5 + h) * p + 1,
            v = (-1 - d) * A + (1.5 + d) * f + 0.5 * p,
            y = d * A - d * f;
          for (let e = 0; e !== a; ++e)
            r[e] = g * s[l + e] + m * s[c + e] + v * s[o + e] + y * s[u + e];
          return r;
        }
      }
      class ad extends rd {
        constructor(e, t, n, i) {
          super(e, t, n, i);
        }
        interpolate_(e, t, n, i) {
          const r = this.resultBuffer,
            s = this.sampleValues,
            a = this.valueSize,
            o = e * a,
            c = o - a,
            l = (n - t) / (i - t),
            u = 1 - l;
          for (let e = 0; e !== a; ++e) r[e] = s[c + e] * u + s[o + e] * l;
          return r;
        }
      }
      class od extends rd {
        constructor(e, t, n, i) {
          super(e, t, n, i);
        }
        interpolate_(e) {
          return this.copySampleValue_(e - 1);
        }
      }
      class cd {
        constructor(e, t, n, i) {
          if (void 0 === e)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
          if (void 0 === t || 0 === t.length)
            throw new Error(
              "THREE.KeyframeTrack: no keyframes in track named " + e
            );
          (this.name = e),
            (this.times = $h(t, this.TimeBufferType)),
            (this.values = $h(n, this.ValueBufferType)),
            this.setInterpolation(i || this.DefaultInterpolation);
        }
        static toJSON(e) {
          const t = e.constructor;
          let n;
          if (t.toJSON !== this.toJSON) n = t.toJSON(e);
          else {
            n = {
              name: e.name,
              times: $h(e.times, Array),
              values: $h(e.values, Array),
            };
            const t = e.getInterpolation();
            t !== e.DefaultInterpolation && (n.interpolation = t);
          }
          return (n.type = e.ValueTypeName), n;
        }
        InterpolantFactoryMethodDiscrete(e) {
          return new od(this.times, this.values, this.getValueSize(), e);
        }
        InterpolantFactoryMethodLinear(e) {
          return new ad(this.times, this.values, this.getValueSize(), e);
        }
        InterpolantFactoryMethodSmooth(e) {
          return new sd(this.times, this.values, this.getValueSize(), e);
        }
        setInterpolation(e) {
          let t;
          switch (e) {
            case Hi:
              t = this.InterpolantFactoryMethodDiscrete;
              break;
            case zi:
              t = this.InterpolantFactoryMethodLinear;
              break;
            case Vi:
              t = this.InterpolantFactoryMethodSmooth;
          }
          if (void 0 === t) {
            const t =
              "unsupported interpolation for " +
              this.ValueTypeName +
              " keyframe track named " +
              this.name;
            if (void 0 === this.createInterpolant) {
              if (e === this.DefaultInterpolation) throw new Error(t);
              this.setInterpolation(this.DefaultInterpolation);
            }
            return console.warn("THREE.KeyframeTrack:", t), this;
          }
          return (this.createInterpolant = t), this;
        }
        getInterpolation() {
          switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
              return Hi;
            case this.InterpolantFactoryMethodLinear:
              return zi;
            case this.InterpolantFactoryMethodSmooth:
              return Vi;
          }
        }
        getValueSize() {
          return this.values.length / this.times.length;
        }
        shift(e) {
          if (0 !== e) {
            const t = this.times;
            for (let n = 0, i = t.length; n !== i; ++n) t[n] += e;
          }
          return this;
        }
        scale(e) {
          if (1 !== e) {
            const t = this.times;
            for (let n = 0, i = t.length; n !== i; ++n) t[n] *= e;
          }
          return this;
        }
        trim(e, t) {
          const n = this.times,
            i = n.length;
          let r = 0,
            s = i - 1;
          for (; r !== i && n[r] < e; ) ++r;
          for (; -1 !== s && n[s] > t; ) --s;
          if ((++s, 0 !== r || s !== i)) {
            r >= s && ((s = Math.max(s, 1)), (r = s - 1));
            const e = this.getValueSize();
            (this.times = n.slice(r, s)),
              (this.values = this.values.slice(r * e, s * e));
          }
          return this;
        }
        validate() {
          let e = !0;
          const t = this.getValueSize();
          t - Math.floor(t) != 0 &&
            (console.error(
              "THREE.KeyframeTrack: Invalid value size in track.",
              this
            ),
            (e = !1));
          const n = this.times,
            i = this.values,
            r = n.length;
          0 === r &&
            (console.error("THREE.KeyframeTrack: Track is empty.", this),
            (e = !1));
          let s = null;
          for (let t = 0; t !== r; t++) {
            const i = n[t];
            if ("number" == typeof i && isNaN(i)) {
              console.error(
                "THREE.KeyframeTrack: Time is not a valid number.",
                this,
                t,
                i
              ),
                (e = !1);
              break;
            }
            if (null !== s && s > i) {
              console.error(
                "THREE.KeyframeTrack: Out of order keys.",
                this,
                t,
                i,
                s
              ),
                (e = !1);
              break;
            }
            s = i;
          }
          if (void 0 !== i && ed(i))
            for (let t = 0, n = i.length; t !== n; ++t) {
              const n = i[t];
              if (isNaN(n)) {
                console.error(
                  "THREE.KeyframeTrack: Value is not a valid number.",
                  this,
                  t,
                  n
                ),
                  (e = !1);
                break;
              }
            }
          return e;
        }
        optimize() {
          const e = this.times.slice(),
            t = this.values.slice(),
            n = this.getValueSize(),
            i = this.getInterpolation() === Vi,
            r = e.length - 1;
          let s = 1;
          for (let a = 1; a < r; ++a) {
            let r = !1;
            const o = e[a];
            if (o !== e[a + 1] && (1 !== a || o !== e[0]))
              if (i) r = !0;
              else {
                const e = a * n,
                  i = e - n,
                  s = e + n;
                for (let a = 0; a !== n; ++a) {
                  const n = t[e + a];
                  if (n !== t[i + a] || n !== t[s + a]) {
                    r = !0;
                    break;
                  }
                }
              }
            if (r) {
              if (a !== s) {
                e[s] = e[a];
                const i = a * n,
                  r = s * n;
                for (let e = 0; e !== n; ++e) t[r + e] = t[i + e];
              }
              ++s;
            }
          }
          if (r > 0) {
            e[s] = e[r];
            for (let e = r * n, i = s * n, a = 0; a !== n; ++a)
              t[i + a] = t[e + a];
            ++s;
          }
          return (
            s !== e.length
              ? ((this.times = e.slice(0, s)),
                (this.values = t.slice(0, s * n)))
              : ((this.times = e), (this.values = t)),
            this
          );
        }
        clone() {
          const e = this.times.slice(),
            t = this.values.slice(),
            n = new (0, this.constructor)(this.name, e, t);
          return (n.createInterpolant = this.createInterpolant), n;
        }
      }
      (cd.prototype.TimeBufferType = Float32Array),
        (cd.prototype.ValueBufferType = Float32Array),
        (cd.prototype.DefaultInterpolation = zi);
      class ld extends cd {
        constructor(e, t, n) {
          super(e, t, n);
        }
      }
      (ld.prototype.ValueTypeName = "bool"),
        (ld.prototype.ValueBufferType = Array),
        (ld.prototype.DefaultInterpolation = Hi),
        (ld.prototype.InterpolantFactoryMethodLinear = void 0),
        (ld.prototype.InterpolantFactoryMethodSmooth = void 0);
      class ud extends cd {}
      ud.prototype.ValueTypeName = "color";
      class hd extends cd {}
      hd.prototype.ValueTypeName = "number";
      class dd extends rd {
        constructor(e, t, n, i) {
          super(e, t, n, i);
        }
        interpolate_(e, t, n, i) {
          const r = this.resultBuffer,
            s = this.sampleValues,
            a = this.valueSize,
            o = (n - t) / (i - t);
          let c = e * a;
          for (let e = c + a; c !== e; c += 4)
            qr.slerpFlat(r, 0, s, c - a, s, c, o);
          return r;
        }
      }
      class pd extends cd {
        InterpolantFactoryMethodLinear(e) {
          return new dd(this.times, this.values, this.getValueSize(), e);
        }
      }
      (pd.prototype.ValueTypeName = "quaternion"),
        (pd.prototype.InterpolantFactoryMethodSmooth = void 0);
      class fd extends cd {
        constructor(e, t, n) {
          super(e, t, n);
        }
      }
      (fd.prototype.ValueTypeName = "string"),
        (fd.prototype.ValueBufferType = Array),
        (fd.prototype.DefaultInterpolation = Hi),
        (fd.prototype.InterpolantFactoryMethodLinear = void 0),
        (fd.prototype.InterpolantFactoryMethodSmooth = void 0);
      class Ad extends cd {}
      Ad.prototype.ValueTypeName = "vector";
      class gd {
        constructor(e = "", t = -1, n = [], i = qi) {
          (this.name = e),
            (this.tracks = n),
            (this.duration = t),
            (this.blendMode = i),
            (this.uuid = pr()),
            this.duration < 0 && this.resetDuration();
        }
        static parse(e) {
          const t = [],
            n = e.tracks,
            i = 1 / (e.fps || 1);
          for (let e = 0, r = n.length; e !== r; ++e) t.push(md(n[e]).scale(i));
          const r = new this(e.name, e.duration, t, e.blendMode);
          return (r.uuid = e.uuid), r;
        }
        static toJSON(e) {
          const t = [],
            n = e.tracks,
            i = {
              name: e.name,
              duration: e.duration,
              tracks: t,
              uuid: e.uuid,
              blendMode: e.blendMode,
            };
          for (let e = 0, i = n.length; e !== i; ++e) t.push(cd.toJSON(n[e]));
          return i;
        }
        static CreateFromMorphTargetSequence(e, t, n, i) {
          const r = t.length,
            s = [];
          for (let e = 0; e < r; e++) {
            let a = [],
              o = [];
            a.push((e + r - 1) % r, e, (e + 1) % r), o.push(0, 1, 0);
            const c = td(a);
            (a = nd(a, 1, c)),
              (o = nd(o, 1, c)),
              i || 0 !== a[0] || (a.push(r), o.push(o[0])),
              s.push(
                new hd(".morphTargetInfluences[" + t[e].name + "]", a, o).scale(
                  1 / n
                )
              );
          }
          return new this(e, -1, s);
        }
        static findByName(e, t) {
          let n = e;
          if (!Array.isArray(e)) {
            const t = e;
            n = (t.geometry && t.geometry.animations) || t.animations;
          }
          for (let e = 0; e < n.length; e++) if (n[e].name === t) return n[e];
          return null;
        }
        static CreateClipsFromMorphTargetSequences(e, t, n) {
          const i = {},
            r = /^([\w-]*?)([\d]+)$/;
          for (let t = 0, n = e.length; t < n; t++) {
            const n = e[t],
              s = n.name.match(r);
            if (s && s.length > 1) {
              const e = s[1];
              let t = i[e];
              t || (i[e] = t = []), t.push(n);
            }
          }
          const s = [];
          for (const e in i)
            s.push(this.CreateFromMorphTargetSequence(e, i[e], t, n));
          return s;
        }
        static parseAnimation(e, t) {
          if (!e)
            return (
              console.error(
                "THREE.AnimationClip: No animation in JSONLoader data."
              ),
              null
            );
          const n = function (e, t, n, i, r) {
              if (0 !== n.length) {
                const s = [],
                  a = [];
                id(n, s, a, i), 0 !== s.length && r.push(new e(t, s, a));
              }
            },
            i = [],
            r = e.name || "default",
            s = e.fps || 30,
            a = e.blendMode;
          let o = e.length || -1;
          const c = e.hierarchy || [];
          for (let e = 0; e < c.length; e++) {
            const r = c[e].keys;
            if (r && 0 !== r.length)
              if (r[0].morphTargets) {
                const e = {};
                let t;
                for (t = 0; t < r.length; t++)
                  if (r[t].morphTargets)
                    for (let n = 0; n < r[t].morphTargets.length; n++)
                      e[r[t].morphTargets[n]] = -1;
                for (const n in e) {
                  const e = [],
                    s = [];
                  for (let i = 0; i !== r[t].morphTargets.length; ++i) {
                    const i = r[t];
                    e.push(i.time), s.push(i.morphTarget === n ? 1 : 0);
                  }
                  i.push(new hd(".morphTargetInfluence[" + n + "]", e, s));
                }
                o = e.length * s;
              } else {
                const s = ".bones[" + t[e].name + "]";
                n(Ad, s + ".position", r, "pos", i),
                  n(pd, s + ".quaternion", r, "rot", i),
                  n(Ad, s + ".scale", r, "scl", i);
              }
          }
          if (0 === i.length) return null;
          return new this(r, o, i, a);
        }
        resetDuration() {
          let e = 0;
          for (let t = 0, n = this.tracks.length; t !== n; ++t) {
            const n = this.tracks[t];
            e = Math.max(e, n.times[n.times.length - 1]);
          }
          return (this.duration = e), this;
        }
        trim() {
          for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].trim(0, this.duration);
          return this;
        }
        validate() {
          let e = !0;
          for (let t = 0; t < this.tracks.length; t++)
            e = e && this.tracks[t].validate();
          return e;
        }
        optimize() {
          for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].optimize();
          return this;
        }
        clone() {
          const e = [];
          for (let t = 0; t < this.tracks.length; t++)
            e.push(this.tracks[t].clone());
          return new this.constructor(
            this.name,
            this.duration,
            e,
            this.blendMode
          );
        }
        toJSON() {
          return this.constructor.toJSON(this);
        }
      }
      function md(e) {
        if (void 0 === e.type)
          throw new Error(
            "THREE.KeyframeTrack: track type undefined, can not parse"
          );
        const t = (function (e) {
          switch (e.toLowerCase()) {
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
              return hd;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
              return Ad;
            case "color":
              return ud;
            case "quaternion":
              return pd;
            case "bool":
            case "boolean":
              return ld;
            case "string":
              return fd;
          }
          throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e);
        })(e.type);
        if (void 0 === e.times) {
          const t = [],
            n = [];
          id(e.keys, t, n, "value"), (e.times = t), (e.values = n);
        }
        return void 0 !== t.parse
          ? t.parse(e)
          : new t(e.name, e.times, e.values, e.interpolation);
      }
      const vd = {
        enabled: !1,
        files: {},
        add: function (e, t) {
          !1 !== this.enabled && (this.files[e] = t);
        },
        get: function (e) {
          if (!1 !== this.enabled) return this.files[e];
        },
        remove: function (e) {
          delete this.files[e];
        },
        clear: function () {
          this.files = {};
        },
      };
      class yd {
        constructor(e, t, n) {
          const i = this;
          let r,
            s = !1,
            a = 0,
            o = 0;
          const c = [];
          (this.onStart = void 0),
            (this.onLoad = e),
            (this.onProgress = t),
            (this.onError = n),
            (this.itemStart = function (e) {
              o++,
                !1 === s && void 0 !== i.onStart && i.onStart(e, a, o),
                (s = !0);
            }),
            (this.itemEnd = function (e) {
              a++,
                void 0 !== i.onProgress && i.onProgress(e, a, o),
                a === o && ((s = !1), void 0 !== i.onLoad && i.onLoad());
            }),
            (this.itemError = function (e) {
              void 0 !== i.onError && i.onError(e);
            }),
            (this.resolveURL = function (e) {
              return r ? r(e) : e;
            }),
            (this.setURLModifier = function (e) {
              return (r = e), this;
            }),
            (this.addHandler = function (e, t) {
              return c.push(e, t), this;
            }),
            (this.removeHandler = function (e) {
              const t = c.indexOf(e);
              return -1 !== t && c.splice(t, 2), this;
            }),
            (this.getHandler = function (e) {
              for (let t = 0, n = c.length; t < n; t += 2) {
                const n = c[t],
                  i = c[t + 1];
                if ((n.global && (n.lastIndex = 0), n.test(e))) return i;
              }
              return null;
            });
        }
      }
      const bd = new yd();
      class _d {
        constructor(e) {
          (this.manager = void 0 !== e ? e : bd),
            (this.crossOrigin = "anonymous"),
            (this.withCredentials = !1),
            (this.path = ""),
            (this.resourcePath = ""),
            (this.requestHeader = {});
        }
        load() {}
        loadAsync(e, t) {
          const n = this;
          return new Promise(function (i, r) {
            n.load(e, i, t, r);
          });
        }
        parse() {}
        setCrossOrigin(e) {
          return (this.crossOrigin = e), this;
        }
        setWithCredentials(e) {
          return (this.withCredentials = e), this;
        }
        setPath(e) {
          return (this.path = e), this;
        }
        setResourcePath(e) {
          return (this.resourcePath = e), this;
        }
        setRequestHeader(e) {
          return (this.requestHeader = e), this;
        }
      }
      _d.DEFAULT_MATERIAL_NAME = "__DEFAULT";
      const xd = {};
      class Ed extends Error {
        constructor(e, t) {
          super(e), (this.response = t);
        }
      }
      class wd extends _d {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          void 0 === e && (e = ""),
            void 0 !== this.path && (e = this.path + e),
            (e = this.manager.resolveURL(e));
          const r = vd.get(e);
          if (void 0 !== r)
            return (
              this.manager.itemStart(e),
              setTimeout(() => {
                t && t(r), this.manager.itemEnd(e);
              }, 0),
              r
            );
          if (void 0 !== xd[e])
            return void xd[e].push({ onLoad: t, onProgress: n, onError: i });
          (xd[e] = []), xd[e].push({ onLoad: t, onProgress: n, onError: i });
          const s = new Request(e, {
              headers: new Headers(this.requestHeader),
              credentials: this.withCredentials ? "include" : "same-origin",
            }),
            a = this.mimeType,
            o = this.responseType;
          fetch(s)
            .then((t) => {
              if (200 === t.status || 0 === t.status) {
                if (
                  (0 === t.status &&
                    console.warn("THREE.FileLoader: HTTP Status 0 received."),
                  "undefined" == typeof ReadableStream ||
                    void 0 === t.body ||
                    void 0 === t.body.getReader)
                )
                  return t;
                const n = xd[e],
                  i = t.body.getReader(),
                  r =
                    t.headers.get("X-File-Size") ||
                    t.headers.get("Content-Length"),
                  s = r ? parseInt(r) : 0,
                  a = 0 !== s;
                let o = 0;
                const c = new ReadableStream({
                  start(e) {
                    !(function t() {
                      i.read().then(
                        ({ done: i, value: r }) => {
                          if (i) e.close();
                          else {
                            o += r.byteLength;
                            const i = new ProgressEvent("progress", {
                              lengthComputable: a,
                              loaded: o,
                              total: s,
                            });
                            for (let e = 0, t = n.length; e < t; e++) {
                              const t = n[e];
                              t.onProgress && t.onProgress(i);
                            }
                            e.enqueue(r), t();
                          }
                        },
                        (t) => {
                          e.error(t);
                        }
                      );
                    })();
                  },
                });
                return new Response(c);
              }
              throw new Ed(
                `fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`,
                t
              );
            })
            .then((e) => {
              switch (o) {
                case "arraybuffer":
                  return e.arrayBuffer();
                case "blob":
                  return e.blob();
                case "document":
                  return e
                    .text()
                    .then((e) => new DOMParser().parseFromString(e, a));
                case "json":
                  return e.json();
                default:
                  if (void 0 === a) return e.text();
                  {
                    const t = /charset="?([^;"\s]*)"?/i.exec(a),
                      n = t && t[1] ? t[1].toLowerCase() : void 0,
                      i = new TextDecoder(n);
                    return e.arrayBuffer().then((e) => i.decode(e));
                  }
              }
            })
            .then((t) => {
              vd.add(e, t);
              const n = xd[e];
              delete xd[e];
              for (let e = 0, i = n.length; e < i; e++) {
                const i = n[e];
                i.onLoad && i.onLoad(t);
              }
            })
            .catch((t) => {
              const n = xd[e];
              if (void 0 === n) throw (this.manager.itemError(e), t);
              delete xd[e];
              for (let e = 0, i = n.length; e < i; e++) {
                const i = n[e];
                i.onError && i.onError(t);
              }
              this.manager.itemError(e);
            })
            .finally(() => {
              this.manager.itemEnd(e);
            }),
            this.manager.itemStart(e);
        }
        setResponseType(e) {
          return (this.responseType = e), this;
        }
        setMimeType(e) {
          return (this.mimeType = e), this;
        }
      }
      class Cd extends _d {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          void 0 !== this.path && (e = this.path + e),
            (e = this.manager.resolveURL(e));
          const r = this,
            s = vd.get(e);
          if (void 0 !== s)
            return (
              r.manager.itemStart(e),
              setTimeout(function () {
                t && t(s), r.manager.itemEnd(e);
              }, 0),
              s
            );
          const a = wr("img");
          function o() {
            l(), vd.add(e, this), t && t(this), r.manager.itemEnd(e);
          }
          function c(t) {
            l(), i && i(t), r.manager.itemError(e), r.manager.itemEnd(e);
          }
          function l() {
            a.removeEventListener("load", o, !1),
              a.removeEventListener("error", c, !1);
          }
          return (
            a.addEventListener("load", o, !1),
            a.addEventListener("error", c, !1),
            "data:" !== e.slice(0, 5) &&
              void 0 !== this.crossOrigin &&
              (a.crossOrigin = this.crossOrigin),
            r.manager.itemStart(e),
            (a.src = e),
            a
          );
        }
      }
      class Sd extends _d {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          const r = this,
            s = new Du(),
            a = new wd(this.manager);
          return (
            a.setResponseType("arraybuffer"),
            a.setRequestHeader(this.requestHeader),
            a.setPath(this.path),
            a.setWithCredentials(r.withCredentials),
            a.load(
              e,
              function (e) {
                let n;
                try {
                  n = r.parse(e);
                } catch (e) {
                  if (void 0 === i) return void console.error(e);
                  i(e);
                }
                void 0 !== n.image
                  ? (s.image = n.image)
                  : void 0 !== n.data &&
                    ((s.image.width = n.width),
                    (s.image.height = n.height),
                    (s.image.data = n.data)),
                  (s.wrapS = void 0 !== n.wrapS ? n.wrapS : Bn),
                  (s.wrapT = void 0 !== n.wrapT ? n.wrapT : Bn),
                  (s.magFilter = void 0 !== n.magFilter ? n.magFilter : Un),
                  (s.minFilter = void 0 !== n.minFilter ? n.minFilter : Un),
                  (s.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1),
                  void 0 !== n.colorSpace && (s.colorSpace = n.colorSpace),
                  void 0 !== n.flipY && (s.flipY = n.flipY),
                  void 0 !== n.format && (s.format = n.format),
                  void 0 !== n.type && (s.type = n.type),
                  void 0 !== n.mipmaps &&
                    ((s.mipmaps = n.mipmaps), (s.minFilter = On)),
                  1 === n.mipmapCount && (s.minFilter = Un),
                  void 0 !== n.generateMipmaps &&
                    (s.generateMipmaps = n.generateMipmaps),
                  (s.needsUpdate = !0),
                  t && t(s, n);
              },
              n,
              i
            ),
            s
          );
        }
      }
      class Id extends _d {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          const r = new Hr(),
            s = new Cd(this.manager);
          return (
            s.setCrossOrigin(this.crossOrigin),
            s.setPath(this.path),
            s.load(
              e,
              function (e) {
                (r.image = e), (r.needsUpdate = !0), void 0 !== t && t(r);
              },
              n,
              i
            ),
            r
          );
        }
      }
      class Md extends Zs {
        constructor(e, t = 1) {
          super(),
            (this.isLight = !0),
            (this.type = "Light"),
            (this.color = new ma(e)),
            (this.intensity = t);
        }
        dispose() {}
        copy(e, t) {
          return (
            super.copy(e, t),
            this.color.copy(e.color),
            (this.intensity = e.intensity),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.color = this.color.getHex()),
            (t.object.intensity = this.intensity),
            void 0 !== this.groundColor &&
              (t.object.groundColor = this.groundColor.getHex()),
            void 0 !== this.distance && (t.object.distance = this.distance),
            void 0 !== this.angle && (t.object.angle = this.angle),
            void 0 !== this.decay && (t.object.decay = this.decay),
            void 0 !== this.penumbra && (t.object.penumbra = this.penumbra),
            void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()),
            void 0 !== this.target && (t.object.target = this.target.uuid),
            t
          );
        }
      }
      const Td = new Cs(),
        Bd = new Yr(),
        Rd = new Yr();
      class Dd {
        constructor(e) {
          (this.camera = e),
            (this.intensity = 1),
            (this.bias = 0),
            (this.normalBias = 0),
            (this.radius = 1),
            (this.blurSamples = 8),
            (this.mapSize = new br(512, 512)),
            (this.map = null),
            (this.mapPass = null),
            (this.matrix = new Cs()),
            (this.autoUpdate = !0),
            (this.needsUpdate = !1),
            (this._frustum = new xo()),
            (this._frameExtents = new br(1, 1)),
            (this._viewportCount = 1),
            (this._viewports = [new zr(0, 0, 1, 1)]);
        }
        getViewportCount() {
          return this._viewportCount;
        }
        getFrustum() {
          return this._frustum;
        }
        updateMatrices(e) {
          const t = this.camera,
            n = this.matrix;
          Bd.setFromMatrixPosition(e.matrixWorld),
            t.position.copy(Bd),
            Rd.setFromMatrixPosition(e.target.matrixWorld),
            t.lookAt(Rd),
            t.updateMatrixWorld(),
            Td.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(Td),
            n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
            n.multiply(Td);
        }
        getViewport(e) {
          return this._viewports[e];
        }
        getFrameExtents() {
          return this._frameExtents;
        }
        dispose() {
          this.map && this.map.dispose(),
            this.mapPass && this.mapPass.dispose();
        }
        copy(e) {
          return (
            (this.camera = e.camera.clone()),
            (this.intensity = e.intensity),
            (this.bias = e.bias),
            (this.radius = e.radius),
            this.mapSize.copy(e.mapSize),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const e = {};
          return (
            1 !== this.intensity && (e.intensity = this.intensity),
            0 !== this.bias && (e.bias = this.bias),
            0 !== this.normalBias && (e.normalBias = this.normalBias),
            1 !== this.radius && (e.radius = this.radius),
            (512 === this.mapSize.x && 512 === this.mapSize.y) ||
              (e.mapSize = this.mapSize.toArray()),
            (e.camera = this.camera.toJSON(!1).object),
            delete e.camera.matrix,
            e
          );
        }
      }
      class Pd extends Dd {
        constructor() {
          super(new uo(50, 1, 0.5, 500)),
            (this.isSpotLightShadow = !0),
            (this.focus = 1);
        }
        updateMatrices(e) {
          const t = this.camera,
            n = 2 * dr * e.angle * this.focus,
            i = this.mapSize.width / this.mapSize.height,
            r = e.distance || t.far;
          (n === t.fov && i === t.aspect && r === t.far) ||
            ((t.fov = n),
            (t.aspect = i),
            (t.far = r),
            t.updateProjectionMatrix()),
            super.updateMatrices(e);
        }
        copy(e) {
          return super.copy(e), (this.focus = e.focus), this;
        }
      }
      class Ld extends Md {
        constructor(e, t, n = 0, i = Math.PI / 3, r = 0, s = 2) {
          super(e, t),
            (this.isSpotLight = !0),
            (this.type = "SpotLight"),
            this.position.copy(Zs.DEFAULT_UP),
            this.updateMatrix(),
            (this.target = new Zs()),
            (this.distance = n),
            (this.angle = i),
            (this.penumbra = r),
            (this.decay = s),
            (this.map = null),
            (this.shadow = new Pd());
        }
        get power() {
          return this.intensity * Math.PI;
        }
        set power(e) {
          this.intensity = e / Math.PI;
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.distance = e.distance),
            (this.angle = e.angle),
            (this.penumbra = e.penumbra),
            (this.decay = e.decay),
            (this.target = e.target.clone()),
            (this.shadow = e.shadow.clone()),
            this
          );
        }
      }
      const Ud = new Cs(),
        Fd = new Yr(),
        Od = new Yr();
      class Nd extends Dd {
        constructor() {
          super(new uo(90, 1, 0.5, 500)),
            (this.isPointLightShadow = !0),
            (this._frameExtents = new br(4, 2)),
            (this._viewportCount = 6),
            (this._viewports = [
              new zr(2, 1, 1, 1),
              new zr(0, 1, 1, 1),
              new zr(3, 1, 1, 1),
              new zr(1, 1, 1, 1),
              new zr(3, 0, 1, 1),
              new zr(1, 0, 1, 1),
            ]),
            (this._cubeDirections = [
              new Yr(1, 0, 0),
              new Yr(-1, 0, 0),
              new Yr(0, 0, 1),
              new Yr(0, 0, -1),
              new Yr(0, 1, 0),
              new Yr(0, -1, 0),
            ]),
            (this._cubeUps = [
              new Yr(0, 1, 0),
              new Yr(0, 1, 0),
              new Yr(0, 1, 0),
              new Yr(0, 1, 0),
              new Yr(0, 0, 1),
              new Yr(0, 0, -1),
            ]);
        }
        updateMatrices(e, t = 0) {
          const n = this.camera,
            i = this.matrix,
            r = e.distance || n.far;
          r !== n.far && ((n.far = r), n.updateProjectionMatrix()),
            Fd.setFromMatrixPosition(e.matrixWorld),
            n.position.copy(Fd),
            Od.copy(n.position),
            Od.add(this._cubeDirections[t]),
            n.up.copy(this._cubeUps[t]),
            n.lookAt(Od),
            n.updateMatrixWorld(),
            i.makeTranslation(-Fd.x, -Fd.y, -Fd.z),
            Ud.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(Ud);
        }
      }
      class kd extends Md {
        constructor(e, t, n = 0, i = 2) {
          super(e, t),
            (this.isPointLight = !0),
            (this.type = "PointLight"),
            (this.distance = n),
            (this.decay = i),
            (this.shadow = new Nd());
        }
        get power() {
          return 4 * this.intensity * Math.PI;
        }
        set power(e) {
          this.intensity = e / (4 * Math.PI);
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.distance = e.distance),
            (this.decay = e.decay),
            (this.shadow = e.shadow.clone()),
            this
          );
        }
      }
      class Qd extends Dd {
        constructor() {
          super(new No(-5, 5, 5, -5, 0.5, 500)),
            (this.isDirectionalLightShadow = !0);
        }
      }
      class Gd extends Md {
        constructor(e, t) {
          super(e, t),
            (this.isDirectionalLight = !0),
            (this.type = "DirectionalLight"),
            this.position.copy(Zs.DEFAULT_UP),
            this.updateMatrix(),
            (this.target = new Zs()),
            (this.shadow = new Qd());
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e) {
          return (
            super.copy(e),
            (this.target = e.target.clone()),
            (this.shadow = e.shadow.clone()),
            this
          );
        }
      }
      class Hd extends Md {
        constructor(e, t) {
          super(e, t), (this.isAmbientLight = !0), (this.type = "AmbientLight");
        }
      }
      class zd {
        static decodeText(e) {
          if (
            (console.warn(
              "THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."
            ),
            "undefined" != typeof TextDecoder)
          )
            return new TextDecoder().decode(e);
          let t = "";
          for (let n = 0, i = e.length; n < i; n++)
            t += String.fromCharCode(e[n]);
          try {
            return decodeURIComponent(escape(t));
          } catch (e) {
            return t;
          }
        }
        static extractUrlBase(e) {
          const t = e.lastIndexOf("/");
          return -1 === t ? "./" : e.slice(0, t + 1);
        }
        static resolveURL(e, t) {
          return "string" != typeof e || "" === e
            ? ""
            : (/^https?:\/\//i.test(t) &&
                /^\//.test(e) &&
                (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
              /^(https?:)?\/\//i.test(e) ||
              /^data:.*,.*$/i.test(e) ||
              /^blob:.*$/i.test(e)
                ? e
                : t + e);
        }
      }
      class Vd extends _d {
        constructor(e) {
          super(e),
            (this.isImageBitmapLoader = !0),
            "undefined" == typeof createImageBitmap &&
              console.warn(
                "THREE.ImageBitmapLoader: createImageBitmap() not supported."
              ),
            "undefined" == typeof fetch &&
              console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
            (this.options = { premultiplyAlpha: "none" });
        }
        setOptions(e) {
          return (this.options = e), this;
        }
        load(e, t, n, i) {
          void 0 === e && (e = ""),
            void 0 !== this.path && (e = this.path + e),
            (e = this.manager.resolveURL(e));
          const r = this,
            s = vd.get(e);
          if (void 0 !== s)
            return (
              r.manager.itemStart(e),
              s.then
                ? void s
                    .then((n) => {
                      t && t(n), r.manager.itemEnd(e);
                    })
                    .catch((e) => {
                      i && i(e);
                    })
                : (setTimeout(function () {
                    t && t(s), r.manager.itemEnd(e);
                  }, 0),
                  s)
            );
          const a = {};
          (a.credentials =
            "anonymous" === this.crossOrigin ? "same-origin" : "include"),
            (a.headers = this.requestHeader);
          const o = fetch(e, a)
            .then(function (e) {
              return e.blob();
            })
            .then(function (e) {
              return createImageBitmap(
                e,
                Object.assign(r.options, { colorSpaceConversion: "none" })
              );
            })
            .then(function (n) {
              return vd.add(e, n), t && t(n), r.manager.itemEnd(e), n;
            })
            .catch(function (t) {
              i && i(t),
                vd.remove(e),
                r.manager.itemError(e),
                r.manager.itemEnd(e);
            });
          vd.add(e, o), r.manager.itemStart(e);
        }
      }
      class jd {
        constructor(e = !0) {
          (this.autoStart = e),
            (this.startTime = 0),
            (this.oldTime = 0),
            (this.elapsedTime = 0),
            (this.running = !1);
        }
        start() {
          (this.startTime = Wd()),
            (this.oldTime = this.startTime),
            (this.elapsedTime = 0),
            (this.running = !0);
        }
        stop() {
          this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
        }
        getElapsedTime() {
          return this.getDelta(), this.elapsedTime;
        }
        getDelta() {
          let e = 0;
          if (this.autoStart && !this.running) return this.start(), 0;
          if (this.running) {
            const t = Wd();
            (e = (t - this.oldTime) / 1e3),
              (this.oldTime = t),
              (this.elapsedTime += e);
          }
          return e;
        }
      }
      function Wd() {
        return performance.now();
      }
      class Xd {
        constructor(e, t, n) {
          let i, r, s;
          switch (((this.binding = e), (this.valueSize = n), t)) {
            case "quaternion":
              (i = this._slerp),
                (r = this._slerpAdditive),
                (s = this._setAdditiveIdentityQuaternion),
                (this.buffer = new Float64Array(6 * n)),
                (this._workIndex = 5);
              break;
            case "string":
            case "bool":
              (i = this._select),
                (r = this._select),
                (s = this._setAdditiveIdentityOther),
                (this.buffer = new Array(5 * n));
              break;
            default:
              (i = this._lerp),
                (r = this._lerpAdditive),
                (s = this._setAdditiveIdentityNumeric),
                (this.buffer = new Float64Array(5 * n));
          }
          (this._mixBufferRegion = i),
            (this._mixBufferRegionAdditive = r),
            (this._setIdentity = s),
            (this._origIndex = 3),
            (this._addIndex = 4),
            (this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0),
            (this.useCount = 0),
            (this.referenceCount = 0);
        }
        accumulate(e, t) {
          const n = this.buffer,
            i = this.valueSize,
            r = e * i + i;
          let s = this.cumulativeWeight;
          if (0 === s) {
            for (let e = 0; e !== i; ++e) n[r + e] = n[e];
            s = t;
          } else {
            s += t;
            const e = t / s;
            this._mixBufferRegion(n, r, 0, e, i);
          }
          this.cumulativeWeight = s;
        }
        accumulateAdditive(e) {
          const t = this.buffer,
            n = this.valueSize,
            i = n * this._addIndex;
          0 === this.cumulativeWeightAdditive && this._setIdentity(),
            this._mixBufferRegionAdditive(t, i, 0, e, n),
            (this.cumulativeWeightAdditive += e);
        }
        apply(e) {
          const t = this.valueSize,
            n = this.buffer,
            i = e * t + t,
            r = this.cumulativeWeight,
            s = this.cumulativeWeightAdditive,
            a = this.binding;
          if (
            ((this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0),
            r < 1)
          ) {
            const e = t * this._origIndex;
            this._mixBufferRegion(n, i, e, 1 - r, t);
          }
          s > 0 &&
            this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t);
          for (let e = t, r = t + t; e !== r; ++e)
            if (n[e] !== n[e + t]) {
              a.setValue(n, i);
              break;
            }
        }
        saveOriginalState() {
          const e = this.binding,
            t = this.buffer,
            n = this.valueSize,
            i = n * this._origIndex;
          e.getValue(t, i);
          for (let e = n, r = i; e !== r; ++e) t[e] = t[i + (e % n)];
          this._setIdentity(),
            (this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0);
        }
        restoreOriginalState() {
          const e = 3 * this.valueSize;
          this.binding.setValue(this.buffer, e);
        }
        _setAdditiveIdentityNumeric() {
          const e = this._addIndex * this.valueSize,
            t = e + this.valueSize;
          for (let n = e; n < t; n++) this.buffer[n] = 0;
        }
        _setAdditiveIdentityQuaternion() {
          this._setAdditiveIdentityNumeric(),
            (this.buffer[this._addIndex * this.valueSize + 3] = 1);
        }
        _setAdditiveIdentityOther() {
          const e = this._origIndex * this.valueSize,
            t = this._addIndex * this.valueSize;
          for (let n = 0; n < this.valueSize; n++)
            this.buffer[t + n] = this.buffer[e + n];
        }
        _select(e, t, n, i, r) {
          if (i >= 0.5) for (let i = 0; i !== r; ++i) e[t + i] = e[n + i];
        }
        _slerp(e, t, n, i) {
          qr.slerpFlat(e, t, e, t, e, n, i);
        }
        _slerpAdditive(e, t, n, i, r) {
          const s = this._workIndex * r;
          qr.multiplyQuaternionsFlat(e, s, e, t, e, n),
            qr.slerpFlat(e, t, e, t, e, s, i);
        }
        _lerp(e, t, n, i, r) {
          const s = 1 - i;
          for (let a = 0; a !== r; ++a) {
            const r = t + a;
            e[r] = e[r] * s + e[n + a] * i;
          }
        }
        _lerpAdditive(e, t, n, i, r) {
          for (let s = 0; s !== r; ++s) {
            const r = t + s;
            e[r] = e[r] + e[n + s] * i;
          }
        }
      }
      const qd = "\\[\\]\\.:\\/",
        Yd = new RegExp("[" + qd + "]", "g"),
        Kd = "[^" + qd + "]",
        Jd = "[^" + qd.replace("\\.", "") + "]",
        Zd = new RegExp(
          "^" +
            /((?:WC+[\/:])*)/.source.replace("WC", Kd) +
            /(WCOD+)?/.source.replace("WCOD", Jd) +
            /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Kd) +
            /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Kd) +
            "$"
        ),
        $d = ["material", "materials", "bones", "map"];
      class ep {
        constructor(e, t, n) {
          (this.path = t),
            (this.parsedPath = n || ep.parseTrackName(t)),
            (this.node = ep.findNode(e, this.parsedPath.nodeName)),
            (this.rootNode = e),
            (this.getValue = this._getValue_unbound),
            (this.setValue = this._setValue_unbound);
        }
        static create(e, t, n) {
          return e && e.isAnimationObjectGroup
            ? new ep.Composite(e, t, n)
            : new ep(e, t, n);
        }
        static sanitizeNodeName(e) {
          return e.replace(/\s/g, "_").replace(Yd, "");
        }
        static parseTrackName(e) {
          const t = Zd.exec(e);
          if (null === t)
            throw new Error("PropertyBinding: Cannot parse trackName: " + e);
          const n = {
              nodeName: t[2],
              objectName: t[3],
              objectIndex: t[4],
              propertyName: t[5],
              propertyIndex: t[6],
            },
            i = n.nodeName && n.nodeName.lastIndexOf(".");
          if (void 0 !== i && -1 !== i) {
            const e = n.nodeName.substring(i + 1);
            -1 !== $d.indexOf(e) &&
              ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = e));
          }
          if (null === n.propertyName || 0 === n.propertyName.length)
            throw new Error(
              "PropertyBinding: can not parse propertyName from trackName: " + e
            );
          return n;
        }
        static findNode(e, t) {
          if (
            void 0 === t ||
            "" === t ||
            "." === t ||
            -1 === t ||
            t === e.name ||
            t === e.uuid
          )
            return e;
          if (e.skeleton) {
            const n = e.skeleton.getBoneByName(t);
            if (void 0 !== n) return n;
          }
          if (e.children) {
            const n = function (e) {
                for (let i = 0; i < e.length; i++) {
                  const r = e[i];
                  if (r.name === t || r.uuid === t) return r;
                  const s = n(r.children);
                  if (s) return s;
                }
                return null;
              },
              i = n(e.children);
            if (i) return i;
          }
          return null;
        }
        _getValue_unavailable() {}
        _setValue_unavailable() {}
        _getValue_direct(e, t) {
          e[t] = this.targetObject[this.propertyName];
        }
        _getValue_array(e, t) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) e[t++] = n[i];
        }
        _getValue_arrayElement(e, t) {
          e[t] = this.resolvedProperty[this.propertyIndex];
        }
        _getValue_toArray(e, t) {
          this.resolvedProperty.toArray(e, t);
        }
        _setValue_direct(e, t) {
          this.targetObject[this.propertyName] = e[t];
        }
        _setValue_direct_setNeedsUpdate(e, t) {
          (this.targetObject[this.propertyName] = e[t]),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
          (this.targetObject[this.propertyName] = e[t]),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _setValue_array(e, t) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
        }
        _setValue_array_setNeedsUpdate(e, t) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
          this.targetObject.needsUpdate = !0;
        }
        _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
          this.targetObject.matrixWorldNeedsUpdate = !0;
        }
        _setValue_arrayElement(e, t) {
          this.resolvedProperty[this.propertyIndex] = e[t];
        }
        _setValue_arrayElement_setNeedsUpdate(e, t) {
          (this.resolvedProperty[this.propertyIndex] = e[t]),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
          (this.resolvedProperty[this.propertyIndex] = e[t]),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _setValue_fromArray(e, t) {
          this.resolvedProperty.fromArray(e, t);
        }
        _setValue_fromArray_setNeedsUpdate(e, t) {
          this.resolvedProperty.fromArray(e, t),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
          this.resolvedProperty.fromArray(e, t),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _getValue_unbound(e, t) {
          this.bind(), this.getValue(e, t);
        }
        _setValue_unbound(e, t) {
          this.bind(), this.setValue(e, t);
        }
        bind() {
          let e = this.node;
          const t = this.parsedPath,
            n = t.objectName,
            i = t.propertyName;
          let r = t.propertyIndex;
          if (
            (e ||
              ((e = ep.findNode(this.rootNode, t.nodeName)), (this.node = e)),
            (this.getValue = this._getValue_unavailable),
            (this.setValue = this._setValue_unavailable),
            !e)
          )
            return void console.warn(
              "THREE.PropertyBinding: No target node found for track: " +
                this.path +
                "."
            );
          if (n) {
            let i = t.objectIndex;
            switch (n) {
              case "materials":
                if (!e.material)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                    this
                  );
                if (!e.material.materials)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                    this
                  );
                e = e.material.materials;
                break;
              case "bones":
                if (!e.skeleton)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                    this
                  );
                e = e.skeleton.bones;
                for (let t = 0; t < e.length; t++)
                  if (e[t].name === i) {
                    i = t;
                    break;
                  }
                break;
              case "map":
                if ("map" in e) {
                  e = e.map;
                  break;
                }
                if (!e.material)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                    this
                  );
                if (!e.material.map)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
                    this
                  );
                e = e.material.map;
                break;
              default:
                if (void 0 === e[n])
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                    this
                  );
                e = e[n];
            }
            if (void 0 !== i) {
              if (void 0 === e[i])
                return void console.error(
                  "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                  this,
                  e
                );
              e = e[i];
            }
          }
          const s = e[i];
          if (void 0 === s) {
            const n = t.nodeName;
            return void console.error(
              "THREE.PropertyBinding: Trying to update property for track: " +
                n +
                "." +
                i +
                " but it wasn't found.",
              e
            );
          }
          let a = this.Versioning.None;
          (this.targetObject = e),
            void 0 !== e.needsUpdate
              ? (a = this.Versioning.NeedsUpdate)
              : void 0 !== e.matrixWorldNeedsUpdate &&
                (a = this.Versioning.MatrixWorldNeedsUpdate);
          let o = this.BindingType.Direct;
          if (void 0 !== r) {
            if ("morphTargetInfluences" === i) {
              if (!e.geometry)
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                  this
                );
              if (!e.geometry.morphAttributes)
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                  this
                );
              void 0 !== e.morphTargetDictionary[r] &&
                (r = e.morphTargetDictionary[r]);
            }
            (o = this.BindingType.ArrayElement),
              (this.resolvedProperty = s),
              (this.propertyIndex = r);
          } else
            void 0 !== s.fromArray && void 0 !== s.toArray
              ? ((o = this.BindingType.HasFromToArray),
                (this.resolvedProperty = s))
              : Array.isArray(s)
              ? ((o = this.BindingType.EntireArray),
                (this.resolvedProperty = s))
              : (this.propertyName = i);
          (this.getValue = this.GetterByBindingType[o]),
            (this.setValue = this.SetterByBindingTypeAndVersioning[o][a]);
        }
        unbind() {
          (this.node = null),
            (this.getValue = this._getValue_unbound),
            (this.setValue = this._setValue_unbound);
        }
      }
      (ep.Composite = class {
        constructor(e, t, n) {
          const i = n || ep.parseTrackName(t);
          (this._targetGroup = e), (this._bindings = e.subscribe_(t, i));
        }
        getValue(e, t) {
          this.bind();
          const n = this._targetGroup.nCachedObjects_,
            i = this._bindings[n];
          void 0 !== i && i.getValue(e, t);
        }
        setValue(e, t) {
          const n = this._bindings;
          for (
            let i = this._targetGroup.nCachedObjects_, r = n.length;
            i !== r;
            ++i
          )
            n[i].setValue(e, t);
        }
        bind() {
          const e = this._bindings;
          for (
            let t = this._targetGroup.nCachedObjects_, n = e.length;
            t !== n;
            ++t
          )
            e[t].bind();
        }
        unbind() {
          const e = this._bindings;
          for (
            let t = this._targetGroup.nCachedObjects_, n = e.length;
            t !== n;
            ++t
          )
            e[t].unbind();
        }
      }),
        (ep.prototype.BindingType = {
          Direct: 0,
          EntireArray: 1,
          ArrayElement: 2,
          HasFromToArray: 3,
        }),
        (ep.prototype.Versioning = {
          None: 0,
          NeedsUpdate: 1,
          MatrixWorldNeedsUpdate: 2,
        }),
        (ep.prototype.GetterByBindingType = [
          ep.prototype._getValue_direct,
          ep.prototype._getValue_array,
          ep.prototype._getValue_arrayElement,
          ep.prototype._getValue_toArray,
        ]),
        (ep.prototype.SetterByBindingTypeAndVersioning = [
          [
            ep.prototype._setValue_direct,
            ep.prototype._setValue_direct_setNeedsUpdate,
            ep.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
          ],
          [
            ep.prototype._setValue_array,
            ep.prototype._setValue_array_setNeedsUpdate,
            ep.prototype._setValue_array_setMatrixWorldNeedsUpdate,
          ],
          [
            ep.prototype._setValue_arrayElement,
            ep.prototype._setValue_arrayElement_setNeedsUpdate,
            ep.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
          ],
          [
            ep.prototype._setValue_fromArray,
            ep.prototype._setValue_fromArray_setNeedsUpdate,
            ep.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
          ],
        ]);
      class tp {
        constructor(e, t, n = null, i = t.blendMode) {
          (this._mixer = e),
            (this._clip = t),
            (this._localRoot = n),
            (this.blendMode = i);
          const r = t.tracks,
            s = r.length,
            a = new Array(s),
            o = { endingStart: ji, endingEnd: ji };
          for (let e = 0; e !== s; ++e) {
            const t = r[e].createInterpolant(null);
            (a[e] = t), (t.settings = o);
          }
          (this._interpolantSettings = o),
            (this._interpolants = a),
            (this._propertyBindings = new Array(s)),
            (this._cacheIndex = null),
            (this._byClipCacheIndex = null),
            (this._timeScaleInterpolant = null),
            (this._weightInterpolant = null),
            (this.loop = Gi),
            (this._loopCount = -1),
            (this._startTime = null),
            (this.time = 0),
            (this.timeScale = 1),
            (this._effectiveTimeScale = 1),
            (this.weight = 1),
            (this._effectiveWeight = 1),
            (this.repetitions = 1 / 0),
            (this.paused = !1),
            (this.enabled = !0),
            (this.clampWhenFinished = !1),
            (this.zeroSlopeAtStart = !0),
            (this.zeroSlopeAtEnd = !0);
        }
        play() {
          return this._mixer._activateAction(this), this;
        }
        stop() {
          return this._mixer._deactivateAction(this), this.reset();
        }
        reset() {
          return (
            (this.paused = !1),
            (this.enabled = !0),
            (this.time = 0),
            (this._loopCount = -1),
            (this._startTime = null),
            this.stopFading().stopWarping()
          );
        }
        isRunning() {
          return (
            this.enabled &&
            !this.paused &&
            0 !== this.timeScale &&
            null === this._startTime &&
            this._mixer._isActiveAction(this)
          );
        }
        isScheduled() {
          return this._mixer._isActiveAction(this);
        }
        startAt(e) {
          return (this._startTime = e), this;
        }
        setLoop(e, t) {
          return (this.loop = e), (this.repetitions = t), this;
        }
        setEffectiveWeight(e) {
          return (
            (this.weight = e),
            (this._effectiveWeight = this.enabled ? e : 0),
            this.stopFading()
          );
        }
        getEffectiveWeight() {
          return this._effectiveWeight;
        }
        fadeIn(e) {
          return this._scheduleFading(e, 0, 1);
        }
        fadeOut(e) {
          return this._scheduleFading(e, 1, 0);
        }
        crossFadeFrom(e, t, n) {
          if ((e.fadeOut(t), this.fadeIn(t), n)) {
            const n = this._clip.duration,
              i = e._clip.duration,
              r = i / n,
              s = n / i;
            e.warp(1, r, t), this.warp(s, 1, t);
          }
          return this;
        }
        crossFadeTo(e, t, n) {
          return e.crossFadeFrom(this, t, n);
        }
        stopFading() {
          const e = this._weightInterpolant;
          return (
            null !== e &&
              ((this._weightInterpolant = null),
              this._mixer._takeBackControlInterpolant(e)),
            this
          );
        }
        setEffectiveTimeScale(e) {
          return (
            (this.timeScale = e),
            (this._effectiveTimeScale = this.paused ? 0 : e),
            this.stopWarping()
          );
        }
        getEffectiveTimeScale() {
          return this._effectiveTimeScale;
        }
        setDuration(e) {
          return (this.timeScale = this._clip.duration / e), this.stopWarping();
        }
        syncWith(e) {
          return (
            (this.time = e.time),
            (this.timeScale = e.timeScale),
            this.stopWarping()
          );
        }
        halt(e) {
          return this.warp(this._effectiveTimeScale, 0, e);
        }
        warp(e, t, n) {
          const i = this._mixer,
            r = i.time,
            s = this.timeScale;
          let a = this._timeScaleInterpolant;
          null === a &&
            ((a = i._lendControlInterpolant()),
            (this._timeScaleInterpolant = a));
          const o = a.parameterPositions,
            c = a.sampleValues;
          return (
            (o[0] = r), (o[1] = r + n), (c[0] = e / s), (c[1] = t / s), this
          );
        }
        stopWarping() {
          const e = this._timeScaleInterpolant;
          return (
            null !== e &&
              ((this._timeScaleInterpolant = null),
              this._mixer._takeBackControlInterpolant(e)),
            this
          );
        }
        getMixer() {
          return this._mixer;
        }
        getClip() {
          return this._clip;
        }
        getRoot() {
          return this._localRoot || this._mixer._root;
        }
        _update(e, t, n, i) {
          if (!this.enabled) return void this._updateWeight(e);
          const r = this._startTime;
          if (null !== r) {
            const i = (e - r) * n;
            i < 0 || 0 === n
              ? (t = 0)
              : ((this._startTime = null), (t = n * i));
          }
          t *= this._updateTimeScale(e);
          const s = this._updateTime(t),
            a = this._updateWeight(e);
          if (a > 0) {
            const e = this._interpolants,
              t = this._propertyBindings;
            if (2501 === this.blendMode)
              for (let n = 0, i = e.length; n !== i; ++n)
                e[n].evaluate(s), t[n].accumulateAdditive(a);
            else
              for (let n = 0, r = e.length; n !== r; ++n)
                e[n].evaluate(s), t[n].accumulate(i, a);
          }
        }
        _updateWeight(e) {
          let t = 0;
          if (this.enabled) {
            t = this.weight;
            const n = this._weightInterpolant;
            if (null !== n) {
              const i = n.evaluate(e)[0];
              (t *= i),
                e > n.parameterPositions[1] &&
                  (this.stopFading(), 0 === i && (this.enabled = !1));
            }
          }
          return (this._effectiveWeight = t), t;
        }
        _updateTimeScale(e) {
          let t = 0;
          if (!this.paused) {
            t = this.timeScale;
            const n = this._timeScaleInterpolant;
            if (null !== n) {
              (t *= n.evaluate(e)[0]),
                e > n.parameterPositions[1] &&
                  (this.stopWarping(),
                  0 === t ? (this.paused = !0) : (this.timeScale = t));
            }
          }
          return (this._effectiveTimeScale = t), t;
        }
        _updateTime(e) {
          const t = this._clip.duration,
            n = this.loop;
          let i = this.time + e,
            r = this._loopCount;
          const s = 2202 === n;
          if (0 === e) return -1 === r || !s || 1 & ~r ? i : t - i;
          if (n === Qi) {
            -1 === r && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
            e: {
              if (i >= t) i = t;
              else {
                if (!(i < 0)) {
                  this.time = i;
                  break e;
                }
                i = 0;
              }
              this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                (this.time = i),
                this._mixer.dispatchEvent({
                  type: "finished",
                  action: this,
                  direction: e < 0 ? -1 : 1,
                });
            }
          } else {
            if (
              (-1 === r &&
                (e >= 0
                  ? ((r = 0), this._setEndings(!0, 0 === this.repetitions, s))
                  : this._setEndings(0 === this.repetitions, !0, s)),
              i >= t || i < 0)
            ) {
              const n = Math.floor(i / t);
              (i -= t * n), (r += Math.abs(n));
              const a = this.repetitions - r;
              if (a <= 0)
                this.clampWhenFinished
                  ? (this.paused = !0)
                  : (this.enabled = !1),
                  (i = e > 0 ? t : 0),
                  (this.time = i),
                  this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: e > 0 ? 1 : -1,
                  });
              else {
                if (1 === a) {
                  const t = e < 0;
                  this._setEndings(t, !t, s);
                } else this._setEndings(!1, !1, s);
                (this._loopCount = r),
                  (this.time = i),
                  this._mixer.dispatchEvent({
                    type: "loop",
                    action: this,
                    loopDelta: n,
                  });
              }
            } else this.time = i;
            if (s && !(1 & ~r)) return t - i;
          }
          return i;
        }
        _setEndings(e, t, n) {
          const i = this._interpolantSettings;
          n
            ? ((i.endingStart = Wi), (i.endingEnd = Wi))
            : ((i.endingStart = e ? (this.zeroSlopeAtStart ? Wi : ji) : Xi),
              (i.endingEnd = t ? (this.zeroSlopeAtEnd ? Wi : ji) : Xi));
        }
        _scheduleFading(e, t, n) {
          const i = this._mixer,
            r = i.time;
          let s = this._weightInterpolant;
          null === s &&
            ((s = i._lendControlInterpolant()), (this._weightInterpolant = s));
          const a = s.parameterPositions,
            o = s.sampleValues;
          return (a[0] = r), (o[0] = t), (a[1] = r + e), (o[1] = n), this;
        }
      }
      const np = new Float32Array(1);
      class ip extends cr {
        constructor(e) {
          super(),
            (this._root = e),
            this._initMemoryManager(),
            (this._accuIndex = 0),
            (this.time = 0),
            (this.timeScale = 1);
        }
        _bindAction(e, t) {
          const n = e._localRoot || this._root,
            i = e._clip.tracks,
            r = i.length,
            s = e._propertyBindings,
            a = e._interpolants,
            o = n.uuid,
            c = this._bindingsByRootAndName;
          let l = c[o];
          void 0 === l && ((l = {}), (c[o] = l));
          for (let e = 0; e !== r; ++e) {
            const r = i[e],
              c = r.name;
            let u = l[c];
            if (void 0 !== u) ++u.referenceCount, (s[e] = u);
            else {
              if (((u = s[e]), void 0 !== u)) {
                null === u._cacheIndex &&
                  (++u.referenceCount, this._addInactiveBinding(u, o, c));
                continue;
              }
              const i = t && t._propertyBindings[e].binding.parsedPath;
              (u = new Xd(
                ep.create(n, c, i),
                r.ValueTypeName,
                r.getValueSize()
              )),
                ++u.referenceCount,
                this._addInactiveBinding(u, o, c),
                (s[e] = u);
            }
            a[e].resultBuffer = u.buffer;
          }
        }
        _activateAction(e) {
          if (!this._isActiveAction(e)) {
            if (null === e._cacheIndex) {
              const t = (e._localRoot || this._root).uuid,
                n = e._clip.uuid,
                i = this._actionsByClip[n];
              this._bindAction(e, i && i.knownActions[0]),
                this._addInactiveAction(e, n, t);
            }
            const t = e._propertyBindings;
            for (let e = 0, n = t.length; e !== n; ++e) {
              const n = t[e];
              0 == n.useCount++ &&
                (this._lendBinding(n), n.saveOriginalState());
            }
            this._lendAction(e);
          }
        }
        _deactivateAction(e) {
          if (this._isActiveAction(e)) {
            const t = e._propertyBindings;
            for (let e = 0, n = t.length; e !== n; ++e) {
              const n = t[e];
              0 == --n.useCount &&
                (n.restoreOriginalState(), this._takeBackBinding(n));
            }
            this._takeBackAction(e);
          }
        }
        _initMemoryManager() {
          (this._actions = []),
            (this._nActiveActions = 0),
            (this._actionsByClip = {}),
            (this._bindings = []),
            (this._nActiveBindings = 0),
            (this._bindingsByRootAndName = {}),
            (this._controlInterpolants = []),
            (this._nActiveControlInterpolants = 0);
          const e = this;
          this.stats = {
            actions: {
              get total() {
                return e._actions.length;
              },
              get inUse() {
                return e._nActiveActions;
              },
            },
            bindings: {
              get total() {
                return e._bindings.length;
              },
              get inUse() {
                return e._nActiveBindings;
              },
            },
            controlInterpolants: {
              get total() {
                return e._controlInterpolants.length;
              },
              get inUse() {
                return e._nActiveControlInterpolants;
              },
            },
          };
        }
        _isActiveAction(e) {
          const t = e._cacheIndex;
          return null !== t && t < this._nActiveActions;
        }
        _addInactiveAction(e, t, n) {
          const i = this._actions,
            r = this._actionsByClip;
          let s = r[t];
          if (void 0 === s)
            (s = { knownActions: [e], actionByRoot: {} }),
              (e._byClipCacheIndex = 0),
              (r[t] = s);
          else {
            const t = s.knownActions;
            (e._byClipCacheIndex = t.length), t.push(e);
          }
          (e._cacheIndex = i.length), i.push(e), (s.actionByRoot[n] = e);
        }
        _removeInactiveAction(e) {
          const t = this._actions,
            n = t[t.length - 1],
            i = e._cacheIndex;
          (n._cacheIndex = i), (t[i] = n), t.pop(), (e._cacheIndex = null);
          const r = e._clip.uuid,
            s = this._actionsByClip,
            a = s[r],
            o = a.knownActions,
            c = o[o.length - 1],
            l = e._byClipCacheIndex;
          (c._byClipCacheIndex = l),
            (o[l] = c),
            o.pop(),
            (e._byClipCacheIndex = null);
          delete a.actionByRoot[(e._localRoot || this._root).uuid],
            0 === o.length && delete s[r],
            this._removeInactiveBindingsForAction(e);
        }
        _removeInactiveBindingsForAction(e) {
          const t = e._propertyBindings;
          for (let e = 0, n = t.length; e !== n; ++e) {
            const n = t[e];
            0 == --n.referenceCount && this._removeInactiveBinding(n);
          }
        }
        _lendAction(e) {
          const t = this._actions,
            n = e._cacheIndex,
            i = this._nActiveActions++,
            r = t[i];
          (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
        }
        _takeBackAction(e) {
          const t = this._actions,
            n = e._cacheIndex,
            i = --this._nActiveActions,
            r = t[i];
          (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
        }
        _addInactiveBinding(e, t, n) {
          const i = this._bindingsByRootAndName,
            r = this._bindings;
          let s = i[t];
          void 0 === s && ((s = {}), (i[t] = s)),
            (s[n] = e),
            (e._cacheIndex = r.length),
            r.push(e);
        }
        _removeInactiveBinding(e) {
          const t = this._bindings,
            n = e.binding,
            i = n.rootNode.uuid,
            r = n.path,
            s = this._bindingsByRootAndName,
            a = s[i],
            o = t[t.length - 1],
            c = e._cacheIndex;
          (o._cacheIndex = c),
            (t[c] = o),
            t.pop(),
            delete a[r],
            0 === Object.keys(a).length && delete s[i];
        }
        _lendBinding(e) {
          const t = this._bindings,
            n = e._cacheIndex,
            i = this._nActiveBindings++,
            r = t[i];
          (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
        }
        _takeBackBinding(e) {
          const t = this._bindings,
            n = e._cacheIndex,
            i = --this._nActiveBindings,
            r = t[i];
          (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
        }
        _lendControlInterpolant() {
          const e = this._controlInterpolants,
            t = this._nActiveControlInterpolants++;
          let n = e[t];
          return (
            void 0 === n &&
              ((n = new ad(new Float32Array(2), new Float32Array(2), 1, np)),
              (n.__cacheIndex = t),
              (e[t] = n)),
            n
          );
        }
        _takeBackControlInterpolant(e) {
          const t = this._controlInterpolants,
            n = e.__cacheIndex,
            i = --this._nActiveControlInterpolants,
            r = t[i];
          (e.__cacheIndex = i), (t[i] = e), (r.__cacheIndex = n), (t[n] = r);
        }
        clipAction(e, t, n) {
          const i = t || this._root,
            r = i.uuid;
          let s = "string" == typeof e ? gd.findByName(i, e) : e;
          const a = null !== s ? s.uuid : e,
            o = this._actionsByClip[a];
          let c = null;
          if (
            (void 0 === n && (n = null !== s ? s.blendMode : qi), void 0 !== o)
          ) {
            const e = o.actionByRoot[r];
            if (void 0 !== e && e.blendMode === n) return e;
            (c = o.knownActions[0]), null === s && (s = c._clip);
          }
          if (null === s) return null;
          const l = new tp(this, s, t, n);
          return this._bindAction(l, c), this._addInactiveAction(l, a, r), l;
        }
        existingAction(e, t) {
          const n = t || this._root,
            i = n.uuid,
            r = "string" == typeof e ? gd.findByName(n, e) : e,
            s = r ? r.uuid : e,
            a = this._actionsByClip[s];
          return (void 0 !== a && a.actionByRoot[i]) || null;
        }
        stopAllAction() {
          const e = this._actions;
          for (let t = this._nActiveActions - 1; t >= 0; --t) e[t].stop();
          return this;
        }
        update(e) {
          e *= this.timeScale;
          const t = this._actions,
            n = this._nActiveActions,
            i = (this.time += e),
            r = Math.sign(e),
            s = (this._accuIndex ^= 1);
          for (let a = 0; a !== n; ++a) {
            t[a]._update(i, e, r, s);
          }
          const a = this._bindings,
            o = this._nActiveBindings;
          for (let e = 0; e !== o; ++e) a[e].apply(s);
          return this;
        }
        setTime(e) {
          this.time = 0;
          for (let e = 0; e < this._actions.length; e++)
            this._actions[e].time = 0;
          return this.update(e);
        }
        getRoot() {
          return this._root;
        }
        uncacheClip(e) {
          const t = this._actions,
            n = e.uuid,
            i = this._actionsByClip,
            r = i[n];
          if (void 0 !== r) {
            const e = r.knownActions;
            for (let n = 0, i = e.length; n !== i; ++n) {
              const i = e[n];
              this._deactivateAction(i);
              const r = i._cacheIndex,
                s = t[t.length - 1];
              (i._cacheIndex = null),
                (i._byClipCacheIndex = null),
                (s._cacheIndex = r),
                (t[r] = s),
                t.pop(),
                this._removeInactiveBindingsForAction(i);
            }
            delete i[n];
          }
        }
        uncacheRoot(e) {
          const t = e.uuid,
            n = this._actionsByClip;
          for (const e in n) {
            const i = n[e].actionByRoot[t];
            void 0 !== i &&
              (this._deactivateAction(i), this._removeInactiveAction(i));
          }
          const i = this._bindingsByRootAndName[t];
          if (void 0 !== i)
            for (const e in i) {
              const t = i[e];
              t.restoreOriginalState(), this._removeInactiveBinding(t);
            }
        }
        uncacheAction(e, t) {
          const n = this.existingAction(e, t);
          null !== n &&
            (this._deactivateAction(n), this._removeInactiveAction(n));
        }
      }
      class rp {
        constructor(e) {
          this.value = e;
        }
        clone() {
          return new rp(
            void 0 === this.value.clone ? this.value : this.value.clone()
          );
        }
      }
      const sp = new Cs();
      class ap {
        constructor(e, t, n = 0, i = 1 / 0) {
          (this.ray = new ws(e, t)),
            (this.near = n),
            (this.far = i),
            (this.camera = null),
            (this.layers = new Fs()),
            (this.params = {
              Mesh: {},
              Line: { threshold: 1 },
              LOD: {},
              Points: { threshold: 1 },
              Sprite: {},
            });
        }
        set(e, t) {
          this.ray.set(e, t);
        }
        setFromCamera(e, t) {
          t.isPerspectiveCamera
            ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
              this.ray.direction
                .set(e.x, e.y, 0.5)
                .unproject(t)
                .sub(this.ray.origin)
                .normalize(),
              (this.camera = t))
            : t.isOrthographicCamera
            ? (this.ray.origin
                .set(e.x, e.y, (t.near + t.far) / (t.near - t.far))
                .unproject(t),
              this.ray.direction
                .set(0, 0, -1)
                .transformDirection(t.matrixWorld),
              (this.camera = t))
            : console.error(
                "THREE.Raycaster: Unsupported camera type: " + t.type
              );
        }
        setFromXRController(e) {
          return (
            sp.identity().extractRotation(e.matrixWorld),
            this.ray.origin.setFromMatrixPosition(e.matrixWorld),
            this.ray.direction.set(0, 0, -1).applyMatrix4(sp),
            this
          );
        }
        intersectObject(e, t = !0, n = []) {
          return cp(e, this, n, t), n.sort(op), n;
        }
        intersectObjects(e, t = !0, n = []) {
          for (let i = 0, r = e.length; i < r; i++) cp(e[i], this, n, t);
          return n.sort(op), n;
        }
      }
      function op(e, t) {
        return e.distance - t.distance;
      }
      function cp(e, t, n, i) {
        let r = !0;
        if (e.layers.test(t.layers)) {
          !1 === e.raycast(t, n) && (r = !1);
        }
        if (!0 === r && !0 === i) {
          const i = e.children;
          for (let e = 0, r = i.length; e < r; e++) cp(i[e], t, n, !0);
        }
      }
      const lp = new Yr(),
        up = new Yr();
      class hp {
        constructor(e = new Yr(), t = new Yr()) {
          (this.start = e), (this.end = t);
        }
        set(e, t) {
          return this.start.copy(e), this.end.copy(t), this;
        }
        copy(e) {
          return this.start.copy(e.start), this.end.copy(e.end), this;
        }
        getCenter(e) {
          return e.addVectors(this.start, this.end).multiplyScalar(0.5);
        }
        delta(e) {
          return e.subVectors(this.end, this.start);
        }
        distanceSq() {
          return this.start.distanceToSquared(this.end);
        }
        distance() {
          return this.start.distanceTo(this.end);
        }
        at(e, t) {
          return this.delta(t).multiplyScalar(e).add(this.start);
        }
        closestPointToPointParameter(e, t) {
          lp.subVectors(e, this.start), up.subVectors(this.end, this.start);
          const n = up.dot(up);
          let i = up.dot(lp) / n;
          return t && (i = fr(i, 0, 1)), i;
        }
        closestPointToPoint(e, t, n) {
          const i = this.closestPointToPointParameter(e, t);
          return this.delta(n).multiplyScalar(i).add(this.start);
        }
        applyMatrix4(e) {
          return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
        }
        equals(e) {
          return e.start.equals(this.start) && e.end.equals(this.end);
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      "undefined" != typeof __THREE_DEVTOOLS__ &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("register", { detail: { revision: rn } })
        ),
        "undefined" != typeof window &&
          (window.__THREE__
            ? console.warn(
                "WARNING: Multiple instances of Three.js being imported."
              )
            : (window.__THREE__ = rn));
      const dp = !1,
        pp = "imported_texture",
        fp =
          (Ue.Group,
          Ue.Water,
          Ue.Scene,
          Ue.Mesh,
          Fe.Box,
          Fe.Plane,
          Fe.Sphere,
          Fe.Cylinder,
          Fe.Cone,
          Fe.Torus,
          Ue.Camera,
          Oe.Perspective,
          Oe.Orthographic,
          Ue.Light,
          Ne.Ambient,
          Ne.Directional,
          Ne.Point,
          Ne.Spot,
          {
            [ke.Unlit]: ["opacity", "color", "reflectivity"],
            [ke.Lit]: [
              "opacity",
              "color",
              "emissive",
              "roughness",
              "metalness",
              "displacementScale",
              "emissiveIntensity",
            ],
            [ke.Physical]: [
              "opacity",
              "color",
              "emissive",
              "roughness",
              "metalness",
              "displacementScale",
              "emissiveIntensity",
              "attenuationDistance",
              "attenuationColor",
              "clearcoat",
              "clearcoatRoughness",
              "dispersion",
              "thickness",
              "transmission",
              "ior",
              "iridescence",
              "iridescenceIOR",
              "reflectivity",
              "specularIntensity",
              "specularColor",
              "sheen",
              "sheenColor",
              "sheenRoughness",
            ],
            [ke.Phong]: [
              "opacity",
              "color",
              "emissive",
              "reflectivity",
              "displacementScale",
              "bumpScale",
              "emissive",
              "refractionRatio",
              "shininess",
              "specular",
              "emissiveIntensity",
            ],
          }),
        Ap =
          (ke.Unlit,
          new Set(fp[ke.Unlit]),
          ke.Phong,
          new Set(fp[ke.Phong]),
          ke.Lit,
          new Set(fp[ke.Lit]),
          ke.Physical,
          new Set(fp[ke.Physical]),
          {
            MeshStandardMaterial: ke.Lit,
            MeshPhysicalMaterial: ke.Physical,
            MeshBasicMaterial: ke.Unlit,
            MeshPhongMaterial: ke.Phong,
          }),
        gp = 768,
        mp = 992;
      function vp() {
        return yr.generateUUID();
      }
      Ne.Ambient, Ne.Directional, Ne.Point, Ne.Spot;
      Qe.Front, Qe.Back, Qe.Double, ze.Clamp, ze.Repeat, ze.MirroredRepeat;
      ke.Lit, ke.Physical, ke.Unlit, ke.Phong;
      const yp = (e, t) => (e.startsWith(t) ? e.substring(t.length) : e),
        bp = (e, t) =>
          e.endsWith(t) ? e.substring(0, e.length - t.length) : e;
      function _p(e) {
        let t = (function (e, t) {
          let n = e,
            i = yp(n, t);
          for (; i !== n; ) (n = i), (i = yp(n, t));
          for (n = i, i = bp(n, t); i !== n; ) (n = i), (i = bp(n, t));
          return i;
        })(e, "/");
        return (
          t.startsWith("/") || (t = `/${t}`),
          t.endsWith("/") || (t = `${t}/`),
          t
        );
      }
      function xp(e) {
        try {
          const t = new URL(e);
          return t ? String(t) : `https://${e}`;
        } catch (t) {
          return `https://${e}`;
        }
      }
      const Ep = {
          [bt.Video]: [".mp4", ".mov", ".webm"],
          [bt.Font]: [".ttf", ".otf", ".woff"],
          [bt.Image]: [".jpg", ".jpeg", ".png", ".ico", ".webp", ".gif"],
          [bt.Vector]: [".svg"],
          [bt.Audio]: [".mp3", ".wav", ".webm"],
          [bt.Model3d]: [".gltf", ".fbx", ".obj", ".glb"],
          [bt.Hdri]: [".exr", ".hdr"],
        },
        wp = [...Ep[bt.Video], ...Ep[bt.Audio]];
      Object.entries(Ep)
        .reverse()
        .reduce((e, [t, n]) => (n.forEach((n) => (e[n] = t)), e), {});
      function Cp(e, t) {
        const n = Math.pow(10, t),
          i = Math.round(e * n) / n;
        return parseFloat(i.toFixed(Math.max(0, t)));
      }
      function Sp(e, t) {
        return Array.isArray(e) ? e : [e, ...t];
      }
      function Ip(e, ...t) {
        const n = Sp(e, t);
        if (0 === n.length)
          throw new Error("Cannot calculate the mean of an empty array");
        return (
          (function (e, ...t) {
            return Sp(e, t).reduce((e, t) => e + t, 0);
          })(n) / n.length
        );
      }
      function Mp(e, t, n) {
        const i = (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y);
        return 0 === i ? 0 : i > 0 ? 1 : 2;
      }
      function Tp(e, t) {
        const n = t.x - e.x,
          i = t.y - e.y;
        return Math.sqrt(n * n + i * i);
      }
      function Bp(e, t, n) {
        return (t.x - e.x) * (n.y - e.y) - (n.x - e.x) * (t.y - e.y);
      }
      function Rp(e, t) {
        return (
          0 !==
          (function (e, t) {
            let n = 0;
            for (let i = 0; i < t.length; i++) {
              const r = t[i],
                s = t[(i + 1) % t.length];
              r.y <= e.y
                ? s.y > e.y && Bp(r, s, e) > 0 && n++
                : s.y <= e.y && Bp(r, s, e) < 0 && n--;
            }
            return n;
          })(e, t)
        );
      }
      function Dp(e) {
        e.preventDefault ? e.preventDefault() : (e.returnValue = !1);
      }
      function Pp(e) {
        e.stopPropagation ? e.stopPropagation() : (e.cancelBubble = !0);
      }
      function Lp(e, t) {
        const n = t === Ye.ScrollTransform;
        return {
          type: e,
          delay: 0,
          duration: 300,
          stiffness: n ? 500 : 400,
          damping: n ? 60 : 30,
          mass: 1,
        };
      }
      function Up(e) {
        const t = {
          opacity: 1,
          scale: 1,
          rotateType: Ke.Rotate2D,
          rotateX: 0,
          rotateY: 0,
          rotateZ: 0,
          offsetX: 0,
          offsetY: 0,
        };
        switch (e) {
          case nt.Fade:
            return Object.assign(Object.assign({}, t), { opacity: 0 });
          case nt.Scale:
            return Object.assign(Object.assign({}, t), { scale: 0.5 });
          case nt.ScaleBottom:
            return Object.assign(Object.assign({}, t), {
              scale: 0.5,
              offsetY: 50,
            });
          case nt.FlipHorizontal:
            return Object.assign(Object.assign({}, t), {
              rotateType: Ke.Rotate3D,
              rotateY: -180,
            });
          case nt.FlipVertical:
            return Object.assign(Object.assign({}, t), {
              rotateType: Ke.Rotate3D,
              rotateX: -180,
            });
          case nt.SlideTop:
            return Object.assign(Object.assign({}, t), {
              opacity: 0,
              offsetY: -150,
            });
          case nt.SlideLeft:
            return Object.assign(Object.assign({}, t), {
              opacity: 0,
              offsetX: -150,
            });
          case nt.SlideRight:
            return Object.assign(Object.assign({}, t), {
              opacity: 0,
              offsetX: 150,
            });
          case nt.SlideBottom:
            return Object.assign(Object.assign({}, t), {
              opacity: 0,
              offsetY: 150,
            });
          default:
            return t;
        }
      }
      $e.ElementInView, nt.Scale;
      const Fp = it.Upload,
        Op = st.Waveform,
        Np = Te.Pointer,
        kp = "#252627";
      st.PlayPause,
        st.Waveform,
        st.Speaker,
        st.PlayPause,
        st.Waveform,
        st.Speaker;
      function Qp(e) {
        return e.playIconType || Op;
      }
      function Gp(e) {
        if (Qp(e) !== st.None) return e.iconPlayUrl;
      }
      function Hp(e) {
        if (Qp(e) !== st.None) return e.iconPauseUrl;
      }
      function zp(e, t) {
        const n = document.createElement("div");
        (n.style.width = "100%"), (n.style.height = "100%");
        return (
          Qp(t) === st.Custom
            ? ((n.style.backgroundImage = `url("${encodeURI(e)}")`),
              (n.style.backgroundSize = "contain"),
              (n.style.backgroundPosition = "center"),
              (n.style.backgroundRepeat = "no-repeat"))
            : ((n.style.backgroundColor = (function (e) {
                return e.playIconColor || kp;
              })(t)),
              (n.style.maskImage = `url("${encodeURI(e)}")`),
              (n.style.maskSize = "contain"),
              (n.style.maskPosition = "center"),
              (n.style.maskRepeat = "no-repeat")),
          n
        );
      }
      const Vp = {
        [at.Top]: at.Bottom,
        [at.Bottom]: at.Top,
        [at.Left]: at.Right,
        [at.Right]: at.Left,
      };
      function jp(e) {
        const { position: t, align: n } = e,
          i = {
            top: "auto",
            right: "auto",
            bottom: "auto",
            left: "auto",
            transform: "none",
          };
        i[Vp[t]] = "100%";
        const r = [at.Left, at.Right].includes(t);
        let s = r ? at.Top : at.Left;
        n === ot.End && (s = Vp[s]);
        const a = n === ot.Center ? "50%" : "0px";
        i[s] = a;
        const o = [];
        n === ot.Center && o.push(r ? "translateY(-50%)" : "translateX(-50%)");
        const c = (function (e) {
          const { position: t, offsetOrthogonal: n, offsetParallel: i } = e,
            r = [at.Top, at.Left].includes(t) ? -1 : 1,
            s = [at.Top, at.Bottom].includes(t),
            a = [n * r, i];
          s && a.reverse();
          return { x: a[0], y: a[1] };
        })(e);
        return (
          c.x && o.push(`translateX(${c.x}px)`),
          c.y && o.push(`translateY(${c.y}px)`),
          o.length > 0 && (i.transform = o.join(" ")),
          i
        );
      }
      const Wp = Math.pow,
        Xp = Math.sqrt,
        qp = Math.sin,
        Yp = Math.cos,
        Kp = Math.PI,
        Jp = 1.70158,
        Zp = 1.525 * Jp,
        $p = Jp + 1,
        ef = (2 * Kp) / 3,
        tf = (2 * Kp) / 4.5,
        nf = function (e) {
          const t = 7.5625,
            n = 2.75;
          return e < 1 / n
            ? t * e * e
            : e < 2 / n
            ? t * (e -= 1.5 / n) * e + 0.75
            : e < 2.5 / n
            ? t * (e -= 2.25 / n) * e + 0.9375
            : t * (e -= 2.625 / n) * e + 0.984375;
        },
        rf = {
          lenisDefault: (e) => Math.min(1, 1.001 - Math.pow(2, -10 * e)),
          linear: (e) => e,
          easeInQuad: function (e) {
            return e * e;
          },
          easeOutQuad: function (e) {
            return 1 - (1 - e) * (1 - e);
          },
          easeInOutQuad: function (e) {
            return e < 0.5 ? 2 * e * e : 1 - Wp(-2 * e + 2, 2) / 2;
          },
          easeInCubic: function (e) {
            return e * e * e;
          },
          easeOutCubic: function (e) {
            return 1 - Wp(1 - e, 3);
          },
          easeInOutCubic: function (e) {
            return e < 0.5 ? 4 * e * e * e : 1 - Wp(-2 * e + 2, 3) / 2;
          },
          easeInQuart: function (e) {
            return e * e * e * e;
          },
          easeOutQuart: function (e) {
            return 1 - Wp(1 - e, 4);
          },
          easeInOutQuart: function (e) {
            return e < 0.5 ? 8 * e * e * e * e : 1 - Wp(-2 * e + 2, 4) / 2;
          },
          easeInQuint: function (e) {
            return e * e * e * e * e;
          },
          easeOutQuint: function (e) {
            return 1 - Wp(1 - e, 5);
          },
          easeInOutQuint: function (e) {
            return e < 0.5 ? 16 * e * e * e * e * e : 1 - Wp(-2 * e + 2, 5) / 2;
          },
          easeInSine: function (e) {
            return 1 - Yp((e * Kp) / 2);
          },
          easeOutSine: function (e) {
            return qp((e * Kp) / 2);
          },
          easeInOutSine: function (e) {
            return -(Yp(Kp * e) - 1) / 2;
          },
          easeInExpo: function (e) {
            return 0 === e ? 0 : Wp(2, 10 * e - 10);
          },
          easeOutExpo: function (e) {
            return 1 === e ? 1 : 1 - Wp(2, -10 * e);
          },
          easeInOutExpo: function (e) {
            return 0 === e
              ? 0
              : 1 === e
              ? 1
              : e < 0.5
              ? Wp(2, 20 * e - 10) / 2
              : (2 - Wp(2, -20 * e + 10)) / 2;
          },
          easeInCirc: function (e) {
            return 1 - Xp(1 - Wp(e, 2));
          },
          easeOutCirc: function (e) {
            return Xp(1 - Wp(e - 1, 2));
          },
          easeInOutCirc: function (e) {
            return e < 0.5
              ? (1 - Xp(1 - Wp(2 * e, 2))) / 2
              : (Xp(1 - Wp(-2 * e + 2, 2)) + 1) / 2;
          },
          easeInBack: function (e) {
            return $p * e * e * e - Jp * e * e;
          },
          easeOutBack: function (e) {
            return 1 + $p * Wp(e - 1, 3) + Jp * Wp(e - 1, 2);
          },
          easeInOutBack: function (e) {
            return e < 0.5
              ? (Wp(2 * e, 2) * (7.189819 * e - Zp)) / 2
              : (Wp(2 * e - 2, 2) * ((Zp + 1) * (2 * e - 2) + Zp) + 2) / 2;
          },
          easeInElastic: function (e) {
            return 0 === e
              ? 0
              : 1 === e
              ? 1
              : -Wp(2, 10 * e - 10) * qp((10 * e - 10.75) * ef);
          },
          easeOutElastic: function (e) {
            return 0 === e
              ? 0
              : 1 === e
              ? 1
              : Wp(2, -10 * e) * qp((10 * e - 0.75) * ef) + 1;
          },
          easeInOutElastic: function (e) {
            return 0 === e
              ? 0
              : 1 === e
              ? 1
              : e < 0.5
              ? (-Wp(2, 20 * e - 10) * qp((20 * e - 11.125) * tf)) / 2
              : (Wp(2, -20 * e + 10) * qp((20 * e - 11.125) * tf)) / 2 + 1;
          },
          easeInBounce: function (e) {
            return 1 - nf(1 - e);
          },
          easeOutBounce: nf,
          easeInOutBounce: function (e) {
            return e < 0.5 ? (1 - nf(1 - 2 * e)) / 2 : (1 + nf(2 * e - 1)) / 2;
          },
        },
        sf = rf;
      sf.lenisDefault,
        sf.linear,
        sf.easeInSine,
        sf.easeOutSine,
        sf.easeInOutSine,
        sf.easeInQuad,
        sf.easeOutQuad,
        sf.easeInOutQuad,
        sf.easeInCubic,
        sf.easeOutCubic,
        sf.easeInOutCubic,
        sf.easeInQuart,
        sf.easeOutQuart,
        sf.easeInOutQuart,
        sf.easeInQuint,
        sf.easeOutQuint,
        sf.easeInOutQuint,
        sf.easeInExpo,
        sf.easeOutExpo,
        sf.easeInOutExpo,
        sf.easeInCirc,
        sf.easeOutCirc,
        sf.easeInOutCirc;
      var af, of;
      !(function (e) {
        (e.Position = "position"),
          (e.Spacing = "spacing"),
          (e.Size = "size"),
          (e.Layout = "layout"),
          (e.Style = "style"),
          (e.Font = "font"),
          (e.Image = "image"),
          (e.Video = "video"),
          (e.Link = "link"),
          (e.Scene = "scene"),
          (e.ScrollSection = "scrollSection"),
          (e.Effects = "effects"),
          (e.Audio = "audio"),
          (e.AudioStyle = "audioStyle"),
          (e.Interactions = "interactions"),
          (e.RelativeOverlay = "relativeOverlay"),
          (e.LoadingBar = "loadingBar"),
          (e.States = "states");
      })(af || (af = {})),
        (function (e) {
          (e.Wrapper = "wrapper"),
            (e.Text = "text"),
            (e.TextNode = "textnode"),
            (e.Block = "block"),
            (e.Rows = "rows"),
            (e.Columns = "columns"),
            (e.Grid = "grid"),
            (e.Image = "image"),
            (e.Video = "video"),
            (e.Background = "background"),
            (e.Scene = "scene"),
            (e.LinkBox = "link"),
            (e.Audio = "audio"),
            (e.RelativeOverlay = "relativeOverlay"),
            (e.LoadingBar = "loadingBar");
        })(of || (of = {}));
      const cf = "pwb-relative-overlay",
        lf = "pwb-loading-wrap",
        uf = "pwb-body-wrap",
        hf = "pwb-error-page-wrap";
      const df = function (e) {
          return we(e).toLowerCase();
        },
        pf =
          (af.States,
          af.Layout,
          af.Position,
          af.Size,
          af.Spacing,
          af.Style,
          af.Link,
          af.ScrollSection,
          af.Effects,
          af.Interactions,
          af.States,
          af.Layout,
          af.Position,
          af.Size,
          af.Spacing,
          af.Style,
          af.Link,
          af.ScrollSection,
          af.Effects,
          af.Interactions,
          of.Block,
          of.Block,
          af.States,
          af.Layout,
          af.Position,
          af.Size,
          af.Spacing,
          af.Style,
          af.Link,
          af.ScrollSection,
          af.Effects,
          af.Interactions,
          of.Block,
          of.Block,
          af.States,
          af.Layout,
          af.Position,
          af.Size,
          af.Spacing,
          af.Style,
          af.Link,
          af.ScrollSection,
          af.Effects,
          af.Interactions,
          of.Block,
          of.Block,
          of.Block,
          of.Block,
          {
            display: "block",
            width: "100%",
            "font-family": "Inter",
            "font-size": "16px",
            "font-weight": "400",
            "letter-spacing": "0px",
            "line-height": "24px",
            color: "#000",
          });
      af.States,
        af.Position,
        af.Size,
        af.Spacing,
        af.Style,
        af.Font,
        af.Link,
        af.ScrollSection,
        af.Effects,
        af.Interactions,
        of.TextNode;
      af.Spacing,
        af.Layout,
        af.Style,
        af.States,
        af.Scene,
        af.Position,
        af.Size,
        af.Style,
        af.Link,
        af.ScrollSection,
        af.Effects,
        af.Interactions,
        af.States,
        af.Layout,
        af.Position,
        af.Size,
        af.Spacing,
        af.Style,
        af.Link,
        af.ScrollSection,
        af.Effects,
        af.Interactions,
        of.Text,
        of.TextNode,
        af.States,
        af.Position,
        af.Size,
        af.Spacing,
        af.Style,
        af.ScrollSection,
        af.Effects,
        af.Audio,
        af.AudioStyle,
        af.RelativeOverlay,
        af.States,
        af.Layout,
        af.Size,
        af.Spacing,
        af.Style,
        af.Link,
        af.ScrollSection,
        af.Effects,
        af.Interactions;
      const ff = "pwb-loading-bar-text";
      af.States,
        af.LoadingBar,
        af.Position,
        af.Size,
        af.Spacing,
        af.Style,
        af.Font;
      of.Block,
        of.Wrapper,
        of.TextNode,
        of.Columns,
        of.Rows,
        of.Grid,
        of.Text,
        of.Image,
        of.Video,
        of.Background,
        of.Scene,
        of.LinkBox,
        of.Audio,
        of.RelativeOverlay,
        of.LoadingBar;
      const Af = window._pwInitialPath,
        gf = !!window._pwIsPreview,
        mf = !!window._pwShowStats,
        vf = window.self !== window.top;
      var yf = function (e, t, n, i) {
        return new (n || (n = Promise))(function (r, s) {
          function a(e) {
            try {
              c(i.next(e));
            } catch (e) {
              s(e);
            }
          }
          function o(e) {
            try {
              c(i.throw(e));
            } catch (e) {
              s(e);
            }
          }
          function c(e) {
            var t;
            e.done
              ? r(e.value)
              : ((t = e.value),
                t instanceof n
                  ? t
                  : new n(function (e) {
                      e(t);
                    })).then(a, o);
          }
          c((i = i.apply(e, t || [])).next());
        });
      };
      function bf(e) {
        return yf(this, void 0, void 0, function* () {
          if (!window._pwLoadFileFromCache)
            throw new Error("Load file from cache function missing.");
          return yield window._pwLoadFileFromCache(e);
        });
      }
      function _f(e, t) {
        window._pwSetFileCache && window._pwSetFileCache(e, t);
      }
      var xf = function (e, t, n, i) {
        return new (n || (n = Promise))(function (r, s) {
          function a(e) {
            try {
              c(i.next(e));
            } catch (e) {
              s(e);
            }
          }
          function o(e) {
            try {
              c(i.throw(e));
            } catch (e) {
              s(e);
            }
          }
          function c(e) {
            var t;
            e.done
              ? r(e.value)
              : ((t = e.value),
                t instanceof n
                  ? t
                  : new n(function (e) {
                      e(t);
                    })).then(a, o);
          }
          c((i = i.apply(e, t || [])).next());
        });
      };
      const Ef = (e, t, n = "/") =>
          xf(void 0, void 0, void 0, function* () {
            const i = `${_p(n)}${e}`,
              r = yield bf(i);
            if (!r) throw new Error(`Failed to fetch "${i}".`);
            const s = yield fetch(r),
              a = s.headers.get("content-type") || "";
            if (!a.includes(t))
              throw new Error(
                `Unexpected content type "${a}" for file "${i}".`
              );
            return s;
          }),
        wf = () =>
          xf(void 0, void 0, void 0, function* () {
            const e = yield Ef(Be.SceneState, "application/json");
            return yield e.json();
          }),
        Cf = (e) =>
          xf(void 0, void 0, void 0, function* () {
            const t = yield Ef(Be.UIState, "application/json", e);
            return yield t.json();
          }),
        Sf = (e) =>
          xf(void 0, void 0, void 0, function* () {
            const t = yield Ef(Be.Index, "text/html", e);
            return yield t.text();
          }),
        If = (e) =>
          xf(void 0, void 0, void 0, function* () {
            const t = yield Ef(Be.Styles, "text/css", e);
            return yield t.text();
          }),
        Mf = () =>
          xf(void 0, void 0, void 0, function* () {
            const e = yield Ef(Be.ErrorPage, "text/html");
            return yield e.text();
          }),
        Tf = () =>
          xf(void 0, void 0, void 0, function* () {
            const e = yield Ef(Be.ErrorPageStyles, "text/css");
            return yield e.text();
          });
      const Bf = function (e, t) {
        return function (n) {
          return e(t(n));
        };
      };
      const Rf = Bf(Object.getPrototypeOf, Object);
      var Df = Function.prototype,
        Pf = Object.prototype,
        Lf = Df.toString,
        Uf = Pf.hasOwnProperty,
        Ff = Lf.call(Object);
      const Of = function (e) {
        if (!A(e) || "[object Object]" != f(e)) return !1;
        var t = Rf(e);
        if (null === t) return !0;
        var n = Uf.call(t, "constructor") && t.constructor;
        return "function" == typeof n && n instanceof n && Lf.call(n) == Ff;
      };
      const Nf = function (e) {
          var t = null == e ? 0 : e.length;
          return t ? e[t - 1] : void 0;
        },
        kf = new WeakMap(),
        Qf = new WeakMap(),
        Gf = Symbol("pointerMeta"),
        Hf = {
          get(e, t) {
            if (t === Gf) return kf.get(e);
            let n = Qf.get(e);
            n || ((n = new Map()), Qf.set(e, n));
            const i = n.get(t);
            if (void 0 !== i) return i;
            const r = kf.get(e),
              s = jf({ root: r.root, path: [...r.path, t] });
            return n.set(t, s), s;
          },
        },
        zf = (e) => e[Gf],
        Vf = (e) => {
          const { root: t, path: n } = zf(e);
          return { root: t, path: n };
        };
      function jf(e) {
        var t;
        const n = {
            root: e.root,
            path: null !== (t = e.path) && void 0 !== t ? t : [],
          },
          i = {};
        return kf.set(i, n), new Proxy(i, Hf);
      }
      const Wf = jf,
        Xf = (e) => e && !!zf(e);
      const qf = (e, t, n) => {
        if (0 === t.length) return n(e);
        if (Array.isArray(e)) {
          let [i, ...r] = t;
          (i = parseInt(String(i), 10)), isNaN(i) && (i = 0);
          const s = e[i],
            a = qf(s, r, n);
          if (s === a) return e;
          const o = [...e];
          return o.splice(i, 1, a), o;
        }
        if ("object" == typeof e && null !== e) {
          const [i, ...r] = t,
            s = e[i],
            a = qf(s, r, n);
          if (s === a) return e;
          return Object.assign(Object.assign({}, e), { [i]: a });
        }
        {
          const [e, ...i] = t;
          return { [e]: qf(void 0, i, n) };
        }
      };
      class Yf {
        constructor() {
          this._head = void 0;
        }
        peek() {
          return this._head && this._head.data;
        }
        pop() {
          const e = this._head;
          if (e) return (this._head = e.next), e.data;
        }
        push(e) {
          const t = { next: this._head, data: e };
          this._head = t;
        }
      }
      function Kf() {
        const e = new Yf(),
          t = () => {};
        return {
          type: "Dataverse_discoveryMechanism",
          startIgnoringDependencies: () => {
            e.push(t);
          },
          stopIgnoringDependencies: () => {
            e.peek() !== t || e.pop();
          },
          reportResolutionStart: (n) => {
            const i = e.peek();
            i && i(n), e.push(t);
          },
          reportResolutionEnd: (t) => {
            e.pop();
          },
          pushCollector: (t) => {
            e.push(t);
          },
          popCollector: (t) => {
            if (e.peek() !== t)
              throw new Error("Popped collector is not on top of the stack");
            e.pop();
          },
        };
      }
      const {
          startIgnoringDependencies: Jf,
          stopIgnoringDependencies: Zf,
          reportResolutionEnd: $f,
          reportResolutionStart: eA,
          pushCollector: tA,
          popCollector: nA,
        } = (function () {
          const e = "__dataverse_discoveryMechanism_sharedStack",
            t =
              "undefined" != typeof window ? window : void 0 !== n.g ? n.g : {};
          if (t) {
            const n = t[e];
            if (
              n &&
              "object" == typeof n &&
              "Dataverse_discoveryMechanism" === n.type
            )
              return n;
            {
              const n = Kf();
              return (t[e] = n), n;
            }
          }
          return Kf();
        })(),
        iA = () => {};
      class rA {
        constructor(e, t) {
          (this._fn = e),
            (this._prismInstance = t),
            (this._didMarkDependentsAsStale = !1),
            (this._isFresh = !1),
            (this._cacheOfDendencyValues = new Map()),
            (this._dependents = new Set()),
            (this._dependencies = new Set()),
            (this._possiblyStaleDeps = new Set()),
            (this._scope = new oA(this)),
            (this._lastValue = void 0),
            (this._forciblySetToStale = !1),
            (this._reactToDependencyGoingStale = (e) => {
              this._possiblyStaleDeps.add(e), this._markAsStale();
            });
          for (const e of this._dependencies)
            e._addDependent(this._reactToDependencyGoingStale);
          Jf(), this.getValue(), Zf();
        }
        get hasDependents() {
          return this._dependents.size > 0;
        }
        removeDependent(e) {
          this._dependents.delete(e);
        }
        addDependent(e) {
          this._dependents.add(e);
        }
        destroy() {
          for (const e of this._dependencies)
            e._removeDependent(this._reactToDependencyGoingStale);
          cA(this._scope);
        }
        getValue() {
          if (!this._isFresh) {
            const e = this._recalculate();
            (this._lastValue = e),
              (this._isFresh = !0),
              (this._didMarkDependentsAsStale = !1),
              (this._forciblySetToStale = !1);
          }
          return this._lastValue;
        }
        _recalculate() {
          let e;
          if (!this._forciblySetToStale && this._possiblyStaleDeps.size > 0) {
            let e = !1;
            Jf();
            for (const t of this._possiblyStaleDeps)
              if (this._cacheOfDendencyValues.get(t) !== t.getValue()) {
                e = !0;
                break;
              }
            if ((Zf(), this._possiblyStaleDeps.clear(), !e))
              return this._lastValue;
          }
          const t = new Set();
          this._cacheOfDendencyValues.clear();
          const n = (e) => {
            t.add(e), this._addDependency(e);
          };
          tA(n), uA.push(this._scope);
          try {
            e = this._fn();
          } catch (e) {
            console.error(e);
          } finally {
            uA.pop() !== this._scope &&
              console.warn("The Prism hook stack has slipped. This is a bug.");
          }
          nA(n);
          for (const e of this._dependencies)
            t.has(e) || this._removeDependency(e);
          (this._dependencies = t), Jf();
          for (const e of t) this._cacheOfDendencyValues.set(e, e.getValue());
          return Zf(), e;
        }
        forceStale() {
          (this._forciblySetToStale = !0), this._markAsStale();
        }
        _markAsStale() {
          if (!this._didMarkDependentsAsStale) {
            (this._didMarkDependentsAsStale = !0), (this._isFresh = !1);
            for (const e of this._dependents) e(this._prismInstance);
          }
        }
        _addDependency(e) {
          this._dependencies.has(e) ||
            (this._dependencies.add(e),
            e._addDependent(this._reactToDependencyGoingStale));
        }
        _removeDependency(e) {
          this._dependencies.has(e) &&
            (this._dependencies.delete(e),
            e._removeDependent(this._reactToDependencyGoingStale));
        }
      }
      const sA = {};
      class aA {
        constructor(e) {
          (this._fn = e),
            (this.isPrism = !0),
            (this._state = { hot: !1, handle: void 0 });
        }
        get isHot() {
          return this._state.hot;
        }
        onChange(e, t, n = !1) {
          const i = () => {
            e.onThisOrNextTick(s);
          };
          let r = sA;
          const s = () => {
            const e = this.getValue();
            e !== r && ((r = e), t(e));
          };
          this._addDependent(i), n && ((r = this.getValue()), t(r));
          return () => {
            this._removeDependent(i), e.offThisOrNextTick(s), e.offNextTick(s);
          };
        }
        onStale(e) {
          const t = () => e();
          return (
            this._addDependent(t),
            () => {
              this._removeDependent(t);
            }
          );
        }
        keepHot() {
          return this.onStale(() => {});
        }
        _addDependent(e) {
          this._state.hot || this._goHot(), this._state.handle.addDependent(e);
        }
        _goHot() {
          const e = new rA(this._fn, this);
          this._state = { hot: !0, handle: e };
        }
        _removeDependent(e) {
          const t = this._state;
          if (!t.hot) return;
          const n = t.handle;
          n.removeDependent(e),
            n.hasDependents ||
              ((this._state = { hot: !1, handle: void 0 }), n.destroy());
        }
        getValue() {
          eA(this);
          const e = this._state;
          let t;
          return (
            (t = e.hot
              ? e.handle.getValue()
              : (function (e) {
                  const t = new fA();
                  let n;
                  uA.push(t);
                  try {
                    n = e();
                  } catch (e) {
                    console.error(e);
                  } finally {
                    uA.pop() !== t &&
                      console.warn(
                        "The Prism hook stack has slipped. This is a bug."
                      );
                  }
                  return n;
                })(this._fn)),
            $f(this),
            t
          );
        }
      }
      class oA {
        constructor(e) {
          (this._hotHandle = e),
            (this._refs = new Map()),
            (this.isPrismScope = !0),
            (this.subs = {}),
            (this.effects = new Map()),
            (this.memos = new Map());
        }
        ref(e, t) {
          const n = this._refs.get(e);
          if (void 0 !== n) return n;
          {
            const n = { current: t };
            return this._refs.set(e, n), n;
          }
        }
        effect(e, t, n) {
          let i = this.effects.get(e);
          void 0 === i &&
            ((i = { cleanup: iA, deps: void 0 }), this.effects.set(e, i)),
            hA(i.deps, n) &&
              (i.cleanup(),
              Jf(),
              (i.cleanup = lA(t, iA).value),
              Zf(),
              (i.deps = n));
        }
        memo(e, t, n) {
          let i = this.memos.get(e);
          return (
            void 0 === i &&
              ((i = { cachedValue: null, deps: void 0 }), this.memos.set(e, i)),
            hA(i.deps, n) &&
              (Jf(), (i.cachedValue = lA(t, void 0).value), Zf(), (i.deps = n)),
            i.cachedValue
          );
        }
        state(e, t) {
          const { value: n, setValue: i } = this.memo(
            "state/" + e,
            () => {
              const e = { current: t };
              return {
                value: e,
                setValue: (t) => {
                  (e.current = t), this._hotHandle.forceStale();
                },
              };
            },
            []
          );
          return [n.current, i];
        }
        sub(e) {
          return (
            this.subs[e] || (this.subs[e] = new oA(this._hotHandle)),
            this.subs[e]
          );
        }
        cleanupEffects() {
          for (const e of this.effects.values()) lA(e.cleanup, void 0);
          this.effects.clear();
        }
        source(e, t) {
          return (
            this.effect(
              "$$source/blah",
              () =>
                e(() => {
                  this._hotHandle.forceStale();
                }),
              [e]
            ),
            t()
          );
        }
      }
      function cA(e) {
        for (const t of Object.values(e.subs)) cA(t);
        e.cleanupEffects();
      }
      function lA(e, t) {
        try {
          return { value: e(), ok: !0 };
        } catch (e) {
          return (
            setTimeout(function () {
              throw e;
            }),
            { value: t, ok: !1 }
          );
        }
      }
      const uA = new Yf();
      function hA(e, t) {
        if (void 0 === e || void 0 === t) return !0;
        const n = e.length;
        if (n !== t.length) return !0;
        for (let i = 0; i < n; i++) if (e[i] !== t[i]) return !0;
        return !1;
      }
      function dA(e, t, n) {
        const i = uA.peek();
        if (!i)
          throw new Error("prism.memo() is called outside of a prism() call.");
        return i.memo(e, t, n);
      }
      const pA = (e) => new aA(e);
      class fA {
        effect(e, t, n) {
          console.warn("prism.effect() does not run in cold prisms");
        }
        memo(e, t, n) {
          return t();
        }
        state(e, t) {
          return [t, () => {}];
        }
        ref(e, t) {
          return { current: t };
        }
        sub(e) {
          return new fA();
        }
        source(e, t) {
          return t();
        }
      }
      (pA.ref = function (e, t) {
        const n = uA.peek();
        if (!n)
          throw new Error("prism.ref() is called outside of a prism() call.");
        return n.ref(e, t);
      }),
        (pA.effect = function (e, t, n) {
          const i = uA.peek();
          if (!i)
            throw new Error(
              "prism.effect() is called outside of a prism() call."
            );
          return i.effect(e, t, n);
        }),
        (pA.memo = dA),
        (pA.ensurePrism = function () {
          if (!uA.peek())
            throw new Error(
              "The parent function is called outside of a prism() call."
            );
        }),
        (pA.state = function (e, t) {
          const n = uA.peek();
          if (!n)
            throw new Error(
              "prism.state() is called outside of a prism() call."
            );
          return n.state(e, t);
        }),
        (pA.scope = function (e, t) {
          const n = uA.peek();
          if (!n)
            throw new Error(
              "prism.scope() is called outside of a prism() call."
            );
          const i = n.sub(e);
          uA.push(i);
          const r = lA(t, void 0).value;
          return uA.pop(), r;
        }),
        (pA.sub = function (e, t, n) {
          return dA(e, () => pA(t), n).getValue();
        }),
        (pA.inPrism = function () {
          return !!uA.peek();
        }),
        (pA.source = function (e, t) {
          const n = uA.peek();
          if (!n)
            throw new Error(
              "prism.source() is called outside of a prism() call."
            );
          return n.source(e, t);
        });
      const AA = pA;
      var gA;
      !(function (e) {
        (e[(e.Dict = 0)] = "Dict"),
          (e[(e.Array = 1)] = "Array"),
          (e[(e.Other = 2)] = "Other");
      })(gA || (gA = {}));
      const mA = (e) =>
          Array.isArray(e) ? gA.Array : Of(e) ? gA.Dict : gA.Other,
        vA = (e, t, n = mA(e)) =>
          (n === gA.Dict && "string" == typeof t) || (n === gA.Array && yA(t))
            ? e[t]
            : void 0,
        yA = (e) => {
          const t = "number" == typeof e ? e : parseInt(e, 10);
          return !isNaN(t) && t >= 0 && t < 1 / 0 && (0 | t) === t;
        };
      class bA {
        constructor(e, t) {
          (this._parent = e),
            (this._path = t),
            (this.children = new Map()),
            (this.identityChangeListeners = new Set());
        }
        addIdentityChangeListener(e) {
          this.identityChangeListeners.add(e);
        }
        removeIdentityChangeListener(e) {
          this.identityChangeListeners.delete(e), this._checkForGC();
        }
        removeChild(e) {
          this.children.delete(e), this._checkForGC();
        }
        getChild(e) {
          return this.children.get(e);
        }
        getOrCreateChild(e) {
          let t = this.children.get(e);
          return (
            t ||
              ((t = t = new bA(this, this._path.concat([e]))),
              this.children.set(e, t)),
            t
          );
        }
        _checkForGC() {
          this.identityChangeListeners.size > 0 ||
            this.children.size > 0 ||
            (this._parent && this._parent.removeChild(Nf(this._path)));
        }
      }
      class _A {
        constructor(e) {
          (this.$$isPointerToPrismProvider = !0),
            (this.pointer = Wf({ root: this, path: [] })),
            (this.prism = this.pointerToPrism(this.pointer)),
            (this.onChangeByPointer = (e, t) => {
              const n = Xf(e) ? e : e(this.pointer),
                { path: i } = Vf(n),
                r = this._getOrCreateScopeForPath(i);
              r.identityChangeListeners.add(t);
              return () => {
                r.identityChangeListeners.delete(t);
              };
            }),
            (this._currentState = e),
            (this._rootScope = new bA(void 0, []));
        }
        set(e) {
          const t = this._currentState;
          (this._currentState = e), this._checkUpdates(this._rootScope, t, e);
        }
        get() {
          return this._currentState;
        }
        getByPointer(e) {
          const t = Xf(e) ? e : e(this.pointer),
            n = Vf(t).path;
          return this._getIn(n);
        }
        _getIn(e) {
          return 0 === e.length ? this.get() : Me(this.get(), e);
        }
        reduce(e) {
          this.set(e(this.get()));
        }
        reduceByPointer(e, t) {
          const n = Xf(e) ? e : e(this.pointer),
            i = Vf(n).path,
            r = (function (e, t, n) {
              return 0 === t.length ? n(e) : qf(e, t, n);
            })(this.get(), i, t);
          this.set(r);
        }
        setByPointer(e, t) {
          this.reduceByPointer(e, () => t);
        }
        _checkUpdates(e, t, n) {
          if (t === n) return;
          for (const t of e.identityChangeListeners) t(n);
          if (0 === e.children.size) return;
          const i = mA(t),
            r = mA(n);
          if (i !== gA.Other || i !== r)
            for (const [s, a] of e.children) {
              const e = vA(t, s, i),
                o = vA(n, s, r);
              this._checkUpdates(a, e, o);
            }
        }
        _getOrCreateScopeForPath(e) {
          let t = this._rootScope;
          for (const n of e) t = t.getOrCreateChild(n);
          return t;
        }
        onChange(e) {
          return this.onChangeByPointer(this.pointer, e);
        }
        pointerToPrism(e) {
          const { path: t } = Vf(e),
            n = (t) => this.onChangeByPointer(e, t),
            i = () => this._getIn(t);
          return AA(() => AA.source(n, i));
        }
      }
      function xA(e) {
        return !(!e || !e.isPrism || !0 !== e.isPrism);
      }
      const EA = new WeakMap();
      const wA = (e) => {
          const t = zf(e);
          let n = EA.get(t);
          if (!n) {
            const i = t.root;
            if (
              !(function (e) {
                return (
                  "object" == typeof e &&
                  null !== e &&
                  !0 === e.$$isPointerToPrismProvider
                );
              })(i)
            )
              throw new Error(
                "Cannot run pointerToPrism() on a pointer whose root is not an PointerToPrismProvider"
              );
            (n = i.pointerToPrism(e)), EA.set(t, n);
          }
          return n;
        },
        CA = (e) => (Xf(e) ? wA(e).getValue() : xA(e) ? e.getValue() : e);
      class SA {
        get dormant() {
          return this._dormant;
        }
        constructor(e) {
          (this._conf = e),
            (this._ticking = !1),
            (this._dormant = !0),
            (this._numberOfDormantTicks = 0),
            (this.__ticks = 0),
            (this._scheduledForThisOrNextTick = new Set()),
            (this._scheduledForNextTick = new Set()),
            (this._timeAtCurrentTick = 0);
        }
        onThisOrNextTick(e) {
          this._scheduledForThisOrNextTick.add(e),
            this._dormant && this._goActive();
        }
        onNextTick(e) {
          this._scheduledForNextTick.add(e), this._dormant && this._goActive();
        }
        offThisOrNextTick(e) {
          this._scheduledForThisOrNextTick.delete(e);
        }
        offNextTick(e) {
          this._scheduledForNextTick.delete(e);
        }
        get time() {
          return this._ticking ? this._timeAtCurrentTick : performance.now();
        }
        _goActive() {
          var e, t;
          this._dormant &&
            ((this._dormant = !1),
            null ===
              (t =
                null === (e = this._conf) || void 0 === e
                  ? void 0
                  : e.onActive) ||
              void 0 === t ||
              t.call(e));
        }
        _goDormant() {
          var e, t;
          this._dormant ||
            ((this._dormant = !0),
            (this._numberOfDormantTicks = 0),
            null ===
              (t =
                null === (e = this._conf) || void 0 === e
                  ? void 0
                  : e.onDormant) ||
              void 0 === t ||
              t.call(e));
        }
        tick(e = performance.now()) {
          if (
            (this.__ticks++,
            !this._dormant &&
              0 === this._scheduledForNextTick.size &&
              0 === this._scheduledForThisOrNextTick.size &&
              (this._numberOfDormantTicks++, this._numberOfDormantTicks >= 180))
          )
            this._goDormant();
          else {
            (this._ticking = !0), (this._timeAtCurrentTick = e);
            for (const e of this._scheduledForNextTick)
              this._scheduledForThisOrNextTick.add(e);
            this._scheduledForNextTick.clear(),
              this._tick(0),
              (this._ticking = !1);
          }
        }
        _tick(e) {
          const t = this.time;
          if (
            (e > 10 && console.warn("_tick() recursing for 10 times"), e > 100)
          )
            throw new Error("Maximum recursion limit for _tick()");
          const n = this._scheduledForThisOrNextTick;
          this._scheduledForThisOrNextTick = new Set();
          for (const e of n) e(t);
          if (this._scheduledForThisOrNextTick.size > 0)
            return this._tick(e + 1);
        }
      }
      class IA {
        constructor(e) {
          (this.$$isPointerToPrismProvider = !0),
            (this._currentPointerBox = new _A(e)),
            (this.pointer = Wf({ root: this, path: [] }));
        }
        setPointer(e) {
          this._currentPointerBox.set(e);
        }
        pointerToPrism(e) {
          const { path: t } = zf(e);
          return AA(() => {
            const e = this._currentPointerBox.prism.getValue(),
              n = t.reduce((e, t) => e[t], e);
            return CA(n);
          });
        }
      }
      const MA = new (class {
          constructor() {
            this.atom = new _A({ projects: {} });
          }
          add(e, t) {
            this.atom.setByPointer((t) => t.projects[e], t);
          }
          get(e) {
            return this.atom.get().projects[e];
          }
          has(e) {
            return !!this.get(e);
          }
        })(),
        TA = MA,
        BA = new WeakMap();
      function RA(e) {
        return BA.get(e);
      }
      function DA(e, t) {
        BA.set(e, t);
      }
      const PA = [];
      function LA(e, t) {
        return 0 === t.length ? e : Me(e, t);
      }
      class UA {
        constructor() {
          this._values = {};
        }
        get(e, t) {
          if (this.has(e)) return this._values[e];
          {
            const n = t();
            return (this._values[e] = n), n;
          }
        }
        has(e) {
          return this._values.hasOwnProperty(e);
        }
      }
      const FA = (function () {
        try {
          var e = F(Object, "defineProperty");
          return e({}, "", {}), e;
        } catch (e) {}
      })();
      const OA = function (e, t, n) {
        "__proto__" == t && FA
          ? FA(e, t, {
              configurable: !0,
              enumerable: !0,
              value: n,
              writable: !0,
            })
          : (e[t] = n);
      };
      var NA = Object.prototype.hasOwnProperty;
      const kA = function (e, t, n) {
        var i = e[t];
        (NA.call(e, t) && q(i, n) && (void 0 !== n || t in e)) || OA(e, t, n);
      };
      var QA = /^(?:0|[1-9]\d*)$/;
      const GA = function (e, t) {
        var n = typeof e;
        return (
          !!(t = null == t ? 9007199254740991 : t) &&
          ("number" == n || ("symbol" != n && QA.test(e))) &&
          e > -1 &&
          e % 1 == 0 &&
          e < t
        );
      };
      const HA = function (e, t, n, i) {
        if (!b(e)) return e;
        for (
          var r = -1, s = (t = Ce(t, e)).length, a = s - 1, o = e;
          null != o && ++r < s;

        ) {
          var c = Se(t[r]),
            l = n;
          if ("__proto__" === c || "constructor" === c || "prototype" === c)
            return e;
          if (r != a) {
            var u = o[c];
            void 0 === (l = i ? i(u, c, o) : void 0) &&
              (l = b(u) ? u : GA(t[r + 1]) ? [] : {});
          }
          kA(o, c, l), (o = o[c]);
        }
        return e;
      };
      const zA = function (e, t, n) {
          return null == e ? e : HA(e, t, n);
        },
        VA = new WeakMap();
      function jA(e) {
        if (VA.has(e)) return VA.get(e);
        const t =
          "compound" === e.type
            ? (function (e) {
                const t = {};
                for (const [n, i] of Object.entries(e.props)) t[n] = jA(i);
                return t;
              })(e)
            : "enum" === e.type
            ? (function (e) {
                const t = { $case: e.defaultCase };
                for (const [n, i] of Object.entries(e.cases)) t[n] = jA(i);
                return t;
              })(e)
            : e.default;
        return VA.set(e, t), t;
      }
      var WA = n(314),
        XA = n.n(WA);
      const qA = function () {
        (this.__data__ = new ne()), (this.size = 0);
      };
      const YA = function (e) {
        var t = this.__data__,
          n = t.delete(e);
        return (this.size = t.size), n;
      };
      const KA = function (e) {
        return this.__data__.get(e);
      };
      const JA = function (e) {
        return this.__data__.has(e);
      };
      const ZA = function (e, t) {
        var n = this.__data__;
        if (n instanceof ne) {
          var i = n.__data__;
          if (!ie || i.length < 199)
            return i.push([e, t]), (this.size = ++n.size), this;
          n = this.__data__ = new de(i);
        }
        return n.set(e, t), (this.size = n.size), this;
      };
      function $A(e) {
        var t = (this.__data__ = new ne(e));
        this.size = t.size;
      }
      ($A.prototype.clear = qA),
        ($A.prototype.delete = YA),
        ($A.prototype.get = KA),
        ($A.prototype.has = JA),
        ($A.prototype.set = ZA);
      const eg = $A;
      const tg = function (e, t) {
        for (
          var n = -1, i = null == e ? 0 : e.length;
          ++n < i && !1 !== t(e[n], n, e);

        );
        return e;
      };
      const ng = function (e, t, n, i) {
        var r = !n;
        n || (n = {});
        for (var s = -1, a = t.length; ++s < a; ) {
          var o = t[s],
            c = i ? i(n[o], e[o], o, n, e) : void 0;
          void 0 === c && (c = e[o]), r ? OA(n, o, c) : kA(n, o, c);
        }
        return n;
      };
      const ig = function (e, t) {
        for (var n = -1, i = Array(e); ++n < e; ) i[n] = t(n);
        return i;
      };
      const rg = function (e) {
        return A(e) && "[object Arguments]" == f(e);
      };
      var sg = Object.prototype,
        ag = sg.hasOwnProperty,
        og = sg.propertyIsEnumerable;
      const cg = rg(
        (function () {
          return arguments;
        })()
      )
        ? rg
        : function (e) {
            return A(e) && ag.call(e, "callee") && !og.call(e, "callee");
          };
      const lg = function () {
        return !1;
      };
      var ug =
          "object" == typeof exports && exports && !exports.nodeType && exports,
        hg =
          ug &&
          "object" == typeof module &&
          module &&
          !module.nodeType &&
          module,
        dg = hg && hg.exports === ug ? r.Buffer : void 0;
      const pg = (dg ? dg.isBuffer : void 0) || lg;
      const fg = function (e) {
        return (
          "number" == typeof e && e > -1 && e % 1 == 0 && e <= 9007199254740991
        );
      };
      var Ag = {};
      (Ag["[object Float32Array]"] =
        Ag["[object Float64Array]"] =
        Ag["[object Int8Array]"] =
        Ag["[object Int16Array]"] =
        Ag["[object Int32Array]"] =
        Ag["[object Uint8Array]"] =
        Ag["[object Uint8ClampedArray]"] =
        Ag["[object Uint16Array]"] =
        Ag["[object Uint32Array]"] =
          !0),
        (Ag["[object Arguments]"] =
          Ag["[object Array]"] =
          Ag["[object ArrayBuffer]"] =
          Ag["[object Boolean]"] =
          Ag["[object DataView]"] =
          Ag["[object Date]"] =
          Ag["[object Error]"] =
          Ag["[object Function]"] =
          Ag["[object Map]"] =
          Ag["[object Number]"] =
          Ag["[object Object]"] =
          Ag["[object RegExp]"] =
          Ag["[object Set]"] =
          Ag["[object String]"] =
          Ag["[object WeakMap]"] =
            !1);
      const gg = function (e) {
        return A(e) && fg(e.length) && !!Ag[f(e)];
      };
      const mg = function (e) {
        return function (t) {
          return e(t);
        };
      };
      var vg =
          "object" == typeof exports && exports && !exports.nodeType && exports,
        yg =
          vg &&
          "object" == typeof module &&
          module &&
          !module.nodeType &&
          module,
        bg = yg && yg.exports === vg && t.process;
      const _g = (function () {
        try {
          var e = yg && yg.require && yg.require("util").types;
          return e || (bg && bg.binding && bg.binding("util"));
        } catch (e) {}
      })();
      var xg = _g && _g.isTypedArray;
      const Eg = xg ? mg(xg) : gg;
      var wg = Object.prototype.hasOwnProperty;
      const Cg = function (t, n) {
        var i = e(t),
          r = !i && cg(t),
          s = !i && !r && pg(t),
          a = !i && !r && !s && Eg(t),
          o = i || r || s || a,
          c = o ? ig(t.length, String) : [],
          l = c.length;
        for (var u in t)
          (!n && !wg.call(t, u)) ||
            (o &&
              ("length" == u ||
                (s && ("offset" == u || "parent" == u)) ||
                (a &&
                  ("buffer" == u || "byteLength" == u || "byteOffset" == u)) ||
                GA(u, l))) ||
            c.push(u);
        return c;
      };
      var Sg = Object.prototype;
      const Ig = function (e) {
        var t = e && e.constructor;
        return e === (("function" == typeof t && t.prototype) || Sg);
      };
      const Mg = Bf(Object.keys, Object);
      var Tg = Object.prototype.hasOwnProperty;
      const Bg = function (e) {
        if (!Ig(e)) return Mg(e);
        var t = [];
        for (var n in Object(e))
          Tg.call(e, n) && "constructor" != n && t.push(n);
        return t;
      };
      const Rg = function (e) {
        return null != e && fg(e.length) && !_(e);
      };
      const Dg = function (e) {
        return Rg(e) ? Cg(e) : Bg(e);
      };
      const Pg = function (e, t) {
        return e && ng(t, Dg(t), e);
      };
      const Lg = function (e) {
        var t = [];
        if (null != e) for (var n in Object(e)) t.push(n);
        return t;
      };
      var Ug = Object.prototype.hasOwnProperty;
      const Fg = function (e) {
        if (!b(e)) return Lg(e);
        var t = Ig(e),
          n = [];
        for (var i in e)
          ("constructor" != i || (!t && Ug.call(e, i))) && n.push(i);
        return n;
      };
      const Og = function (e) {
        return Rg(e) ? Cg(e, !0) : Fg(e);
      };
      const Ng = function (e, t) {
        return e && ng(t, Og(t), e);
      };
      var kg =
          "object" == typeof exports && exports && !exports.nodeType && exports,
        Qg =
          kg &&
          "object" == typeof module &&
          module &&
          !module.nodeType &&
          module,
        Gg = Qg && Qg.exports === kg ? r.Buffer : void 0,
        Hg = Gg ? Gg.allocUnsafe : void 0;
      const zg = function (e, t) {
        if (t) return e.slice();
        var n = e.length,
          i = Hg ? Hg(n) : new e.constructor(n);
        return e.copy(i), i;
      };
      const Vg = function (e, t) {
        var n = -1,
          i = e.length;
        for (t || (t = Array(i)); ++n < i; ) t[n] = e[n];
        return t;
      };
      const jg = function (e, t) {
        for (
          var n = -1, i = null == e ? 0 : e.length, r = 0, s = [];
          ++n < i;

        ) {
          var a = e[n];
          t(a, n, e) && (s[r++] = a);
        }
        return s;
      };
      const Wg = function () {
        return [];
      };
      var Xg = Object.prototype.propertyIsEnumerable,
        qg = Object.getOwnPropertySymbols;
      const Yg = qg
        ? function (e) {
            return null == e
              ? []
              : ((e = Object(e)),
                jg(qg(e), function (t) {
                  return Xg.call(e, t);
                }));
          }
        : Wg;
      const Kg = function (e, t) {
        return ng(e, Yg(e), t);
      };
      const Jg = function (e, t) {
        for (var n = -1, i = t.length, r = e.length; ++n < i; ) e[r + n] = t[n];
        return e;
      };
      const Zg = Object.getOwnPropertySymbols
        ? function (e) {
            for (var t = []; e; ) Jg(t, Yg(e)), (e = Rf(e));
            return t;
          }
        : Wg;
      const $g = function (e, t) {
        return ng(e, Zg(e), t);
      };
      const em = function (t, n, i) {
        var r = n(t);
        return e(t) ? r : Jg(r, i(t));
      };
      const tm = function (e) {
        return em(e, Dg, Yg);
      };
      const nm = function (e) {
        return em(e, Og, Zg);
      };
      const im = F(r, "DataView");
      const rm = F(r, "Promise");
      const sm = F(r, "Set");
      const am = F(r, "WeakMap");
      var om = "[object Map]",
        cm = "[object Promise]",
        lm = "[object Set]",
        um = "[object WeakMap]",
        hm = "[object DataView]",
        dm = I(im),
        pm = I(ie),
        fm = I(rm),
        Am = I(sm),
        gm = I(am),
        mm = f;
      ((im && mm(new im(new ArrayBuffer(1))) != hm) ||
        (ie && mm(new ie()) != om) ||
        (rm && mm(rm.resolve()) != cm) ||
        (sm && mm(new sm()) != lm) ||
        (am && mm(new am()) != um)) &&
        (mm = function (e) {
          var t = f(e),
            n = "[object Object]" == t ? e.constructor : void 0,
            i = n ? I(n) : "";
          if (i)
            switch (i) {
              case dm:
                return hm;
              case pm:
                return om;
              case fm:
                return cm;
              case Am:
                return lm;
              case gm:
                return um;
            }
          return t;
        });
      const vm = mm;
      var ym = Object.prototype.hasOwnProperty;
      const bm = function (e) {
        var t = e.length,
          n = new e.constructor(t);
        return (
          t &&
            "string" == typeof e[0] &&
            ym.call(e, "index") &&
            ((n.index = e.index), (n.input = e.input)),
          n
        );
      };
      const _m = r.Uint8Array;
      const xm = function (e) {
        var t = new e.constructor(e.byteLength);
        return new _m(t).set(new _m(e)), t;
      };
      const Em = function (e, t) {
        var n = t ? xm(e.buffer) : e.buffer;
        return new e.constructor(n, e.byteOffset, e.byteLength);
      };
      var wm = /\w*$/;
      const Cm = function (e) {
        var t = new e.constructor(e.source, wm.exec(e));
        return (t.lastIndex = e.lastIndex), t;
      };
      var Sm = s ? s.prototype : void 0,
        Im = Sm ? Sm.valueOf : void 0;
      const Mm = function (e) {
        return Im ? Object(Im.call(e)) : {};
      };
      const Tm = function (e, t) {
        var n = t ? xm(e.buffer) : e.buffer;
        return new e.constructor(n, e.byteOffset, e.length);
      };
      const Bm = function (e, t, n) {
        var i = e.constructor;
        switch (t) {
          case "[object ArrayBuffer]":
            return xm(e);
          case "[object Boolean]":
          case "[object Date]":
            return new i(+e);
          case "[object DataView]":
            return Em(e, n);
          case "[object Float32Array]":
          case "[object Float64Array]":
          case "[object Int8Array]":
          case "[object Int16Array]":
          case "[object Int32Array]":
          case "[object Uint8Array]":
          case "[object Uint8ClampedArray]":
          case "[object Uint16Array]":
          case "[object Uint32Array]":
            return Tm(e, n);
          case "[object Map]":
          case "[object Set]":
            return new i();
          case "[object Number]":
          case "[object String]":
            return new i(e);
          case "[object RegExp]":
            return Cm(e);
          case "[object Symbol]":
            return Mm(e);
        }
      };
      var Rm = Object.create;
      const Dm = (function () {
        function e() {}
        return function (t) {
          if (!b(t)) return {};
          if (Rm) return Rm(t);
          e.prototype = t;
          var n = new e();
          return (e.prototype = void 0), n;
        };
      })();
      const Pm = function (e) {
        return "function" != typeof e.constructor || Ig(e) ? {} : Dm(Rf(e));
      };
      const Lm = function (e) {
        return A(e) && "[object Map]" == vm(e);
      };
      var Um = _g && _g.isMap;
      const Fm = Um ? mg(Um) : Lm;
      const Om = function (e) {
        return A(e) && "[object Set]" == vm(e);
      };
      var Nm = _g && _g.isSet;
      const km = Nm ? mg(Nm) : Om;
      var Qm = "[object Arguments]",
        Gm = "[object Function]",
        Hm = "[object Object]",
        zm = {};
      (zm[Qm] =
        zm["[object Array]"] =
        zm["[object ArrayBuffer]"] =
        zm["[object DataView]"] =
        zm["[object Boolean]"] =
        zm["[object Date]"] =
        zm["[object Float32Array]"] =
        zm["[object Float64Array]"] =
        zm["[object Int8Array]"] =
        zm["[object Int16Array]"] =
        zm["[object Int32Array]"] =
        zm["[object Map]"] =
        zm["[object Number]"] =
        zm[Hm] =
        zm["[object RegExp]"] =
        zm["[object Set]"] =
        zm["[object String]"] =
        zm["[object Symbol]"] =
        zm["[object Uint8Array]"] =
        zm["[object Uint8ClampedArray]"] =
        zm["[object Uint16Array]"] =
        zm["[object Uint32Array]"] =
          !0),
        (zm["[object Error]"] = zm[Gm] = zm["[object WeakMap]"] = !1);
      const Vm = function t(n, i, r, s, a, o) {
        var c,
          l = 1 & i,
          u = 2 & i,
          h = 4 & i;
        if ((r && (c = a ? r(n, s, a, o) : r(n)), void 0 !== c)) return c;
        if (!b(n)) return n;
        var d = e(n);
        if (d) {
          if (((c = bm(n)), !l)) return Vg(n, c);
        } else {
          var p = vm(n),
            f = p == Gm || "[object GeneratorFunction]" == p;
          if (pg(n)) return zg(n, l);
          if (p == Hm || p == Qm || (f && !a)) {
            if (((c = u || f ? {} : Pm(n)), !l))
              return u ? $g(n, Ng(c, n)) : Kg(n, Pg(c, n));
          } else {
            if (!zm[p]) return a ? n : {};
            c = Bm(n, p, l);
          }
        }
        o || (o = new eg());
        var A = o.get(n);
        if (A) return A;
        o.set(n, c),
          km(n)
            ? n.forEach(function (e) {
                c.add(t(e, i, r, e, n, o));
              })
            : Fm(n) &&
              n.forEach(function (e, s) {
                c.set(s, t(e, i, r, s, n, o));
              });
        var g = d ? void 0 : (h ? (u ? nm : tm) : u ? Og : Dg)(n);
        return (
          tg(g || n, function (e, s) {
            g && (e = n[(s = e)]), kA(c, s, t(e, i, r, s, n, o));
          }),
          c
        );
      };
      const jm = function (e) {
        return Vm(e, 5);
      };
      function Wm(e) {
        const t = new Map();
        return (n) => (t.has(n) || t.set(n, e(n)), t.get(n));
      }
      var Xm;
      function qm(e, t, n) {
        return AA(() => {
          const i = CA(t),
            r = AA.memo(
              "driver",
              () =>
                i
                  ? "BasicKeyframedTrack" === i.type
                    ? (function (e, t, n) {
                        return AA(() => {
                          const e = AA.ref("state", { started: !1 });
                          let i = e.current;
                          const r = n.getValue();
                          return (
                            (!i.started || r < i.validFrom || i.validTo <= r) &&
                              (e.current = i =
                                (function (e, t, n) {
                                  const i = Xm.getSortedKeyframesCached(
                                      n.keyframes
                                    ),
                                    r = t.getValue();
                                  if (0 === i.length)
                                    return {
                                      started: !0,
                                      validFrom: -1 / 0,
                                      validTo: 1 / 0,
                                      der: Ym,
                                    };
                                  let s = 0;
                                  for (;;) {
                                    const e = i[s];
                                    if (!e) return Km.error;
                                    const n = s === i.length - 1;
                                    if (r < e.position)
                                      return 0 === s
                                        ? Km.beforeFirstKeyframe(e)
                                        : Km.error;
                                    if (e.position === r)
                                      return n
                                        ? Km.lastKeyframe(e)
                                        : Km.between(e, i[s + 1], t);
                                    if (s === i.length - 1)
                                      return Km.lastKeyframe(e);
                                    {
                                      const n = s + 1;
                                      if (i[n].position <= r) {
                                        s = n;
                                        continue;
                                      }
                                      return Km.between(e, i[s + 1], t);
                                    }
                                  }
                                })(0, n, t)),
                            i.der.getValue()
                          );
                        });
                      })(0, i, n)
                    : (e.logger.error("Track type not yet supported."),
                      AA(() => {}))
                  : AA(() => {}),
              [i]
            );
          return r.getValue();
        });
      }
      !(function (e) {
        (e.getSortedKeyframes = (e) => {
          const t = Object.values(e.byId);
          return t.sort((e, t) => e.position - t.position), jm(t);
        }),
          (e.getSortedKeyframesCached = Wm(e.getSortedKeyframes)),
          (e.fromArray = (e) => {
            const t = {},
              n = {};
            for (const i of e) (t[i.id] = i), (n[i.id] = !0);
            return jm({ byId: t, allIds: n });
          }),
          (e.fromSortedKeyframesCached = Wm(e.fromArray));
      })(Xm || (Xm = {}));
      const Ym = AA(() => {});
      const Km = {
        beforeFirstKeyframe: (e) => ({
          started: !0,
          validFrom: -1 / 0,
          validTo: e.position,
          der: AA(() => ({ left: e.value, progression: 0 })),
        }),
        lastKeyframe: (e) => ({
          started: !0,
          validFrom: e.position,
          validTo: 1 / 0,
          der: AA(() => ({ left: e.value, progression: 0 })),
        }),
        between(e, t, n) {
          if (!e.connectedRight)
            return {
              started: !0,
              validFrom: e.position,
              validTo: t.position,
              der: AA(() => ({ left: e.value, progression: 0 })),
            };
          const i = (n) => (n - e.position) / (t.position - e.position);
          if (!e.type || "bezier" === e.type) {
            const r = new (XA())(
                e.handles[2],
                e.handles[3],
                t.handles[0],
                t.handles[1]
              ),
              s = AA(() => {
                const s = i(n.getValue()),
                  a = r.solveSimple(s);
                return { left: e.value, right: t.value, progression: a };
              });
            return {
              started: !0,
              validFrom: e.position,
              validTo: t.position,
              der: s,
            };
          }
          const r = AA(() => {
            const r = i(n.getValue()),
              s = Math.floor(r);
            return { left: e.value, right: t.value, progression: s };
          });
          return {
            started: !0,
            validFrom: e.position,
            validTo: t.position,
            der: r,
          };
        },
        error: { started: !0, validFrom: -1 / 0, validTo: 1 / 0, der: Ym },
      };
      function Jm(e, t, n) {
        const i = n.get(e);
        if (i && i.override === t) return i.merged;
        const r = Object.assign({}, e);
        for (const i of Object.keys(t)) {
          const s = t[i],
            a = e[i];
          r[i] =
            "object" == typeof s && "object" == typeof a
              ? Jm(a, s, n)
              : void 0 === s
              ? a
              : s;
        }
        return n.set(e, { override: t, merged: r }), r;
      }
      function Zm(e, t) {
        let n = e;
        for (const e of t) n = n[e];
        return n;
      }
      const $m = function () {
        return r.Date.now();
      };
      var ev = /\s/;
      const tv = function (e) {
        for (var t = e.length; t-- && ev.test(e.charAt(t)); );
        return t;
      };
      var nv = /^\s+/;
      const iv = function (e) {
        return e ? e.slice(0, tv(e) + 1).replace(nv, "") : e;
      };
      var rv = /^[-+]0x[0-9a-f]+$/i,
        sv = /^0b[01]+$/i,
        av = /^0o[0-7]+$/i,
        ov = parseInt;
      const cv = function (e) {
        if ("number" == typeof e) return e;
        if (g(e)) return NaN;
        if (b(e)) {
          var t = "function" == typeof e.valueOf ? e.valueOf() : e;
          e = b(t) ? t + "" : t;
        }
        if ("string" != typeof e) return 0 === e ? e : +e;
        e = iv(e);
        var n = sv.test(e);
        return n || av.test(e)
          ? ov(e.slice(2), n ? 2 : 8)
          : rv.test(e)
          ? NaN
          : +e;
      };
      var lv = Math.max,
        uv = Math.min;
      const hv = function (e, t, n) {
        var i,
          r,
          s,
          a,
          o,
          c,
          l = 0,
          u = !1,
          h = !1,
          d = !0;
        if ("function" != typeof e) throw new TypeError("Expected a function");
        function p(t) {
          var n = i,
            s = r;
          return (i = r = void 0), (l = t), (a = e.apply(s, n));
        }
        function f(e) {
          var n = e - c;
          return void 0 === c || n >= t || n < 0 || (h && e - l >= s);
        }
        function A() {
          var e = $m();
          if (f(e)) return g(e);
          o = setTimeout(
            A,
            (function (e) {
              var n = t - (e - c);
              return h ? uv(n, s - (e - l)) : n;
            })(e)
          );
        }
        function g(e) {
          return (o = void 0), d && i ? p(e) : ((i = r = void 0), a);
        }
        function m() {
          var e = $m(),
            n = f(e);
          if (((i = arguments), (r = this), (c = e), n)) {
            if (void 0 === o)
              return (function (e) {
                return (l = e), (o = setTimeout(A, t)), u ? p(e) : a;
              })(c);
            if (h) return clearTimeout(o), (o = setTimeout(A, t)), p(c);
          }
          return void 0 === o && (o = setTimeout(A, t)), a;
        }
        return (
          (t = cv(t) || 0),
          b(n) &&
            ((u = !!n.leading),
            (s = (h = "maxWait" in n) ? lv(cv(n.maxWait) || 0, t) : s),
            (d = "trailing" in n ? !!n.trailing : d)),
          (m.cancel = function () {
            void 0 !== o && clearTimeout(o), (l = 0), (i = c = r = o = void 0);
          }),
          (m.flush = function () {
            return void 0 === o ? a : g($m());
          }),
          m
        );
      };
      class dv {
        get type() {
          return "Theatre_SheetObject_PublicAPI";
        }
        constructor(e) {
          (this._cache = new UA()),
            (this._keepHotUntapDebounce = void 0),
            DA(this, e);
        }
        get props() {
          return RA(this).propsP;
        }
        get sheet() {
          return RA(this).sheet.publicApi;
        }
        get project() {
          return RA(this).sheet.project.publicApi;
        }
        get address() {
          return Object.assign({}, RA(this).address);
        }
        _valuesPrism() {
          return this._cache.get("_valuesPrism", () => {
            const e = RA(this);
            return AA(() => CA(e.getValues().getValue()));
          });
        }
        onValuesChange(e, t) {
          return (function (e, t, n) {
            const i = n ? RA(n).ticker : Xy();
            if (Xf(e)) {
              return wA(e).onChange(i, t, !0);
            }
            if (xA(e)) return e.onChange(i, t, !0);
            throw new Error(
              "Called onChange(p) where p is neither a pointer nor a prism."
            );
          })(this._valuesPrism(), e, t);
        }
        get value() {
          const e = this._valuesPrism();
          if (!e.isHot) {
            null != this._keepHotUntapDebounce &&
              this._keepHotUntapDebounce.flush();
            const t = e.keepHot();
            this._keepHotUntapDebounce = hv(() => {
              t(), (this._keepHotUntapDebounce = void 0);
            }, 5e3);
          }
          return (
            this._keepHotUntapDebounce && this._keepHotUntapDebounce(),
            e.getValue()
          );
        }
        set initialValue(e) {
          RA(this).setInitialValue(e);
        }
      }
      function pv(e) {
        return "compound" === e.type || "enum" === e.type;
      }
      function fv(e, t) {
        if (!e) return;
        const [n, ...i] = t;
        if (void 0 === n) return e;
        if (!pv(e)) return;
        return fv("enum" === e.type ? e.cases[n] : e.props[n], i);
      }
      const Av = Wm((e) => {
        if ("enum" === e.type) throw new Error("Not implemented yet for enums");
        for (const t in e.props) {
          const n = e.props[t];
          if (!pv(n)) return !0;
          if (Av(n)) return !0;
        }
        return !1;
      });
      class gv {
        get type() {
          return "Theatre_SheetObject";
        }
        constructor(e, t, n) {
          (this.sheet = e),
            (this.template = t),
            (this.nativeObject = n),
            (this.$$isPointerToPrismProvider = !0),
            (this._initialValue = new _A({})),
            (this._cache = new UA()),
            (this._logger = e._logger.named(
              "SheetObject",
              t.address.objectKey
            )),
            this._logger._trace("creating object"),
            (this._internalUtilCtx = {
              logger: this._logger.utilFor.internal(),
            }),
            (this.address = Object.assign(Object.assign({}, t.address), {
              sheetInstanceId: e.address.sheetInstanceId,
            })),
            (this.publicApi = new dv(this));
        }
        getValues() {
          return this._cache.get("getValues()", () =>
            AA(() => {
              const e = Jm(
                CA(this.template.getDefaultValues()),
                CA(this._initialValue.pointer),
                AA.memo("withInitialCache", () => new WeakMap(), [])
              );
              let t,
                n = Jm(
                  e,
                  CA(this.template.getStaticValues()),
                  AA.memo("withStatics", () => new WeakMap(), [])
                );
              {
                const e = AA.memo("seq", () => this.getSequencedValues(), []),
                  i = AA.memo("withSeqsCache", () => new WeakMap(), []);
                t = CA(CA(e));
                n = Jm(n, t, i);
              }
              return ((e, t) => {
                const n = AA.memo(e, () => new _A(t), []);
                return n.set(t), n;
              })("finalAtom", n).pointer;
            })
          );
        }
        getValueByPointer(e) {
          const t = CA(this.getValues()),
            { path: n } = Vf(e);
          return CA(Zm(t, n));
        }
        pointerToPrism(e) {
          const { path: t } = Vf(e);
          return AA(() => {
            const e = CA(this.getValues());
            return CA(Zm(e, t));
          });
        }
        getSequencedValues() {
          return AA(() => {
            const e = AA.memo(
                "tracksToProcess",
                () => this.template.getArrayOfValidSequenceTracks(),
                []
              ),
              t = CA(e),
              n = new _A({}),
              i = CA(this.template.configPointer);
            return (
              AA.effect(
                "processTracks",
                () => {
                  const e = [];
                  for (const { trackId: r, pathToProp: s } of t) {
                    const t = this._trackIdToPrism(r),
                      a = fv(i, s),
                      o = a.deserializeAndSanitize,
                      c = a.interpolate,
                      l = () => {
                        const e = t.getValue();
                        if (!e) return n.setByPointer((e) => Zm(e, s), void 0);
                        const i = o(e.left),
                          r = void 0 === i ? a.default : i;
                        if (void 0 === e.right)
                          return n.setByPointer((e) => Zm(e, s), r);
                        const l = o(e.right),
                          u = void 0 === l ? a.default : l;
                        return n.setByPointer(
                          (e) => Zm(e, s),
                          c(r, u, e.progression)
                        );
                      },
                      u = t.onStale(l);
                    l(), e.push(u);
                  }
                  return () => {
                    for (const t of e) t();
                  };
                },
                [i, ...t]
              ),
              n.pointer
            );
          });
        }
        _trackIdToPrism(e) {
          const t =
              this.template.project.pointers.historic.sheetsById[
                this.address.sheetId
              ].sequence.tracksByObject[this.address.objectKey].trackData[e],
            n = this.sheet.getSequence().positionPrism;
          return qm(this._internalUtilCtx, t, n);
        }
        get propsP() {
          return this._cache.get("propsP", () => Wf({ root: this, path: [] }));
        }
        validateValue(e, t) {}
        setInitialValue(e) {
          this.validateValue(this.propsP, e), this._initialValue.set(e);
        }
      }
      function mv(e) {
        return function (t, n) {
          return e(t, n());
        };
      }
      var vv, yv, bv, _v;
      !(function (e) {
        (e[(e.GENERAL = 1)] = "GENERAL"),
          (e[(e.TODO = 2)] = "TODO"),
          (e[(e.TROUBLESHOOTING = 4)] = "TROUBLESHOOTING");
      })(vv || (vv = {})),
        (function (e) {
          (e[(e.INTERNAL = 8)] = "INTERNAL"),
            (e[(e.DEV = 16)] = "DEV"),
            (e[(e.PUBLIC = 32)] = "PUBLIC");
        })(yv || (yv = {})),
        (function (e) {
          (e[(e.TRACE = 64)] = "TRACE"),
            (e[(e.DEBUG = 128)] = "DEBUG"),
            (e[(e.WARN = 256)] = "WARN"),
            (e[(e.ERROR = 512)] = "ERROR");
        })(bv || (bv = {})),
        (function (e) {
          (e[(e.ERROR_PUBLIC = 545)] = "ERROR_PUBLIC"),
            (e[(e.ERROR_DEV = 529)] = "ERROR_DEV"),
            (e[(e._HMM = 524)] = "_HMM"),
            (e[(e._TODO = 522)] = "_TODO"),
            (e[(e._ERROR = 521)] = "_ERROR"),
            (e[(e.WARN_PUBLIC = 289)] = "WARN_PUBLIC"),
            (e[(e.WARN_DEV = 273)] = "WARN_DEV"),
            (e[(e._KAPOW = 268)] = "_KAPOW"),
            (e[(e._WARN = 265)] = "_WARN"),
            (e[(e.DEBUG_DEV = 145)] = "DEBUG_DEV"),
            (e[(e._DEBUG = 137)] = "_DEBUG"),
            (e[(e.TRACE_DEV = 81)] = "TRACE_DEV"),
            (e[(e._TRACE = 73)] = "_TRACE");
        })(_v || (_v = {}));
      const xv = {
        _hmm: Ev(_v._HMM),
        _todo: Ev(_v._TODO),
        _error: Ev(_v._ERROR),
        errorDev: Ev(_v.ERROR_DEV),
        errorPublic: Ev(_v.ERROR_PUBLIC),
        _kapow: Ev(_v._KAPOW),
        _warn: Ev(_v._WARN),
        warnDev: Ev(_v.WARN_DEV),
        warnPublic: Ev(_v.WARN_PUBLIC),
        _debug: Ev(_v._DEBUG),
        debugDev: Ev(_v.DEBUG_DEV),
        _trace: Ev(_v._TRACE),
        traceDev: Ev(_v.TRACE_DEV),
      };
      function Ev(e) {
        return Object.freeze({
          audience: wv(e, yv.INTERNAL)
            ? "internal"
            : wv(e, yv.DEV)
            ? "dev"
            : "public",
          category: wv(e, vv.TROUBLESHOOTING)
            ? "troubleshooting"
            : wv(e, vv.TODO)
            ? "todo"
            : "general",
          level: wv(e, bv.ERROR)
            ? bv.ERROR
            : wv(e, bv.WARN)
            ? bv.WARN
            : wv(e, bv.DEBUG)
            ? bv.DEBUG
            : bv.TRACE,
        });
      }
      function wv(e, t) {
        return (e & t) === t;
      }
      function Cv(e, t) {
        return (
          ((t & yv.PUBLIC) === yv.PUBLIC ||
            ((t & yv.DEV) === yv.DEV
              ? e.dev
              : (t & yv.INTERNAL) === yv.INTERNAL && e.internal)) &&
          e.min <= t
        );
      }
      const Sv = {
        loggingConsoleStyle: !0,
        loggerConsoleStyle: !0,
        includes: Object.freeze({ internal: !1, dev: !1, min: bv.WARN }),
        filtered: function () {},
        include: function () {
          return {};
        },
        create: null,
        creatExt: null,
        named(e, t, n) {
          return this.create({ names: [...e.names, { name: t, key: n }] });
        },
        style: {
          bold: void 0,
          italic: void 0,
          cssMemo: new Map([["", ""]]),
          collapseOnRE: /[a-z- ]+/g,
          color: void 0,
          collapsed(e) {
            if (e.length < 5) return e;
            const t = e.replace(this.collapseOnRE, "");
            return this.cssMemo.has(t) || this.cssMemo.set(t, this.css(e)), t;
          },
          css(e) {
            var t, n, i, r;
            const s = this.cssMemo.get(e);
            if (s) return s;
            let a = `color:${
              null !==
                (n =
                  null === (t = this.color) || void 0 === t
                    ? void 0
                    : t.call(this, e)) && void 0 !== n
                ? n
                : `hsl(${
                    (e.charCodeAt(0) + e.charCodeAt(e.length - 1)) % 360
                  }, 100%, 60%)`
            }`;
            return (
              (null === (i = this.bold) || void 0 === i ? void 0 : i.test(e)) &&
                (a += ";font-weight:600"),
              (null === (r = this.italic) || void 0 === r
                ? void 0
                : r.test(e)) && (a += ";font-style:italic"),
              this.cssMemo.set(e, a),
              a
            );
          },
        },
      };
      function Iv(e = console, t = {}) {
        const n = Object.assign(Object.assign({}, Sv), {
            includes: Object.assign({}, Sv.includes),
          }),
          i = { styled: Bv.bind(n, e), noStyle: Rv.bind(n, e) },
          r = Tv.bind(n);
        function s() {
          return n.loggingConsoleStyle && n.loggerConsoleStyle
            ? i.styled
            : i.noStyle;
        }
        return (
          (n.create = s()),
          {
            configureLogger(e) {
              var t;
              "console" === e
                ? ((n.loggerConsoleStyle = Sv.loggerConsoleStyle),
                  (n.create = s()))
                : "console" === e.type
                ? ((n.loggerConsoleStyle =
                    null !== (t = e.style) && void 0 !== t
                      ? t
                      : Sv.loggerConsoleStyle),
                  (n.create = s()))
                : "keyed" === e.type
                ? ((n.creatExt = (t) => e.keyed(t.names)), (n.create = r))
                : "named" === e.type &&
                  ((n.creatExt = Mv.bind(null, e.named)), (n.create = r));
            },
            configureLogging(e) {
              var t, i, r, a, o;
              (n.includes.dev =
                null !== (t = e.dev) && void 0 !== t ? t : Sv.includes.dev),
                (n.includes.internal =
                  null !== (i = e.internal) && void 0 !== i
                    ? i
                    : Sv.includes.internal),
                (n.includes.min =
                  null !== (r = e.min) && void 0 !== r ? r : Sv.includes.min),
                (n.include =
                  null !== (a = e.include) && void 0 !== a ? a : Sv.include),
                (n.loggingConsoleStyle =
                  null !== (o = e.consoleStyle) && void 0 !== o
                    ? o
                    : Sv.loggingConsoleStyle),
                (n.create = s());
            },
            getLogger: () => n.create({ names: [] }),
          }
        );
      }
      function Mv(e, t) {
        const n = [];
        for (let { name: e, key: i } of t.names)
          n.push(null == i ? e : `${e} (${i})`);
        return e(n);
      }
      function Tv(e) {
        const t = Object.assign(
            Object.assign({}, this.includes),
            this.include(e)
          ),
          n = this.filtered,
          i = this.named.bind(this, e),
          r = this.creatExt(e),
          s = Cv(t, _v._HMM),
          a = Cv(t, _v._TODO),
          o = Cv(t, _v._ERROR),
          c = Cv(t, _v.ERROR_DEV),
          l = Cv(t, _v.ERROR_PUBLIC),
          u = Cv(t, _v._WARN),
          h = Cv(t, _v._KAPOW),
          d = Cv(t, _v.WARN_DEV),
          p = Cv(t, _v.WARN_PUBLIC),
          f = Cv(t, _v._DEBUG),
          A = Cv(t, _v.DEBUG_DEV),
          g = Cv(t, _v._TRACE),
          m = Cv(t, _v.TRACE_DEV),
          v = s ? r.error.bind(r, xv._hmm) : n.bind(e, _v._HMM),
          y = a ? r.error.bind(r, xv._todo) : n.bind(e, _v._TODO),
          b = o ? r.error.bind(r, xv._error) : n.bind(e, _v._ERROR),
          _ = c ? r.error.bind(r, xv.errorDev) : n.bind(e, _v.ERROR_DEV),
          x = l ? r.error.bind(r, xv.errorPublic) : n.bind(e, _v.ERROR_PUBLIC),
          E = h ? r.warn.bind(r, xv._kapow) : n.bind(e, _v._KAPOW),
          w = u ? r.warn.bind(r, xv._warn) : n.bind(e, _v._WARN),
          C = d ? r.warn.bind(r, xv.warnDev) : n.bind(e, _v.WARN_DEV),
          S = p ? r.warn.bind(r, xv.warnPublic) : n.bind(e, _v.WARN_DEV),
          I = f ? r.debug.bind(r, xv._debug) : n.bind(e, _v._DEBUG),
          M = A ? r.debug.bind(r, xv.debugDev) : n.bind(e, _v.DEBUG_DEV),
          T = g ? r.trace.bind(r, xv._trace) : n.bind(e, _v._TRACE),
          B = m ? r.trace.bind(r, xv.traceDev) : n.bind(e, _v.TRACE_DEV),
          R = {
            _hmm: v,
            _todo: y,
            _error: b,
            errorDev: _,
            errorPublic: x,
            _kapow: E,
            _warn: w,
            warnDev: C,
            warnPublic: S,
            _debug: I,
            debugDev: M,
            _trace: T,
            traceDev: B,
            lazy: {
              _hmm: s ? mv(v) : v,
              _todo: a ? mv(y) : y,
              _error: o ? mv(b) : b,
              errorDev: c ? mv(_) : _,
              errorPublic: l ? mv(x) : x,
              _kapow: h ? mv(E) : E,
              _warn: u ? mv(w) : w,
              warnDev: d ? mv(C) : C,
              warnPublic: p ? mv(S) : S,
              _debug: f ? mv(I) : I,
              debugDev: A ? mv(M) : M,
              _trace: g ? mv(T) : T,
              traceDev: m ? mv(B) : B,
            },
            named: i,
            utilFor: {
              internal: () => ({
                debug: R._debug,
                error: R._error,
                warn: R._warn,
                trace: R._trace,
                named: (e, t) => R.named(e, t).utilFor.internal(),
              }),
              dev: () => ({
                debug: R.debugDev,
                error: R.errorDev,
                warn: R.warnDev,
                trace: R.traceDev,
                named: (e, t) => R.named(e, t).utilFor.dev(),
              }),
              public: () => ({
                error: R.errorPublic,
                warn: R.warnPublic,
                debug(e, t) {
                  R._warn(`(public "debug" filtered out) ${e}`, t);
                },
                trace(e, t) {
                  R._warn(`(public "trace" filtered out) ${e}`, t);
                },
                named: (e, t) => R.named(e, t).utilFor.public(),
              }),
            },
          };
        return R;
      }
      function Bv(e, t) {
        const n = Object.assign(
            Object.assign({}, this.includes),
            this.include(t)
          ),
          i = [];
        let r = "";
        for (let e = 0; e < t.names.length; e++) {
          const { name: n, key: s } = t.names[e];
          if (((r += ` %c${n}`), i.push(this.style.css(n)), null != s)) {
            const e = `%c#${s}`;
            (r += e), i.push(this.style.css(e));
          }
        }
        const s = this.filtered,
          a = this.named.bind(this, t),
          o = [r, ...i];
        return Dv(
          s,
          t,
          n,
          e,
          o,
          (function (e) {
            const t = e.slice(0);
            for (let e = 1; e < t.length; e++)
              t[e] += ";background-color:#e0005a;padding:2px;color:white";
            return t;
          })(o),
          a
        );
      }
      function Rv(e, t) {
        const n = Object.assign(
          Object.assign({}, this.includes),
          this.include(t)
        );
        let i = "";
        for (let e = 0; e < t.names.length; e++) {
          const { name: n, key: r } = t.names[e];
          (i += ` ${n}`), null != r && (i += `#${r}`);
        }
        const r = [i];
        return Dv(this.filtered, t, n, e, r, r, this.named.bind(this, t));
      }
      function Dv(e, t, n, i, r, s, a) {
        const o = Cv(n, _v._HMM),
          c = Cv(n, _v._TODO),
          l = Cv(n, _v._ERROR),
          u = Cv(n, _v.ERROR_DEV),
          h = Cv(n, _v.ERROR_PUBLIC),
          d = Cv(n, _v._WARN),
          p = Cv(n, _v._KAPOW),
          f = Cv(n, _v.WARN_DEV),
          A = Cv(n, _v.WARN_PUBLIC),
          g = Cv(n, _v._DEBUG),
          m = Cv(n, _v.DEBUG_DEV),
          v = Cv(n, _v._TRACE),
          y = Cv(n, _v.TRACE_DEV),
          b = o ? i.error.bind(i, ...r) : e.bind(t, _v._HMM),
          _ = c ? i.error.bind(i, ...r) : e.bind(t, _v._TODO),
          x = l ? i.error.bind(i, ...r) : e.bind(t, _v._ERROR),
          E = u ? i.error.bind(i, ...r) : e.bind(t, _v.ERROR_DEV),
          w = h ? i.error.bind(i, ...r) : e.bind(t, _v.ERROR_PUBLIC),
          C = p ? i.warn.bind(i, ...s) : e.bind(t, _v._KAPOW),
          S = d ? i.warn.bind(i, ...r) : e.bind(t, _v._WARN),
          I = f ? i.warn.bind(i, ...r) : e.bind(t, _v.WARN_DEV),
          M = A ? i.warn.bind(i, ...r) : e.bind(t, _v.WARN_DEV),
          T = g ? i.info.bind(i, ...r) : e.bind(t, _v._DEBUG),
          B = m ? i.info.bind(i, ...r) : e.bind(t, _v.DEBUG_DEV),
          R = v ? i.debug.bind(i, ...r) : e.bind(t, _v._TRACE),
          D = y ? i.debug.bind(i, ...r) : e.bind(t, _v.TRACE_DEV),
          P = {
            _hmm: b,
            _todo: _,
            _error: x,
            errorDev: E,
            errorPublic: w,
            _kapow: C,
            _warn: S,
            warnDev: I,
            warnPublic: M,
            _debug: T,
            debugDev: B,
            _trace: R,
            traceDev: D,
            lazy: {
              _hmm: o ? mv(b) : b,
              _todo: c ? mv(_) : _,
              _error: l ? mv(x) : x,
              errorDev: u ? mv(E) : E,
              errorPublic: h ? mv(w) : w,
              _kapow: p ? mv(C) : C,
              _warn: d ? mv(S) : S,
              warnDev: f ? mv(I) : I,
              warnPublic: A ? mv(M) : M,
              _debug: g ? mv(T) : T,
              debugDev: m ? mv(B) : B,
              _trace: v ? mv(R) : R,
              traceDev: y ? mv(D) : D,
            },
            named: a,
            utilFor: {
              internal: () => ({
                debug: P._debug,
                error: P._error,
                warn: P._warn,
                trace: P._trace,
                named: (e, t) => P.named(e, t).utilFor.internal(),
              }),
              dev: () => ({
                debug: P.debugDev,
                error: P.errorDev,
                warn: P.warnDev,
                trace: P.traceDev,
                named: (e, t) => P.named(e, t).utilFor.dev(),
              }),
              public: () => ({
                error: P.errorPublic,
                warn: P.warnPublic,
                debug(e, t) {
                  P._warn(`(public "debug" filtered out) ${e}`, t);
                },
                trace(e, t) {
                  P._warn(`(public "trace" filtered out) ${e}`, t);
                },
                named: (e, t) => P.named(e, t).utilFor.public(),
              }),
            },
          };
        return P;
      }
      const Pv = Iv(console, {
        _debug: function () {},
        _error: function () {},
      });
      Pv.configureLogging({ dev: !0, min: bv.TRACE });
      const Lv = Pv.getLogger()
          .named("Theatre.js (default logger)")
          .utilFor.dev(),
        Uv = new WeakMap();
      function Fv(e, t, n) {
        for (const [i, r] of Object.entries(t.props))
          if (!pv(r)) {
            const t = [...e, i];
            n.set(JSON.stringify(t), n.size), Ov(t, r, n);
          }
        for (const [i, r] of Object.entries(t.props))
          if (pv(r)) {
            const t = [...e, i];
            n.set(JSON.stringify(t), n.size), Ov(t, r, n);
          }
      }
      function Ov(e, t, n) {
        if ("compound" === t.type) Fv(e, t, n);
        else {
          if ("enum" === t.type) throw new Error("Enums aren't supported yet");
          n.set(JSON.stringify(e), n.size);
        }
      }
      const Nv = function (e, t, n) {
        var i = -1,
          r = e.length;
        t < 0 && (t = -t > r ? 0 : r + t),
          (n = n > r ? r : n) < 0 && (n += r),
          (r = t > n ? 0 : (n - t) >>> 0),
          (t >>>= 0);
        for (var s = Array(r); ++i < r; ) s[i] = e[i + t];
        return s;
      };
      const kv = function (e, t) {
        return t.length < 2 ? e : Ie(e, Nv(t, 0, -1));
      };
      const Qv = function (e, t) {
        return (t = Ce(t, e)), null == (e = kv(e, t)) || delete e[Se(Nf(t))];
      };
      const Gv = function (e, t) {
        return null == e || Qv(e, t);
      };
      function Hv(e) {
        return (
          "object" == typeof e && null !== e && 0 === Object.keys(e).length
        );
      }
      class zv {
        get staticConfig() {
          return this._config.get();
        }
        get configPointer() {
          return this._config.pointer;
        }
        get _temp_actions() {
          return this._temp_actions_atom.get();
        }
        get _temp_actionsPointer() {
          return this._temp_actions_atom.pointer;
        }
        constructor(e, t, n, i, r) {
          (this.sheetTemplate = e),
            (this.type = "Theatre_SheetObjectTemplate"),
            (this._cache = new UA()),
            (this.address = Object.assign(Object.assign({}, e.address), {
              objectKey: t,
            })),
            (this._config = new _A(i)),
            (this._temp_actions_atom = new _A(r)),
            (this.project = e.project),
            (this.pointerToSheetState =
              this.sheetTemplate.project.pointers.historic.sheetsById[
                this.address.sheetId
              ]),
            (this.pointerToStaticOverrides =
              this.pointerToSheetState.staticOverrides.byObject[
                this.address.objectKey
              ]);
        }
        createInstance(e, t, n) {
          return this._config.set(n), new gv(e, this, t);
        }
        reconfigure(e) {
          this._config.set(e);
        }
        _temp_setActions(e) {
          this._temp_actions_atom.set(e);
        }
        getDefaultValues() {
          return this._cache.get("getDefaultValues()", () =>
            AA(() =>
              (function (e) {
                return jA(e);
              })(CA(this.configPointer))
            )
          );
        }
        getStaticValues() {
          return this._cache.get("getStaticValues", () =>
            AA(() => {
              var e;
              const t =
                null !== (e = CA(this.pointerToStaticOverrides)) && void 0 !== e
                  ? e
                  : {};
              return CA(this.configPointer).deserializeAndSanitize(t) || {};
            })
          );
        }
        getArrayOfValidSequenceTracks() {
          return this._cache.get("getArrayOfValidSequenceTracks", () =>
            AA(() => {
              const e =
                  this.project.pointers.historic.sheetsById[
                    this.address.sheetId
                  ],
                t = CA(
                  e.sequence.tracksByObject[this.address.objectKey]
                    .trackIdByPropPath
                );
              if (!t) return PA;
              const n = [];
              if (!t) return PA;
              const i = CA(this.configPointer),
                r = Object.entries(t);
              for (const [e, t] of r) {
                const r = Vv(e);
                if (!r) continue;
                const s = fv(i, r);
                s && !pv(s) && n.push({ pathToProp: r, trackId: t });
              }
              const s = (function (e) {
                const t = Uv.get(e);
                if (t) return t;
                const n = new Map();
                return Uv.set(e, n), Fv([], e, n), n;
              })(i);
              return (
                n.sort((e, t) => {
                  const n = e.pathToProp,
                    i = t.pathToProp;
                  return s.get(JSON.stringify(n)) > s.get(JSON.stringify(i))
                    ? 1
                    : -1;
                }),
                0 === n.length ? PA : n
              );
            })
          );
        }
        getMapOfValidSequenceTracks_forStudio() {
          return this._cache.get("getMapOfValidSequenceTracks_forStudio", () =>
            AA(() => {
              const e = CA(this.getArrayOfValidSequenceTracks()),
                t = {};
              for (const { pathToProp: n, trackId: i } of e) zA(t, n, i);
              return t;
            })
          );
        }
        getStaticButNotSequencedOverrides() {
          return this._cache.get("getStaticButNotSequencedOverrides", () =>
            AA(() => {
              const e = CA(this.getStaticValues()),
                t = CA(this.getArrayOfValidSequenceTracks()),
                n = jm(e);
              for (const { pathToProp: e } of t) {
                Gv(n, e);
                let t = e.slice(0, -1);
                for (; t.length > 0; ) {
                  if (!Hv(LA(n, t))) break;
                  Gv(n, t), (t = t.slice(0, -1));
                }
              }
              return Hv(n) ? void 0 : n;
            })
          );
        }
        getDefaultsAtPointer(e) {
          const { path: t } = Vf(e);
          return LA(this.getDefaultValues().getValue(), t);
        }
      }
      function Vv(e) {
        try {
          return JSON.parse(e);
        } catch (t) {
          return void Lv.warn(
            `property ${JSON.stringify(e)} cannot be parsed. Skipping.`
          );
        }
      }
      const jv = Wm((e) => JSON.stringify(e));
      Wm((e) => JSON.parse(e));
      n(722);
      class Wv extends Error {}
      class Xv extends Wv {}
      var qv = Math.floor;
      const Yv = function (e, t) {
        var n = "";
        if (!e || t < 1 || t > 9007199254740991) return n;
        do {
          t % 2 && (n += e), (t = qv(t / 2)) && (e += e);
        } while (t);
        return n;
      };
      const Kv = function (e, t, n) {
        var i = e.length;
        return (n = void 0 === n ? i : n), !t && n >= i ? e : Nv(e, t, n);
      };
      var Jv = RegExp(
        "[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]"
      );
      const Zv = function (e) {
        return Jv.test(e);
      };
      const $v = function (e) {
        return function (t) {
          return null == t ? void 0 : t[e];
        };
      };
      const ey = $v("length");
      var ty = "\\ud800-\\udfff",
        ny = "[" + ty + "]",
        iy = "[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]",
        ry = "\\ud83c[\\udffb-\\udfff]",
        sy = "[^" + ty + "]",
        ay = "(?:\\ud83c[\\udde6-\\uddff]){2}",
        oy = "[\\ud800-\\udbff][\\udc00-\\udfff]",
        cy = "(?:" + iy + "|" + ry + ")" + "?",
        ly = "[\\ufe0e\\ufe0f]?",
        uy =
          ly +
          cy +
          ("(?:\\u200d(?:" + [sy, ay, oy].join("|") + ")" + ly + cy + ")*"),
        hy = "(?:" + [sy + iy + "?", iy, ay, oy, ny].join("|") + ")",
        dy = RegExp(ry + "(?=" + ry + ")|" + hy + uy, "g");
      const py = function (e) {
        for (var t = (dy.lastIndex = 0); dy.test(e); ) ++t;
        return t;
      };
      const fy = function (e) {
        return Zv(e) ? py(e) : ey(e);
      };
      const Ay = function (e) {
        return e.split("");
      };
      var gy = "\\ud800-\\udfff",
        my = "[" + gy + "]",
        vy = "[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]",
        yy = "\\ud83c[\\udffb-\\udfff]",
        by = "[^" + gy + "]",
        _y = "(?:\\ud83c[\\udde6-\\uddff]){2}",
        xy = "[\\ud800-\\udbff][\\udc00-\\udfff]",
        Ey = "(?:" + vy + "|" + yy + ")" + "?",
        wy = "[\\ufe0e\\ufe0f]?",
        Cy =
          wy +
          Ey +
          ("(?:\\u200d(?:" + [by, _y, xy].join("|") + ")" + wy + Ey + ")*"),
        Sy = "(?:" + [by + vy + "?", vy, _y, xy, my].join("|") + ")",
        Iy = RegExp(yy + "(?=" + yy + ")|" + Sy + Cy, "g");
      const My = function (e) {
        return e.match(Iy) || [];
      };
      const Ty = function (e) {
        return Zv(e) ? My(e) : Ay(e);
      };
      var By = Math.ceil;
      const Ry = function (e, t) {
        var n = (t = void 0 === t ? " " : Ee(t)).length;
        if (n < 2) return n ? Yv(t, e) : t;
        var i = Yv(t, By(e / fy(t)));
        return Zv(t) ? Kv(Ty(i), 0, e).join("") : i.slice(0, e);
      };
      var Dy = 1 / 0;
      const Py = function (e) {
        return e
          ? (e = cv(e)) === Dy || e === -1 / 0
            ? 17976931348623157e292 * (e < 0 ? -1 : 1)
            : e == e
            ? e
            : 0
          : 0 === e
          ? e
          : 0;
      };
      const Ly = function (e) {
        var t = Py(e),
          n = t % 1;
        return t == t ? (n ? t - n : t) : 0;
      };
      const Uy = function (e, t, n) {
        e = we(e);
        var i = (t = Ly(t)) ? fy(e) : 0;
        return t && i < t ? Ry(t - i, n) + e : e;
      };
      function Fy() {
        let e, t;
        const n = new Promise((n, r) => {
            (e = (e) => {
              n(e), (i.status = "resolved");
            }),
              (t = (e) => {
                r(e), (i.status = "rejected");
              });
          }),
          i = { resolve: e, reject: t, promise: n, status: "pending" };
        return i;
      }
      const Oy = () => {};
      class Ny {
        constructor() {
          (this._stopPlayCallback = Oy),
            (this._state = new _A({ position: 0, playing: !1 })),
            (this.statePointer = this._state.pointer);
        }
        destroy() {}
        pause() {
          this._stopPlayCallback(),
            (this.playing = !1),
            (this._stopPlayCallback = Oy);
        }
        gotoPosition(e) {
          this._updatePositionInState(e);
        }
        _updatePositionInState(e) {
          this._state.setByPointer((e) => e.position, e);
        }
        getCurrentPosition() {
          return this._state.get().position;
        }
        get playing() {
          return this._state.get().playing;
        }
        set playing(e) {
          this._state.setByPointer((e) => e.playing, e);
        }
        play(e, t, n, i, r) {
          this.playing && this.pause(), (this.playing = !0);
          const s = t[1] - t[0];
          {
            const e = this.getCurrentPosition();
            e < t[0] || e > t[1]
              ? "normal" === i || "alternate" === i
                ? this._updatePositionInState(t[0])
                : ("reverse" !== i && "alternateReverse" !== i) ||
                  this._updatePositionInState(t[1])
              : "normal" === i || "alternate" === i
              ? e === t[1] && this._updatePositionInState(t[0])
              : e === t[0] && this._updatePositionInState(t[1]);
          }
          const a = Fy(),
            o = r.time,
            c = s * e;
          let l = this.getCurrentPosition() - t[0];
          ("reverse" !== i && "alternateReverse" !== i) ||
            (l = t[1] - this.getCurrentPosition());
          const u = (r) => {
            const u = Math.max(r - o, 0) / 1e3,
              d = Math.min(u * n + l, c);
            if (d !== c) {
              const e = Math.floor(d / s);
              let n = ((d / s) % 1) * s;
              if ("normal" !== i)
                if ("reverse" === i) n = s - n;
                else {
                  const t = e % 2 == 0;
                  "alternate" === i ? t || (n = s - n) : t && (n = s - n);
                }
              this._updatePositionInState(n + t[0]), h();
            } else {
              if ("normal" === i) this._updatePositionInState(t[1]);
              else if ("reverse" === i) this._updatePositionInState(t[0]);
              else {
                const n = (e - 1) % 2 == 0;
                "alternate" === i
                  ? n
                    ? this._updatePositionInState(t[1])
                    : this._updatePositionInState(t[0])
                  : n
                  ? this._updatePositionInState(t[0])
                  : this._updatePositionInState(t[1]);
              }
              (this.playing = !1), a.resolve(!0);
            }
          };
          this._stopPlayCallback = () => {
            r.offThisOrNextTick(u),
              r.offNextTick(u),
              this.playing && a.resolve(!1);
          };
          const h = () => r.onNextTick(u);
          return r.onThisOrNextTick(u), a.promise;
        }
        playDynamicRange(e, t) {
          this.playing && this.pause(), (this.playing = !0);
          const n = Fy(),
            i = e.keepHot();
          n.promise.then(i, i);
          let r = t.time;
          const s = (t) => {
            const n = Math.max(t - r, 0);
            r = t;
            const i = n / 1e3,
              s = this.getCurrentPosition(),
              o = e.getValue();
            if (s < o[0] || s > o[1]) this.gotoPosition(o[0]);
            else {
              let e = s + i;
              e > o[1] && (e = o[0] + (e - o[1])), this.gotoPosition(e);
            }
            a();
          };
          this._stopPlayCallback = () => {
            t.offThisOrNextTick(s), t.offNextTick(s), n.resolve(!1);
          };
          const a = () => t.onNextTick(s);
          return t.onThisOrNextTick(s), n.promise;
        }
      }
      const ky = "__TheatreJS_CoreBundle",
        Qy =
          (e) =>
          (...t) => {
            var n;
            switch (e) {
              case "success":
              case "info":
                Lv.debug(t.slice(0, 2).join("\n"));
                break;
              case "warning":
                Lv.warn(t.slice(0, 2).join("\n"));
            }
            return "undefined" != typeof window
              ? null === (n = window.__TheatreJS_Notifications) || void 0 === n
                ? void 0
                : n.notify[e](...t)
              : void 0;
          },
        Gy = {
          warning: Qy("warning"),
          success: Qy("success"),
          info: Qy("info"),
          error: Qy("error"),
        };
      "undefined" != typeof window &&
        (window.addEventListener("error", (e) => {
          Gy.error(
            "An error occurred",
            `<pre>${e.message}</pre>\n\nSee **console** for details.`
          );
        }),
        window.addEventListener("unhandledrejection", (e) => {
          Gy.error(
            "An error occurred",
            `<pre>${e.reason}</pre>\n\nSee **console** for details.`
          );
        }));
      class Hy {
        constructor(e, t, n) {
          (this._decodedBuffer = e),
            (this._audioContext = t),
            (this._nodeDestination = n),
            (this._state = new _A({ position: 0, playing: !1 })),
            (this._stopPlayCallback = Oy),
            (this.statePointer = this._state.pointer),
            (this._mainGain = this._audioContext.createGain()),
            this._mainGain.connect(this._nodeDestination);
        }
        playDynamicRange(e, t) {
          const n = Fy();
          let i;
          this._playing && this.pause(), (this._playing = !0);
          const r = () => {
              null == i || i(), (i = this._loopInRange(e.getValue(), t).stop);
            },
            s = e.onStale(r);
          return (
            r(),
            (this._stopPlayCallback = () => {
              null == i || i(), s(), n.resolve(!1);
            }),
            n.promise
          );
        }
        _loopInRange(e, t) {
          let n = this.getCurrentPosition();
          const i = e[1] - e[0];
          (n < e[0] || n > e[1] || n === e[1]) &&
            this._updatePositionInState(e[0]),
            (n = this.getCurrentPosition());
          const r = this._audioContext.createBufferSource();
          (r.buffer = this._decodedBuffer),
            r.connect(this._mainGain),
            (r.playbackRate.value = 1),
            (r.loop = !0),
            (r.loopStart = e[0]),
            (r.loopEnd = e[1]);
          const s = t.time;
          let a = n - e[0];
          r.start(0, n);
          const o = (t) => {
              let n = (((1 * (Math.max(t - s, 0) / 1e3) + a) / i) % 1) * i;
              this._updatePositionInState(n + e[0]), c();
            },
            c = () => t.onNextTick(o);
          t.onThisOrNextTick(o);
          return {
            stop: () => {
              r.stop(),
                r.disconnect(),
                t.offThisOrNextTick(o),
                t.offNextTick(o);
            },
          };
        }
        get _playing() {
          return this._state.get().playing;
        }
        set _playing(e) {
          this._state.setByPointer((e) => e.playing, e);
        }
        destroy() {}
        pause() {
          this._stopPlayCallback(),
            (this._playing = !1),
            (this._stopPlayCallback = Oy);
        }
        gotoPosition(e) {
          this._updatePositionInState(e);
        }
        _updatePositionInState(e) {
          this._state.reduce((t) =>
            Object.assign(Object.assign({}, t), { position: e })
          );
        }
        getCurrentPosition() {
          return this._state.get().position;
        }
        play(e, t, n, i, r) {
          this._playing && this.pause(), (this._playing = !0);
          let s = this.getCurrentPosition();
          const a = t[1] - t[0];
          if ("normal" !== i)
            throw new Xv(
              `Audio-controlled sequences can only be played in the "normal" direction. '${i}' given.`
            );
          (s < t[0] || s > t[1] || s === t[1]) &&
            this._updatePositionInState(t[0]),
            (s = this.getCurrentPosition());
          const o = Fy(),
            c = this._audioContext.createBufferSource();
          (c.buffer = this._decodedBuffer),
            c.connect(this._mainGain),
            (c.playbackRate.value = n),
            e > 1e3 &&
              (Gy.warning(
                "Can't play sequences with audio more than 1000 times",
                `The sequence will still play, but only 1000 times. The \`iterationCount: ${e}\` provided to \`sequence.play()\`\nis too high for a sequence with audio.\n\nTo fix this, either set \`iterationCount\` to a lower value, or remove the audio from the sequence.`,
                [
                  {
                    url: "https://www.theatrejs.com/docs/latest/manual/audio",
                    title: "Using Audio",
                  },
                  {
                    url: "https://www.theatrejs.com/docs/latest/api/core#sequence.attachaudio",
                    title: "Audio API",
                  },
                ]
              ),
              (e = 1e3)),
            e > 1 && ((c.loop = !0), (c.loopStart = t[0]), (c.loopEnd = t[1]));
          const l = r.time;
          let u = s - t[0];
          const h = a * e;
          c.start(0, s, h - u);
          const d = (e) => {
              const i = Math.max(e - l, 0) / 1e3,
                r = Math.min(i * n + u, h);
              if (r !== h) {
                let e = ((r / a) % 1) * a;
                this._updatePositionInState(e + t[0]), f();
              } else
                this._updatePositionInState(t[1]),
                  (this._playing = !1),
                  p(),
                  o.resolve(!0);
            },
            p = () => {
              c.stop(), c.disconnect();
            };
          this._stopPlayCallback = () => {
            p(),
              r.offThisOrNextTick(d),
              r.offNextTick(d),
              this._playing && o.resolve(!1);
          };
          const f = () => r.onNextTick(d);
          return r.onThisOrNextTick(d), o.promise;
        }
      }
      let zy,
        Vy = 0;
      function jy() {
        let e = null;
        const t = (function (e) {
          var t;
          const n = new SA({
              onActive() {
                var t;
                null === (t = null == e ? void 0 : e.start) ||
                  void 0 === t ||
                  t.call(e);
              },
              onDormant() {
                var t;
                null === (t = null == e ? void 0 : e.stop) ||
                  void 0 === t ||
                  t.call(e);
              },
            }),
            i = {
              tick: (e) => {
                n.tick(e);
              },
              id: Vy++,
              name:
                null !== (t = null == e ? void 0 : e.name) && void 0 !== t
                  ? t
                  : `CustomRafDriver-${Vy}`,
              type: "Theatre_RafDriver_PublicAPI",
            };
          return (
            DA(i, {
              type: "Theatre_RafDriver_PrivateAPI",
              publicApi: i,
              ticker: n,
              start: null == e ? void 0 : e.start,
              stop: null == e ? void 0 : e.stop,
            }),
            i
          );
        })({
          name: "DefaultCoreRafDriver",
          start: () => {
            if ("undefined" != typeof window) {
              const n = (i) => {
                t.tick(i), (e = window.requestAnimationFrame(n));
              };
              e = window.requestAnimationFrame(n);
            } else t.tick(0), setTimeout(() => t.tick(1), 0);
          },
          stop: () => {
            "undefined" != typeof window &&
              null !== e &&
              window.cancelAnimationFrame(e);
          },
        });
        return t;
      }
      function Wy() {
        return (
          zy ||
            (function (e) {
              if (zy)
                throw new Error("`setCoreRafDriver()` is already called.");
              const t = RA(e);
              zy = t;
            })(jy()),
          zy
        );
      }
      function Xy() {
        return Wy().ticker;
      }
      var qy = function (e, t, n, i) {
        return new (n || (n = Promise))(function (r, s) {
          function a(e) {
            try {
              c(i.next(e));
            } catch (e) {
              s(e);
            }
          }
          function o(e) {
            try {
              c(i.throw(e));
            } catch (e) {
              s(e);
            }
          }
          function c(e) {
            var t;
            e.done
              ? r(e.value)
              : ((t = e.value),
                t instanceof n
                  ? t
                  : new n(function (e) {
                      e(t);
                    })).then(a, o);
          }
          c((i = i.apply(e, t || [])).next());
        });
      };
      class Yy {
        get type() {
          return "Theatre_Sequence_PublicAPI";
        }
        constructor(e) {
          DA(this, e);
        }
        play(e) {
          const t = RA(this);
          if (t._project.isReady()) {
            const n = (null == e ? void 0 : e.rafDriver)
              ? RA(e.rafDriver).ticker
              : Xy();
            return t.play(null != e ? e : {}, n);
          }
          {
            0;
            const e = Fy();
            return e.resolve(!0), e.promise;
          }
        }
        pause() {
          RA(this).pause();
        }
        get position() {
          return RA(this).position;
        }
        set position(e) {
          RA(this).position = e;
        }
        __experimental_getKeyframes(e) {
          return RA(this).getKeyframesOfSimpleProp(e);
        }
        attachAudio(e) {
          return qy(this, void 0, void 0, function* () {
            const {
                audioContext: t,
                destinationNode: n,
                decodedBuffer: i,
                gainNode: r,
              } = yield (function (e) {
                return qy(this, void 0, void 0, function* () {
                  function t() {
                    if (e.audioContext) return Promise.resolve(e.audioContext);
                    const t = new AudioContext();
                    return "running" === t.state || "undefined" == typeof window
                      ? Promise.resolve(t)
                      : new Promise((e) => {
                          const n = () => {
                              t.resume().catch((e) => {
                                console.error(e);
                              });
                            },
                            i = ["mousedown", "keydown", "touchstart"],
                            r = { capture: !0, passive: !1 };
                          i.forEach((e) => {
                            window.addEventListener(e, n, r);
                          }),
                            t.addEventListener("statechange", () => {
                              "running" === t.state &&
                                (i.forEach((e) => {
                                  window.removeEventListener(e, n, r);
                                }),
                                e(t));
                            });
                        });
                  }
                  function n() {
                    return qy(this, void 0, void 0, function* () {
                      if (e.source instanceof AudioBuffer) return e.source;
                      const t = Fy();
                      if ("string" != typeof e.source)
                        throw new Error(
                          "Error validating arguments to sequence.attachAudio(). args.source must either be a string or an instance of AudioBuffer."
                        );
                      let n, r;
                      try {
                        n = yield fetch(e.source);
                      } catch (t) {
                        throw (
                          (console.error(t),
                          new Error(
                            `Could not fetch '${e.source}'. Network error logged above.`
                          ))
                        );
                      }
                      try {
                        r = yield n.arrayBuffer();
                      } catch (t) {
                        throw (
                          (console.error(t),
                          new Error(
                            `Could not read '${e.source}' as an arrayBuffer.`
                          ))
                        );
                      }
                      let s;
                      (yield i).decodeAudioData(r, t.resolve, t.reject);
                      try {
                        s = yield t.promise;
                      } catch (t) {
                        throw (
                          (console.error(t),
                          new Error(
                            `Could not decode ${e.source} as an audio file.`
                          ))
                        );
                      }
                      return s;
                    });
                  }
                  const i = t(),
                    r = n(),
                    [s, a] = yield Promise.all([i, r]),
                    o = e.destinationNode || s.destination,
                    c = s.createGain();
                  return (
                    c.connect(o),
                    {
                      audioContext: s,
                      decodedBuffer: a,
                      gainNode: c,
                      destinationNode: o,
                    }
                  );
                });
              })(e),
              s = new Hy(i, t, r);
            return (
              RA(this).replacePlaybackController(s),
              {
                audioContext: t,
                destinationNode: n,
                decodedBuffer: i,
                gainNode: r,
              }
            );
          });
        }
        get pointer() {
          return RA(this).pointer;
        }
      }
      Jy("Theatre_Project"), Jy("Theatre_Sheet"), Jy("Theatre_SheetTemplate");
      const Ky = Jy("Theatre_SheetObject");
      Jy("Theatre_SheetObjectTemplate"),
        Jy("Theatre_Project_PublicAPI"),
        Jy("Theatre_Sheet_PublicAPI"),
        Jy("Theatre_SheetObject_PublicAPI");
      function Jy(e) {
        return (t) => "object" == typeof t && !!t && t.type === e;
      }
      var Zy = function (e, t, n, i) {
        return new (n || (n = Promise))(function (r, s) {
          function a(e) {
            try {
              c(i.next(e));
            } catch (e) {
              s(e);
            }
          }
          function o(e) {
            try {
              c(i.throw(e));
            } catch (e) {
              s(e);
            }
          }
          function c(e) {
            var t;
            e.done
              ? r(e.value)
              : ((t = e.value),
                t instanceof n
                  ? t
                  : new n(function (e) {
                      e(t);
                    })).then(a, o);
          }
          c((i = i.apply(e, t || [])).next());
        });
      };
      class $y {
        constructor(e, t, n, i, r) {
          (this._project = e),
            (this._sheet = t),
            (this._lengthD = n),
            (this._subUnitsPerUnitD = i),
            (this.pointer = Wf({ root: this, path: [] })),
            (this.$$isPointerToPrismProvider = !0),
            (this.closestGridPosition = (e) => {
              const t = 1 / this.subUnitsPerUnit;
              return parseFloat((Math.round(e / t) * t).toFixed(3));
            }),
            (this._logger = e._logger
              .named("Sheet", t.address.sheetId)
              .named("Instance", t.address.sheetInstanceId)),
            (this.address = Object.assign(
              Object.assign({}, this._sheet.address),
              { sequenceName: "default" }
            )),
            (this.publicApi = new Yy(this)),
            (this._playbackControllerBox = new _A(null != r ? r : new Ny())),
            (this._prismOfStatePointer = AA(
              () => this._playbackControllerBox.prism.getValue().statePointer
            )),
            (this._positionD = AA(() => {
              const e = this._prismOfStatePointer.getValue();
              return CA(e.position);
            })),
            (this._positionFormatterD = AA(() => {
              const e = CA(this._subUnitsPerUnitD);
              return new eb(e);
            }));
        }
        pointerToPrism(e) {
          const { path: t } = Vf(e);
          if (0 === t.length)
            return AA(() => ({
              length: CA(this.pointer.length),
              playing: CA(this.pointer.playing),
              position: CA(this.pointer.position),
            }));
          if (t.length > 1) return AA(() => {});
          const [n] = t;
          return "length" === n
            ? this._lengthD
            : "position" === n
            ? this._positionD
            : AA(
                "playing" === n
                  ? () => CA(this._prismOfStatePointer.getValue().playing)
                  : () => {}
              );
        }
        getKeyframesOfSimpleProp(e) {
          const { path: t, root: n } = Vf(e);
          if (!Ky(n))
            throw new Xv(
              "Argument prop must be a pointer to a SheetObject property"
            );
          const i = CA(
            this._project.pointers.historic.sheetsById[
              this._sheet.address.sheetId
            ].sequence.tracksByObject[n.address.objectKey]
          );
          if (!i) return [];
          const { trackData: r, trackIdByPropPath: s } = i,
            a = s[jv(t)];
          if (!a) return [];
          const o = r[a];
          return o ? Xm.getSortedKeyframesCached(o.keyframes) : [];
        }
        get positionFormatter() {
          return this._positionFormatterD.getValue();
        }
        get prismOfStatePointer() {
          return this._prismOfStatePointer;
        }
        get length() {
          return this._lengthD.getValue();
        }
        get positionPrism() {
          return this._positionD;
        }
        get position() {
          return this._playbackControllerBox.get().getCurrentPosition();
        }
        get subUnitsPerUnit() {
          return this._subUnitsPerUnitD.getValue();
        }
        get positionSnappedToGrid() {
          return this.closestGridPosition(this.position);
        }
        set position(e) {
          let t = e;
          this.pause(), t > this.length && (t = this.length);
          const n = this.length;
          this._playbackControllerBox.get().gotoPosition(t > n ? n : t);
        }
        getDurationCold() {
          return this._lengthD.getValue();
        }
        get playing() {
          return CA(this._playbackControllerBox.get().statePointer.playing);
        }
        _makeRangeFromSequenceTemplate() {
          return AA(() => [0, CA(this._lengthD)]);
        }
        playDynamicRange(e, t) {
          return this._playbackControllerBox.get().playDynamicRange(e, t);
        }
        play(e, t) {
          return Zy(this, void 0, void 0, function* () {
            const n = this.length,
              i = e && e.range ? e.range : [0, n];
            const r =
              e && "number" == typeof e.iterationCount ? e.iterationCount : 1;
            const s = e && void 0 !== e.rate ? e.rate : 1;
            const a = e && e.direction ? e.direction : "normal";
            return yield this._play(r, [i[0], i[1]], s, a, t);
          });
        }
        _play(e, t, n, i, r) {
          return this._playbackControllerBox.get().play(e, t, n, i, r);
        }
        pause() {
          this._playbackControllerBox.get().pause();
        }
        replacePlaybackController(e) {
          this.pause();
          const t = this._playbackControllerBox.get();
          this._playbackControllerBox.set(e);
          const n = t.getCurrentPosition();
          t.destroy(), e.gotoPosition(n);
        }
      }
      class eb {
        constructor(e) {
          this._fps = e;
        }
        formatSubUnitForGrid(e) {
          const t = e % 1,
            n = 1 / this._fps;
          return Math.round(t / n) + "f";
        }
        formatFullUnitForGrid(e) {
          let t = e,
            n = "";
          if (t >= ib) {
            (n += Math.floor(t / ib) + "h"), (t %= ib);
          }
          if (t >= nb) {
            (n += Math.floor(t / nb) + "m"), (t %= nb);
          }
          if (t >= tb) {
            (n += Math.floor(t / tb) + "s"), (t %= tb);
          }
          const i = 1 / this._fps;
          if (t >= i) {
            (n += Math.floor(t / i) + "f"), (t %= i);
          }
          return 0 === n.length ? "0s" : n;
        }
        formatForPlayhead(e) {
          let t = e,
            n = "";
          if (t >= ib) {
            const e = Math.floor(t / ib);
            (n += Uy(e.toString(), 2, "0") + "h"), (t %= ib);
          }
          if (t >= nb) {
            const e = Math.floor(t / nb);
            (n += Uy(e.toString(), 2, "0") + "m"), (t %= nb);
          } else n.length > 0 && (n += "00m");
          if (t >= tb) {
            const e = Math.floor(t / tb);
            (n += Uy(e.toString(), 2, "0") + "s"), (t %= tb);
          } else n += "00s";
          const i = 1 / this._fps;
          if (t >= i) {
            const e = Math.round(t / i);
            (n += Uy(e.toString(), 2, "0") + "f"), (t %= i);
          } else if (t / i > 0.98) {
            (n += Uy((1).toString(), 2, "0") + "f"), (t %= i);
          } else n += "00f";
          return 0 === n.length ? "00s00f" : n;
        }
        formatBasic(e) {
          return e.toFixed(2) + "s";
        }
      }
      const tb = 1,
        nb = 60 * tb,
        ib = 60 * nb;
      const rb = function (e, t, n) {
        return (
          e == e &&
            (void 0 !== n && (e = e <= n ? e : n),
            void 0 !== t && (e = e >= t ? e : t)),
          e
        );
      };
      const sb = function (e, t, n) {
        return (
          void 0 === n && ((n = t), (t = void 0)),
          void 0 !== n && (n = (n = cv(n)) == n ? n : 0),
          void 0 !== t && (t = (t = cv(t)) == t ? t : 0),
          rb(cv(e), t, n)
        );
      };
      function ab(e, { removeAlphaIfOpaque: t = !1 } = {}) {
        const n = ((255 * e.a) | 256).toString(16).slice(1);
        return `#${
          ((255 * e.r) | 256).toString(16).slice(1) +
          ((255 * e.g) | 256).toString(16).slice(1) +
          ((255 * e.b) | 256).toString(16).slice(1) +
          (t && "ff" === n ? "" : n)
        }`;
      }
      const ob = Wm((e) => {
        const t = Object.assign({}, e);
        return (
          Object.defineProperty(t, "toString", {
            value: () => ab(e),
            enumerable: !1,
            writable: !1,
            configurable: !1,
          }),
          t
        );
      });
      function cb(e) {
        function t(e) {
          return e >= 0.0031308
            ? 1.055 * Math.pow(e, 1 / 2.4) - 0.055
            : 12.92 * e;
        }
        return (function (e) {
          return Object.fromEntries(
            Object.entries(e).map(([e, t]) => [e, sb(t, 0, 1)])
          );
        })({ r: t(e.r), g: t(e.g), b: t(e.b), a: e.a });
      }
      function lb(e) {
        function t(e) {
          return e >= 0.04045 ? Math.pow((e + 0.055) / 1.055, 2.4) : e / 12.92;
        }
        return { r: t(e.r), g: t(e.g), b: t(e.b), a: e.a };
      }
      function ub(e) {
        let t = 0.4122214708 * e.r + 0.5363325363 * e.g + 0.0514459929 * e.b,
          n = 0.2119034982 * e.r + 0.6806995451 * e.g + 0.1073969566 * e.b,
          i = 0.0883024619 * e.r + 0.2817188376 * e.g + 0.6299787005 * e.b,
          r = Math.cbrt(t),
          s = Math.cbrt(n),
          a = Math.cbrt(i);
        return {
          L: 0.2104542553 * r + 0.793617785 * s - 0.0040720468 * a,
          a: 1.9779984951 * r - 2.428592205 * s + 0.4505937099 * a,
          b: 0.0259040371 * r + 0.7827717662 * s - 0.808675766 * a,
          alpha: e.a,
        };
      }
      const hb = (function (e) {
        return function (t, n, i) {
          for (var r = -1, s = Object(t), a = i(t), o = a.length; o--; ) {
            var c = a[e ? o : ++r];
            if (!1 === n(s[c], c, s)) break;
          }
          return t;
        };
      })();
      const db = function (e, t) {
        return e && hb(e, t, Dg);
      };
      const pb = function (e) {
        return this.__data__.set(e, "__lodash_hash_undefined__"), this;
      };
      const fb = function (e) {
        return this.__data__.has(e);
      };
      function Ab(e) {
        var t = -1,
          n = null == e ? 0 : e.length;
        for (this.__data__ = new de(); ++t < n; ) this.add(e[t]);
      }
      (Ab.prototype.add = Ab.prototype.push = pb), (Ab.prototype.has = fb);
      const gb = Ab;
      const mb = function (e, t) {
        for (var n = -1, i = null == e ? 0 : e.length; ++n < i; )
          if (t(e[n], n, e)) return !0;
        return !1;
      };
      const vb = function (e, t) {
        return e.has(t);
      };
      const yb = function (e, t, n, i, r, s) {
        var a = 1 & n,
          o = e.length,
          c = t.length;
        if (o != c && !(a && c > o)) return !1;
        var l = s.get(e),
          u = s.get(t);
        if (l && u) return l == t && u == e;
        var h = -1,
          d = !0,
          p = 2 & n ? new gb() : void 0;
        for (s.set(e, t), s.set(t, e); ++h < o; ) {
          var f = e[h],
            A = t[h];
          if (i) var g = a ? i(A, f, h, t, e, s) : i(f, A, h, e, t, s);
          if (void 0 !== g) {
            if (g) continue;
            d = !1;
            break;
          }
          if (p) {
            if (
              !mb(t, function (e, t) {
                if (!vb(p, t) && (f === e || r(f, e, n, i, s)))
                  return p.push(t);
              })
            ) {
              d = !1;
              break;
            }
          } else if (f !== A && !r(f, A, n, i, s)) {
            d = !1;
            break;
          }
        }
        return s.delete(e), s.delete(t), d;
      };
      const bb = function (e) {
        var t = -1,
          n = Array(e.size);
        return (
          e.forEach(function (e, i) {
            n[++t] = [i, e];
          }),
          n
        );
      };
      const _b = function (e) {
        var t = -1,
          n = Array(e.size);
        return (
          e.forEach(function (e) {
            n[++t] = e;
          }),
          n
        );
      };
      var xb = s ? s.prototype : void 0,
        Eb = xb ? xb.valueOf : void 0;
      const wb = function (e, t, n, i, r, s, a) {
        switch (n) {
          case "[object DataView]":
            if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
              return !1;
            (e = e.buffer), (t = t.buffer);
          case "[object ArrayBuffer]":
            return !(e.byteLength != t.byteLength || !s(new _m(e), new _m(t)));
          case "[object Boolean]":
          case "[object Date]":
          case "[object Number]":
            return q(+e, +t);
          case "[object Error]":
            return e.name == t.name && e.message == t.message;
          case "[object RegExp]":
          case "[object String]":
            return e == t + "";
          case "[object Map]":
            var o = bb;
          case "[object Set]":
            var c = 1 & i;
            if ((o || (o = _b), e.size != t.size && !c)) return !1;
            var l = a.get(e);
            if (l) return l == t;
            (i |= 2), a.set(e, t);
            var u = yb(o(e), o(t), i, r, s, a);
            return a.delete(e), u;
          case "[object Symbol]":
            if (Eb) return Eb.call(e) == Eb.call(t);
        }
        return !1;
      };
      var Cb = Object.prototype.hasOwnProperty;
      const Sb = function (e, t, n, i, r, s) {
        var a = 1 & n,
          o = tm(e),
          c = o.length;
        if (c != tm(t).length && !a) return !1;
        for (var l = c; l--; ) {
          var u = o[l];
          if (!(a ? u in t : Cb.call(t, u))) return !1;
        }
        var h = s.get(e),
          d = s.get(t);
        if (h && d) return h == t && d == e;
        var p = !0;
        s.set(e, t), s.set(t, e);
        for (var f = a; ++l < c; ) {
          var A = e[(u = o[l])],
            g = t[u];
          if (i) var m = a ? i(g, A, u, t, e, s) : i(A, g, u, e, t, s);
          if (!(void 0 === m ? A === g || r(A, g, n, i, s) : m)) {
            p = !1;
            break;
          }
          f || (f = "constructor" == u);
        }
        if (p && !f) {
          var v = e.constructor,
            y = t.constructor;
          v == y ||
            !("constructor" in e) ||
            !("constructor" in t) ||
            ("function" == typeof v &&
              v instanceof v &&
              "function" == typeof y &&
              y instanceof y) ||
            (p = !1);
        }
        return s.delete(e), s.delete(t), p;
      };
      var Ib = "[object Arguments]",
        Mb = "[object Array]",
        Tb = "[object Object]",
        Bb = Object.prototype.hasOwnProperty;
      const Rb = function (t, n, i, r, s, a) {
        var o = e(t),
          c = e(n),
          l = o ? Mb : vm(t),
          u = c ? Mb : vm(n),
          h = (l = l == Ib ? Tb : l) == Tb,
          d = (u = u == Ib ? Tb : u) == Tb,
          p = l == u;
        if (p && pg(t)) {
          if (!pg(n)) return !1;
          (o = !0), (h = !1);
        }
        if (p && !h)
          return (
            a || (a = new eg()),
            o || Eg(t) ? yb(t, n, i, r, s, a) : wb(t, n, l, i, r, s, a)
          );
        if (!(1 & i)) {
          var f = h && Bb.call(t, "__wrapped__"),
            A = d && Bb.call(n, "__wrapped__");
          if (f || A) {
            var g = f ? t.value() : t,
              m = A ? n.value() : n;
            return a || (a = new eg()), s(g, m, i, r, a);
          }
        }
        return !!p && (a || (a = new eg()), Sb(t, n, i, r, s, a));
      };
      const Db = function e(t, n, i, r, s) {
        return (
          t === n ||
          (null == t || null == n || (!A(t) && !A(n))
            ? t != t && n != n
            : Rb(t, n, i, r, e, s))
        );
      };
      const Pb = function (e, t, n, i) {
        var r = n.length,
          s = r,
          a = !i;
        if (null == e) return !s;
        for (e = Object(e); r--; ) {
          var o = n[r];
          if (a && o[2] ? o[1] !== e[o[0]] : !(o[0] in e)) return !1;
        }
        for (; ++r < s; ) {
          var c = (o = n[r])[0],
            l = e[c],
            u = o[1];
          if (a && o[2]) {
            if (void 0 === l && !(c in e)) return !1;
          } else {
            var h = new eg();
            if (i) var d = i(l, u, c, e, t, h);
            if (!(void 0 === d ? Db(u, l, 3, i, h) : d)) return !1;
          }
        }
        return !0;
      };
      const Lb = function (e) {
        return e == e && !b(e);
      };
      const Ub = function (e) {
        for (var t = Dg(e), n = t.length; n--; ) {
          var i = t[n],
            r = e[i];
          t[n] = [i, r, Lb(r)];
        }
        return t;
      };
      const Fb = function (e, t) {
        return function (n) {
          return null != n && n[e] === t && (void 0 !== t || e in Object(n));
        };
      };
      const Ob = function (e) {
        var t = Ub(e);
        return 1 == t.length && t[0][2]
          ? Fb(t[0][0], t[0][1])
          : function (n) {
              return n === e || Pb(n, e, t);
            };
      };
      const Nb = function (e, t) {
        return null != e && t in Object(e);
      };
      const kb = function (t, n, i) {
        for (var r = -1, s = (n = Ce(n, t)).length, a = !1; ++r < s; ) {
          var o = Se(n[r]);
          if (!(a = null != t && i(t, o))) break;
          t = t[o];
        }
        return a || ++r != s
          ? a
          : !!(s = null == t ? 0 : t.length) &&
              fg(s) &&
              GA(o, s) &&
              (e(t) || cg(t));
      };
      const Qb = function (e, t) {
        return null != e && kb(e, t, Nb);
      };
      const Gb = function (e, t) {
        return y(e) && Lb(t)
          ? Fb(Se(e), t)
          : function (n) {
              var i = Me(n, e);
              return void 0 === i && i === t ? Qb(n, e) : Db(t, i, 3);
            };
      };
      const Hb = function (e) {
        return e;
      };
      const zb = function (e) {
        return function (t) {
          return Ie(t, e);
        };
      };
      const Vb = function (e) {
        return y(e) ? $v(Se(e)) : zb(e);
      };
      const jb = function (t) {
        return "function" == typeof t
          ? t
          : null == t
          ? Hb
          : "object" == typeof t
          ? e(t)
            ? Gb(t[0], t[1])
            : Ob(t)
          : Vb(t);
      };
      const Wb = function (e, t) {
        var n = {};
        return (
          (t = jb(t, 3)),
          db(e, function (e, i, r) {
            OA(n, i, t(e, i, r));
          }),
          n
        );
      };
      function Xb(e, t) {
        return e.length <= t ? e : e.substr(0, t - 3) + "...";
      }
      const qb = (e) =>
          "string" == typeof e
            ? `string("${Xb(e, 10)}")`
            : "number" == typeof e
            ? `number(${Xb(String(e), 10)})`
            : null === e
            ? "null"
            : void 0 === e
            ? "undefined"
            : "boolean" == typeof e
            ? String(e)
            : Array.isArray(e)
            ? "array"
            : "object" == typeof e
            ? "object"
            : "unknown",
        Yb = Symbol("TheatrePropType_Basic");
      function Kb(e) {
        return "object" == typeof e && !!e && "TheatrePropType" === e[Yb];
      }
      function Jb(e) {
        if ("number" == typeof e) return $b(e);
        if ("boolean" == typeof e) return a_(e);
        if ("string" == typeof e) return l_(e);
        if ("object" == typeof e && e) {
          if (Kb(e)) return e;
          if (Of(e)) return Zb(e);
          throw new Xv(`This value is not a valid prop type: ${qb(e)}`);
        }
        throw new Xv(`This value is not a valid prop type: ${qb(e)}`);
      }
      const Zb = (e, t = {}) => {
          const n = (function (e) {
              const t = {};
              for (const n of Object.keys(e)) {
                const i = e[n];
                Kb(i) ? (t[n] = i) : (t[n] = Jb(i));
              }
              return t;
            })(e),
            i = new WeakMap(),
            r = {
              type: "compound",
              props: n,
              valueType: null,
              [Yb]: "TheatrePropType",
              label: t.label,
              default: Wb(n, (e) => e.default),
              deserializeAndSanitize: (e) => {
                if ("object" != typeof e || !e) return;
                if (i.has(e)) return i.get(e);
                const t = {};
                let r = !1;
                for (const [i, s] of Object.entries(n))
                  if (Object.prototype.hasOwnProperty.call(e, i)) {
                    const n = s.deserializeAndSanitize(e[i]);
                    null != n && ((r = !0), (t[i] = n));
                  }
                return i.set(e, t), r ? t : void 0;
              },
            };
          return r;
        },
        $b = (e, t = {}) => {
          var n;
          return Object.assign(
            Object.assign(
              {
                type: "number",
                valueType: 0,
                default: e,
                [Yb]: "TheatrePropType",
              },
              t || {}
            ),
            {
              label: t.label,
              nudgeFn: null !== (n = t.nudgeFn) && void 0 !== n ? n : h_,
              nudgeMultiplier:
                "number" == typeof t.nudgeMultiplier
                  ? t.nudgeMultiplier
                  : void 0,
              interpolate: n_,
              deserializeAndSanitize: e_(t.range),
            }
          );
        },
        e_ = (e) =>
          e
            ? (t) => {
                if ("number" == typeof t && isFinite(t))
                  return sb(t, e[0], e[1]);
              }
            : t_,
        t_ = (e) => ("number" == typeof e && isFinite(e) ? e : void 0),
        n_ = (e, t, n) => e + n * (t - e),
        i_ = (e = { r: 0, g: 0, b: 0, a: 1 }, t = {}) => {
          const n = {};
          for (const t of ["r", "g", "b", "a"])
            n[t] = Math.min(Math.max(e[t], 0), 1);
          return {
            type: "rgba",
            valueType: null,
            default: ob(n),
            [Yb]: "TheatrePropType",
            label: t.label,
            interpolate: s_,
            deserializeAndSanitize: r_,
          };
        },
        r_ = (e) => {
          if (!e) return;
          let t = !0;
          for (const n of ["r", "g", "b", "a"])
            (Object.prototype.hasOwnProperty.call(e, n) &&
              "number" == typeof e[n]) ||
              (t = !1);
          if (!t) return;
          const n = {};
          for (const t of ["r", "g", "b", "a"])
            n[t] = Math.min(Math.max(e[t], 0), 1);
          return ob(n);
        },
        s_ = (e, t, n) => {
          const i = ub(lb(e)),
            r = ub(lb(t)),
            s = cb(
              (function (e) {
                let t = e.L + 0.3963377774 * e.a + 0.2158037573 * e.b,
                  n = e.L - 0.1055613458 * e.a - 0.0638541728 * e.b,
                  i = e.L - 0.0894841775 * e.a - 1.291485548 * e.b,
                  r = t * t * t,
                  s = n * n * n,
                  a = i * i * i;
                return {
                  r: 4.0767416621 * r - 3.3077115913 * s + 0.2309699292 * a,
                  g: -1.2684380046 * r + 2.6097574011 * s - 0.3413193965 * a,
                  b: -0.0041960863 * r - 0.7034186147 * s + 1.707614701 * a,
                  a: e.alpha,
                };
              })({
                L: (1 - n) * i.L + n * r.L,
                a: (1 - n) * i.a + n * r.a,
                b: (1 - n) * i.b + n * r.b,
                alpha: (1 - n) * i.alpha + n * r.alpha,
              })
            );
          return ob(s);
        },
        a_ = (e, t = {}) => {
          var n;
          return {
            type: "boolean",
            default: e,
            valueType: null,
            [Yb]: "TheatrePropType",
            label: t.label,
            interpolate: null !== (n = t.interpolate) && void 0 !== n ? n : c_,
            deserializeAndSanitize: o_,
          };
        },
        o_ = (e) => ("boolean" == typeof e ? e : void 0);
      function c_(e) {
        return e;
      }
      const l_ = (e, t = {}) => {
        var n;
        return {
          type: "string",
          default: e,
          valueType: null,
          [Yb]: "TheatrePropType",
          label: t.label,
          interpolate: null !== (n = t.interpolate) && void 0 !== n ? n : c_,
          deserializeAndSanitize: u_,
        };
      };
      function u_(e) {
        return "string" == typeof e ? e : void 0;
      }
      const h_ = ({ config: e, deltaX: t, deltaFraction: n, magnitude: i }) => {
        var r;
        const { range: s } = e;
        return e.nudgeMultiplier ||
          !s ||
          s.includes(1 / 0) ||
          s.includes(-1 / 0)
          ? t * i * (null !== (r = e.nudgeMultiplier) && void 0 !== r ? r : 1)
          : n * (s[1] - s[0]) * i;
      };
      function d_(e, t, n) {
        const i = ((e) =>
          e
            .replace(/^[\s\/]*/, "")
            .replace(/[\s\/]*$/, "")
            .replace(/\s*\/\s*/g, " / "))(e);
        return i;
      }
      new WeakMap();
      class p_ {
        get type() {
          return "Theatre_Sheet_PublicAPI";
        }
        constructor(e) {
          DA(this, e);
        }
        object(e, t, n) {
          const i = RA(this),
            r = d_(e, 0, Gy.warning),
            s = i.getObject(r),
            a =
              null == n
                ? void 0
                : n.__actions__THIS_API_IS_UNSTABLE_AND_WILL_CHANGE_IN_THE_NEXT_VERSION;
          if (s) return a && s.template._temp_setActions(a), s.publicApi;
          {
            const e = Zb(t);
            return i.createObject(r, null, e, a).publicApi;
          }
        }
        get sequence() {
          return RA(this).getSequence().publicApi;
        }
        get project() {
          return RA(this).project.publicApi;
        }
        get address() {
          return Object.assign({}, RA(this).address);
        }
        detachObject(e) {
          const t = RA(this),
            n = d_(e, 0, Gy.warning);
          if (!t.getObject(n))
            return (
              Gy.warning(
                `Couldn't delete object "${n}"`,
                `There is no object with key "${n}".\n\nTo fix this, make sure you are calling \`sheet.deleteObject("${n}")\` with the correct key.`
              ),
              void console.warn(`Object key "${n}" does not exist.`)
            );
          t.deleteObject(n);
        }
      }
      const f_ = function (e) {
        return "number" == typeof e && e == Ly(e);
      };
      class A_ {
        constructor(e, t) {
          (this.template = e),
            (this.instanceId = t),
            (this._objects = new _A({})),
            (this.objectsP = this._objects.pointer),
            (this.type = "Theatre_Sheet"),
            (this._logger = e.project._logger.named("Sheet", t)),
            this._logger._trace("creating sheet"),
            (this.project = e.project),
            (this.address = Object.assign(Object.assign({}, e.address), {
              sheetInstanceId: this.instanceId,
            })),
            (this.publicApi = new p_(this));
        }
        createObject(e, t, n, i = {}) {
          const r = this.template
            .getObjectTemplate(e, t, n, i)
            .createInstance(this, t, n);
          return this._objects.setByPointer((t) => t[e], r), r;
        }
        getObject(e) {
          return this._objects.get()[e];
        }
        deleteObject(e) {
          this._objects.reduce((t) => {
            const n = Object.assign({}, t);
            return delete n[e], n;
          });
        }
        getSequence() {
          if (!this._sequence) {
            const e = AA(() => {
                const e = CA(
                  this.project.pointers.historic.sheetsById[
                    this.address.sheetId
                  ].sequence.length
                );
                return g_(e);
              }),
              t = AA(() => {
                const e = CA(
                  this.project.pointers.historic.sheetsById[
                    this.address.sheetId
                  ].sequence.subUnitsPerUnit
                );
                return m_(e);
              });
            this._sequence = new $y(this.template.project, this, e, t);
          }
          return this._sequence;
        }
      }
      const g_ = (e) => ("number" == typeof e && isFinite(e) && e > 0 ? e : 10),
        m_ = (e) =>
          "number" == typeof e && f_(e) && e >= 1 && e <= 1e3 ? e : 30;
      class v_ {
        constructor(e, t) {
          (this.project = e),
            (this.type = "Theatre_SheetTemplate"),
            (this._instances = new _A({})),
            (this.instancesP = this._instances.pointer),
            (this._objectTemplates = new _A({})),
            (this.objectTemplatesP = this._objectTemplates.pointer),
            (this.address = Object.assign(Object.assign({}, e.address), {
              sheetId: t,
            }));
        }
        getInstance(e) {
          let t = this._instances.get()[e];
          return (
            t ||
              ((t = new A_(this, e)),
              this._instances.setByPointer((t) => t[e], t)),
            t
          );
        }
        getObjectTemplate(e, t, n, i) {
          let r = this._objectTemplates.get()[e];
          return (
            r ||
              ((r = new zv(this, e, t, n, i)),
              this._objectTemplates.setByPointer((t) => t[e], r)),
            r
          );
        }
      }
      const y_ = { currentProjectStateDefinitionVersion: "0.4.0" };
      function b_() {}
      function __(e) {
        var t, n;
        const i = (
            null === (t = null == e ? void 0 : e.logging) || void 0 === t
              ? void 0
              : t.internal
          )
            ? null !== (n = e.logging.min) && void 0 !== n
              ? n
              : bv.WARN
            : 1 / 0,
          r = i <= bv.DEBUG,
          s = i <= bv.ERROR,
          a = Iv(void 0, {
            _debug: r
              ? console.debug.bind(
                  console,
                  "_coreLogger(TheatreInternalLogger) debug"
                )
              : b_,
            _error: s
              ? console.error.bind(
                  console,
                  "_coreLogger(TheatreInternalLogger) error"
                )
              : b_,
          });
        if (e) {
          const { logger: t, logging: n } = e;
          t && a.configureLogger(t),
            n ? a.configureLogging(n) : a.configureLogging({ dev: !1 });
        }
        return a.getLogger().named("Theatre");
      }
      class x_ {
        constructor(e, t = {}, n) {
          var i;
          (this.config = t),
            (this.publicApi = n),
            (this._sheetTemplates = new _A({})),
            (this.sheetTemplatesP = this._sheetTemplates.pointer),
            (this.type = "Theatre_Project"),
            (this._logger = __({ logging: { dev: !0 } }).named("Project", e)),
            this._logger.traceDev("creating project"),
            (this.address = { projectId: e });
          const r = new _A({
            loadingState: { type: "loaded" },
            lastExportedObject: null,
          });
          t.state &&
            Object.values(t.state.sheetsById).forEach((e) =>
              Object.values(e.sequence.tracksByObject).forEach((e) =>
                Object.values(e.trackData).forEach((e) => {
                  e.keyframes = Xm.fromArray(e.keyframes);
                })
              )
            );
          const s = new _A({
            historic:
              null !== (i = t.state) && void 0 !== i
                ? i
                : {
                    sheetsById: {},
                    definitionVersion: y_.currentProjectStateDefinitionVersion,
                    revisionHistory: [],
                  },
          });
          (this.diskStateAtom = s),
            (this._assetStorageReadyDeferred = Fy()),
            (this.assetStorage = {
              getAssetUrl: (e) => {
                var n;
                return `${
                  null === (n = t.assets) || void 0 === n ? void 0 : n.baseUrl
                }/${e}`;
              },
              createAsset: () => {
                throw new Error("Please wait for Project.ready to use assets.");
              },
            }),
            (this._pointerProxies = {
              historic: new IA(s.pointer.historic),
              ephemeral: new IA(r.pointer),
            }),
            (this.pointers = {
              historic: this._pointerProxies.historic.pointer,
              ephemeral: this._pointerProxies.ephemeral.pointer,
            }),
            TA.add(e, this),
            (this._studioReadyDeferred = Fy()),
            this._studioReadyDeferred.resolve(void 0),
            this._assetStorageReadyDeferred.resolve(void 0),
            (this._readyPromise = Promise.all([
              this._studioReadyDeferred.promise,
              this._assetStorageReadyDeferred.promise,
            ]).then(() => {})),
            t.state ||
              ("undefined" == typeof window &&
                console.error(
                  `Argument config.state in Theatre.getProject("${e}", config) is empty. You can safely ignore this message if you're developing a Next.js/Remix project in development mode. But if you are shipping to your end-users, then you need to set config.state, otherwise your project's state will be empty and nothing will animate. Learn more at https://www.theatrejs.com/docs/latest/manual/projects#state`
                ));
        }
        attachToStudio() {
          throw new Error(
            "Studio has been removed! This function should not be called anymore"
          );
        }
        get isAttachedToStudio() {
          return (
            console.error(
              "Studio has been removed! This function shouldn't be called anymore"
            ),
            !1
          );
        }
        get ready() {
          return this._readyPromise;
        }
        isReady() {
          return (
            "resolved" === this._studioReadyDeferred.status &&
            "resolved" === this._assetStorageReadyDeferred.status
          );
        }
        getOrCreateSheet(e, t = "default") {
          let n = this._sheetTemplates.get()[e];
          return (
            n ||
              ((n = new v_(this, e)),
              this._sheetTemplates.reduce((t) =>
                Object.assign(Object.assign({}, t), { [e]: n })
              )),
            n.getInstance(t)
          );
        }
      }
      class E_ {
        get type() {
          return "Theatre_Project_PublicAPI";
        }
        constructor(e, t = {}) {
          DA(this, new x_(e, t, this));
        }
        get ready() {
          return RA(this).ready;
        }
        get isReady() {
          return RA(this).isReady();
        }
        get address() {
          return Object.assign({}, RA(this).address);
        }
        getAssetUrl(e) {
          if (this.isReady)
            return e.id ? RA(this).assetStorage.getAssetUrl(e.id) : void 0;
          console.error(
            "Calling `project.getAssetUrl()` before `project.ready` is resolved, will always return `undefined`. Either use `project.ready.then(() => project.getAssetUrl())` or `await project.ready` before calling `project.getAssetUrl()`."
          );
        }
        sheet(e, t = "default") {
          const n = d_(e, 0, Gy.warning);
          return RA(this).getOrCreateSheet(n, t).publicApi;
        }
        setState(e) {
          RA(this).diskStateAtom.setByPointer(
            RA(this).diskStateAtom.pointer.historic.sheetsById,
            e
          );
        }
      }
      n(792);
      const w_ = (e, t) => {
        ((e, t) => {
          if (
            Array.isArray(t) ||
            null == t ||
            t.definitionVersion !== y_.currentProjectStateDefinitionVersion
          )
            throw new Xv(
              `Error validating conf.state in Theatre.getProject(${JSON.stringify(
                e
              )}, conf). The state seems to be formatted in a way that is unreadable to Theatre.js. Read more at https://www.theatrejs.com/docs/latest/manual/projects#state`
            );
        })(e, t);
      };
      class C_ {
        constructor() {}
        get type() {
          return "Theatre_CoreBundle";
        }
        get version() {
          return process.env.THEATRE_VERSION;
        }
        getBitsForStudio(e, t) {
          throw new Error(
            "Studio has been removed! This function shouldn't be called anymore"
          );
        }
      }
      function S_(e) {
        return `${e.uuid}`;
      }
      !(function () {
        if (
          "undefined" == typeof window &&
          !0 !== n.g.__THEATREJS__FORCE_CONNECT_CORE_AND_STUDIO
        )
          return;
        const e = "undefined" != typeof window ? window : n.g,
          t = e[ky];
        if (void 0 !== t) {
          if ("object" == typeof t && t && "string" == typeof t.version)
            throw new Error(
              "It seems that the module '@theatre-local/core' is loaded more than once. This could have two possible causes:\n1. You might have two separate versions of Theatre.js in node_modules.\n2. Or this might be a bundling misconfiguration, in case you're using a bundler like Webpack/ESBuild/Rollup.\n\nNote that it **is okay** to import '@theatre-local/core' multiple times. But those imports should point to the same module."
            );
          console.warn(
            `The variable window.${ky} seems to be already set by a module other than @theatre-local/core.`
          );
        }
        const i = new C_();
        e[ky] = i;
      })();
      const I_ = "DEFAULT_ANIMATION_SHEET_NAME",
        M_ = 10,
        T_ = [
          "color",
          "emissive",
          "specular",
          "specularColor",
          "attenuationColor",
          "sheenColor",
        ],
        B_ = -911231231231232,
        R_ = { r: -1, g: -1, b: -1, a: 0.5 };
      function D_(e, t) {
        let n = !0;
        const i = (function (e, t = {}) {
            const n = TA.get(e);
            if (n) return n.publicApi;
            const i = __().named("Project", e);
            return (
              t.state
                ? (w_(e, t.state),
                  i._debug("deep validated config.state on disk"))
                : i._debug("no config.state"),
              new E_(e, t)
            );
          })(e, { state: t }),
          r = new Map();
        return {
          getAnimation: function (e) {
            const t = i.sheet(e);
            return {
              play: function () {
                t.sequence.play({ rate: 1 / M_ });
              },
              pause: function () {
                t.sequence.pause();
              },
              setPosition: function (e) {
                t.sequence.position = e;
              },
              animateObject3D: function (e) {
                if (r.has(e.uuid)) return;
                function i(e, t) {
                  t.x !== B_ && (e.x = t.x),
                    t.y !== B_ && (e.y = t.y),
                    t.z !== B_ && (e.z = t.z);
                }
                const s = t
                  .object(S_(e), {
                    position: Zb({ x: $b(B_), y: $b(B_), z: $b(B_) }),
                    rotation: Zb({ x: $b(B_), y: $b(B_), z: $b(B_) }),
                    scale: Zb({ x: $b(B_), y: $b(B_), z: $b(B_) }),
                  })
                  .onValuesChange((t) => {
                    n &&
                      (i(e.position, t.position),
                      i(e.rotation, t.rotation),
                      i(e.scale, t.scale));
                  });
                r.set(e.uuid, s);
              },
              animateMaterial: function (e) {
                if (r.has(e.uuid)) return;
                const i = Ap[e.type],
                  s = fp[i],
                  a = {};
                s.forEach((e) => {
                  T_.includes(e) ? (a[e] = i_(R_)) : (a[e] = $b(B_));
                });
                const o = t
                  .object(S_(e), a, { reconfigure: !0 })
                  .onValuesChange((t) => {
                    if (n) for (const e in t) T_.includes(e) ? r(e) : i(e);
                    function i(n, i) {
                      t[n] !== B_ &&
                        void 0 !== e[n] &&
                        ((e[n] = i || t[n]),
                        "attenuationDistance" === n &&
                          0 === e[n] &&
                          (e[n] = 1 / 0));
                    }
                    function r(e) {
                      t[e].a !== R_.a &&
                        i(e, new ma(String(ab(t[e])).slice(0, -2)));
                    }
                  });
                r.set(e.uuid, o);
              },
              removeObjectAnimation: function (e) {
                const n = r.get(e.uuid);
                n && (n(), t.detachObject(S_(e)), r.delete(e.uuid));
              },
              animationSheet: t,
            };
          },
          setState: function (e) {
            i.setState(e);
          },
          setActive: function (e) {
            if (((n = e), e)) {
              const e = i.sheet(I_).sequence.position;
              (i.sheet(I_).sequence.position += e > 1e-5 ? -1e-5 : 1e-5),
                setTimeout(() => {
                  i.sheet(I_).sequence.position = e;
                });
            }
          },
        };
      }
      var P_, L_, U_;
      function F_(e, t) {
        return {
          set: (n, i, r) => {
            const s = n[i] !== r,
              a = Reflect.set(n, i, r);
            return e.includes(i) && s && t(i), a;
          },
        };
      }
      function O_(e) {
        const t = e;
        function n(e, n) {
          const i = t[e],
            r = new Proxy(
              i,
              F_(["x", "y", "z", "_x", "_y", "_z"], (e) => {
                t.dispatchEvent({ type: n, target: t, property: e });
              })
            );
          !(function (e, t, n) {
            Reflect.deleteProperty(e, t),
              Reflect.defineProperty(e, t, {
                value: n,
                configurable: !1,
                enumerable: !0,
                writable: !1,
              });
          })(t, e, r);
        }
        return (
          n("position", L_.UpdatePosition),
          n("rotation", L_.UpdateRotation),
          n("scale", L_.UpdateScale),
          t
        );
      }
      function N_(e) {
        var t, n, i, r, s, a, o, c, l, u, h, d, p, f;
        e instanceof Yh &&
          (null === (t = e.alphaMap) || void 0 === t || t.dispose(),
          null === (n = e.aoMap) || void 0 === n || n.dispose(),
          null === (i = e.emissiveMap) || void 0 === i || i.dispose(),
          null === (r = e.aoMap) || void 0 === r || r.dispose(),
          null === (s = e.map) || void 0 === s || s.dispose(),
          null === (a = e.normalMap) || void 0 === a || a.dispose(),
          null === (o = e.metalnessMap) || void 0 === o || o.dispose(),
          null === (c = e.roughnessMap) || void 0 === c || c.dispose(),
          null === (l = e.displacementMap) || void 0 === l || l.dispose()),
          e instanceof _a &&
            (null === (u = e.alphaMap) || void 0 === u || u.dispose(),
            null === (h = e.aoMap) || void 0 === h || h.dispose(),
            null === (d = e.aoMap) || void 0 === d || d.dispose(),
            null === (p = e.specularMap) || void 0 === p || p.dispose(),
            null === (f = e.map) || void 0 === f || f.dispose()),
          e.dispose();
      }
      function k_(e) {
        return e ? (e.userData.isPwObject ? e : k_(e.parent)) : null;
      }
      function Q_(e, t) {
        return t ? e.set(t.x, t.y, t.z) : e.set(0, 0, 0);
      }
      !(function (e) {
        (e.MouseDown = "MOUSE_DOWN"),
          (e.MouseUp = "MOUSE_UP"),
          (e.MouseMove = "MOUSE_MOVE"),
          (e.Loaded = "LOADED"),
          (e.ResourcesLoaded = "RESOURCES_LOADED"),
          (e.SceneReady = "SCENE_READY");
      })(P_ || (P_ = {})),
        (function (e) {
          (e.UpdatePosition = "UPDATE_POSITION"),
            (e.UpdateRotation = "UPDATE_ROTATION"),
            (e.UpdateScale = "UPDATE_SCALE");
        })(L_ || (L_ = {})),
        (function (e) {
          e.Update = "UPDATE";
        })(U_ || (U_ = {}));
      const G_ = new Yr();
      function H_(e) {
        const t = new Map();
        return (
          e.traverse((e) => {
            (e instanceof Za || e instanceof Vu) &&
              t.set(e.material.uuid, e.material);
          }),
          Array.from(t.values())
        );
      }
      new Zr();
      var z_ = function (e, t, n, i) {
        return new (n || (n = Promise))(function (r, s) {
          function a(e) {
            try {
              c(i.next(e));
            } catch (e) {
              s(e);
            }
          }
          function o(e) {
            try {
              c(i.throw(e));
            } catch (e) {
              s(e);
            }
          }
          function c(e) {
            var t;
            e.done
              ? r(e.value)
              : ((t = e.value),
                t instanceof n
                  ? t
                  : new n(function (e) {
                      e(t);
                    })).then(a, o);
          }
          c((i = i.apply(e, t || [])).next());
        });
      };
      class V_ {
        constructor(e, t) {
          this.usedBy = new Set();
          const { assetType: n, assetUrl: i } = e;
          (this.loaded = !1),
            (this.assetUrl = i),
            (this.assetType = n),
            (this.loader = t);
        }
        getData() {
          var e;
          return z_(this, void 0, void 0, function* () {
            if (this.loaded && this.data) return this.data;
            const t =
              (!wp.some((e) => this.assetUrl.endsWith(e)) &&
                (yield null === (e = window._pwLoadFileFromCache) ||
                void 0 === e
                  ? void 0
                  : e.call(window, this.assetUrl))) ||
              this.assetUrl;
            if (!t) throw new Error(`Failed to load file "${this.assetUrl}".`);
            const n = yield this.loadAssetData(this.assetType, t);
            return (this.data = n), (this.loaded = !0), this.data;
          });
        }
        loadAssetData(e, t) {
          return z_(this, void 0, void 0, function* () {
            return yield this.loader.loadAsync(e, t);
          });
        }
        dispose() {
          if (this.data)
            switch (this.assetType) {
              case Ge.Texture:
              case Ge.HDRTexture:
              case Ge.EXRTexture:
                this.data.dispose();
                break;
              case Ge.Gltf:
                this.data.scenes.forEach((e) => {
                  e.traverse(function (e) {
                    e instanceof Za && (e.geometry.dispose(), N_(e.material));
                  });
                });
                break;
              case Ge.FBX:
              case Ge.Obj:
                this.data.traverse(function (e) {
                  e instanceof Za && (e.geometry.dispose(), N_(e.material));
                });
            }
        }
      }
      function j_(e) {
        const t = new Map(),
          n = new Map(),
          i = e.clone();
        return (
          W_(e, i, function (e, i) {
            t.set(i, e), n.set(e, i);
          }),
          i.traverse(function (e) {
            if (!e.isSkinnedMesh) return;
            const i = e,
              r = t.get(e),
              s = r.skeleton.bones;
            (i.skeleton = r.skeleton.clone()),
              i.bindMatrix.copy(r.bindMatrix),
              (i.skeleton.bones = s.map(function (e) {
                return n.get(e);
              })),
              i.bind(i.skeleton, i.bindMatrix);
          }),
          i
        );
      }
      function W_(e, t, n) {
        n(e, t);
        for (let i = 0; i < e.children.length; i++)
          W_(e.children[i], t.children[i], n);
      }
      const X_ = { [ze.Clamp]: Bn, [ze.Repeat]: Tn, [ze.MirroredRepeat]: Rn },
        q_ = [
          Ge.Texture,
          Ge.HDRTexture,
          Ge.EXRTexture,
          Ge.Gltf,
          Ge.Obj,
          Ge.FBX,
          Ge.VideoTexture,
        ];
      class Y_ {
        constructor(e, t) {
          const { uuid: n, assetUrl: i } = e;
          if (
            ((this.uuid = n),
            (this.assetUrl = i),
            t.usedBy.add(n),
            !q_.includes(e.assetType))
          )
            throw new Error(`Asset type ${e.assetType} is not supported!`);
          this.assetInstance = t.getData().then((t) => {
            switch (e.assetType) {
              case Ge.Texture: {
                const {
                    center: n,
                    offset: i,
                    repeat: r,
                    wrapS: s = ze.Clamp,
                    wrapT: a = ze.Clamp,
                  } = e,
                  o = t.clone();
                return (
                  (o.center = new br(n.x, n.y)),
                  (o.offset = new br(i.x, i.y)),
                  (o.repeat = new br(r.x, r.y)),
                  (o.wrapS = X_[s]),
                  (o.wrapT = X_[a]),
                  (o.colorSpace = Zi),
                  (o.needsUpdate = !0),
                  o
                );
              }
              case Ge.VideoTexture: {
                const {
                    center: t,
                    offset: n,
                    repeat: r,
                    wrapS: s = ze.Clamp,
                    wrapT: a = ze.Clamp,
                    loop: o,
                  } = e,
                  c = document.createElement("video");
                c.setAttribute("id", "video"),
                  (c.crossOrigin = "anonymous"),
                  (c.style.display = "none"),
                  (c.playsInline = !0),
                  (c.autoplay = !0),
                  (c.muted = !0),
                  (c.loop = o),
                  (c.src = i),
                  document.body.append(c),
                  c.load(),
                  (c.preload = "auto"),
                  c.play();
                const l = new dh(c);
                return (
                  (l.center = new br(t.x, t.y)),
                  (l.offset = new br(n.x, n.y)),
                  (l.repeat = new br(r.x, r.y)),
                  (l.wrapS = X_[s]),
                  (l.wrapT = X_[a]),
                  (l.colorSpace = Zi),
                  (l.needsUpdate = !0),
                  new Promise((e) => {
                    c.oncanplay = () => {
                      e(l);
                    };
                  })
                );
              }
              case Ge.HDRTexture:
              case Ge.EXRTexture: {
                const e = t.clone();
                e.mapping = Sn;
                const n = t.clone();
                return (
                  (n.mapping = In),
                  (e.needsUpdate = !0),
                  { reflection: e, refraction: n }
                );
              }
              case Ge.Gltf: {
                const e = new au(),
                  n = t;
                return (
                  n.scenes.forEach((t) => {
                    e.add(j_(t));
                  }),
                  (e.userData = { isGLTF: !0 }),
                  {
                    model: e,
                    animations: n.animations.map((e) => e.clone()),
                    materials: H_(e),
                  }
                );
              }
              case Ge.Obj: {
                const e = t.clone();
                return { model: e, materials: H_(e) };
              }
              case Ge.FBX: {
                const e = j_(t);
                return { model: e, materials: H_(e) };
              }
              default:
                throw new Error(
                  "Resource type should be checked before the async code, otherwise error can't be caught!"
                );
            }
          });
        }
        dispose() {
          this.assetInstance.then((e) => {
            if (
              (e instanceof dh &&
                (document.body.removeChild(e.source.data), e.dispose()),
              e instanceof Hr && e.dispose(),
              e instanceof au)
            ) {
              e.traverse(function (e) {
                e instanceof Za && (e.geometry.dispose(), N_(e.material));
              });
            }
          });
        }
      }
      function K_(e, t) {
        const n = new Map(),
          i = new Map(),
          r = new Set();
        let s = !1;
        function a() {
          r.size > 0 ||
            s ||
            ((s = !0), t.dispatchEvent({ type: P_.ResourcesLoaded }));
        }
        function o(t) {
          const i = new V_(t, e);
          return n.set(t.assetUrl, i), i;
        }
        return {
          createResource: function (e) {
            const t = new Y_(e, n.get(e.assetUrl) || o(e));
            return (
              r.add(t),
              i.set(e.uuid, t),
              t.assetInstance.finally(() => {
                r.delete(t), a();
              }),
              t
            );
          },
          createAsset: o,
          getAsset: n.get.bind(n),
          deleteResource: function (e) {
            const t = i.get(e);
            if (!t) return;
            t.dispose(), i.delete(e);
            const r = n.get(t.assetUrl);
            r &&
              (r.usedBy.delete(t.uuid),
              0 === r.usedBy.size && (n.delete(t.assetUrl), r.dispose()));
          },
          dispose: function () {
            n.forEach((e) => {
              e.dispose();
            }),
              i.forEach((e) => {
                e.dispose();
              }),
              i.clear(),
              n.clear();
          },
          getResource: i.get.bind(i),
          checkIfResourceLoadingFinished: a,
        };
      }
      const J_ = new WeakMap();
      class Z_ extends _d {
        constructor(e) {
          super(e),
            (this.decoderPath = ""),
            (this.decoderConfig = {}),
            (this.decoderBinary = null),
            (this.decoderPending = null),
            (this.workerLimit = 4),
            (this.workerPool = []),
            (this.workerNextTaskID = 1),
            (this.workerSourceURL = ""),
            (this.defaultAttributeIDs = {
              position: "POSITION",
              normal: "NORMAL",
              color: "COLOR",
              uv: "TEX_COORD",
            }),
            (this.defaultAttributeTypes = {
              position: "Float32Array",
              normal: "Float32Array",
              color: "Float32Array",
              uv: "Float32Array",
            });
        }
        setDecoderPath(e) {
          return (this.decoderPath = e), this;
        }
        setDecoderConfig(e) {
          return (this.decoderConfig = e), this;
        }
        setWorkerLimit(e) {
          return (this.workerLimit = e), this;
        }
        load(e, t, n, i) {
          const r = new wd(this.manager);
          r.setPath(this.path),
            r.setResponseType("arraybuffer"),
            r.setRequestHeader(this.requestHeader),
            r.setWithCredentials(this.withCredentials),
            r.load(
              e,
              (e) => {
                this.parse(e, t, i);
              },
              n,
              i
            );
        }
        parse(e, t, n = () => {}) {
          this.decodeDracoFile(e, t, null, null, Zi, n).catch(n);
        }
        decodeDracoFile(e, t, n, i, r = $i, s = () => {}) {
          const a = {
            attributeIDs: n || this.defaultAttributeIDs,
            attributeTypes: i || this.defaultAttributeTypes,
            useUniqueIDs: !!n,
            vertexColorSpace: r,
          };
          return this.decodeGeometry(e, a).then(t).catch(s);
        }
        decodeGeometry(e, t) {
          const n = JSON.stringify(t);
          if (J_.has(e)) {
            const t = J_.get(e);
            if (t.key === n) return t.promise;
            if (0 === e.byteLength)
              throw new Error(
                "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
              );
          }
          let i;
          const r = this.workerNextTaskID++,
            s = e.byteLength,
            a = this._getWorker(r, s)
              .then(
                (n) => (
                  (i = n),
                  new Promise((n, s) => {
                    (i._callbacks[r] = { resolve: n, reject: s }),
                      i.postMessage(
                        { type: "decode", id: r, taskConfig: t, buffer: e },
                        [e]
                      );
                  })
                )
              )
              .then((e) => this._createGeometry(e.geometry));
          return (
            a
              .catch(() => !0)
              .then(() => {
                i && r && this._releaseTask(i, r);
              }),
            J_.set(e, { key: n, promise: a }),
            a
          );
        }
        _createGeometry(e) {
          const t = new Qa();
          e.index && t.setIndex(new Ta(e.index.array, 1));
          for (let n = 0; n < e.attributes.length; n++) {
            const i = e.attributes[n],
              r = i.name,
              s = i.array,
              a = i.itemSize,
              o = new Ta(s, a);
            "color" === r &&
              (this._assignVertexColorSpace(o, i.vertexColorSpace),
              (o.normalized = s instanceof Float32Array == !1)),
              t.setAttribute(r, o);
          }
          return t;
        }
        _assignVertexColorSpace(e, t) {
          if (t !== Zi) return;
          const n = new ma();
          for (let t = 0, i = e.count; t < i; t++)
            n.fromBufferAttribute(e, t),
              Mr.toWorkingColorSpace(n, Zi),
              e.setXYZ(t, n.r, n.g, n.b);
        }
        _loadLibrary(e, t) {
          const n = new wd(this.manager);
          return (
            n.setPath(this.decoderPath),
            n.setResponseType(t),
            n.setWithCredentials(this.withCredentials),
            new Promise((t, i) => {
              n.load(e, t, void 0, i);
            })
          );
        }
        preload() {
          return this._initDecoder(), this;
        }
        _initDecoder() {
          if (this.decoderPending) return this.decoderPending;
          const e =
              "object" != typeof WebAssembly ||
              "js" === this.decoderConfig.type,
            t = [];
          return (
            e
              ? t.push(this._loadLibrary("draco_decoder.js", "text"))
              : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
                t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))),
            (this.decoderPending = Promise.all(t).then((t) => {
              const n = t[0];
              e || (this.decoderConfig.wasmBinary = t[1]);
              const i = $_.toString(),
                r = [
                  "/* draco decoder */",
                  n,
                  "",
                  "/* worker */",
                  i.substring(i.indexOf("{") + 1, i.lastIndexOf("}")),
                ].join("\n");
              this.workerSourceURL = URL.createObjectURL(new Blob([r]));
            })),
            this.decoderPending
          );
        }
        _getWorker(e, t) {
          return this._initDecoder().then(() => {
            if (this.workerPool.length < this.workerLimit) {
              const e = new Worker(this.workerSourceURL);
              (e._callbacks = {}),
                (e._taskCosts = {}),
                (e._taskLoad = 0),
                e.postMessage({
                  type: "init",
                  decoderConfig: this.decoderConfig,
                }),
                (e.onmessage = function (t) {
                  const n = t.data;
                  switch (n.type) {
                    case "decode":
                      e._callbacks[n.id].resolve(n);
                      break;
                    case "error":
                      e._callbacks[n.id].reject(n);
                      break;
                    default:
                      console.error(
                        'THREE.DRACOLoader: Unexpected message, "' +
                          n.type +
                          '"'
                      );
                  }
                }),
                this.workerPool.push(e);
            } else
              this.workerPool.sort(function (e, t) {
                return e._taskLoad > t._taskLoad ? -1 : 1;
              });
            const n = this.workerPool[this.workerPool.length - 1];
            return (n._taskCosts[e] = t), (n._taskLoad += t), n;
          });
        }
        _releaseTask(e, t) {
          (e._taskLoad -= e._taskCosts[t]),
            delete e._callbacks[t],
            delete e._taskCosts[t];
        }
        debug() {
          console.log(
            "Task load: ",
            this.workerPool.map((e) => e._taskLoad)
          );
        }
        dispose() {
          for (let e = 0; e < this.workerPool.length; ++e)
            this.workerPool[e].terminate();
          return (
            (this.workerPool.length = 0),
            "" !== this.workerSourceURL &&
              URL.revokeObjectURL(this.workerSourceURL),
            this
          );
        }
      }
      function $_() {
        let e, t;
        function n(e, t, n, i, r, s) {
          const a = s.num_components(),
            o = n.num_points() * a,
            c = o * r.BYTES_PER_ELEMENT,
            l = (function (e, t) {
              switch (t) {
                case Float32Array:
                  return e.DT_FLOAT32;
                case Int8Array:
                  return e.DT_INT8;
                case Int16Array:
                  return e.DT_INT16;
                case Int32Array:
                  return e.DT_INT32;
                case Uint8Array:
                  return e.DT_UINT8;
                case Uint16Array:
                  return e.DT_UINT16;
                case Uint32Array:
                  return e.DT_UINT32;
              }
            })(e, r),
            u = e._malloc(c);
          t.GetAttributeDataArrayForAllPoints(n, s, l, c, u);
          const h = new r(e.HEAPF32.buffer, u, o).slice();
          return e._free(u), { name: i, array: h, itemSize: a };
        }
        onmessage = function (i) {
          const r = i.data;
          switch (r.type) {
            case "init":
              (e = r.decoderConfig),
                (t = new Promise(function (t) {
                  (e.onModuleLoaded = function (e) {
                    t({ draco: e });
                  }),
                    DracoDecoderModule(e);
                }));
              break;
            case "decode":
              const i = r.buffer,
                s = r.taskConfig;
              t.then((e) => {
                const t = e.draco,
                  a = new t.Decoder();
                try {
                  const e = (function (e, t, i, r) {
                      const s = r.attributeIDs,
                        a = r.attributeTypes;
                      let o, c;
                      const l = t.GetEncodedGeometryType(i);
                      if (l === e.TRIANGULAR_MESH)
                        (o = new e.Mesh()),
                          (c = t.DecodeArrayToMesh(i, i.byteLength, o));
                      else {
                        if (l !== e.POINT_CLOUD)
                          throw new Error(
                            "THREE.DRACOLoader: Unexpected geometry type."
                          );
                        (o = new e.PointCloud()),
                          (c = t.DecodeArrayToPointCloud(i, i.byteLength, o));
                      }
                      if (!c.ok() || 0 === o.ptr)
                        throw new Error(
                          "THREE.DRACOLoader: Decoding failed: " + c.error_msg()
                        );
                      const u = { index: null, attributes: [] };
                      for (const i in s) {
                        const c = self[a[i]];
                        let l, h;
                        if (r.useUniqueIDs)
                          (h = s[i]), (l = t.GetAttributeByUniqueId(o, h));
                        else {
                          if (((h = t.GetAttributeId(o, e[s[i]])), -1 === h))
                            continue;
                          l = t.GetAttribute(o, h);
                        }
                        const d = n(e, t, o, i, c, l);
                        "color" === i &&
                          (d.vertexColorSpace = r.vertexColorSpace),
                          u.attributes.push(d);
                      }
                      l === e.TRIANGULAR_MESH &&
                        (u.index = (function (e, t, n) {
                          const i = n.num_faces(),
                            r = 3 * i,
                            s = 4 * r,
                            a = e._malloc(s);
                          t.GetTrianglesUInt32Array(n, s, a);
                          const o = new Uint32Array(
                            e.HEAPF32.buffer,
                            a,
                            r
                          ).slice();
                          return e._free(a), { array: o, itemSize: 1 };
                        })(e, t, o));
                      return e.destroy(o), u;
                    })(t, a, new Int8Array(i), s),
                    o = e.attributes.map((e) => e.array.buffer);
                  e.index && o.push(e.index.array.buffer),
                    self.postMessage(
                      { type: "decode", id: r.id, geometry: e },
                      o
                    );
                } catch (e) {
                  console.error(e),
                    self.postMessage({
                      type: "error",
                      id: r.id,
                      error: e.message,
                    });
                } finally {
                  t.destroy(a);
                }
              });
          }
        };
      }
      function ex(e, t) {
        if (0 === t)
          return (
            console.warn(
              "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."
            ),
            e
          );
        if (2 === t || 1 === t) {
          let n = e.getIndex();
          if (null === n) {
            const t = [],
              i = e.getAttribute("position");
            if (void 0 === i)
              return (
                console.error(
                  "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
                ),
                e
              );
            for (let e = 0; e < i.count; e++) t.push(e);
            e.setIndex(t), (n = e.getIndex());
          }
          const i = n.count - 2,
            r = [];
          if (2 === t)
            for (let e = 1; e <= i; e++)
              r.push(n.getX(0)), r.push(n.getX(e)), r.push(n.getX(e + 1));
          else
            for (let e = 0; e < i; e++)
              e % 2 == 0
                ? (r.push(n.getX(e)),
                  r.push(n.getX(e + 1)),
                  r.push(n.getX(e + 2)))
                : (r.push(n.getX(e + 2)),
                  r.push(n.getX(e + 1)),
                  r.push(n.getX(e)));
          r.length / 3 !== i &&
            console.error(
              "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
            );
          const s = e.clone();
          return s.setIndex(r), s.clearGroups(), s;
        }
        return (
          console.error(
            "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",
            t
          ),
          e
        );
      }
      class tx extends _d {
        constructor(e) {
          super(e),
            (this.dracoLoader = null),
            (this.ktx2Loader = null),
            (this.meshoptDecoder = null),
            (this.pluginCallbacks = []),
            this.register(function (e) {
              return new ox(e);
            }),
            this.register(function (e) {
              return new cx(e);
            }),
            this.register(function (e) {
              return new mx(e);
            }),
            this.register(function (e) {
              return new vx(e);
            }),
            this.register(function (e) {
              return new yx(e);
            }),
            this.register(function (e) {
              return new ux(e);
            }),
            this.register(function (e) {
              return new hx(e);
            }),
            this.register(function (e) {
              return new dx(e);
            }),
            this.register(function (e) {
              return new px(e);
            }),
            this.register(function (e) {
              return new ax(e);
            }),
            this.register(function (e) {
              return new fx(e);
            }),
            this.register(function (e) {
              return new lx(e);
            }),
            this.register(function (e) {
              return new gx(e);
            }),
            this.register(function (e) {
              return new Ax(e);
            }),
            this.register(function (e) {
              return new rx(e);
            }),
            this.register(function (e) {
              return new bx(e);
            }),
            this.register(function (e) {
              return new _x(e);
            });
        }
        load(e, t, n, i) {
          const r = this;
          let s;
          if ("" !== this.resourcePath) s = this.resourcePath;
          else if ("" !== this.path) {
            const t = zd.extractUrlBase(e);
            s = zd.resolveURL(t, this.path);
          } else s = zd.extractUrlBase(e);
          this.manager.itemStart(e);
          const a = function (t) {
              i ? i(t) : console.error(t),
                r.manager.itemError(e),
                r.manager.itemEnd(e);
            },
            o = new wd(this.manager);
          o.setPath(this.path),
            o.setResponseType("arraybuffer"),
            o.setRequestHeader(this.requestHeader),
            o.setWithCredentials(this.withCredentials),
            o.load(
              e,
              function (n) {
                try {
                  r.parse(
                    n,
                    s,
                    function (n) {
                      t(n), r.manager.itemEnd(e);
                    },
                    a
                  );
                } catch (e) {
                  a(e);
                }
              },
              n,
              a
            );
        }
        setDRACOLoader(e) {
          return (this.dracoLoader = e), this;
        }
        setKTX2Loader(e) {
          return (this.ktx2Loader = e), this;
        }
        setMeshoptDecoder(e) {
          return (this.meshoptDecoder = e), this;
        }
        register(e) {
          return (
            -1 === this.pluginCallbacks.indexOf(e) &&
              this.pluginCallbacks.push(e),
            this
          );
        }
        unregister(e) {
          return (
            -1 !== this.pluginCallbacks.indexOf(e) &&
              this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
            this
          );
        }
        parse(e, t, n, i) {
          let r;
          const s = {},
            a = {},
            o = new TextDecoder();
          if ("string" == typeof e) r = JSON.parse(e);
          else if (e instanceof ArrayBuffer) {
            if (o.decode(new Uint8Array(e, 0, 4)) === xx) {
              try {
                s[ix.KHR_BINARY_GLTF] = new Cx(e);
              } catch (e) {
                return void (i && i(e));
              }
              r = JSON.parse(s[ix.KHR_BINARY_GLTF].content);
            } else r = JSON.parse(o.decode(e));
          } else r = e;
          if (void 0 === r.asset || r.asset.version[0] < 2)
            return void (
              i &&
              i(
                new Error(
                  "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
                )
              )
            );
          const c = new Jx(r, {
            path: t || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder,
          });
          c.fileLoader.setRequestHeader(this.requestHeader);
          for (let e = 0; e < this.pluginCallbacks.length; e++) {
            const t = this.pluginCallbacks[e](c);
            t.name ||
              console.error(
                "THREE.GLTFLoader: Invalid plugin found: missing name"
              ),
              (a[t.name] = t),
              (s[t.name] = !0);
          }
          if (r.extensionsUsed)
            for (let e = 0; e < r.extensionsUsed.length; ++e) {
              const t = r.extensionsUsed[e],
                n = r.extensionsRequired || [];
              switch (t) {
                case ix.KHR_MATERIALS_UNLIT:
                  s[t] = new sx();
                  break;
                case ix.KHR_DRACO_MESH_COMPRESSION:
                  s[t] = new Sx(r, this.dracoLoader);
                  break;
                case ix.KHR_TEXTURE_TRANSFORM:
                  s[t] = new Ix();
                  break;
                case ix.KHR_MESH_QUANTIZATION:
                  s[t] = new Mx();
                  break;
                default:
                  n.indexOf(t) >= 0 &&
                    void 0 === a[t] &&
                    console.warn(
                      'THREE.GLTFLoader: Unknown extension "' + t + '".'
                    );
              }
            }
          c.setExtensions(s), c.setPlugins(a), c.parse(n, i);
        }
        parseAsync(e, t) {
          const n = this;
          return new Promise(function (i, r) {
            n.parse(e, t, i, r);
          });
        }
      }
      function nx() {
        let e = {};
        return {
          get: function (t) {
            return e[t];
          },
          add: function (t, n) {
            e[t] = n;
          },
          remove: function (t) {
            delete e[t];
          },
          removeAll: function () {
            e = {};
          },
        };
      }
      const ix = {
        KHR_BINARY_GLTF: "KHR_binary_glTF",
        KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
        KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
        KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
        KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
        KHR_MATERIALS_IOR: "KHR_materials_ior",
        KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
        KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
        KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
        KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
        KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
        KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
        KHR_MATERIALS_VOLUME: "KHR_materials_volume",
        KHR_TEXTURE_BASISU: "KHR_texture_basisu",
        KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
        KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
        KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
        EXT_MATERIALS_BUMP: "EXT_materials_bump",
        EXT_TEXTURE_WEBP: "EXT_texture_webp",
        EXT_TEXTURE_AVIF: "EXT_texture_avif",
        EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
        EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing",
      };
      class rx {
        constructor(e) {
          (this.parser = e),
            (this.name = ix.KHR_LIGHTS_PUNCTUAL),
            (this.cache = { refs: {}, uses: {} });
        }
        _markDefs() {
          const e = this.parser,
            t = this.parser.json.nodes || [];
          for (let n = 0, i = t.length; n < i; n++) {
            const i = t[n];
            i.extensions &&
              i.extensions[this.name] &&
              void 0 !== i.extensions[this.name].light &&
              e._addNodeRef(this.cache, i.extensions[this.name].light);
          }
        }
        _loadLight(e) {
          const t = this.parser,
            n = "light:" + e;
          let i = t.cache.get(n);
          if (i) return i;
          const r = t.json,
            s = (((r.extensions && r.extensions[this.name]) || {}).lights ||
              [])[e];
          let a;
          const o = new ma(16777215);
          void 0 !== s.color &&
            o.setRGB(s.color[0], s.color[1], s.color[2], $i);
          const c = void 0 !== s.range ? s.range : 0;
          switch (s.type) {
            case "directional":
              (a = new Gd(o)), a.target.position.set(0, 0, -1), a.add(a.target);
              break;
            case "point":
              (a = new kd(o)), (a.distance = c);
              break;
            case "spot":
              (a = new Ld(o)),
                (a.distance = c),
                (s.spot = s.spot || {}),
                (s.spot.innerConeAngle =
                  void 0 !== s.spot.innerConeAngle ? s.spot.innerConeAngle : 0),
                (s.spot.outerConeAngle =
                  void 0 !== s.spot.outerConeAngle
                    ? s.spot.outerConeAngle
                    : Math.PI / 4),
                (a.angle = s.spot.outerConeAngle),
                (a.penumbra =
                  1 - s.spot.innerConeAngle / s.spot.outerConeAngle),
                a.target.position.set(0, 0, -1),
                a.add(a.target);
              break;
            default:
              throw new Error(
                "THREE.GLTFLoader: Unexpected light type: " + s.type
              );
          }
          return (
            a.position.set(0, 0, 0),
            (a.decay = 2),
            jx(a, s),
            void 0 !== s.intensity && (a.intensity = s.intensity),
            (a.name = t.createUniqueName(s.name || "light_" + e)),
            (i = Promise.resolve(a)),
            t.cache.add(n, i),
            i
          );
        }
        getDependency(e, t) {
          if ("light" === e) return this._loadLight(t);
        }
        createNodeAttachment(e) {
          const t = this,
            n = this.parser,
            i = n.json.nodes[e],
            r = ((i.extensions && i.extensions[this.name]) || {}).light;
          return void 0 === r
            ? null
            : this._loadLight(r).then(function (e) {
                return n._getNodeRef(t.cache, r, e);
              });
        }
      }
      class sx {
        constructor() {
          this.name = ix.KHR_MATERIALS_UNLIT;
        }
        getMaterialType() {
          return _a;
        }
        extendParams(e, t, n) {
          const i = [];
          (e.color = new ma(1, 1, 1)), (e.opacity = 1);
          const r = t.pbrMetallicRoughness;
          if (r) {
            if (Array.isArray(r.baseColorFactor)) {
              const t = r.baseColorFactor;
              e.color.setRGB(t[0], t[1], t[2], $i), (e.opacity = t[3]);
            }
            void 0 !== r.baseColorTexture &&
              i.push(n.assignTexture(e, "map", r.baseColorTexture, Zi));
          }
          return Promise.all(i);
        }
      }
      class ax {
        constructor(e) {
          (this.parser = e), (this.name = ix.KHR_MATERIALS_EMISSIVE_STRENGTH);
        }
        extendMaterialParams(e, t) {
          const n = this.parser.json.materials[e];
          if (!n.extensions || !n.extensions[this.name])
            return Promise.resolve();
          const i = n.extensions[this.name].emissiveStrength;
          return void 0 !== i && (t.emissiveIntensity = i), Promise.resolve();
        }
      }
      class ox {
        constructor(e) {
          (this.parser = e), (this.name = ix.KHR_MATERIALS_CLEARCOAT);
        }
        getMaterialType(e) {
          const t = this.parser.json.materials[e];
          return t.extensions && t.extensions[this.name] ? Kh : null;
        }
        extendMaterialParams(e, t) {
          const n = this.parser,
            i = n.json.materials[e];
          if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
          const r = [],
            s = i.extensions[this.name];
          if (
            (void 0 !== s.clearcoatFactor && (t.clearcoat = s.clearcoatFactor),
            void 0 !== s.clearcoatTexture &&
              r.push(n.assignTexture(t, "clearcoatMap", s.clearcoatTexture)),
            void 0 !== s.clearcoatRoughnessFactor &&
              (t.clearcoatRoughness = s.clearcoatRoughnessFactor),
            void 0 !== s.clearcoatRoughnessTexture &&
              r.push(
                n.assignTexture(
                  t,
                  "clearcoatRoughnessMap",
                  s.clearcoatRoughnessTexture
                )
              ),
            void 0 !== s.clearcoatNormalTexture &&
              (r.push(
                n.assignTexture(
                  t,
                  "clearcoatNormalMap",
                  s.clearcoatNormalTexture
                )
              ),
              void 0 !== s.clearcoatNormalTexture.scale))
          ) {
            const e = s.clearcoatNormalTexture.scale;
            t.clearcoatNormalScale = new br(e, e);
          }
          return Promise.all(r);
        }
      }
      class cx {
        constructor(e) {
          (this.parser = e), (this.name = ix.KHR_MATERIALS_DISPERSION);
        }
        getMaterialType(e) {
          const t = this.parser.json.materials[e];
          return t.extensions && t.extensions[this.name] ? Kh : null;
        }
        extendMaterialParams(e, t) {
          const n = this.parser.json.materials[e];
          if (!n.extensions || !n.extensions[this.name])
            return Promise.resolve();
          const i = n.extensions[this.name];
          return (
            (t.dispersion = void 0 !== i.dispersion ? i.dispersion : 0),
            Promise.resolve()
          );
        }
      }
      class lx {
        constructor(e) {
          (this.parser = e), (this.name = ix.KHR_MATERIALS_IRIDESCENCE);
        }
        getMaterialType(e) {
          const t = this.parser.json.materials[e];
          return t.extensions && t.extensions[this.name] ? Kh : null;
        }
        extendMaterialParams(e, t) {
          const n = this.parser,
            i = n.json.materials[e];
          if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
          const r = [],
            s = i.extensions[this.name];
          return (
            void 0 !== s.iridescenceFactor &&
              (t.iridescence = s.iridescenceFactor),
            void 0 !== s.iridescenceTexture &&
              r.push(
                n.assignTexture(t, "iridescenceMap", s.iridescenceTexture)
              ),
            void 0 !== s.iridescenceIor &&
              (t.iridescenceIOR = s.iridescenceIor),
            void 0 === t.iridescenceThicknessRange &&
              (t.iridescenceThicknessRange = [100, 400]),
            void 0 !== s.iridescenceThicknessMinimum &&
              (t.iridescenceThicknessRange[0] = s.iridescenceThicknessMinimum),
            void 0 !== s.iridescenceThicknessMaximum &&
              (t.iridescenceThicknessRange[1] = s.iridescenceThicknessMaximum),
            void 0 !== s.iridescenceThicknessTexture &&
              r.push(
                n.assignTexture(
                  t,
                  "iridescenceThicknessMap",
                  s.iridescenceThicknessTexture
                )
              ),
            Promise.all(r)
          );
        }
      }
      class ux {
        constructor(e) {
          (this.parser = e), (this.name = ix.KHR_MATERIALS_SHEEN);
        }
        getMaterialType(e) {
          const t = this.parser.json.materials[e];
          return t.extensions && t.extensions[this.name] ? Kh : null;
        }
        extendMaterialParams(e, t) {
          const n = this.parser,
            i = n.json.materials[e];
          if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
          const r = [];
          (t.sheenColor = new ma(0, 0, 0)),
            (t.sheenRoughness = 0),
            (t.sheen = 1);
          const s = i.extensions[this.name];
          if (void 0 !== s.sheenColorFactor) {
            const e = s.sheenColorFactor;
            t.sheenColor.setRGB(e[0], e[1], e[2], $i);
          }
          return (
            void 0 !== s.sheenRoughnessFactor &&
              (t.sheenRoughness = s.sheenRoughnessFactor),
            void 0 !== s.sheenColorTexture &&
              r.push(
                n.assignTexture(t, "sheenColorMap", s.sheenColorTexture, Zi)
              ),
            void 0 !== s.sheenRoughnessTexture &&
              r.push(
                n.assignTexture(t, "sheenRoughnessMap", s.sheenRoughnessTexture)
              ),
            Promise.all(r)
          );
        }
      }
      class hx {
        constructor(e) {
          (this.parser = e), (this.name = ix.KHR_MATERIALS_TRANSMISSION);
        }
        getMaterialType(e) {
          const t = this.parser.json.materials[e];
          return t.extensions && t.extensions[this.name] ? Kh : null;
        }
        extendMaterialParams(e, t) {
          const n = this.parser,
            i = n.json.materials[e];
          if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
          const r = [],
            s = i.extensions[this.name];
          return (
            void 0 !== s.transmissionFactor &&
              (t.transmission = s.transmissionFactor),
            void 0 !== s.transmissionTexture &&
              r.push(
                n.assignTexture(t, "transmissionMap", s.transmissionTexture)
              ),
            Promise.all(r)
          );
        }
      }
      class dx {
        constructor(e) {
          (this.parser = e), (this.name = ix.KHR_MATERIALS_VOLUME);
        }
        getMaterialType(e) {
          const t = this.parser.json.materials[e];
          return t.extensions && t.extensions[this.name] ? Kh : null;
        }
        extendMaterialParams(e, t) {
          const n = this.parser,
            i = n.json.materials[e];
          if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
          const r = [],
            s = i.extensions[this.name];
          (t.thickness = void 0 !== s.thicknessFactor ? s.thicknessFactor : 0),
            void 0 !== s.thicknessTexture &&
              r.push(n.assignTexture(t, "thicknessMap", s.thicknessTexture)),
            (t.attenuationDistance = s.attenuationDistance || 1 / 0);
          const a = s.attenuationColor || [1, 1, 1];
          return (
            (t.attenuationColor = new ma().setRGB(a[0], a[1], a[2], $i)),
            Promise.all(r)
          );
        }
      }
      class px {
        constructor(e) {
          (this.parser = e), (this.name = ix.KHR_MATERIALS_IOR);
        }
        getMaterialType(e) {
          const t = this.parser.json.materials[e];
          return t.extensions && t.extensions[this.name] ? Kh : null;
        }
        extendMaterialParams(e, t) {
          const n = this.parser.json.materials[e];
          if (!n.extensions || !n.extensions[this.name])
            return Promise.resolve();
          const i = n.extensions[this.name];
          return (t.ior = void 0 !== i.ior ? i.ior : 1.5), Promise.resolve();
        }
      }
      class fx {
        constructor(e) {
          (this.parser = e), (this.name = ix.KHR_MATERIALS_SPECULAR);
        }
        getMaterialType(e) {
          const t = this.parser.json.materials[e];
          return t.extensions && t.extensions[this.name] ? Kh : null;
        }
        extendMaterialParams(e, t) {
          const n = this.parser,
            i = n.json.materials[e];
          if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
          const r = [],
            s = i.extensions[this.name];
          (t.specularIntensity =
            void 0 !== s.specularFactor ? s.specularFactor : 1),
            void 0 !== s.specularTexture &&
              r.push(
                n.assignTexture(t, "specularIntensityMap", s.specularTexture)
              );
          const a = s.specularColorFactor || [1, 1, 1];
          return (
            (t.specularColor = new ma().setRGB(a[0], a[1], a[2], $i)),
            void 0 !== s.specularColorTexture &&
              r.push(
                n.assignTexture(
                  t,
                  "specularColorMap",
                  s.specularColorTexture,
                  Zi
                )
              ),
            Promise.all(r)
          );
        }
      }
      class Ax {
        constructor(e) {
          (this.parser = e), (this.name = ix.EXT_MATERIALS_BUMP);
        }
        getMaterialType(e) {
          const t = this.parser.json.materials[e];
          return t.extensions && t.extensions[this.name] ? Kh : null;
        }
        extendMaterialParams(e, t) {
          const n = this.parser,
            i = n.json.materials[e];
          if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
          const r = [],
            s = i.extensions[this.name];
          return (
            (t.bumpScale = void 0 !== s.bumpFactor ? s.bumpFactor : 1),
            void 0 !== s.bumpTexture &&
              r.push(n.assignTexture(t, "bumpMap", s.bumpTexture)),
            Promise.all(r)
          );
        }
      }
      class gx {
        constructor(e) {
          (this.parser = e), (this.name = ix.KHR_MATERIALS_ANISOTROPY);
        }
        getMaterialType(e) {
          const t = this.parser.json.materials[e];
          return t.extensions && t.extensions[this.name] ? Kh : null;
        }
        extendMaterialParams(e, t) {
          const n = this.parser,
            i = n.json.materials[e];
          if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
          const r = [],
            s = i.extensions[this.name];
          return (
            void 0 !== s.anisotropyStrength &&
              (t.anisotropy = s.anisotropyStrength),
            void 0 !== s.anisotropyRotation &&
              (t.anisotropyRotation = s.anisotropyRotation),
            void 0 !== s.anisotropyTexture &&
              r.push(n.assignTexture(t, "anisotropyMap", s.anisotropyTexture)),
            Promise.all(r)
          );
        }
      }
      class mx {
        constructor(e) {
          (this.parser = e), (this.name = ix.KHR_TEXTURE_BASISU);
        }
        loadTexture(e) {
          const t = this.parser,
            n = t.json,
            i = n.textures[e];
          if (!i.extensions || !i.extensions[this.name]) return null;
          const r = i.extensions[this.name],
            s = t.options.ktx2Loader;
          if (!s) {
            if (
              n.extensionsRequired &&
              n.extensionsRequired.indexOf(this.name) >= 0
            )
              throw new Error(
                "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
              );
            return null;
          }
          return t.loadTextureImage(e, r.source, s);
        }
      }
      class vx {
        constructor(e) {
          (this.parser = e),
            (this.name = ix.EXT_TEXTURE_WEBP),
            (this.isSupported = null);
        }
        loadTexture(e) {
          const t = this.name,
            n = this.parser,
            i = n.json,
            r = i.textures[e];
          if (!r.extensions || !r.extensions[t]) return null;
          const s = r.extensions[t],
            a = i.images[s.source];
          let o = n.textureLoader;
          if (a.uri) {
            const e = n.options.manager.getHandler(a.uri);
            null !== e && (o = e);
          }
          return this.detectSupport().then(function (r) {
            if (r) return n.loadTextureImage(e, s.source, o);
            if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
              throw new Error(
                "THREE.GLTFLoader: WebP required by asset but unsupported."
              );
            return n.loadTexture(e);
          });
        }
        detectSupport() {
          return (
            this.isSupported ||
              (this.isSupported = new Promise(function (e) {
                const t = new Image();
                (t.src =
                  "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
                  (t.onload = t.onerror =
                    function () {
                      e(1 === t.height);
                    });
              })),
            this.isSupported
          );
        }
      }
      class yx {
        constructor(e) {
          (this.parser = e),
            (this.name = ix.EXT_TEXTURE_AVIF),
            (this.isSupported = null);
        }
        loadTexture(e) {
          const t = this.name,
            n = this.parser,
            i = n.json,
            r = i.textures[e];
          if (!r.extensions || !r.extensions[t]) return null;
          const s = r.extensions[t],
            a = i.images[s.source];
          let o = n.textureLoader;
          if (a.uri) {
            const e = n.options.manager.getHandler(a.uri);
            null !== e && (o = e);
          }
          return this.detectSupport().then(function (r) {
            if (r) return n.loadTextureImage(e, s.source, o);
            if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
              throw new Error(
                "THREE.GLTFLoader: AVIF required by asset but unsupported."
              );
            return n.loadTexture(e);
          });
        }
        detectSupport() {
          return (
            this.isSupported ||
              (this.isSupported = new Promise(function (e) {
                const t = new Image();
                (t.src =
                  "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI="),
                  (t.onload = t.onerror =
                    function () {
                      e(1 === t.height);
                    });
              })),
            this.isSupported
          );
        }
      }
      class bx {
        constructor(e) {
          (this.name = ix.EXT_MESHOPT_COMPRESSION), (this.parser = e);
        }
        loadBufferView(e) {
          const t = this.parser.json,
            n = t.bufferViews[e];
          if (n.extensions && n.extensions[this.name]) {
            const e = n.extensions[this.name],
              i = this.parser.getDependency("buffer", e.buffer),
              r = this.parser.options.meshoptDecoder;
            if (!r || !r.supported) {
              if (
                t.extensionsRequired &&
                t.extensionsRequired.indexOf(this.name) >= 0
              )
                throw new Error(
                  "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
                );
              return null;
            }
            return i.then(function (t) {
              const n = e.byteOffset || 0,
                i = e.byteLength || 0,
                s = e.count,
                a = e.byteStride,
                o = new Uint8Array(t, n, i);
              return r.decodeGltfBufferAsync
                ? r
                    .decodeGltfBufferAsync(s, a, o, e.mode, e.filter)
                    .then(function (e) {
                      return e.buffer;
                    })
                : r.ready.then(function () {
                    const t = new ArrayBuffer(s * a);
                    return (
                      r.decodeGltfBuffer(
                        new Uint8Array(t),
                        s,
                        a,
                        o,
                        e.mode,
                        e.filter
                      ),
                      t
                    );
                  });
            });
          }
          return null;
        }
      }
      class _x {
        constructor(e) {
          (this.name = ix.EXT_MESH_GPU_INSTANCING), (this.parser = e);
        }
        createNodeMesh(e) {
          const t = this.parser.json,
            n = t.nodes[e];
          if (!n.extensions || !n.extensions[this.name] || void 0 === n.mesh)
            return null;
          const i = t.meshes[n.mesh];
          for (const e of i.primitives)
            if (
              e.mode !== Dx.TRIANGLES &&
              e.mode !== Dx.TRIANGLE_STRIP &&
              e.mode !== Dx.TRIANGLE_FAN &&
              void 0 !== e.mode
            )
              return null;
          const r = n.extensions[this.name].attributes,
            s = [],
            a = {};
          for (const e in r)
            s.push(
              this.parser
                .getDependency("accessor", r[e])
                .then((t) => ((a[e] = t), a[e]))
            );
          return s.length < 1
            ? null
            : (s.push(this.parser.createNodeMesh(e)),
              Promise.all(s).then((e) => {
                const t = e.pop(),
                  n = t.isGroup ? t.children : [t],
                  i = e[0].count,
                  r = [];
                for (const e of n) {
                  const t = new Cs(),
                    n = new Yr(),
                    s = new qr(),
                    o = new Yr(1, 1, 1),
                    c = new Vu(e.geometry, e.material, i);
                  for (let e = 0; e < i; e++)
                    a.TRANSLATION && n.fromBufferAttribute(a.TRANSLATION, e),
                      a.ROTATION && s.fromBufferAttribute(a.ROTATION, e),
                      a.SCALE && o.fromBufferAttribute(a.SCALE, e),
                      c.setMatrixAt(e, t.compose(n, s, o));
                  for (const t in a)
                    if ("_COLOR_0" === t) {
                      const e = a[t];
                      c.instanceColor = new Fu(
                        e.array,
                        e.itemSize,
                        e.normalized
                      );
                    } else
                      "TRANSLATION" !== t &&
                        "ROTATION" !== t &&
                        "SCALE" !== t &&
                        e.geometry.setAttribute(t, a[t]);
                  Zs.prototype.copy.call(c, e),
                    this.parser.assignFinalMaterial(c),
                    r.push(c);
                }
                return t.isGroup ? (t.clear(), t.add(...r), t) : r[0];
              }));
        }
      }
      const xx = "glTF",
        Ex = 1313821514,
        wx = 5130562;
      class Cx {
        constructor(e) {
          (this.name = ix.KHR_BINARY_GLTF),
            (this.content = null),
            (this.body = null);
          const t = new DataView(e, 0, 12),
            n = new TextDecoder();
          if (
            ((this.header = {
              magic: n.decode(new Uint8Array(e.slice(0, 4))),
              version: t.getUint32(4, !0),
              length: t.getUint32(8, !0),
            }),
            this.header.magic !== xx)
          )
            throw new Error(
              "THREE.GLTFLoader: Unsupported glTF-Binary header."
            );
          if (this.header.version < 2)
            throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
          const i = this.header.length - 12,
            r = new DataView(e, 12);
          let s = 0;
          for (; s < i; ) {
            const t = r.getUint32(s, !0);
            s += 4;
            const i = r.getUint32(s, !0);
            if (((s += 4), i === Ex)) {
              const i = new Uint8Array(e, 12 + s, t);
              this.content = n.decode(i);
            } else if (i === wx) {
              const n = 12 + s;
              this.body = e.slice(n, n + t);
            }
            s += t;
          }
          if (null === this.content)
            throw new Error("THREE.GLTFLoader: JSON content not found.");
        }
      }
      class Sx {
        constructor(e, t) {
          if (!t)
            throw new Error(
              "THREE.GLTFLoader: No DRACOLoader instance provided."
            );
          (this.name = ix.KHR_DRACO_MESH_COMPRESSION),
            (this.json = e),
            (this.dracoLoader = t),
            this.dracoLoader.preload();
        }
        decodePrimitive(e, t) {
          const n = this.json,
            i = this.dracoLoader,
            r = e.extensions[this.name].bufferView,
            s = e.extensions[this.name].attributes,
            a = {},
            o = {},
            c = {};
          for (const e in s) {
            const t = Ox[e] || e.toLowerCase();
            a[t] = s[e];
          }
          for (const t in e.attributes) {
            const i = Ox[t] || t.toLowerCase();
            if (void 0 !== s[t]) {
              const r = n.accessors[e.attributes[t]],
                s = Px[r.componentType];
              (c[i] = s.name), (o[i] = !0 === r.normalized);
            }
          }
          return t.getDependency("bufferView", r).then(function (e) {
            return new Promise(function (t, n) {
              i.decodeDracoFile(
                e,
                function (e) {
                  for (const t in e.attributes) {
                    const n = e.attributes[t],
                      i = o[t];
                    void 0 !== i && (n.normalized = i);
                  }
                  t(e);
                },
                a,
                c,
                $i,
                n
              );
            });
          });
        }
      }
      class Ix {
        constructor() {
          this.name = ix.KHR_TEXTURE_TRANSFORM;
        }
        extendTexture(e, t) {
          return (void 0 !== t.texCoord && t.texCoord !== e.channel) ||
            void 0 !== t.offset ||
            void 0 !== t.rotation ||
            void 0 !== t.scale
            ? ((e = e.clone()),
              void 0 !== t.texCoord && (e.channel = t.texCoord),
              void 0 !== t.offset && e.offset.fromArray(t.offset),
              void 0 !== t.rotation && (e.rotation = t.rotation),
              void 0 !== t.scale && e.repeat.fromArray(t.scale),
              (e.needsUpdate = !0),
              e)
            : e;
        }
      }
      class Mx {
        constructor() {
          this.name = ix.KHR_MESH_QUANTIZATION;
        }
      }
      class Tx extends rd {
        constructor(e, t, n, i) {
          super(e, t, n, i);
        }
        copySampleValue_(e) {
          const t = this.resultBuffer,
            n = this.sampleValues,
            i = this.valueSize,
            r = e * i * 3 + i;
          for (let e = 0; e !== i; e++) t[e] = n[r + e];
          return t;
        }
        interpolate_(e, t, n, i) {
          const r = this.resultBuffer,
            s = this.sampleValues,
            a = this.valueSize,
            o = 2 * a,
            c = 3 * a,
            l = i - t,
            u = (n - t) / l,
            h = u * u,
            d = h * u,
            p = e * c,
            f = p - c,
            A = -2 * d + 3 * h,
            g = d - h,
            m = 1 - A,
            v = g - h + u;
          for (let e = 0; e !== a; e++) {
            const t = s[f + e + a],
              n = s[f + e + o] * l,
              i = s[p + e + a],
              c = s[p + e] * l;
            r[e] = m * t + v * n + A * i + g * c;
          }
          return r;
        }
      }
      const Bx = new qr();
      class Rx extends Tx {
        interpolate_(e, t, n, i) {
          const r = super.interpolate_(e, t, n, i);
          return Bx.fromArray(r).normalize().toArray(r), r;
        }
      }
      const Dx = {
          FLOAT: 5126,
          FLOAT_MAT3: 35675,
          FLOAT_MAT4: 35676,
          FLOAT_VEC2: 35664,
          FLOAT_VEC3: 35665,
          FLOAT_VEC4: 35666,
          LINEAR: 9729,
          REPEAT: 10497,
          SAMPLER_2D: 35678,
          POINTS: 0,
          LINES: 1,
          LINE_LOOP: 2,
          LINE_STRIP: 3,
          TRIANGLES: 4,
          TRIANGLE_STRIP: 5,
          TRIANGLE_FAN: 6,
          UNSIGNED_BYTE: 5121,
          UNSIGNED_SHORT: 5123,
        },
        Px = {
          5120: Int8Array,
          5121: Uint8Array,
          5122: Int16Array,
          5123: Uint16Array,
          5125: Uint32Array,
          5126: Float32Array,
        },
        Lx = { 9728: Dn, 9729: Un, 9984: Pn, 9985: Fn, 9986: Ln, 9987: On },
        Ux = { 33071: Bn, 33648: Rn, 10497: Tn },
        Fx = {
          SCALAR: 1,
          VEC2: 2,
          VEC3: 3,
          VEC4: 4,
          MAT2: 4,
          MAT3: 9,
          MAT4: 16,
        },
        Ox = {
          POSITION: "position",
          NORMAL: "normal",
          TANGENT: "tangent",
          TEXCOORD_0: "uv",
          TEXCOORD_1: "uv1",
          TEXCOORD_2: "uv2",
          TEXCOORD_3: "uv3",
          COLOR_0: "color",
          WEIGHTS_0: "skinWeight",
          JOINTS_0: "skinIndex",
        },
        Nx = {
          scale: "scale",
          translation: "position",
          rotation: "quaternion",
          weights: "morphTargetInfluences",
        },
        kx = { CUBICSPLINE: void 0, LINEAR: zi, STEP: Hi },
        Qx = "OPAQUE",
        Gx = "MASK",
        Hx = "BLEND";
      function zx(e) {
        return (
          void 0 === e.DefaultMaterial &&
            (e.DefaultMaterial = new Yh({
              color: 16777215,
              emissive: 0,
              metalness: 1,
              roughness: 1,
              transparent: !1,
              depthTest: !0,
              side: cn,
            })),
          e.DefaultMaterial
        );
      }
      function Vx(e, t, n) {
        for (const i in n.extensions)
          void 0 === e[i] &&
            ((t.userData.gltfExtensions = t.userData.gltfExtensions || {}),
            (t.userData.gltfExtensions[i] = n.extensions[i]));
      }
      function jx(e, t) {
        void 0 !== t.extras &&
          ("object" == typeof t.extras
            ? Object.assign(e.userData, t.extras)
            : console.warn(
                "THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras
              ));
      }
      function Wx(e, t) {
        if ((e.updateMorphTargets(), void 0 !== t.weights))
          for (let n = 0, i = t.weights.length; n < i; n++)
            e.morphTargetInfluences[n] = t.weights[n];
        if (t.extras && Array.isArray(t.extras.targetNames)) {
          const n = t.extras.targetNames;
          if (e.morphTargetInfluences.length === n.length) {
            e.morphTargetDictionary = {};
            for (let t = 0, i = n.length; t < i; t++)
              e.morphTargetDictionary[n[t]] = t;
          } else
            console.warn(
              "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
            );
        }
      }
      function Xx(e) {
        let t;
        const n = e.extensions && e.extensions[ix.KHR_DRACO_MESH_COMPRESSION];
        if (
          ((t = n
            ? "draco:" + n.bufferView + ":" + n.indices + ":" + qx(n.attributes)
            : e.indices + ":" + qx(e.attributes) + ":" + e.mode),
          void 0 !== e.targets)
        )
          for (let n = 0, i = e.targets.length; n < i; n++)
            t += ":" + qx(e.targets[n]);
        return t;
      }
      function qx(e) {
        let t = "";
        const n = Object.keys(e).sort();
        for (let i = 0, r = n.length; i < r; i++)
          t += n[i] + ":" + e[n[i]] + ";";
        return t;
      }
      function Yx(e) {
        switch (e) {
          case Int8Array:
            return 1 / 127;
          case Uint8Array:
            return 1 / 255;
          case Int16Array:
            return 1 / 32767;
          case Uint16Array:
            return 1 / 65535;
          default:
            throw new Error(
              "THREE.GLTFLoader: Unsupported normalized accessor component type."
            );
        }
      }
      const Kx = new Cs();
      class Jx {
        constructor(e = {}, t = {}) {
          (this.json = e),
            (this.extensions = {}),
            (this.plugins = {}),
            (this.options = t),
            (this.cache = new nx()),
            (this.associations = new Map()),
            (this.primitiveCache = {}),
            (this.nodeCache = {}),
            (this.meshCache = { refs: {}, uses: {} }),
            (this.cameraCache = { refs: {}, uses: {} }),
            (this.lightCache = { refs: {}, uses: {} }),
            (this.sourceCache = {}),
            (this.textureCache = {}),
            (this.nodeNamesUsed = {});
          let n = !1,
            i = -1,
            r = !1,
            s = -1;
          if ("undefined" != typeof navigator) {
            const e = navigator.userAgent;
            n = !0 === /^((?!chrome|android).)*safari/i.test(e);
            const t = e.match(/Version\/(\d+)/);
            (i = n && t ? parseInt(t[1], 10) : -1),
              (r = e.indexOf("Firefox") > -1),
              (s = r ? e.match(/Firefox\/([0-9]+)\./)[1] : -1);
          }
          "undefined" == typeof createImageBitmap ||
          (n && i < 17) ||
          (r && s < 98)
            ? (this.textureLoader = new Id(this.options.manager))
            : (this.textureLoader = new Vd(this.options.manager)),
            this.textureLoader.setCrossOrigin(this.options.crossOrigin),
            this.textureLoader.setRequestHeader(this.options.requestHeader),
            (this.fileLoader = new wd(this.options.manager)),
            this.fileLoader.setResponseType("arraybuffer"),
            "use-credentials" === this.options.crossOrigin &&
              this.fileLoader.setWithCredentials(!0);
        }
        setExtensions(e) {
          this.extensions = e;
        }
        setPlugins(e) {
          this.plugins = e;
        }
        parse(e, t) {
          const n = this,
            i = this.json,
            r = this.extensions;
          this.cache.removeAll(),
            (this.nodeCache = {}),
            this._invokeAll(function (e) {
              return e._markDefs && e._markDefs();
            }),
            Promise.all(
              this._invokeAll(function (e) {
                return e.beforeRoot && e.beforeRoot();
              })
            )
              .then(function () {
                return Promise.all([
                  n.getDependencies("scene"),
                  n.getDependencies("animation"),
                  n.getDependencies("camera"),
                ]);
              })
              .then(function (t) {
                const s = {
                  scene: t[0][i.scene || 0],
                  scenes: t[0],
                  animations: t[1],
                  cameras: t[2],
                  asset: i.asset,
                  parser: n,
                  userData: {},
                };
                return (
                  Vx(r, s, i),
                  jx(s, i),
                  Promise.all(
                    n._invokeAll(function (e) {
                      return e.afterRoot && e.afterRoot(s);
                    })
                  ).then(function () {
                    for (const e of s.scenes) e.updateMatrixWorld();
                    e(s);
                  })
                );
              })
              .catch(t);
        }
        _markDefs() {
          const e = this.json.nodes || [],
            t = this.json.skins || [],
            n = this.json.meshes || [];
          for (let n = 0, i = t.length; n < i; n++) {
            const i = t[n].joints;
            for (let t = 0, n = i.length; t < n; t++) e[i[t]].isBone = !0;
          }
          for (let t = 0, i = e.length; t < i; t++) {
            const i = e[t];
            void 0 !== i.mesh &&
              (this._addNodeRef(this.meshCache, i.mesh),
              void 0 !== i.skin && (n[i.mesh].isSkinnedMesh = !0)),
              void 0 !== i.camera &&
                this._addNodeRef(this.cameraCache, i.camera);
          }
        }
        _addNodeRef(e, t) {
          void 0 !== t &&
            (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
        }
        _getNodeRef(e, t, n) {
          if (e.refs[t] <= 1) return n;
          const i = n.clone(),
            r = (e, t) => {
              const n = this.associations.get(e);
              null != n && this.associations.set(t, n);
              for (const [n, i] of e.children.entries()) r(i, t.children[n]);
            };
          return r(n, i), (i.name += "_instance_" + e.uses[t]++), i;
        }
        _invokeOne(e) {
          const t = Object.values(this.plugins);
          t.push(this);
          for (let n = 0; n < t.length; n++) {
            const i = e(t[n]);
            if (i) return i;
          }
          return null;
        }
        _invokeAll(e) {
          const t = Object.values(this.plugins);
          t.unshift(this);
          const n = [];
          for (let i = 0; i < t.length; i++) {
            const r = e(t[i]);
            r && n.push(r);
          }
          return n;
        }
        getDependency(e, t) {
          const n = e + ":" + t;
          let i = this.cache.get(n);
          if (!i) {
            switch (e) {
              case "scene":
                i = this.loadScene(t);
                break;
              case "node":
                i = this._invokeOne(function (e) {
                  return e.loadNode && e.loadNode(t);
                });
                break;
              case "mesh":
                i = this._invokeOne(function (e) {
                  return e.loadMesh && e.loadMesh(t);
                });
                break;
              case "accessor":
                i = this.loadAccessor(t);
                break;
              case "bufferView":
                i = this._invokeOne(function (e) {
                  return e.loadBufferView && e.loadBufferView(t);
                });
                break;
              case "buffer":
                i = this.loadBuffer(t);
                break;
              case "material":
                i = this._invokeOne(function (e) {
                  return e.loadMaterial && e.loadMaterial(t);
                });
                break;
              case "texture":
                i = this._invokeOne(function (e) {
                  return e.loadTexture && e.loadTexture(t);
                });
                break;
              case "skin":
                i = this.loadSkin(t);
                break;
              case "animation":
                i = this._invokeOne(function (e) {
                  return e.loadAnimation && e.loadAnimation(t);
                });
                break;
              case "camera":
                i = this.loadCamera(t);
                break;
              default:
                if (
                  ((i = this._invokeOne(function (n) {
                    return (
                      n != this && n.getDependency && n.getDependency(e, t)
                    );
                  })),
                  !i)
                )
                  throw new Error("Unknown type: " + e);
            }
            this.cache.add(n, i);
          }
          return i;
        }
        getDependencies(e) {
          let t = this.cache.get(e);
          if (!t) {
            const n = this,
              i = this.json[e + ("mesh" === e ? "es" : "s")] || [];
            (t = Promise.all(
              i.map(function (t, i) {
                return n.getDependency(e, i);
              })
            )),
              this.cache.add(e, t);
          }
          return t;
        }
        loadBuffer(e) {
          const t = this.json.buffers[e],
            n = this.fileLoader;
          if (t.type && "arraybuffer" !== t.type)
            throw new Error(
              "THREE.GLTFLoader: " + t.type + " buffer type is not supported."
            );
          if (void 0 === t.uri && 0 === e)
            return Promise.resolve(this.extensions[ix.KHR_BINARY_GLTF].body);
          const i = this.options;
          return new Promise(function (e, r) {
            n.load(zd.resolveURL(t.uri, i.path), e, void 0, function () {
              r(
                new Error(
                  'THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'
                )
              );
            });
          });
        }
        loadBufferView(e) {
          const t = this.json.bufferViews[e];
          return this.getDependency("buffer", t.buffer).then(function (e) {
            const n = t.byteLength || 0,
              i = t.byteOffset || 0;
            return e.slice(i, i + n);
          });
        }
        loadAccessor(e) {
          const t = this,
            n = this.json,
            i = this.json.accessors[e];
          if (void 0 === i.bufferView && void 0 === i.sparse) {
            const e = Fx[i.type],
              t = Px[i.componentType],
              n = !0 === i.normalized,
              r = new t(i.count * e);
            return Promise.resolve(new Ta(r, e, n));
          }
          const r = [];
          return (
            void 0 !== i.bufferView
              ? r.push(this.getDependency("bufferView", i.bufferView))
              : r.push(null),
            void 0 !== i.sparse &&
              (r.push(
                this.getDependency("bufferView", i.sparse.indices.bufferView)
              ),
              r.push(
                this.getDependency("bufferView", i.sparse.values.bufferView)
              )),
            Promise.all(r).then(function (e) {
              const r = e[0],
                s = Fx[i.type],
                a = Px[i.componentType],
                o = a.BYTES_PER_ELEMENT,
                c = o * s,
                l = i.byteOffset || 0,
                u =
                  void 0 !== i.bufferView
                    ? n.bufferViews[i.bufferView].byteStride
                    : void 0,
                h = !0 === i.normalized;
              let d, p;
              if (u && u !== c) {
                const e = Math.floor(l / u),
                  n =
                    "InterleavedBuffer:" +
                    i.bufferView +
                    ":" +
                    i.componentType +
                    ":" +
                    e +
                    ":" +
                    i.count;
                let c = t.cache.get(n);
                c ||
                  ((d = new a(r, e * u, (i.count * u) / o)),
                  (c = new vu(d, u / o)),
                  t.cache.add(n, c)),
                  (p = new bu(c, s, (l % u) / o, h));
              } else (d = null === r ? new a(i.count * s) : new a(r, l, i.count * s)), (p = new Ta(d, s, h));
              if (void 0 !== i.sparse) {
                const t = Fx.SCALAR,
                  n = Px[i.sparse.indices.componentType],
                  o = i.sparse.indices.byteOffset || 0,
                  c = i.sparse.values.byteOffset || 0,
                  l = new n(e[1], o, i.sparse.count * t),
                  u = new a(e[2], c, i.sparse.count * s);
                null !== r &&
                  (p = new Ta(p.array.slice(), p.itemSize, p.normalized)),
                  (p.normalized = !1);
                for (let e = 0, t = l.length; e < t; e++) {
                  const t = l[e];
                  if (
                    (p.setX(t, u[e * s]),
                    s >= 2 && p.setY(t, u[e * s + 1]),
                    s >= 3 && p.setZ(t, u[e * s + 2]),
                    s >= 4 && p.setW(t, u[e * s + 3]),
                    s >= 5)
                  )
                    throw new Error(
                      "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
                    );
                }
                p.normalized = h;
              }
              return p;
            })
          );
        }
        loadTexture(e) {
          const t = this.json,
            n = this.options,
            i = t.textures[e].source,
            r = t.images[i];
          let s = this.textureLoader;
          if (r.uri) {
            const e = n.manager.getHandler(r.uri);
            null !== e && (s = e);
          }
          return this.loadTextureImage(e, i, s);
        }
        loadTextureImage(e, t, n) {
          const i = this,
            r = this.json,
            s = r.textures[e],
            a = r.images[t],
            o = (a.uri || a.bufferView) + ":" + s.sampler;
          if (this.textureCache[o]) return this.textureCache[o];
          const c = this.loadImageSource(t, n)
            .then(function (t) {
              (t.flipY = !1),
                (t.name = s.name || a.name || ""),
                "" === t.name &&
                  "string" == typeof a.uri &&
                  !1 === a.uri.startsWith("data:image/") &&
                  (t.name = a.uri);
              const n = (r.samplers || {})[s.sampler] || {};
              return (
                (t.magFilter = Lx[n.magFilter] || Un),
                (t.minFilter = Lx[n.minFilter] || On),
                (t.wrapS = Ux[n.wrapS] || Tn),
                (t.wrapT = Ux[n.wrapT] || Tn),
                (t.generateMipmaps =
                  !t.isCompressedTexture &&
                  t.minFilter !== Dn &&
                  t.minFilter !== Un),
                i.associations.set(t, { textures: e }),
                t
              );
            })
            .catch(function () {
              return null;
            });
          return (this.textureCache[o] = c), c;
        }
        loadImageSource(e, t) {
          const n = this,
            i = this.json,
            r = this.options;
          if (void 0 !== this.sourceCache[e])
            return this.sourceCache[e].then((e) => e.clone());
          const s = i.images[e],
            a = self.URL || self.webkitURL;
          let o = s.uri || "",
            c = !1;
          if (void 0 !== s.bufferView)
            o = n.getDependency("bufferView", s.bufferView).then(function (e) {
              c = !0;
              const t = new Blob([e], { type: s.mimeType });
              return (o = a.createObjectURL(t)), o;
            });
          else if (void 0 === s.uri)
            throw new Error(
              "THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"
            );
          const l = Promise.resolve(o)
            .then(function (e) {
              return new Promise(function (n, i) {
                let s = n;
                !0 === t.isImageBitmapLoader &&
                  (s = function (e) {
                    const t = new Hr(e);
                    (t.needsUpdate = !0), n(t);
                  }),
                  t.load(zd.resolveURL(e, r.path), s, void 0, i);
              });
            })
            .then(function (e) {
              var t;
              return (
                !0 === c && a.revokeObjectURL(o),
                jx(e, s),
                (e.userData.mimeType =
                  s.mimeType ||
                  ((t = s.uri).search(/\.jpe?g($|\?)/i) > 0 ||
                  0 === t.search(/^data\:image\/jpeg/)
                    ? "image/jpeg"
                    : t.search(/\.webp($|\?)/i) > 0 ||
                      0 === t.search(/^data\:image\/webp/)
                    ? "image/webp"
                    : t.search(/\.ktx2($|\?)/i) > 0 ||
                      0 === t.search(/^data\:image\/ktx2/)
                    ? "image/ktx2"
                    : "image/png")),
                e
              );
            })
            .catch(function (e) {
              throw (
                (console.error("THREE.GLTFLoader: Couldn't load texture", o), e)
              );
            });
          return (this.sourceCache[e] = l), l;
        }
        assignTexture(e, t, n, i) {
          const r = this;
          return this.getDependency("texture", n.index).then(function (s) {
            if (!s) return null;
            if (
              (void 0 !== n.texCoord &&
                n.texCoord > 0 &&
                ((s = s.clone()).channel = n.texCoord),
              r.extensions[ix.KHR_TEXTURE_TRANSFORM])
            ) {
              const e =
                void 0 !== n.extensions
                  ? n.extensions[ix.KHR_TEXTURE_TRANSFORM]
                  : void 0;
              if (e) {
                const t = r.associations.get(s);
                (s = r.extensions[ix.KHR_TEXTURE_TRANSFORM].extendTexture(
                  s,
                  e
                )),
                  r.associations.set(s, t);
              }
            }
            return void 0 !== i && (s.colorSpace = i), (e[t] = s), s;
          });
        }
        assignFinalMaterial(e) {
          const t = e.geometry;
          let n = e.material;
          const i = void 0 === t.attributes.tangent,
            r = void 0 !== t.attributes.color,
            s = void 0 === t.attributes.normal;
          if (e.isPoints) {
            const e = "PointsMaterial:" + n.uuid;
            let t = this.cache.get(e);
            t ||
              ((t = new sh()),
              ba.prototype.copy.call(t, n),
              t.color.copy(n.color),
              (t.map = n.map),
              (t.sizeAttenuation = !1),
              this.cache.add(e, t)),
              (n = t);
          } else if (e.isLine) {
            const e = "LineBasicMaterial:" + n.uuid;
            let t = this.cache.get(e);
            t ||
              ((t = new ju()),
              ba.prototype.copy.call(t, n),
              t.color.copy(n.color),
              (t.map = n.map),
              this.cache.add(e, t)),
              (n = t);
          }
          if (i || r || s) {
            let e = "ClonedMaterial:" + n.uuid + ":";
            i && (e += "derivative-tangents:"),
              r && (e += "vertex-colors:"),
              s && (e += "flat-shading:");
            let t = this.cache.get(e);
            t ||
              ((t = n.clone()),
              r && (t.vertexColors = !0),
              s && (t.flatShading = !0),
              i &&
                (t.normalScale && (t.normalScale.y *= -1),
                t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)),
              this.cache.add(e, t),
              this.associations.set(t, this.associations.get(n))),
              (n = t);
          }
          e.material = n;
        }
        getMaterialType() {
          return Yh;
        }
        loadMaterial(e) {
          const t = this,
            n = this.json,
            i = this.extensions,
            r = n.materials[e];
          let s;
          const a = {},
            o = [];
          if ((r.extensions || {})[ix.KHR_MATERIALS_UNLIT]) {
            const e = i[ix.KHR_MATERIALS_UNLIT];
            (s = e.getMaterialType()), o.push(e.extendParams(a, r, t));
          } else {
            const n = r.pbrMetallicRoughness || {};
            if (
              ((a.color = new ma(1, 1, 1)),
              (a.opacity = 1),
              Array.isArray(n.baseColorFactor))
            ) {
              const e = n.baseColorFactor;
              a.color.setRGB(e[0], e[1], e[2], $i), (a.opacity = e[3]);
            }
            void 0 !== n.baseColorTexture &&
              o.push(t.assignTexture(a, "map", n.baseColorTexture, Zi)),
              (a.metalness =
                void 0 !== n.metallicFactor ? n.metallicFactor : 1),
              (a.roughness =
                void 0 !== n.roughnessFactor ? n.roughnessFactor : 1),
              void 0 !== n.metallicRoughnessTexture &&
                (o.push(
                  t.assignTexture(a, "metalnessMap", n.metallicRoughnessTexture)
                ),
                o.push(
                  t.assignTexture(a, "roughnessMap", n.metallicRoughnessTexture)
                )),
              (s = this._invokeOne(function (t) {
                return t.getMaterialType && t.getMaterialType(e);
              })),
              o.push(
                Promise.all(
                  this._invokeAll(function (t) {
                    return (
                      t.extendMaterialParams && t.extendMaterialParams(e, a)
                    );
                  })
                )
              );
          }
          !0 === r.doubleSided && (a.side = un);
          const c = r.alphaMode || Qx;
          if (
            (c === Hx
              ? ((a.transparent = !0), (a.depthWrite = !1))
              : ((a.transparent = !1),
                c === Gx &&
                  (a.alphaTest =
                    void 0 !== r.alphaCutoff ? r.alphaCutoff : 0.5)),
            void 0 !== r.normalTexture &&
              s !== _a &&
              (o.push(t.assignTexture(a, "normalMap", r.normalTexture)),
              (a.normalScale = new br(1, 1)),
              void 0 !== r.normalTexture.scale))
          ) {
            const e = r.normalTexture.scale;
            a.normalScale.set(e, e);
          }
          if (
            (void 0 !== r.occlusionTexture &&
              s !== _a &&
              (o.push(t.assignTexture(a, "aoMap", r.occlusionTexture)),
              void 0 !== r.occlusionTexture.strength &&
                (a.aoMapIntensity = r.occlusionTexture.strength)),
            void 0 !== r.emissiveFactor && s !== _a)
          ) {
            const e = r.emissiveFactor;
            a.emissive = new ma().setRGB(e[0], e[1], e[2], $i);
          }
          return (
            void 0 !== r.emissiveTexture &&
              s !== _a &&
              o.push(t.assignTexture(a, "emissiveMap", r.emissiveTexture, Zi)),
            Promise.all(o).then(function () {
              const n = new s(a);
              return (
                r.name && (n.name = r.name),
                jx(n, r),
                t.associations.set(n, { materials: e }),
                r.extensions && Vx(i, n, r),
                n
              );
            })
          );
        }
        createUniqueName(e) {
          const t = ep.sanitizeNodeName(e || "");
          return t in this.nodeNamesUsed
            ? t + "_" + ++this.nodeNamesUsed[t]
            : ((this.nodeNamesUsed[t] = 0), t);
        }
        loadGeometries(e) {
          const t = this,
            n = this.extensions,
            i = this.primitiveCache;
          function r(e) {
            return n[ix.KHR_DRACO_MESH_COMPRESSION]
              .decodePrimitive(e, t)
              .then(function (n) {
                return Zx(n, e, t);
              });
          }
          const s = [];
          for (let n = 0, a = e.length; n < a; n++) {
            const a = e[n],
              o = Xx(a),
              c = i[o];
            if (c) s.push(c.promise);
            else {
              let e;
              (e =
                a.extensions && a.extensions[ix.KHR_DRACO_MESH_COMPRESSION]
                  ? r(a)
                  : Zx(new Qa(), a, t)),
                (i[o] = { primitive: a, promise: e }),
                s.push(e);
            }
          }
          return Promise.all(s);
        }
        loadMesh(e) {
          const t = this,
            n = this.json,
            i = this.extensions,
            r = n.meshes[e],
            s = r.primitives,
            a = [];
          for (let e = 0, t = s.length; e < t; e++) {
            const t =
              void 0 === s[e].material
                ? zx(this.cache)
                : this.getDependency("material", s[e].material);
            a.push(t);
          }
          return (
            a.push(t.loadGeometries(s)),
            Promise.all(a).then(function (n) {
              const a = n.slice(0, n.length - 1),
                o = n[n.length - 1],
                c = [];
              for (let n = 0, l = o.length; n < l; n++) {
                const l = o[n],
                  u = s[n];
                let h;
                const d = a[n];
                if (
                  u.mode === Dx.TRIANGLES ||
                  u.mode === Dx.TRIANGLE_STRIP ||
                  u.mode === Dx.TRIANGLE_FAN ||
                  void 0 === u.mode
                )
                  (h = !0 === r.isSkinnedMesh ? new Bu(l, d) : new Za(l, d)),
                    !0 === h.isSkinnedMesh && h.normalizeSkinWeights(),
                    u.mode === Dx.TRIANGLE_STRIP
                      ? (h.geometry = ex(h.geometry, 1))
                      : u.mode === Dx.TRIANGLE_FAN &&
                        (h.geometry = ex(h.geometry, 2));
                else if (u.mode === Dx.LINES) h = new ih(l, d);
                else if (u.mode === Dx.LINE_STRIP) h = new $u(l, d);
                else if (u.mode === Dx.LINE_LOOP) h = new rh(l, d);
                else {
                  if (u.mode !== Dx.POINTS)
                    throw new Error(
                      "THREE.GLTFLoader: Primitive mode unsupported: " + u.mode
                    );
                  h = new uh(l, d);
                }
                Object.keys(h.geometry.morphAttributes).length > 0 && Wx(h, r),
                  (h.name = t.createUniqueName(r.name || "mesh_" + e)),
                  jx(h, r),
                  u.extensions && Vx(i, h, u),
                  t.assignFinalMaterial(h),
                  c.push(h);
              }
              for (let n = 0, i = c.length; n < i; n++)
                t.associations.set(c[n], { meshes: e, primitives: n });
              if (1 === c.length) return r.extensions && Vx(i, c[0], r), c[0];
              const l = new au();
              r.extensions && Vx(i, l, r), t.associations.set(l, { meshes: e });
              for (let e = 0, t = c.length; e < t; e++) l.add(c[e]);
              return l;
            })
          );
        }
        loadCamera(e) {
          let t;
          const n = this.json.cameras[e],
            i = n[n.type];
          if (i)
            return (
              "perspective" === n.type
                ? (t = new uo(
                    yr.radToDeg(i.yfov),
                    i.aspectRatio || 1,
                    i.znear || 1,
                    i.zfar || 2e6
                  ))
                : "orthographic" === n.type &&
                  (t = new No(
                    -i.xmag,
                    i.xmag,
                    i.ymag,
                    -i.ymag,
                    i.znear,
                    i.zfar
                  )),
              n.name && (t.name = this.createUniqueName(n.name)),
              jx(t, n),
              Promise.resolve(t)
            );
          console.warn("THREE.GLTFLoader: Missing camera parameters.");
        }
        loadSkin(e) {
          const t = this.json.skins[e],
            n = [];
          for (let e = 0, i = t.joints.length; e < i; e++)
            n.push(this._loadNodeShallow(t.joints[e]));
          return (
            void 0 !== t.inverseBindMatrices
              ? n.push(this.getDependency("accessor", t.inverseBindMatrices))
              : n.push(null),
            Promise.all(n).then(function (e) {
              const n = e.pop(),
                i = e,
                r = [],
                s = [];
              for (let e = 0, a = i.length; e < a; e++) {
                const a = i[e];
                if (a) {
                  r.push(a);
                  const t = new Cs();
                  null !== n && t.fromArray(n.array, 16 * e), s.push(t);
                } else
                  console.warn(
                    'THREE.GLTFLoader: Joint "%s" could not be found.',
                    t.joints[e]
                  );
              }
              return new Uu(r, s);
            })
          );
        }
        loadAnimation(e) {
          const t = this.json,
            n = this,
            i = t.animations[e],
            r = i.name ? i.name : "animation_" + e,
            s = [],
            a = [],
            o = [],
            c = [],
            l = [];
          for (let e = 0, t = i.channels.length; e < t; e++) {
            const t = i.channels[e],
              n = i.samplers[t.sampler],
              r = t.target,
              u = r.node,
              h = void 0 !== i.parameters ? i.parameters[n.input] : n.input,
              d = void 0 !== i.parameters ? i.parameters[n.output] : n.output;
            void 0 !== r.node &&
              (s.push(this.getDependency("node", u)),
              a.push(this.getDependency("accessor", h)),
              o.push(this.getDependency("accessor", d)),
              c.push(n),
              l.push(r));
          }
          return Promise.all([
            Promise.all(s),
            Promise.all(a),
            Promise.all(o),
            Promise.all(c),
            Promise.all(l),
          ]).then(function (e) {
            const t = e[0],
              i = e[1],
              s = e[2],
              a = e[3],
              o = e[4],
              c = [];
            for (let e = 0, r = t.length; e < r; e++) {
              const r = t[e],
                l = i[e],
                u = s[e],
                h = a[e],
                d = o[e];
              if (void 0 === r) continue;
              r.updateMatrix && r.updateMatrix();
              const p = n._createAnimationTracks(r, l, u, h, d);
              if (p) for (let e = 0; e < p.length; e++) c.push(p[e]);
            }
            return new gd(r, void 0, c);
          });
        }
        createNodeMesh(e) {
          const t = this.json,
            n = this,
            i = t.nodes[e];
          return void 0 === i.mesh
            ? null
            : n.getDependency("mesh", i.mesh).then(function (e) {
                const t = n._getNodeRef(n.meshCache, i.mesh, e);
                return (
                  void 0 !== i.weights &&
                    t.traverse(function (e) {
                      if (e.isMesh)
                        for (let t = 0, n = i.weights.length; t < n; t++)
                          e.morphTargetInfluences[t] = i.weights[t];
                    }),
                  t
                );
              });
        }
        loadNode(e) {
          const t = this,
            n = this.json.nodes[e],
            i = t._loadNodeShallow(e),
            r = [],
            s = n.children || [];
          for (let e = 0, n = s.length; e < n; e++)
            r.push(t.getDependency("node", s[e]));
          const a =
            void 0 === n.skin
              ? Promise.resolve(null)
              : t.getDependency("skin", n.skin);
          return Promise.all([i, Promise.all(r), a]).then(function (e) {
            const t = e[0],
              n = e[1],
              i = e[2];
            null !== i &&
              t.traverse(function (e) {
                e.isSkinnedMesh && e.bind(i, Kx);
              });
            for (let e = 0, i = n.length; e < i; e++) t.add(n[e]);
            return t;
          });
        }
        _loadNodeShallow(e) {
          const t = this.json,
            n = this.extensions,
            i = this;
          if (void 0 !== this.nodeCache[e]) return this.nodeCache[e];
          const r = t.nodes[e],
            s = r.name ? i.createUniqueName(r.name) : "",
            a = [],
            o = i._invokeOne(function (t) {
              return t.createNodeMesh && t.createNodeMesh(e);
            });
          return (
            o && a.push(o),
            void 0 !== r.camera &&
              a.push(
                i.getDependency("camera", r.camera).then(function (e) {
                  return i._getNodeRef(i.cameraCache, r.camera, e);
                })
              ),
            i
              ._invokeAll(function (t) {
                return t.createNodeAttachment && t.createNodeAttachment(e);
              })
              .forEach(function (e) {
                a.push(e);
              }),
            (this.nodeCache[e] = Promise.all(a).then(function (t) {
              let a;
              if (
                ((a =
                  !0 === r.isBone
                    ? new Ru()
                    : t.length > 1
                    ? new au()
                    : 1 === t.length
                    ? t[0]
                    : new Zs()),
                a !== t[0])
              )
                for (let e = 0, n = t.length; e < n; e++) a.add(t[e]);
              if (
                (r.name && ((a.userData.name = r.name), (a.name = s)),
                jx(a, r),
                r.extensions && Vx(n, a, r),
                void 0 !== r.matrix)
              ) {
                const e = new Cs();
                e.fromArray(r.matrix), a.applyMatrix4(e);
              } else void 0 !== r.translation && a.position.fromArray(r.translation), void 0 !== r.rotation && a.quaternion.fromArray(r.rotation), void 0 !== r.scale && a.scale.fromArray(r.scale);
              return (
                i.associations.has(a) || i.associations.set(a, {}),
                (i.associations.get(a).nodes = e),
                a
              );
            })),
            this.nodeCache[e]
          );
        }
        loadScene(e) {
          const t = this.extensions,
            n = this.json.scenes[e],
            i = this,
            r = new au();
          n.name && (r.name = i.createUniqueName(n.name)),
            jx(r, n),
            n.extensions && Vx(t, r, n);
          const s = n.nodes || [],
            a = [];
          for (let e = 0, t = s.length; e < t; e++)
            a.push(i.getDependency("node", s[e]));
          return Promise.all(a).then(function (e) {
            for (let t = 0, n = e.length; t < n; t++) r.add(e[t]);
            return (
              (i.associations = ((e) => {
                const t = new Map();
                for (const [e, n] of i.associations)
                  (e instanceof ba || e instanceof Hr) && t.set(e, n);
                return (
                  e.traverse((e) => {
                    const n = i.associations.get(e);
                    null != n && t.set(e, n);
                  }),
                  t
                );
              })(r)),
              r
            );
          });
        }
        _createAnimationTracks(e, t, n, i, r) {
          const s = [],
            a = e.name ? e.name : e.uuid,
            o = [];
          let c;
          switch (
            (Nx[r.path] === Nx.weights
              ? e.traverse(function (e) {
                  e.morphTargetInfluences && o.push(e.name ? e.name : e.uuid);
                })
              : o.push(a),
            Nx[r.path])
          ) {
            case Nx.weights:
              c = hd;
              break;
            case Nx.rotation:
              c = pd;
              break;
            case Nx.position:
            case Nx.scale:
              c = Ad;
              break;
            default:
              if (1 === n.itemSize) c = hd;
              else c = Ad;
          }
          const l = void 0 !== i.interpolation ? kx[i.interpolation] : zi,
            u = this._getArrayFromAccessor(n);
          for (let e = 0, n = o.length; e < n; e++) {
            const n = new c(o[e] + "." + Nx[r.path], t.array, u, l);
            "CUBICSPLINE" === i.interpolation &&
              this._createCubicSplineTrackInterpolant(n),
              s.push(n);
          }
          return s;
        }
        _getArrayFromAccessor(e) {
          let t = e.array;
          if (e.normalized) {
            const e = Yx(t.constructor),
              n = new Float32Array(t.length);
            for (let i = 0, r = t.length; i < r; i++) n[i] = t[i] * e;
            t = n;
          }
          return t;
        }
        _createCubicSplineTrackInterpolant(e) {
          (e.createInterpolant = function (e) {
            return new (this instanceof pd ? Rx : Tx)(
              this.times,
              this.values,
              this.getValueSize() / 3,
              e
            );
          }),
            (e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline =
              !0);
        }
      }
      function Zx(e, t, n) {
        const i = t.attributes,
          r = [];
        function s(t, i) {
          return n.getDependency("accessor", t).then(function (t) {
            e.setAttribute(i, t);
          });
        }
        for (const t in i) {
          const n = Ox[t] || t.toLowerCase();
          n in e.attributes || r.push(s(i[t], n));
        }
        if (void 0 !== t.indices && !e.index) {
          const i = n.getDependency("accessor", t.indices).then(function (t) {
            e.setIndex(t);
          });
          r.push(i);
        }
        return (
          Mr.workingColorSpace !== $i &&
            "COLOR_0" in i &&
            console.warn(
              `THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Mr.workingColorSpace}" not supported.`
            ),
          jx(e, t),
          (function (e, t, n) {
            const i = t.attributes,
              r = new Zr();
            if (void 0 === i.POSITION) return;
            {
              const e = n.json.accessors[i.POSITION],
                t = e.min,
                s = e.max;
              if (void 0 === t || void 0 === s)
                return void console.warn(
                  "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
                );
              if (
                (r.set(new Yr(t[0], t[1], t[2]), new Yr(s[0], s[1], s[2])),
                e.normalized)
              ) {
                const t = Yx(Px[e.componentType]);
                r.min.multiplyScalar(t), r.max.multiplyScalar(t);
              }
            }
            const s = t.targets;
            if (void 0 !== s) {
              const e = new Yr(),
                t = new Yr();
              for (let i = 0, r = s.length; i < r; i++) {
                const r = s[i];
                if (void 0 !== r.POSITION) {
                  const i = n.json.accessors[r.POSITION],
                    s = i.min,
                    a = i.max;
                  if (void 0 !== s && void 0 !== a) {
                    if (
                      (t.setX(Math.max(Math.abs(s[0]), Math.abs(a[0]))),
                      t.setY(Math.max(Math.abs(s[1]), Math.abs(a[1]))),
                      t.setZ(Math.max(Math.abs(s[2]), Math.abs(a[2]))),
                      i.normalized)
                    ) {
                      const e = Yx(Px[i.componentType]);
                      t.multiplyScalar(e);
                    }
                    e.max(t);
                  } else
                    console.warn(
                      "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
                    );
                }
              }
              r.expandByVector(e);
            }
            e.boundingBox = r;
            const a = new gs();
            r.getCenter(a.center),
              (a.radius = r.min.distanceTo(r.max) / 2),
              (e.boundingSphere = a);
          })(e, t, n),
          Promise.all(r).then(function () {
            return void 0 !== t.targets
              ? (function (e, t, n) {
                  let i = !1,
                    r = !1,
                    s = !1;
                  for (let e = 0, n = t.length; e < n; e++) {
                    const n = t[e];
                    if (
                      (void 0 !== n.POSITION && (i = !0),
                      void 0 !== n.NORMAL && (r = !0),
                      void 0 !== n.COLOR_0 && (s = !0),
                      i && r && s)
                    )
                      break;
                  }
                  if (!i && !r && !s) return Promise.resolve(e);
                  const a = [],
                    o = [],
                    c = [];
                  for (let l = 0, u = t.length; l < u; l++) {
                    const u = t[l];
                    if (i) {
                      const t =
                        void 0 !== u.POSITION
                          ? n.getDependency("accessor", u.POSITION)
                          : e.attributes.position;
                      a.push(t);
                    }
                    if (r) {
                      const t =
                        void 0 !== u.NORMAL
                          ? n.getDependency("accessor", u.NORMAL)
                          : e.attributes.normal;
                      o.push(t);
                    }
                    if (s) {
                      const t =
                        void 0 !== u.COLOR_0
                          ? n.getDependency("accessor", u.COLOR_0)
                          : e.attributes.color;
                      c.push(t);
                    }
                  }
                  return Promise.all([
                    Promise.all(a),
                    Promise.all(o),
                    Promise.all(c),
                  ]).then(function (t) {
                    const n = t[0],
                      a = t[1],
                      o = t[2];
                    return (
                      i && (e.morphAttributes.position = n),
                      r && (e.morphAttributes.normal = a),
                      s && (e.morphAttributes.color = o),
                      (e.morphTargetsRelative = !0),
                      e
                    );
                  });
                })(e, t.targets, n)
              : e;
          })
        );
      }
      class $x extends Sd {
        constructor(e) {
          super(e), (this.type = jn);
        }
        parse(e) {
          const t = function (e, t) {
              switch (e) {
                case 1:
                  throw new Error("THREE.RGBELoader: Read Error: " + (t || ""));
                case 2:
                  throw new Error(
                    "THREE.RGBELoader: Write Error: " + (t || "")
                  );
                case 3:
                  throw new Error(
                    "THREE.RGBELoader: Bad File Format: " + (t || "")
                  );
                default:
                  throw new Error(
                    "THREE.RGBELoader: Memory Error: " + (t || "")
                  );
              }
            },
            n = function (e, t, n) {
              t = t || 1024;
              let i = e.pos,
                r = -1,
                s = 0,
                a = "",
                o = String.fromCharCode.apply(
                  null,
                  new Uint16Array(e.subarray(i, i + 128))
                );
              for (; 0 > (r = o.indexOf("\n")) && s < t && i < e.byteLength; )
                (a += o),
                  (s += o.length),
                  (i += 128),
                  (o += String.fromCharCode.apply(
                    null,
                    new Uint16Array(e.subarray(i, i + 128))
                  ));
              return (
                -1 < r && (!1 !== n && (e.pos += s + r + 1), a + o.slice(0, r))
              );
            },
            i = function (e, t, n, i) {
              const r = e[t + 3],
                s = Math.pow(2, r - 128) / 255;
              (n[i + 0] = e[t + 0] * s),
                (n[i + 1] = e[t + 1] * s),
                (n[i + 2] = e[t + 2] * s),
                (n[i + 3] = 1);
            },
            r = function (e, t, n, i) {
              const r = e[t + 3],
                s = Math.pow(2, r - 128) / 255;
              (n[i + 0] = Sa.toHalfFloat(Math.min(e[t + 0] * s, 65504))),
                (n[i + 1] = Sa.toHalfFloat(Math.min(e[t + 1] * s, 65504))),
                (n[i + 2] = Sa.toHalfFloat(Math.min(e[t + 2] * s, 65504))),
                (n[i + 3] = Sa.toHalfFloat(1));
            },
            s = new Uint8Array(e);
          s.pos = 0;
          const a = (function (e) {
              const i = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
                r = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
                s = /^\s*FORMAT=(\S+)\s*$/,
                a = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
                o = {
                  valid: 0,
                  string: "",
                  comments: "",
                  programtype: "RGBE",
                  format: "",
                  gamma: 1,
                  exposure: 1,
                  width: 0,
                  height: 0,
                };
              let c, l;
              for (
                (e.pos >= e.byteLength || !(c = n(e))) &&
                  t(1, "no header found"),
                  (l = c.match(/^#\?(\S+)/)) || t(3, "bad initial token"),
                  o.valid |= 1,
                  o.programtype = l[1],
                  o.string += c + "\n";
                (c = n(e)), !1 !== c;

              )
                if (((o.string += c + "\n"), "#" !== c.charAt(0))) {
                  if (
                    ((l = c.match(i)) && (o.gamma = parseFloat(l[1])),
                    (l = c.match(r)) && (o.exposure = parseFloat(l[1])),
                    (l = c.match(s)) && ((o.valid |= 2), (o.format = l[1])),
                    (l = c.match(a)) &&
                      ((o.valid |= 4),
                      (o.height = parseInt(l[1], 10)),
                      (o.width = parseInt(l[2], 10))),
                    2 & o.valid && 4 & o.valid)
                  )
                    break;
                } else o.comments += c + "\n";
              return (
                2 & o.valid || t(3, "missing format specifier"),
                4 & o.valid || t(3, "missing image size specifier"),
                o
              );
            })(s),
            o = a.width,
            c = a.height,
            l = (function (e, n, i) {
              const r = n;
              if (r < 8 || r > 32767 || 2 !== e[0] || 2 !== e[1] || 128 & e[2])
                return new Uint8Array(e);
              r !== ((e[2] << 8) | e[3]) && t(3, "wrong scanline width");
              const s = new Uint8Array(4 * n * i);
              s.length || t(4, "unable to allocate buffer space");
              let a = 0,
                o = 0;
              const c = 4 * r,
                l = new Uint8Array(4),
                u = new Uint8Array(c);
              let h = i;
              for (; h > 0 && o < e.byteLength; ) {
                o + 4 > e.byteLength && t(1),
                  (l[0] = e[o++]),
                  (l[1] = e[o++]),
                  (l[2] = e[o++]),
                  (l[3] = e[o++]),
                  (2 == l[0] && 2 == l[1] && ((l[2] << 8) | l[3]) == r) ||
                    t(3, "bad rgbe scanline format");
                let n,
                  i = 0;
                for (; i < c && o < e.byteLength; ) {
                  n = e[o++];
                  const r = n > 128;
                  if (
                    (r && (n -= 128),
                    (0 === n || i + n > c) && t(3, "bad scanline data"),
                    r)
                  ) {
                    const t = e[o++];
                    for (let e = 0; e < n; e++) u[i++] = t;
                  } else u.set(e.subarray(o, o + n), i), (i += n), (o += n);
                }
                const d = r;
                for (let e = 0; e < d; e++) {
                  let t = 0;
                  (s[a] = u[e + t]),
                    (t += r),
                    (s[a + 1] = u[e + t]),
                    (t += r),
                    (s[a + 2] = u[e + t]),
                    (t += r),
                    (s[a + 3] = u[e + t]),
                    (a += 4);
                }
                h--;
              }
              return s;
            })(s.subarray(s.pos), o, c);
          let u, h, d;
          switch (this.type) {
            case Vn:
              d = l.length / 4;
              const e = new Float32Array(4 * d);
              for (let t = 0; t < d; t++) i(l, 4 * t, e, 4 * t);
              (u = e), (h = Vn);
              break;
            case jn:
              d = l.length / 4;
              const t = new Uint16Array(4 * d);
              for (let e = 0; e < d; e++) r(l, 4 * e, t, 4 * e);
              (u = t), (h = jn);
              break;
            default:
              throw new Error(
                "THREE.RGBELoader: Unsupported type: " + this.type
              );
          }
          return {
            width: o,
            height: c,
            data: u,
            header: a.string,
            gamma: a.gamma,
            exposure: a.exposure,
            type: h,
          };
        }
        setDataType(e) {
          return (this.type = e), this;
        }
        load(e, t, n, i) {
          return super.load(
            e,
            function (e, n) {
              switch (e.type) {
                case Vn:
                case jn:
                  (e.colorSpace = $i),
                    (e.minFilter = Un),
                    (e.magFilter = Un),
                    (e.generateMipmaps = !1),
                    (e.flipY = !0);
              }
              t && t(e, n);
            },
            n,
            i
          );
        }
      }
      var eE = Uint8Array,
        tE = Uint16Array,
        nE = Int32Array,
        iE = new eE([
          0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,
          4, 5, 5, 5, 5, 0, 0, 0, 0,
        ]),
        rE = new eE([
          0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10,
          10, 11, 11, 12, 12, 13, 13, 0, 0,
        ]),
        sE = new eE([
          16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
        ]),
        aE = function (e, t) {
          for (var n = new tE(31), i = 0; i < 31; ++i)
            n[i] = t += 1 << e[i - 1];
          var r = new nE(n[30]);
          for (i = 1; i < 30; ++i)
            for (var s = n[i]; s < n[i + 1]; ++s) r[s] = ((s - n[i]) << 5) | i;
          return { b: n, r };
        },
        oE = aE(iE, 2),
        cE = oE.b,
        lE = oE.r;
      (cE[28] = 258), (lE[258] = 28);
      for (
        var uE = aE(rE, 0), hE = uE.b, dE = (uE.r, new tE(32768)), pE = 0;
        pE < 32768;
        ++pE
      ) {
        var fE = ((43690 & pE) >> 1) | ((21845 & pE) << 1);
        (fE =
          ((61680 & (fE = ((52428 & fE) >> 2) | ((13107 & fE) << 2))) >> 4) |
          ((3855 & fE) << 4)),
          (dE[pE] = (((65280 & fE) >> 8) | ((255 & fE) << 8)) >> 1);
      }
      var AE = function (e, t, n) {
          for (var i = e.length, r = 0, s = new tE(t); r < i; ++r)
            e[r] && ++s[e[r] - 1];
          var a,
            o = new tE(t);
          for (r = 1; r < t; ++r) o[r] = (o[r - 1] + s[r - 1]) << 1;
          if (n) {
            a = new tE(1 << t);
            var c = 15 - t;
            for (r = 0; r < i; ++r)
              if (e[r])
                for (
                  var l = (r << 4) | e[r],
                    u = t - e[r],
                    h = o[e[r] - 1]++ << u,
                    d = h | ((1 << u) - 1);
                  h <= d;
                  ++h
                )
                  a[dE[h] >> c] = l;
          } else
            for (a = new tE(i), r = 0; r < i; ++r)
              e[r] && (a[r] = dE[o[e[r] - 1]++] >> (15 - e[r]));
          return a;
        },
        gE = new eE(288);
      for (pE = 0; pE < 144; ++pE) gE[pE] = 8;
      for (pE = 144; pE < 256; ++pE) gE[pE] = 9;
      for (pE = 256; pE < 280; ++pE) gE[pE] = 7;
      for (pE = 280; pE < 288; ++pE) gE[pE] = 8;
      var mE = new eE(32);
      for (pE = 0; pE < 32; ++pE) mE[pE] = 5;
      var vE = AE(gE, 9, 1),
        yE = AE(mE, 5, 1),
        bE = function (e) {
          for (var t = e[0], n = 1; n < e.length; ++n) e[n] > t && (t = e[n]);
          return t;
        },
        _E = function (e, t, n) {
          var i = (t / 8) | 0;
          return ((e[i] | (e[i + 1] << 8)) >> (7 & t)) & n;
        },
        xE = function (e, t) {
          var n = (t / 8) | 0;
          return (e[n] | (e[n + 1] << 8) | (e[n + 2] << 16)) >> (7 & t);
        },
        EE = function (e) {
          return ((e + 7) / 8) | 0;
        },
        wE = function (e, t, n) {
          return (
            (null == t || t < 0) && (t = 0),
            (null == n || n > e.length) && (n = e.length),
            new eE(e.subarray(t, n))
          );
        },
        CE = [
          "unexpected EOF",
          "invalid block type",
          "invalid length/literal",
          "invalid distance",
          "stream finished",
          "no stream handler",
          ,
          "no callback",
          "invalid UTF-8 data",
          "extra field too long",
          "date not in range 1980-2099",
          "filename too long",
          "stream finishing",
          "invalid zip data",
        ],
        SE = function (e, t, n) {
          var i = new Error(t || CE[e]);
          if (
            ((i.code = e),
            Error.captureStackTrace && Error.captureStackTrace(i, SE),
            !n)
          )
            throw i;
          return i;
        },
        IE = function (e, t, n, i) {
          var r = e.length,
            s = i ? i.length : 0;
          if (!r || (t.f && !t.l)) return n || new eE(0);
          var a = !n,
            o = a || 2 != t.i,
            c = t.i;
          a && (n = new eE(3 * r));
          var l = function (e) {
              var t = n.length;
              if (e > t) {
                var i = new eE(Math.max(2 * t, e));
                i.set(n), (n = i);
              }
            },
            u = t.f || 0,
            h = t.p || 0,
            d = t.b || 0,
            p = t.l,
            f = t.d,
            A = t.m,
            g = t.n,
            m = 8 * r;
          do {
            if (!p) {
              u = _E(e, h, 1);
              var v = _E(e, h + 1, 3);
              if (((h += 3), !v)) {
                var y = e[(B = EE(h) + 4) - 4] | (e[B - 3] << 8),
                  b = B + y;
                if (b > r) {
                  c && SE(0);
                  break;
                }
                o && l(d + y),
                  n.set(e.subarray(B, b), d),
                  (t.b = d += y),
                  (t.p = h = 8 * b),
                  (t.f = u);
                continue;
              }
              if (1 == v) (p = vE), (f = yE), (A = 9), (g = 5);
              else if (2 == v) {
                var _ = _E(e, h, 31) + 257,
                  x = _E(e, h + 10, 15) + 4,
                  E = _ + _E(e, h + 5, 31) + 1;
                h += 14;
                for (var w = new eE(E), C = new eE(19), S = 0; S < x; ++S)
                  C[sE[S]] = _E(e, h + 3 * S, 7);
                h += 3 * x;
                var I = bE(C),
                  M = (1 << I) - 1,
                  T = AE(C, I, 1);
                for (S = 0; S < E; ) {
                  var B,
                    R = T[_E(e, h, M)];
                  if (((h += 15 & R), (B = R >> 4) < 16)) w[S++] = B;
                  else {
                    var D = 0,
                      P = 0;
                    for (
                      16 == B
                        ? ((P = 3 + _E(e, h, 3)), (h += 2), (D = w[S - 1]))
                        : 17 == B
                        ? ((P = 3 + _E(e, h, 7)), (h += 3))
                        : 18 == B && ((P = 11 + _E(e, h, 127)), (h += 7));
                      P--;

                    )
                      w[S++] = D;
                  }
                }
                var L = w.subarray(0, _),
                  U = w.subarray(_);
                (A = bE(L)), (g = bE(U)), (p = AE(L, A, 1)), (f = AE(U, g, 1));
              } else SE(1);
              if (h > m) {
                c && SE(0);
                break;
              }
            }
            o && l(d + 131072);
            for (var F = (1 << A) - 1, O = (1 << g) - 1, N = h; ; N = h) {
              var k = (D = p[xE(e, h) & F]) >> 4;
              if ((h += 15 & D) > m) {
                c && SE(0);
                break;
              }
              if ((D || SE(2), k < 256)) n[d++] = k;
              else {
                if (256 == k) {
                  (N = h), (p = null);
                  break;
                }
                var Q = k - 254;
                if (k > 264) {
                  var G = iE[(S = k - 257)];
                  (Q = _E(e, h, (1 << G) - 1) + cE[S]), (h += G);
                }
                var H = f[xE(e, h) & O],
                  z = H >> 4;
                H || SE(3), (h += 15 & H);
                U = hE[z];
                if (z > 3) {
                  G = rE[z];
                  (U += xE(e, h) & ((1 << G) - 1)), (h += G);
                }
                if (h > m) {
                  c && SE(0);
                  break;
                }
                o && l(d + 131072);
                var V = d + Q;
                if (d < U) {
                  var j = s - U,
                    W = Math.min(U, V);
                  for (j + d < 0 && SE(3); d < W; ++d) n[d] = i[j + d];
                }
                for (; d < V; ++d) n[d] = n[d - U];
              }
            }
            (t.l = p),
              (t.p = N),
              (t.b = d),
              (t.f = u),
              p && ((u = 1), (t.m = A), (t.d = f), (t.n = g));
          } while (!u);
          return d != n.length && a ? wE(n, 0, d) : n.subarray(0, d);
        },
        ME = new eE(0),
        TE = function (e, t) {
          return (
            (8 != (15 & e[0]) || e[0] >> 4 > 7 || ((e[0] << 8) | e[1]) % 31) &&
              SE(6, "invalid zlib data"),
            ((e[1] >> 5) & 1) == +!t &&
              SE(
                6,
                "invalid zlib data: " +
                  (32 & e[1] ? "need" : "unexpected") +
                  " dictionary"
              ),
            2 + ((e[1] >> 3) & 4)
          );
        };
      function BE(e, t) {
        return IE(
          e.subarray(TE(e, t && t.dictionary), -4),
          { i: 2 },
          t && t.out,
          t && t.dictionary
        );
      }
      var RE = "undefined" != typeof TextDecoder && new TextDecoder();
      try {
        RE.decode(ME, { stream: !0 }), 1;
      } catch (e) {}
      "function" == typeof queueMicrotask
        ? queueMicrotask
        : "function" == typeof setTimeout && setTimeout;
      class DE extends Sd {
        constructor(e) {
          super(e), (this.type = jn);
        }
        parse(e) {
          const t = 65536,
            n = 14,
            i = 65537,
            r = 16384,
            s = Math.pow(2.7182818, 2.2);
          const a = { l: 0, c: 0, lc: 0 };
          function o(e, t, n, i, r) {
            for (; n < e; ) (t = (t << 8) | G(i, r)), (n += 8);
            (n -= e), (a.l = (t >> n) & ((1 << e) - 1)), (a.c = t), (a.lc = n);
          }
          const c = new Array(59);
          function l(e, t, n, r, s, l) {
            const u = t;
            let h = 0,
              d = 0;
            for (; r <= s; r++) {
              if (u.value - t.value > n) return !1;
              o(6, h, d, e, u);
              const i = a.l;
              if (((h = a.c), (d = a.lc), (l[r] = i), 63 == i)) {
                if (u.value - t.value > n)
                  throw new Error("Something wrong with hufUnpackEncTable");
                o(8, h, d, e, u);
                let i = a.l + 6;
                if (((h = a.c), (d = a.lc), r + i > s + 1))
                  throw new Error("Something wrong with hufUnpackEncTable");
                for (; i--; ) l[r++] = 0;
                r--;
              } else if (i >= 59) {
                let e = i - 59 + 2;
                if (r + e > s + 1)
                  throw new Error("Something wrong with hufUnpackEncTable");
                for (; e--; ) l[r++] = 0;
                r--;
              }
            }
            !(function (e) {
              for (let e = 0; e <= 58; ++e) c[e] = 0;
              for (let t = 0; t < i; ++t) c[e[t]] += 1;
              let t = 0;
              for (let e = 58; e > 0; --e) {
                const n = (t + c[e]) >> 1;
                (c[e] = t), (t = n);
              }
              for (let t = 0; t < i; ++t) {
                const n = e[t];
                n > 0 && (e[t] = n | (c[n]++ << 6));
              }
            })(l);
          }
          function u(e) {
            return 63 & e;
          }
          function h(e) {
            return e >> 6;
          }
          const d = { c: 0, lc: 0 };
          function p(e, t, n, i) {
            (e = (e << 8) | G(n, i)), (t += 8), (d.c = e), (d.lc = t);
          }
          const f = { c: 0, lc: 0 };
          function A(e, t, n, i, r, s, a, o, c) {
            if (e == t) {
              i < 8 && (p(n, i, r, s), (n = d.c), (i = d.lc));
              let e = n >> (i -= 8);
              if (((e = new Uint8Array([e])[0]), o.value + e > c)) return !1;
              const t = a[o.value - 1];
              for (; e-- > 0; ) a[o.value++] = t;
            } else {
              if (!(o.value < c)) return !1;
              a[o.value++] = e;
            }
            (f.c = n), (f.lc = i);
          }
          function g(e) {
            return 65535 & e;
          }
          function m(e) {
            const t = g(e);
            return t > 32767 ? t - 65536 : t;
          }
          const v = { a: 0, b: 0 };
          function y(e, t) {
            const n = m(e),
              i = m(t),
              r = n + (1 & i) + (i >> 1),
              s = r,
              a = r - i;
            (v.a = s), (v.b = a);
          }
          function b(e, t) {
            const n = g(e),
              i = g(t),
              r = (n - (i >> 1)) & 65535,
              s = (i + r - 32768) & 65535;
            (v.a = s), (v.b = r);
          }
          function _(e, t, n, i, r, s, a) {
            const o = a < 16384,
              c = n > r ? r : n;
            let l,
              u,
              h = 1;
            for (; h <= c; ) h <<= 1;
            for (h >>= 1, l = h, h >>= 1; h >= 1; ) {
              u = 0;
              const a = u + s * (r - l),
                c = s * h,
                d = s * l,
                p = i * h,
                f = i * l;
              let A, g, m, _;
              for (; u <= a; u += d) {
                let r = u;
                const s = u + i * (n - l);
                for (; r <= s; r += f) {
                  const n = r + p,
                    i = r + c,
                    s = i + p;
                  o
                    ? (y(e[r + t], e[i + t]),
                      (A = v.a),
                      (m = v.b),
                      y(e[n + t], e[s + t]),
                      (g = v.a),
                      (_ = v.b),
                      y(A, g),
                      (e[r + t] = v.a),
                      (e[n + t] = v.b),
                      y(m, _),
                      (e[i + t] = v.a),
                      (e[s + t] = v.b))
                    : (b(e[r + t], e[i + t]),
                      (A = v.a),
                      (m = v.b),
                      b(e[n + t], e[s + t]),
                      (g = v.a),
                      (_ = v.b),
                      b(A, g),
                      (e[r + t] = v.a),
                      (e[n + t] = v.b),
                      b(m, _),
                      (e[i + t] = v.a),
                      (e[s + t] = v.b));
                }
                if (n & h) {
                  const n = r + c;
                  o ? y(e[r + t], e[n + t]) : b(e[r + t], e[n + t]),
                    (A = v.a),
                    (e[n + t] = v.b),
                    (e[r + t] = A);
                }
              }
              if (r & h) {
                let r = u;
                const s = u + i * (n - l);
                for (; r <= s; r += f) {
                  const n = r + p;
                  o ? y(e[r + t], e[n + t]) : b(e[r + t], e[n + t]),
                    (A = v.a),
                    (e[n + t] = v.b),
                    (e[r + t] = A);
                }
              }
              (l = h), (h >>= 1);
            }
            return u;
          }
          function x(e, t, s, a, o, c) {
            const g = s.value,
              m = Q(t, s),
              v = Q(t, s);
            s.value += 4;
            const y = Q(t, s);
            if (((s.value += 4), m < 0 || m >= i || v < 0 || v >= i))
              throw new Error("Something wrong with HUF_ENCSIZE");
            const b = new Array(i),
              _ = new Array(r);
            !(function (e) {
              for (let t = 0; t < r; t++)
                (e[t] = {}), (e[t].len = 0), (e[t].lit = 0), (e[t].p = null);
            })(_);
            if (
              (l(e, s, a - (s.value - g), m, v, b), y > 8 * (a - (s.value - g)))
            )
              throw new Error("Something wrong with hufUncompress");
            !(function (e, t, i, r) {
              for (; t <= i; t++) {
                const i = h(e[t]),
                  s = u(e[t]);
                if (i >> s) throw new Error("Invalid table entry");
                if (s > n) {
                  const e = r[i >> (s - n)];
                  if (e.len) throw new Error("Invalid table entry");
                  if ((e.lit++, e.p)) {
                    const t = e.p;
                    e.p = new Array(e.lit);
                    for (let n = 0; n < e.lit - 1; ++n) e.p[n] = t[n];
                  } else e.p = new Array(1);
                  e.p[e.lit - 1] = t;
                } else if (s) {
                  let e = 0;
                  for (let a = 1 << (n - s); a > 0; a--) {
                    const a = r[(i << (n - s)) + e];
                    if (a.len || a.p) throw new Error("Invalid table entry");
                    (a.len = s), (a.lit = t), e++;
                  }
                }
              }
            })(b, m, v, _),
              (function (e, t, i, r, s, a, o, c, l) {
                let g = 0,
                  m = 0;
                const v = o,
                  y = Math.trunc(r.value + (s + 7) / 8);
                for (; r.value < y; )
                  for (p(g, m, i, r), g = d.c, m = d.lc; m >= n; ) {
                    const s = t[(g >> (m - n)) & 16383];
                    if (s.len)
                      (m -= s.len),
                        A(s.lit, a, g, m, i, r, c, l, v),
                        (g = f.c),
                        (m = f.lc);
                    else {
                      if (!s.p) throw new Error("hufDecode issues");
                      let t;
                      for (t = 0; t < s.lit; t++) {
                        const n = u(e[s.p[t]]);
                        for (; m < n && r.value < y; )
                          p(g, m, i, r), (g = d.c), (m = d.lc);
                        if (
                          m >= n &&
                          h(e[s.p[t]]) == ((g >> (m - n)) & ((1 << n) - 1))
                        ) {
                          (m -= n),
                            A(s.p[t], a, g, m, i, r, c, l, v),
                            (g = f.c),
                            (m = f.lc);
                          break;
                        }
                      }
                      if (t == s.lit) throw new Error("hufDecode issues");
                    }
                  }
                const b = (8 - s) & 7;
                for (g >>= b, m -= b; m > 0; ) {
                  const e = t[(g << (n - m)) & 16383];
                  if (!e.len) throw new Error("hufDecode issues");
                  (m -= e.len),
                    A(e.lit, a, g, m, i, r, c, l, v),
                    (g = f.c),
                    (m = f.lc);
                }
              })(b, _, e, s, y, v, c, o, { value: 0 });
          }
          function E(e) {
            for (let t = 1; t < e.length; t++) {
              const n = e[t - 1] + e[t] - 128;
              e[t] = n;
            }
          }
          function w(e, t) {
            let n = 0,
              i = Math.floor((e.length + 1) / 2),
              r = 0;
            const s = e.length - 1;
            for (; !(r > s || ((t[r++] = e[n++]), r > s)); ) t[r++] = e[i++];
          }
          function C(e) {
            let t = e.byteLength;
            const n = new Array();
            let i = 0;
            const r = new DataView(e);
            for (; t > 0; ) {
              const e = r.getInt8(i++);
              if (e < 0) {
                const s = -e;
                t -= s + 1;
                for (let e = 0; e < s; e++) n.push(r.getUint8(i++));
              } else {
                const s = e;
                t -= 2;
                const a = r.getUint8(i++);
                for (let e = 0; e < s + 1; e++) n.push(a);
              }
            }
            return n;
          }
          function S(e, t, n) {
            let i,
              r = 1;
            for (; r < 64; )
              (i = t[e.value]),
                65280 == i
                  ? (r = 64)
                  : i >> 8 == 255
                  ? (r += 255 & i)
                  : ((n[r] = i), r++),
                e.value++;
          }
          function I(e, t) {
            (t[0] = W(e[0])),
              (t[1] = W(e[1])),
              (t[2] = W(e[5])),
              (t[3] = W(e[6])),
              (t[4] = W(e[14])),
              (t[5] = W(e[15])),
              (t[6] = W(e[27])),
              (t[7] = W(e[28])),
              (t[8] = W(e[2])),
              (t[9] = W(e[4])),
              (t[10] = W(e[7])),
              (t[11] = W(e[13])),
              (t[12] = W(e[16])),
              (t[13] = W(e[26])),
              (t[14] = W(e[29])),
              (t[15] = W(e[42])),
              (t[16] = W(e[3])),
              (t[17] = W(e[8])),
              (t[18] = W(e[12])),
              (t[19] = W(e[17])),
              (t[20] = W(e[25])),
              (t[21] = W(e[30])),
              (t[22] = W(e[41])),
              (t[23] = W(e[43])),
              (t[24] = W(e[9])),
              (t[25] = W(e[11])),
              (t[26] = W(e[18])),
              (t[27] = W(e[24])),
              (t[28] = W(e[31])),
              (t[29] = W(e[40])),
              (t[30] = W(e[44])),
              (t[31] = W(e[53])),
              (t[32] = W(e[10])),
              (t[33] = W(e[19])),
              (t[34] = W(e[23])),
              (t[35] = W(e[32])),
              (t[36] = W(e[39])),
              (t[37] = W(e[45])),
              (t[38] = W(e[52])),
              (t[39] = W(e[54])),
              (t[40] = W(e[20])),
              (t[41] = W(e[22])),
              (t[42] = W(e[33])),
              (t[43] = W(e[38])),
              (t[44] = W(e[46])),
              (t[45] = W(e[51])),
              (t[46] = W(e[55])),
              (t[47] = W(e[60])),
              (t[48] = W(e[21])),
              (t[49] = W(e[34])),
              (t[50] = W(e[37])),
              (t[51] = W(e[47])),
              (t[52] = W(e[50])),
              (t[53] = W(e[56])),
              (t[54] = W(e[59])),
              (t[55] = W(e[61])),
              (t[56] = W(e[35])),
              (t[57] = W(e[36])),
              (t[58] = W(e[48])),
              (t[59] = W(e[49])),
              (t[60] = W(e[57])),
              (t[61] = W(e[58])),
              (t[62] = W(e[62])),
              (t[63] = W(e[63]));
          }
          function M(e) {
            const t = 0.5 * Math.cos(0.7853975),
              n = 0.5 * Math.cos(3.14159 / 16),
              i = 0.5 * Math.cos(3.14159 / 8),
              r = 0.5 * Math.cos((3 * 3.14159) / 16),
              s = 0.5 * Math.cos(0.981746875),
              a = 0.5 * Math.cos((3 * 3.14159) / 8),
              o = 0.5 * Math.cos(1.374445625),
              c = new Array(4),
              l = new Array(4),
              u = new Array(4),
              h = new Array(4);
            for (let d = 0; d < 8; ++d) {
              const p = 8 * d;
              (c[0] = i * e[p + 2]),
                (c[1] = a * e[p + 2]),
                (c[2] = i * e[p + 6]),
                (c[3] = a * e[p + 6]),
                (l[0] =
                  n * e[p + 1] + r * e[p + 3] + s * e[p + 5] + o * e[p + 7]),
                (l[1] =
                  r * e[p + 1] - o * e[p + 3] - n * e[p + 5] - s * e[p + 7]),
                (l[2] =
                  s * e[p + 1] - n * e[p + 3] + o * e[p + 5] + r * e[p + 7]),
                (l[3] =
                  o * e[p + 1] - s * e[p + 3] + r * e[p + 5] - n * e[p + 7]),
                (u[0] = t * (e[p + 0] + e[p + 4])),
                (u[3] = t * (e[p + 0] - e[p + 4])),
                (u[1] = c[0] + c[3]),
                (u[2] = c[1] - c[2]),
                (h[0] = u[0] + u[1]),
                (h[1] = u[3] + u[2]),
                (h[2] = u[3] - u[2]),
                (h[3] = u[0] - u[1]),
                (e[p + 0] = h[0] + l[0]),
                (e[p + 1] = h[1] + l[1]),
                (e[p + 2] = h[2] + l[2]),
                (e[p + 3] = h[3] + l[3]),
                (e[p + 4] = h[3] - l[3]),
                (e[p + 5] = h[2] - l[2]),
                (e[p + 6] = h[1] - l[1]),
                (e[p + 7] = h[0] - l[0]);
            }
            for (let d = 0; d < 8; ++d)
              (c[0] = i * e[16 + d]),
                (c[1] = a * e[16 + d]),
                (c[2] = i * e[48 + d]),
                (c[3] = a * e[48 + d]),
                (l[0] =
                  n * e[8 + d] + r * e[24 + d] + s * e[40 + d] + o * e[56 + d]),
                (l[1] =
                  r * e[8 + d] - o * e[24 + d] - n * e[40 + d] - s * e[56 + d]),
                (l[2] =
                  s * e[8 + d] - n * e[24 + d] + o * e[40 + d] + r * e[56 + d]),
                (l[3] =
                  o * e[8 + d] - s * e[24 + d] + r * e[40 + d] - n * e[56 + d]),
                (u[0] = t * (e[d] + e[32 + d])),
                (u[3] = t * (e[d] - e[32 + d])),
                (u[1] = c[0] + c[3]),
                (u[2] = c[1] - c[2]),
                (h[0] = u[0] + u[1]),
                (h[1] = u[3] + u[2]),
                (h[2] = u[3] - u[2]),
                (h[3] = u[0] - u[1]),
                (e[0 + d] = h[0] + l[0]),
                (e[8 + d] = h[1] + l[1]),
                (e[16 + d] = h[2] + l[2]),
                (e[24 + d] = h[3] + l[3]),
                (e[32 + d] = h[3] - l[3]),
                (e[40 + d] = h[2] - l[2]),
                (e[48 + d] = h[1] - l[1]),
                (e[56 + d] = h[0] - l[0]);
          }
          function T(e) {
            for (let t = 0; t < 64; ++t) {
              const n = e[0][t],
                i = e[1][t],
                r = e[2][t];
              (e[0][t] = n + 1.5747 * r),
                (e[1][t] = n - 0.1873 * i - 0.4682 * r),
                (e[2][t] = n + 1.8556 * i);
            }
          }
          function B(e, t, n) {
            for (let i = 0; i < 64; ++i) t[n + i] = Sa.toHalfFloat(R(e[i]));
          }
          function R(e) {
            return e <= 1
              ? Math.sign(e) * Math.pow(Math.abs(e), 2.2)
              : Math.sign(e) * Math.pow(s, Math.abs(e) - 1);
          }
          function D(e) {
            return new DataView(e.array.buffer, e.offset.value, e.size);
          }
          function P(e) {
            const t = e.viewer.buffer.slice(
                e.offset.value,
                e.offset.value + e.size
              ),
              n = new Uint8Array(C(t)),
              i = new Uint8Array(n.length);
            return E(n), w(n, i), new DataView(i.buffer);
          }
          function L(e) {
            const t = BE(
                e.array.slice(e.offset.value, e.offset.value + e.size)
              ),
              n = new Uint8Array(t.length);
            return E(t), w(t, n), new DataView(n.buffer);
          }
          function U(e) {
            const n = e.viewer,
              i = { value: e.offset.value },
              r = new Uint16Array(
                e.columns * e.lines * (e.inputChannels.length * e.type)
              ),
              s = new Uint8Array(8192);
            let a = 0;
            const o = new Array(e.inputChannels.length);
            for (let t = 0, n = e.inputChannels.length; t < n; t++)
              (o[t] = {}),
                (o[t].start = a),
                (o[t].end = o[t].start),
                (o[t].nx = e.columns),
                (o[t].ny = e.lines),
                (o[t].size = e.type),
                (a += o[t].nx * o[t].ny * o[t].size);
            const c = X(n, i),
              l = X(n, i);
            if (l >= 8192)
              throw new Error(
                "Something is wrong with PIZ_COMPRESSION BITMAP_SIZE"
              );
            if (c <= l) for (let e = 0; e < l - c + 1; e++) s[e + c] = H(n, i);
            const u = new Uint16Array(t),
              h = (function (e, n) {
                let i = 0;
                for (let r = 0; r < t; ++r)
                  (0 == r || e[r >> 3] & (1 << (7 & r))) && (n[i++] = r);
                const r = i - 1;
                for (; i < t; ) n[i++] = 0;
                return r;
              })(s, u),
              d = Q(n, i);
            x(e.array, n, i, d, r, a);
            for (let t = 0; t < e.inputChannels.length; ++t) {
              const e = o[t];
              for (let n = 0; n < o[t].size; ++n)
                _(r, e.start + n, e.nx, e.size, e.ny, e.nx * e.size, h);
            }
            !(function (e, t, n) {
              for (let i = 0; i < n; ++i) t[i] = e[t[i]];
            })(u, r, a);
            let p = 0;
            const f = new Uint8Array(r.buffer.byteLength);
            for (let t = 0; t < e.lines; t++)
              for (let t = 0; t < e.inputChannels.length; t++) {
                const e = o[t],
                  n = e.nx * e.size,
                  i = new Uint8Array(r.buffer, 2 * e.end, 2 * n);
                f.set(i, p), (p += 2 * n), (e.end += n);
              }
            return new DataView(f.buffer);
          }
          function F(e) {
            const t = BE(
                e.array.slice(e.offset.value, e.offset.value + e.size)
              ),
              n = e.inputChannels.length * e.lines * e.columns * e.totalBytes,
              i = new ArrayBuffer(n),
              r = new DataView(i);
            let s = 0,
              a = 0;
            const o = new Array(4);
            for (let n = 0; n < e.lines; n++)
              for (let n = 0; n < e.inputChannels.length; n++) {
                let i = 0;
                switch (e.inputChannels[n].pixelType) {
                  case 1:
                    (o[0] = s),
                      (o[1] = o[0] + e.columns),
                      (s = o[1] + e.columns);
                    for (let n = 0; n < e.columns; ++n) {
                      (i += (t[o[0]++] << 8) | t[o[1]++]),
                        r.setUint16(a, i, !0),
                        (a += 2);
                    }
                    break;
                  case 2:
                    (o[0] = s),
                      (o[1] = o[0] + e.columns),
                      (o[2] = o[1] + e.columns),
                      (s = o[2] + e.columns);
                    for (let n = 0; n < e.columns; ++n) {
                      (i +=
                        (t[o[0]++] << 24) |
                        (t[o[1]++] << 16) |
                        (t[o[2]++] << 8)),
                        r.setUint32(a, i, !0),
                        (a += 4);
                    }
                }
              }
            return r;
          }
          function O(e) {
            const t = e.viewer,
              n = { value: e.offset.value },
              i = new Uint8Array(
                e.columns * e.lines * (e.inputChannels.length * e.type * 2)
              ),
              r = {
                version: z(t, n),
                unknownUncompressedSize: z(t, n),
                unknownCompressedSize: z(t, n),
                acCompressedSize: z(t, n),
                dcCompressedSize: z(t, n),
                rleCompressedSize: z(t, n),
                rleUncompressedSize: z(t, n),
                rleRawSize: z(t, n),
                totalAcUncompressedCount: z(t, n),
                totalDcUncompressedCount: z(t, n),
                acCompression: z(t, n),
              };
            if (r.version < 2)
              throw new Error(
                "EXRLoader.parse: " +
                  ie.compression +
                  " version " +
                  r.version +
                  " is unsupported"
              );
            const s = new Array();
            let a = X(t, n) - 2;
            for (; a > 0; ) {
              const e = N(t.buffer, n),
                i = H(t, n),
                r = (i >> 2) & 3,
                o = new Int8Array([(i >> 4) - 1])[0],
                c = H(t, n);
              s.push({ name: e, index: o, type: c, compression: r }),
                (a -= e.length + 3);
            }
            const o = ie.channels,
              c = new Array(e.inputChannels.length);
            for (let t = 0; t < e.inputChannels.length; ++t) {
              const n = (c[t] = {}),
                i = o[t];
              (n.name = i.name),
                (n.compression = 0),
                (n.decoded = !1),
                (n.type = i.pixelType),
                (n.pLinear = i.pLinear),
                (n.width = e.columns),
                (n.height = e.lines);
            }
            const l = { idx: new Array(3) };
            for (let t = 0; t < e.inputChannels.length; ++t) {
              const e = c[t];
              for (let n = 0; n < s.length; ++n) {
                const i = s[n];
                e.name == i.name &&
                  ((e.compression = i.compression),
                  i.index >= 0 && (l.idx[i.index] = t),
                  (e.offset = t));
              }
            }
            let u, h, d;
            if (r.acCompressedSize > 0)
              switch (r.acCompression) {
                case 0:
                  (u = new Uint16Array(r.totalAcUncompressedCount)),
                    x(
                      e.array,
                      t,
                      n,
                      r.acCompressedSize,
                      u,
                      r.totalAcUncompressedCount
                    );
                  break;
                case 1:
                  const i = BE(
                    e.array.slice(n.value, n.value + r.totalAcUncompressedCount)
                  );
                  (u = new Uint16Array(i.buffer)),
                    (n.value += r.totalAcUncompressedCount);
              }
            if (r.dcCompressedSize > 0) {
              const t = { array: e.array, offset: n, size: r.dcCompressedSize };
              (h = new Uint16Array(L(t).buffer)),
                (n.value += r.dcCompressedSize);
            }
            if (r.rleRawSize > 0) {
              (d = C(
                BE(e.array.slice(n.value, n.value + r.rleCompressedSize)).buffer
              )),
                (n.value += r.rleCompressedSize);
            }
            let p = 0;
            const f = new Array(c.length);
            for (let e = 0; e < f.length; ++e) f[e] = new Array();
            for (let t = 0; t < e.lines; ++t)
              for (let t = 0; t < c.length; ++t)
                f[t].push(p), (p += c[t].width * e.type * 2);
            !(function (e, t, n, i, r, s) {
              let a = new DataView(s.buffer);
              const o = n[e.idx[0]].width,
                c = n[e.idx[0]].height,
                l = Math.floor(o / 8),
                u = Math.ceil(o / 8),
                h = Math.ceil(c / 8),
                d = o - 8 * (u - 1),
                p = c - 8 * (h - 1),
                f = { value: 0 },
                A = new Array(3),
                g = new Array(3),
                m = new Array(3),
                v = new Array(3),
                y = new Array(3);
              for (let n = 0; n < 3; ++n)
                (y[n] = t[e.idx[n]]),
                  (A[n] = n < 1 ? 0 : A[n - 1] + u * h),
                  (g[n] = new Float32Array(64)),
                  (m[n] = new Uint16Array(64)),
                  (v[n] = new Uint16Array(64 * u));
              for (let t = 0; t < h; ++t) {
                let s = 8;
                t == h - 1 && (s = p);
                let o = 8;
                for (let e = 0; e < u; ++e) {
                  e == u - 1 && (o = d);
                  for (let e = 0; e < 3; ++e)
                    m[e].fill(0),
                      (m[e][0] = r[A[e]++]),
                      S(f, i, m[e]),
                      I(m[e], g[e]),
                      M(g[e]);
                  T(g);
                  for (let t = 0; t < 3; ++t) B(g[t], v[t], 64 * e);
                }
                let c = 0;
                for (let i = 0; i < 3; ++i) {
                  const r = n[e.idx[i]].type;
                  for (let e = 8 * t; e < 8 * t + s; ++e) {
                    c = y[i][e];
                    for (let t = 0; t < l; ++t) {
                      const n = 64 * t + 8 * (7 & e);
                      a.setUint16(c + 0 * r, v[i][n + 0], !0),
                        a.setUint16(c + 2 * r, v[i][n + 1], !0),
                        a.setUint16(c + 4 * r, v[i][n + 2], !0),
                        a.setUint16(c + 6 * r, v[i][n + 3], !0),
                        a.setUint16(c + 8 * r, v[i][n + 4], !0),
                        a.setUint16(c + 10 * r, v[i][n + 5], !0),
                        a.setUint16(c + 12 * r, v[i][n + 6], !0),
                        a.setUint16(c + 14 * r, v[i][n + 7], !0),
                        (c += 16 * r);
                    }
                  }
                  if (l != u)
                    for (let e = 8 * t; e < 8 * t + s; ++e) {
                      const t = y[i][e] + 8 * l * 2 * r,
                        n = 64 * l + 8 * (7 & e);
                      for (let e = 0; e < o; ++e)
                        a.setUint16(t + 2 * e * r, v[i][n + e], !0);
                    }
                }
              }
              const b = new Uint16Array(o);
              a = new DataView(s.buffer);
              for (let t = 0; t < 3; ++t) {
                n[e.idx[t]].decoded = !0;
                const i = n[e.idx[t]].type;
                if (2 == n[t].type)
                  for (let e = 0; e < c; ++e) {
                    const n = y[t][e];
                    for (let e = 0; e < o; ++e)
                      b[e] = a.getUint16(n + 2 * e * i, !0);
                    for (let e = 0; e < o; ++e)
                      a.setFloat32(n + 2 * e * i, W(b[e]), !0);
                  }
              }
            })(l, f, c, u, h, i);
            for (let t = 0; t < c.length; ++t) {
              const n = c[t];
              if (!n.decoded) {
                if (2 !== n.compression)
                  throw new Error(
                    "EXRLoader.parse: unsupported channel compression"
                  );
                {
                  let r = 0,
                    s = 0;
                  for (let a = 0; a < e.lines; ++a) {
                    let e = f[t][r];
                    for (let t = 0; t < n.width; ++t) {
                      for (let t = 0; t < 2 * n.type; ++t)
                        i[e++] = d[s + t * n.width * n.height];
                      s++;
                    }
                    r++;
                  }
                }
              }
            }
            return new DataView(i.buffer);
          }
          function N(e, t) {
            const n = new Uint8Array(e);
            let i = 0;
            for (; 0 != n[t.value + i]; ) i += 1;
            const r = new TextDecoder().decode(n.slice(t.value, t.value + i));
            return (t.value = t.value + i + 1), r;
          }
          function k(e, t) {
            const n = e.getInt32(t.value, !0);
            return (t.value = t.value + 4), n;
          }
          function Q(e, t) {
            const n = e.getUint32(t.value, !0);
            return (t.value = t.value + 4), n;
          }
          function G(e, t) {
            const n = e[t.value];
            return (t.value = t.value + 1), n;
          }
          function H(e, t) {
            const n = e.getUint8(t.value);
            return (t.value = t.value + 1), n;
          }
          const z = function (e, t) {
            let n;
            return (
              (n =
                "getBigInt64" in DataView.prototype
                  ? Number(e.getBigInt64(t.value, !0))
                  : e.getUint32(t.value + 4, !0) +
                    Number(e.getUint32(t.value, !0) << 32)),
              (t.value += 8),
              n
            );
          };
          function V(e, t) {
            const n = e.getFloat32(t.value, !0);
            return (t.value += 4), n;
          }
          function j(e, t) {
            return Sa.toHalfFloat(V(e, t));
          }
          function W(e) {
            const t = (31744 & e) >> 10,
              n = 1023 & e;
            return (
              (e >> 15 ? -1 : 1) *
              (t
                ? 31 === t
                  ? n
                    ? NaN
                    : 1 / 0
                  : Math.pow(2, t - 15) * (1 + n / 1024)
                : (n / 1024) * 6103515625e-14)
            );
          }
          function X(e, t) {
            const n = e.getUint16(t.value, !0);
            return (t.value += 2), n;
          }
          function q(e, t) {
            return W(X(e, t));
          }
          function Y(e, t, n, i, r) {
            return "string" === i || "stringvector" === i || "iccProfile" === i
              ? (function (e, t, n) {
                  const i = new TextDecoder().decode(
                    new Uint8Array(e).slice(t.value, t.value + n)
                  );
                  return (t.value = t.value + n), i;
                })(t, n, r)
              : "chlist" === i
              ? (function (e, t, n, i) {
                  const r = n.value,
                    s = [];
                  for (; n.value < r + i - 1; ) {
                    const i = N(t, n),
                      r = k(e, n),
                      a = H(e, n);
                    n.value += 3;
                    const o = k(e, n),
                      c = k(e, n);
                    s.push({
                      name: i,
                      pixelType: r,
                      pLinear: a,
                      xSampling: o,
                      ySampling: c,
                    });
                  }
                  return (n.value += 1), s;
                })(e, t, n, r)
              : "chromaticities" === i
              ? (function (e, t) {
                  return {
                    redX: V(e, t),
                    redY: V(e, t),
                    greenX: V(e, t),
                    greenY: V(e, t),
                    blueX: V(e, t),
                    blueY: V(e, t),
                    whiteX: V(e, t),
                    whiteY: V(e, t),
                  };
                })(e, n)
              : "compression" === i
              ? (function (e, t) {
                  return [
                    "NO_COMPRESSION",
                    "RLE_COMPRESSION",
                    "ZIPS_COMPRESSION",
                    "ZIP_COMPRESSION",
                    "PIZ_COMPRESSION",
                    "PXR24_COMPRESSION",
                    "B44_COMPRESSION",
                    "B44A_COMPRESSION",
                    "DWAA_COMPRESSION",
                    "DWAB_COMPRESSION",
                  ][H(e, t)];
                })(e, n)
              : "box2i" === i
              ? (function (e, t) {
                  return {
                    xMin: k(e, t),
                    yMin: k(e, t),
                    xMax: k(e, t),
                    yMax: k(e, t),
                  };
                })(e, n)
              : "envmap" === i
              ? (function (e, t) {
                  return ["ENVMAP_LATLONG", "ENVMAP_CUBE"][H(e, t)];
                })(e, n)
              : "tiledesc" === i
              ? (function (e, t) {
                  const n = Q(e, t),
                    i = Q(e, t),
                    r = H(e, t);
                  return {
                    xSize: n,
                    ySize: i,
                    levelMode: ["ONE_LEVEL", "MIPMAP_LEVELS", "RIPMAP_LEVELS"][
                      15 & r
                    ],
                    roundingMode: ["ROUND_DOWN", "ROUND_UP"][r >> 4],
                  };
                })(e, n)
              : "lineOrder" === i
              ? (function (e, t) {
                  return ["INCREASING_Y", "DECREASING_Y", "RANDOM_Y"][H(e, t)];
                })(e, n)
              : "float" === i
              ? V(e, n)
              : "v2f" === i
              ? (function (e, t) {
                  return [V(e, t), V(e, t)];
                })(e, n)
              : "v3f" === i
              ? (function (e, t) {
                  return [V(e, t), V(e, t), V(e, t)];
                })(e, n)
              : "int" === i
              ? k(e, n)
              : "rational" === i
              ? (function (e, t) {
                  return [k(e, t), Q(e, t)];
                })(e, n)
              : "timecode" === i
              ? (function (e, t) {
                  return [Q(e, t), Q(e, t)];
                })(e, n)
              : "preview" === i
              ? ((n.value += r), "skipped")
              : void (n.value += r);
          }
          function K(e, t, n) {
            let i = 0;
            switch (e.levelMode) {
              case "ONE_LEVEL":
                i = 1;
                break;
              case "MIPMAP_LEVELS":
                i =
                  (function (e, t) {
                    const n = Math.log2(e);
                    return "ROUND_DOWN" == t ? Math.floor(n) : Math.ceil(n);
                  })(Math.max(t, n), e.roundingMode) + 1;
                break;
              case "RIPMAP_LEVELS":
                throw new Error(
                  "THREE.EXRLoader: RIPMAP_LEVELS tiles currently unsupported."
                );
            }
            return i;
          }
          function J(e, t, n, i) {
            const r = new Array(e);
            for (let s = 0; s < e; s++) {
              const e = 1 << s;
              let a = (t / e) | 0;
              "ROUND_UP" == i && a * e < t && (a += 1);
              const o = Math.max(a, 1);
              r[s] = ((o + n - 1) / n) | 0;
            }
            return r;
          }
          function Z() {
            const e = this,
              t = e.offset,
              n = { value: 0 };
            for (let i = 0; i < e.tileCount; i++) {
              const i = k(e.viewer, t),
                r = k(e.viewer, t);
              (t.value += 8), (e.size = Q(e.viewer, t));
              const s = i * e.blockWidth,
                a = r * e.blockHeight;
              (e.columns =
                s + e.blockWidth > e.width ? e.width - s : e.blockWidth),
                (e.lines =
                  a + e.blockHeight > e.height ? e.height - a : e.blockHeight);
              const o = e.columns * e.totalBytes,
                c = e.size < e.lines * o ? e.uncompress(e) : D(e);
              t.value += e.size;
              for (let t = 0; t < e.lines; t++) {
                const i = t * e.columns * e.totalBytes;
                for (let r = 0; r < e.inputChannels.length; r++) {
                  const o = ie.channels[r].name,
                    l = e.channelByteOffsets[o] * e.columns,
                    u = e.decodeChannels[o];
                  if (void 0 === u) continue;
                  n.value = i + l;
                  const h = (e.height - (1 + a + t)) * e.outLineWidth;
                  for (let t = 0; t < e.columns; t++) {
                    const i = h + (t + s) * e.outputChannels + u;
                    e.byteArray[i] = e.getter(c, n);
                  }
                }
              }
            }
          }
          function $() {
            const e = this,
              t = e.offset,
              n = { value: 0 };
            for (let i = 0; i < e.height / e.blockHeight; i++) {
              const r = k(e.viewer, t) - ie.dataWindow.yMin;
              (e.size = Q(e.viewer, t)),
                (e.lines =
                  r + e.blockHeight > e.height ? e.height - r : e.blockHeight);
              const s = e.columns * e.totalBytes,
                a = e.size < e.lines * s ? e.uncompress(e) : D(e);
              t.value += e.size;
              for (let t = 0; t < e.blockHeight; t++) {
                const r = i * e.blockHeight,
                  o = t + e.scanOrder(r);
                if (o >= e.height) continue;
                const c = t * s,
                  l = (e.height - 1 - o) * e.outLineWidth;
                for (let t = 0; t < e.inputChannels.length; t++) {
                  const i = ie.channels[t].name,
                    r = e.channelByteOffsets[i] * e.columns,
                    s = e.decodeChannels[i];
                  if (void 0 !== s) {
                    n.value = c + r;
                    for (let t = 0; t < e.columns; t++) {
                      const i = l + t * e.outputChannels + s;
                      e.byteArray[i] = e.getter(a, n);
                    }
                  }
                }
              }
            }
          }
          const ee = { value: 0 },
            te = new DataView(e),
            ne = new Uint8Array(e),
            ie = (function (e, t, n) {
              const i = {};
              if (20000630 != e.getUint32(0, !0))
                throw new Error(
                  "THREE.EXRLoader: Provided file doesn't appear to be in OpenEXR format."
                );
              i.version = e.getUint8(4);
              const r = e.getUint8(5);
              (i.spec = {
                singleTile: !!(2 & r),
                longName: !!(4 & r),
                deepFormat: !!(8 & r),
                multiPart: !!(16 & r),
              }),
                (n.value = 8);
              let s = !0;
              for (; s; ) {
                const r = N(t, n);
                if (0 == r) s = !1;
                else {
                  const s = N(t, n),
                    a = Y(e, t, n, s, Q(e, n));
                  void 0 === a
                    ? console.warn(
                        `THREE.EXRLoader: Skipped unknown header attribute type '${s}'.`
                      )
                    : (i[r] = a);
                }
              }
              if (-7 & r)
                throw (
                  (console.error("THREE.EXRHeader:", i),
                  new Error(
                    "THREE.EXRLoader: Provided file is currently unsupported."
                  ))
                );
              return i;
            })(te, e, ee),
            re = (function (e, t, n, i, r) {
              const s = {
                size: 0,
                viewer: t,
                array: n,
                offset: i,
                width: e.dataWindow.xMax - e.dataWindow.xMin + 1,
                height: e.dataWindow.yMax - e.dataWindow.yMin + 1,
                inputChannels: e.channels,
                channelByteOffsets: {},
                scanOrder: null,
                totalBytes: null,
                columns: null,
                lines: null,
                type: null,
                uncompress: null,
                getter: null,
                format: null,
                colorSpace: $i,
              };
              switch (e.compression) {
                case "NO_COMPRESSION":
                  (s.blockHeight = 1), (s.uncompress = D);
                  break;
                case "RLE_COMPRESSION":
                  (s.blockHeight = 1), (s.uncompress = P);
                  break;
                case "ZIPS_COMPRESSION":
                  (s.blockHeight = 1), (s.uncompress = L);
                  break;
                case "ZIP_COMPRESSION":
                  (s.blockHeight = 16), (s.uncompress = L);
                  break;
                case "PIZ_COMPRESSION":
                  (s.blockHeight = 32), (s.uncompress = U);
                  break;
                case "PXR24_COMPRESSION":
                  (s.blockHeight = 16), (s.uncompress = F);
                  break;
                case "DWAA_COMPRESSION":
                  (s.blockHeight = 32), (s.uncompress = O);
                  break;
                case "DWAB_COMPRESSION":
                  (s.blockHeight = 256), (s.uncompress = O);
                  break;
                default:
                  throw new Error(
                    "EXRLoader.parse: " + e.compression + " is unsupported"
                  );
              }
              const a = {};
              for (const t of e.channels)
                switch (t.name) {
                  case "Y":
                  case "R":
                  case "G":
                  case "B":
                  case "A":
                    (a[t.name] = !0), (s.type = t.pixelType);
                }
              let o = !1;
              if (a.R && a.G && a.B)
                (o = !a.A),
                  (s.outputChannels = 4),
                  (s.decodeChannels = { R: 0, G: 1, B: 2, A: 3 });
              else {
                if (!a.Y)
                  throw new Error(
                    "EXRLoader.parse: file contains unsupported data channels."
                  );
                (s.outputChannels = 1), (s.decodeChannels = { Y: 0 });
              }
              if (1 == s.type)
                switch (r) {
                  case Vn:
                    s.getter = q;
                    break;
                  case jn:
                    s.getter = X;
                }
              else {
                if (2 != s.type)
                  throw new Error(
                    "EXRLoader.parse: unsupported pixelType " +
                      s.type +
                      " for " +
                      e.compression +
                      "."
                  );
                switch (r) {
                  case Vn:
                    s.getter = V;
                    break;
                  case jn:
                    s.getter = j;
                }
              }
              s.columns = s.width;
              const c = s.width * s.height * s.outputChannels;
              switch (r) {
                case Vn:
                  (s.byteArray = new Float32Array(c)),
                    o && s.byteArray.fill(1, 0, c);
                  break;
                case jn:
                  (s.byteArray = new Uint16Array(c)),
                    o && s.byteArray.fill(15360, 0, c);
                  break;
                default:
                  console.error("THREE.EXRLoader: unsupported type: ", r);
              }
              let l = 0;
              for (const t of e.channels)
                void 0 !== s.decodeChannels[t.name] &&
                  (s.channelByteOffsets[t.name] = l),
                  (l += 2 * t.pixelType);
              if (
                ((s.totalBytes = l),
                (s.outLineWidth = s.width * s.outputChannels),
                "INCREASING_Y" === e.lineOrder
                  ? (s.scanOrder = (e) => e)
                  : (s.scanOrder = (e) => s.height - 1 - e),
                4 == s.outputChannels
                  ? ((s.format = Zn), (s.colorSpace = $i))
                  : ((s.format = ii), (s.colorSpace = Ji)),
                e.spec.singleTile)
              ) {
                (s.blockHeight = e.tiles.ySize), (s.blockWidth = e.tiles.xSize);
                const n = K(e.tiles, s.width, s.height),
                  r = J(n, s.width, e.tiles.xSize, e.tiles.roundingMode),
                  a = J(n, s.height, e.tiles.ySize, e.tiles.roundingMode);
                s.tileCount = r[0] * a[0];
                for (let e = 0; e < n; e++)
                  for (let n = 0; n < a[e]; n++)
                    for (let n = 0; n < r[e]; n++) z(t, i);
                s.decode = Z.bind(s);
              } else {
                s.blockWidth = s.width;
                const e = Math.ceil(s.height / s.blockHeight);
                for (let n = 0; n < e; n++) z(t, i);
                s.decode = $.bind(s);
              }
              return s;
            })(ie, te, ne, ee, this.type);
          return (
            re.decode(),
            {
              header: ie,
              width: re.width,
              height: re.height,
              data: re.byteArray,
              format: re.format,
              colorSpace: re.colorSpace,
              type: this.type,
            }
          );
        }
        setDataType(e) {
          return (this.type = e), this;
        }
        load(e, t, n, i) {
          return super.load(
            e,
            function (e, n) {
              (e.colorSpace = n.colorSpace),
                (e.minFilter = Un),
                (e.magFilter = Un),
                (e.generateMipmaps = !1),
                (e.flipY = !1),
                t && t(e, n);
            },
            n,
            i
          );
        }
      }
      const PE = /^[og]\s*(.+)?/,
        LE = /^mtllib /,
        UE = /^usemtl /,
        FE = /^usemap /,
        OE = /\s+/,
        NE = new Yr(),
        kE = new Yr(),
        QE = new Yr(),
        GE = new Yr(),
        HE = new Yr(),
        zE = new ma();
      function VE() {
        const e = {
          objects: [],
          object: {},
          vertices: [],
          normals: [],
          colors: [],
          uvs: [],
          materials: {},
          materialLibraries: [],
          startObject: function (e, t) {
            if (this.object && !1 === this.object.fromDeclaration)
              return (
                (this.object.name = e),
                void (this.object.fromDeclaration = !1 !== t)
              );
            const n =
              this.object && "function" == typeof this.object.currentMaterial
                ? this.object.currentMaterial()
                : void 0;
            if (
              (this.object &&
                "function" == typeof this.object._finalize &&
                this.object._finalize(!0),
              (this.object = {
                name: e || "",
                fromDeclaration: !1 !== t,
                geometry: {
                  vertices: [],
                  normals: [],
                  colors: [],
                  uvs: [],
                  hasUVIndices: !1,
                },
                materials: [],
                smooth: !0,
                startMaterial: function (e, t) {
                  const n = this._finalize(!1);
                  n &&
                    (n.inherited || n.groupCount <= 0) &&
                    this.materials.splice(n.index, 1);
                  const i = {
                    index: this.materials.length,
                    name: e || "",
                    mtllib:
                      Array.isArray(t) && t.length > 0 ? t[t.length - 1] : "",
                    smooth: void 0 !== n ? n.smooth : this.smooth,
                    groupStart: void 0 !== n ? n.groupEnd : 0,
                    groupEnd: -1,
                    groupCount: -1,
                    inherited: !1,
                    clone: function (e) {
                      const t = {
                        index: "number" == typeof e ? e : this.index,
                        name: this.name,
                        mtllib: this.mtllib,
                        smooth: this.smooth,
                        groupStart: 0,
                        groupEnd: -1,
                        groupCount: -1,
                        inherited: !1,
                      };
                      return (t.clone = this.clone.bind(t)), t;
                    },
                  };
                  return this.materials.push(i), i;
                },
                currentMaterial: function () {
                  if (this.materials.length > 0)
                    return this.materials[this.materials.length - 1];
                },
                _finalize: function (e) {
                  const t = this.currentMaterial();
                  if (
                    (t &&
                      -1 === t.groupEnd &&
                      ((t.groupEnd = this.geometry.vertices.length / 3),
                      (t.groupCount = t.groupEnd - t.groupStart),
                      (t.inherited = !1)),
                    e && this.materials.length > 1)
                  )
                    for (let e = this.materials.length - 1; e >= 0; e--)
                      this.materials[e].groupCount <= 0 &&
                        this.materials.splice(e, 1);
                  return (
                    e &&
                      0 === this.materials.length &&
                      this.materials.push({ name: "", smooth: this.smooth }),
                    t
                  );
                },
              }),
              n && n.name && "function" == typeof n.clone)
            ) {
              const e = n.clone(0);
              (e.inherited = !0), this.object.materials.push(e);
            }
            this.objects.push(this.object);
          },
          finalize: function () {
            this.object &&
              "function" == typeof this.object._finalize &&
              this.object._finalize(!0);
          },
          parseVertexIndex: function (e, t) {
            const n = parseInt(e, 10);
            return 3 * (n >= 0 ? n - 1 : n + t / 3);
          },
          parseNormalIndex: function (e, t) {
            const n = parseInt(e, 10);
            return 3 * (n >= 0 ? n - 1 : n + t / 3);
          },
          parseUVIndex: function (e, t) {
            const n = parseInt(e, 10);
            return 2 * (n >= 0 ? n - 1 : n + t / 2);
          },
          addVertex: function (e, t, n) {
            const i = this.vertices,
              r = this.object.geometry.vertices;
            r.push(i[e + 0], i[e + 1], i[e + 2]),
              r.push(i[t + 0], i[t + 1], i[t + 2]),
              r.push(i[n + 0], i[n + 1], i[n + 2]);
          },
          addVertexPoint: function (e) {
            const t = this.vertices;
            this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2]);
          },
          addVertexLine: function (e) {
            const t = this.vertices;
            this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2]);
          },
          addNormal: function (e, t, n) {
            const i = this.normals,
              r = this.object.geometry.normals;
            r.push(i[e + 0], i[e + 1], i[e + 2]),
              r.push(i[t + 0], i[t + 1], i[t + 2]),
              r.push(i[n + 0], i[n + 1], i[n + 2]);
          },
          addFaceNormal: function (e, t, n) {
            const i = this.vertices,
              r = this.object.geometry.normals;
            NE.fromArray(i, e),
              kE.fromArray(i, t),
              QE.fromArray(i, n),
              HE.subVectors(QE, kE),
              GE.subVectors(NE, kE),
              HE.cross(GE),
              HE.normalize(),
              r.push(HE.x, HE.y, HE.z),
              r.push(HE.x, HE.y, HE.z),
              r.push(HE.x, HE.y, HE.z);
          },
          addColor: function (e, t, n) {
            const i = this.colors,
              r = this.object.geometry.colors;
            void 0 !== i[e] && r.push(i[e + 0], i[e + 1], i[e + 2]),
              void 0 !== i[t] && r.push(i[t + 0], i[t + 1], i[t + 2]),
              void 0 !== i[n] && r.push(i[n + 0], i[n + 1], i[n + 2]);
          },
          addUV: function (e, t, n) {
            const i = this.uvs,
              r = this.object.geometry.uvs;
            r.push(i[e + 0], i[e + 1]),
              r.push(i[t + 0], i[t + 1]),
              r.push(i[n + 0], i[n + 1]);
          },
          addDefaultUV: function () {
            const e = this.object.geometry.uvs;
            e.push(0, 0), e.push(0, 0), e.push(0, 0);
          },
          addUVLine: function (e) {
            const t = this.uvs;
            this.object.geometry.uvs.push(t[e + 0], t[e + 1]);
          },
          addFace: function (e, t, n, i, r, s, a, o, c) {
            const l = this.vertices.length;
            let u = this.parseVertexIndex(e, l),
              h = this.parseVertexIndex(t, l),
              d = this.parseVertexIndex(n, l);
            if (
              (this.addVertex(u, h, d),
              this.addColor(u, h, d),
              void 0 !== a && "" !== a)
            ) {
              const e = this.normals.length;
              (u = this.parseNormalIndex(a, e)),
                (h = this.parseNormalIndex(o, e)),
                (d = this.parseNormalIndex(c, e)),
                this.addNormal(u, h, d);
            } else this.addFaceNormal(u, h, d);
            if (void 0 !== i && "" !== i) {
              const e = this.uvs.length;
              (u = this.parseUVIndex(i, e)),
                (h = this.parseUVIndex(r, e)),
                (d = this.parseUVIndex(s, e)),
                this.addUV(u, h, d),
                (this.object.geometry.hasUVIndices = !0);
            } else this.addDefaultUV();
          },
          addPointGeometry: function (e) {
            this.object.geometry.type = "Points";
            const t = this.vertices.length;
            for (let n = 0, i = e.length; n < i; n++) {
              const i = this.parseVertexIndex(e[n], t);
              this.addVertexPoint(i), this.addColor(i);
            }
          },
          addLineGeometry: function (e, t) {
            this.object.geometry.type = "Line";
            const n = this.vertices.length,
              i = this.uvs.length;
            for (let t = 0, i = e.length; t < i; t++)
              this.addVertexLine(this.parseVertexIndex(e[t], n));
            for (let e = 0, n = t.length; e < n; e++)
              this.addUVLine(this.parseUVIndex(t[e], i));
          },
        };
        return e.startObject("", !1), e;
      }
      class jE extends _d {
        constructor(e) {
          super(e), (this.materials = null);
        }
        load(e, t, n, i) {
          const r = this,
            s = new wd(this.manager);
          s.setPath(this.path),
            s.setRequestHeader(this.requestHeader),
            s.setWithCredentials(this.withCredentials),
            s.load(
              e,
              function (n) {
                try {
                  t(r.parse(n));
                } catch (t) {
                  i ? i(t) : console.error(t), r.manager.itemError(e);
                }
              },
              n,
              i
            );
        }
        setMaterials(e) {
          return (this.materials = e), this;
        }
        parse(e) {
          const t = new VE();
          -1 !== e.indexOf("\r\n") && (e = e.replace(/\r\n/g, "\n")),
            -1 !== e.indexOf("\\\n") && (e = e.replace(/\\\n/g, ""));
          const n = e.split("\n");
          let i = [];
          for (let e = 0, r = n.length; e < r; e++) {
            const r = n[e].trimStart();
            if (0 === r.length) continue;
            const s = r.charAt(0);
            if ("#" !== s)
              if ("v" === s) {
                const e = r.split(OE);
                switch (e[0]) {
                  case "v":
                    t.vertices.push(
                      parseFloat(e[1]),
                      parseFloat(e[2]),
                      parseFloat(e[3])
                    ),
                      e.length >= 7
                        ? (zE.setRGB(
                            parseFloat(e[4]),
                            parseFloat(e[5]),
                            parseFloat(e[6]),
                            Zi
                          ),
                          t.colors.push(zE.r, zE.g, zE.b))
                        : t.colors.push(void 0, void 0, void 0);
                    break;
                  case "vn":
                    t.normals.push(
                      parseFloat(e[1]),
                      parseFloat(e[2]),
                      parseFloat(e[3])
                    );
                    break;
                  case "vt":
                    t.uvs.push(parseFloat(e[1]), parseFloat(e[2]));
                }
              } else if ("f" === s) {
                const e = r.slice(1).trim().split(OE),
                  n = [];
                for (let t = 0, i = e.length; t < i; t++) {
                  const i = e[t];
                  if (i.length > 0) {
                    const e = i.split("/");
                    n.push(e);
                  }
                }
                const i = n[0];
                for (let e = 1, r = n.length - 1; e < r; e++) {
                  const r = n[e],
                    s = n[e + 1];
                  t.addFace(
                    i[0],
                    r[0],
                    s[0],
                    i[1],
                    r[1],
                    s[1],
                    i[2],
                    r[2],
                    s[2]
                  );
                }
              } else if ("l" === s) {
                const e = r.substring(1).trim().split(" ");
                let n = [];
                const i = [];
                if (-1 === r.indexOf("/")) n = e;
                else
                  for (let t = 0, r = e.length; t < r; t++) {
                    const r = e[t].split("/");
                    "" !== r[0] && n.push(r[0]), "" !== r[1] && i.push(r[1]);
                  }
                t.addLineGeometry(n, i);
              } else if ("p" === s) {
                const e = r.slice(1).trim().split(" ");
                t.addPointGeometry(e);
              } else if (null !== (i = PE.exec(r))) {
                const e = (" " + i[0].slice(1).trim()).slice(1);
                t.startObject(e);
              } else if (UE.test(r))
                t.object.startMaterial(
                  r.substring(7).trim(),
                  t.materialLibraries
                );
              else if (LE.test(r))
                t.materialLibraries.push(r.substring(7).trim());
              else if (FE.test(r))
                console.warn(
                  'THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.'
                );
              else if ("s" === s) {
                if (((i = r.split(" ")), i.length > 1)) {
                  const e = i[1].trim().toLowerCase();
                  t.object.smooth = "0" !== e && "off" !== e;
                } else t.object.smooth = !0;
                const e = t.object.currentMaterial();
                e && (e.smooth = t.object.smooth);
              } else {
                if ("\0" === r) continue;
                console.warn('THREE.OBJLoader: Unexpected line: "' + r + '"');
              }
          }
          t.finalize();
          const r = new au();
          r.materialLibraries = [].concat(t.materialLibraries);
          if (
            !0 ===
            !(
              1 === t.objects.length &&
              0 === t.objects[0].geometry.vertices.length
            )
          )
            for (let e = 0, n = t.objects.length; e < n; e++) {
              const n = t.objects[e],
                i = n.geometry,
                s = n.materials,
                a = "Line" === i.type,
                o = "Points" === i.type;
              let c = !1;
              if (0 === i.vertices.length) continue;
              const l = new Qa();
              l.setAttribute("position", new Da(i.vertices, 3)),
                i.normals.length > 0 &&
                  l.setAttribute("normal", new Da(i.normals, 3)),
                i.colors.length > 0 &&
                  ((c = !0), l.setAttribute("color", new Da(i.colors, 3))),
                !0 === i.hasUVIndices && l.setAttribute("uv", new Da(i.uvs, 2));
              const u = [];
              for (let e = 0, n = s.length; e < n; e++) {
                const n = s[e],
                  i = n.name + "_" + n.smooth + "_" + c;
                let r = t.materials[i];
                if (null !== this.materials)
                  if (
                    ((r = this.materials.create(n.name)),
                    !a || !r || r instanceof ju)
                  ) {
                    if (o && r && !(r instanceof sh)) {
                      const e = new sh({ size: 10, sizeAttenuation: !1 });
                      ba.prototype.copy.call(e, r),
                        e.color.copy(r.color),
                        (e.map = r.map),
                        (r = e);
                    }
                  } else {
                    const e = new ju();
                    ba.prototype.copy.call(e, r),
                      e.color.copy(r.color),
                      (r = e);
                  }
                void 0 === r &&
                  ((r = a
                    ? new ju()
                    : o
                    ? new sh({ size: 1, sizeAttenuation: !1 })
                    : new Jh()),
                  (r.name = n.name),
                  (r.flatShading = !n.smooth),
                  (r.vertexColors = c),
                  (t.materials[i] = r)),
                  u.push(r);
              }
              let h;
              if (u.length > 1) {
                for (let e = 0, t = s.length; e < t; e++) {
                  const t = s[e];
                  l.addGroup(t.groupStart, t.groupCount, e);
                }
                h = a ? new ih(l, u) : o ? new uh(l, u) : new Za(l, u);
              } else
                h = a ? new ih(l, u[0]) : o ? new uh(l, u[0]) : new Za(l, u[0]);
              (h.name = n.name), r.add(h);
            }
          else if (t.vertices.length > 0) {
            const e = new sh({ size: 1, sizeAttenuation: !1 }),
              n = new Qa();
            n.setAttribute("position", new Da(t.vertices, 3)),
              t.colors.length > 0 &&
                void 0 !== t.colors[0] &&
                (n.setAttribute("color", new Da(t.colors, 3)),
                (e.vertexColors = !0));
            const i = new uh(n, e);
            r.add(i);
          }
          return r;
        }
      }
      function WE(e, t, n) {
        const i = n.length - e - 1;
        if (t >= n[i]) return i - 1;
        if (t <= n[e]) return e;
        let r = e,
          s = i,
          a = Math.floor((r + s) / 2);
        for (; t < n[a] || t >= n[a + 1]; )
          t < n[a] ? (s = a) : (r = a), (a = Math.floor((r + s) / 2));
        return a;
      }
      function XE(e, t, n, i) {
        const r = [],
          s = [],
          a = [];
        r[0] = 1;
        for (let o = 1; o <= n; ++o) {
          (s[o] = t - i[e + 1 - o]), (a[o] = i[e + o] - t);
          let n = 0;
          for (let e = 0; e < o; ++e) {
            const t = a[e + 1],
              i = s[o - e],
              c = r[e] / (t + i);
            (r[e] = n + t * c), (n = i * c);
          }
          r[o] = n;
        }
        return r;
      }
      function qE(e, t) {
        let n = 1;
        for (let t = 2; t <= e; ++t) n *= t;
        let i = 1;
        for (let e = 2; e <= t; ++e) i *= e;
        for (let n = 2; n <= e - t; ++n) i *= n;
        return n / i;
      }
      function YE(e, t, n, i, r) {
        const s = (function (e, t, n, i, r) {
          const s = r < e ? r : e,
            a = [],
            o = WE(e, i, t),
            c = (function (e, t, n, i, r) {
              const s = [];
              for (let e = 0; e <= n; ++e) s[e] = 0;
              const a = [];
              for (let e = 0; e <= i; ++e) a[e] = s.slice(0);
              const o = [];
              for (let e = 0; e <= n; ++e) o[e] = s.slice(0);
              o[0][0] = 1;
              const c = s.slice(0),
                l = s.slice(0);
              for (let i = 1; i <= n; ++i) {
                (c[i] = t - r[e + 1 - i]), (l[i] = r[e + i] - t);
                let n = 0;
                for (let e = 0; e < i; ++e) {
                  const t = l[e + 1],
                    r = c[i - e];
                  o[i][e] = t + r;
                  const s = o[e][i - 1] / o[i][e];
                  (o[e][i] = n + t * s), (n = r * s);
                }
                o[i][i] = n;
              }
              for (let e = 0; e <= n; ++e) a[0][e] = o[e][n];
              for (let e = 0; e <= n; ++e) {
                let t = 0,
                  r = 1;
                const c = [];
                for (let e = 0; e <= n; ++e) c[e] = s.slice(0);
                c[0][0] = 1;
                for (let s = 1; s <= i; ++s) {
                  let i = 0;
                  const l = e - s,
                    u = n - s;
                  e >= s &&
                    ((c[r][0] = c[t][0] / o[u + 1][l]),
                    (i = c[r][0] * o[l][u]));
                  const h = e - 1 <= u ? s - 1 : n - e;
                  for (let e = l >= -1 ? 1 : -l; e <= h; ++e)
                    (c[r][e] = (c[t][e] - c[t][e - 1]) / o[u + 1][l + e]),
                      (i += c[r][e] * o[l + e][u]);
                  e <= u &&
                    ((c[r][s] = -c[t][s - 1] / o[u + 1][e]),
                    (i += c[r][s] * o[e][u])),
                    (a[s][e] = i);
                  const d = t;
                  (t = r), (r = d);
                }
              }
              let u = n;
              for (let e = 1; e <= i; ++e) {
                for (let t = 0; t <= n; ++t) a[e][t] *= u;
                u *= n - e;
              }
              return a;
            })(o, i, e, s, t),
            l = [];
          for (let e = 0; e < n.length; ++e) {
            const t = n[e].clone(),
              i = t.w;
            (t.x *= i), (t.y *= i), (t.z *= i), (l[e] = t);
          }
          for (let t = 0; t <= s; ++t) {
            const n = l[o - e].clone().multiplyScalar(c[t][0]);
            for (let i = 1; i <= e; ++i)
              n.add(l[o - e + i].clone().multiplyScalar(c[t][i]));
            a[t] = n;
          }
          for (let e = s + 1; e <= r + 1; ++e) a[e] = new zr(0, 0, 0);
          return a;
        })(e, t, n, i, r);
        return (function (e) {
          const t = e.length,
            n = [],
            i = [];
          for (let r = 0; r < t; ++r) {
            const t = e[r];
            (n[r] = new Yr(t.x, t.y, t.z)), (i[r] = t.w);
          }
          const r = [];
          for (let e = 0; e < t; ++e) {
            const t = n[e].clone();
            for (let n = 1; n <= e; ++n)
              t.sub(r[e - n].clone().multiplyScalar(qE(e, n) * i[n]));
            r[e] = t.divideScalar(i[0]);
          }
          return r;
        })(s);
      }
      class KE extends gh {
        constructor(e, t, n, i, r) {
          super();
          const s = t ? t.length - 1 : 0,
            a = n ? n.length : 0;
          (this.degree = e),
            (this.knots = t),
            (this.controlPoints = []),
            (this.startKnot = i || 0),
            (this.endKnot = r || s);
          for (let e = 0; e < a; ++e) {
            const t = n[e];
            this.controlPoints[e] = new zr(t.x, t.y, t.z, t.w);
          }
        }
        getPoint(e, t = new Yr()) {
          const n = t,
            i =
              this.knots[this.startKnot] +
              e * (this.knots[this.endKnot] - this.knots[this.startKnot]),
            r = (function (e, t, n, i) {
              const r = WE(e, i, t),
                s = XE(r, i, e, t),
                a = new zr(0, 0, 0, 0);
              for (let t = 0; t <= e; ++t) {
                const i = n[r - e + t],
                  o = s[t],
                  c = i.w * o;
                (a.x += i.x * c),
                  (a.y += i.y * c),
                  (a.z += i.z * c),
                  (a.w += i.w * o);
              }
              return a;
            })(this.degree, this.knots, this.controlPoints, i);
          return 1 !== r.w && r.divideScalar(r.w), n.set(r.x, r.y, r.z);
        }
        getTangent(e, t = new Yr()) {
          const n = t,
            i =
              this.knots[0] +
              e * (this.knots[this.knots.length - 1] - this.knots[0]),
            r = YE(this.degree, this.knots, this.controlPoints, i, 1);
          return n.copy(r[1]).normalize(), n;
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.degree = this.degree),
            (e.knots = [...this.knots]),
            (e.controlPoints = this.controlPoints.map((e) => e.toArray())),
            (e.startKnot = this.startKnot),
            (e.endKnot = this.endKnot),
            e
          );
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            (this.degree = e.degree),
            (this.knots = [...e.knots]),
            (this.controlPoints = e.controlPoints.map(
              (e) => new zr(e[0], e[1], e[2], e[3])
            )),
            (this.startKnot = e.startKnot),
            (this.endKnot = e.endKnot),
            this
          );
        }
      }
      let JE, ZE, $E;
      class ew extends _d {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          const r = this,
            s = "" === r.path ? zd.extractUrlBase(e) : r.path,
            a = new wd(this.manager);
          a.setPath(r.path),
            a.setResponseType("arraybuffer"),
            a.setRequestHeader(r.requestHeader),
            a.setWithCredentials(r.withCredentials),
            a.load(
              e,
              function (n) {
                try {
                  t(r.parse(n, s));
                } catch (t) {
                  i ? i(t) : console.error(t), r.manager.itemError(e);
                }
              },
              n,
              i
            );
        }
        parse(e, t) {
          if (
            (function (e) {
              const t = "Kaydara FBX Binary  \0";
              return e.byteLength >= t.length && t === mw(e, 0, t.length);
            })(e)
          )
            JE = new sw().parse(e);
          else {
            const t = mw(e);
            if (
              !(function (e) {
                const t = [
                  "K",
                  "a",
                  "y",
                  "d",
                  "a",
                  "r",
                  "a",
                  "\\",
                  "F",
                  "B",
                  "X",
                  "\\",
                  "B",
                  "i",
                  "n",
                  "a",
                  "r",
                  "y",
                  "\\",
                  "\\",
                ];
                let n = 0;
                function i(t) {
                  const i = e[t - 1];
                  return (e = e.slice(n + t)), n++, i;
                }
                for (let e = 0; e < t.length; ++e) {
                  if (i(1) === t[e]) return !1;
                }
                return !0;
              })(t)
            )
              throw new Error("THREE.FBXLoader: Unknown format.");
            if (cw(t) < 7e3)
              throw new Error(
                "THREE.FBXLoader: FBX version not supported, FileVersion: " +
                  cw(t)
              );
            JE = new rw().parse(t);
          }
          const n = new Id(this.manager)
            .setPath(this.resourcePath || t)
            .setCrossOrigin(this.crossOrigin);
          return new tw(n, this.manager).parse(JE);
        }
      }
      class tw {
        constructor(e, t) {
          (this.textureLoader = e), (this.manager = t);
        }
        parse() {
          ZE = this.parseConnections();
          const e = this.parseImages(),
            t = this.parseTextures(e),
            n = this.parseMaterials(t),
            i = this.parseDeformers(),
            r = new nw().parse(i);
          return this.parseScene(i, r, n), $E;
        }
        parseConnections() {
          const e = new Map();
          if ("Connections" in JE) {
            JE.Connections.connections.forEach(function (t) {
              const n = t[0],
                i = t[1],
                r = t[2];
              e.has(n) || e.set(n, { parents: [], children: [] });
              const s = { ID: i, relationship: r };
              e.get(n).parents.push(s),
                e.has(i) || e.set(i, { parents: [], children: [] });
              const a = { ID: n, relationship: r };
              e.get(i).children.push(a);
            });
          }
          return e;
        }
        parseImages() {
          const e = {},
            t = {};
          if ("Video" in JE.Objects) {
            const n = JE.Objects.Video;
            for (const i in n) {
              const r = n[i];
              if (
                ((e[parseInt(i)] = r.RelativeFilename || r.Filename),
                "Content" in r)
              ) {
                const e =
                    r.Content instanceof ArrayBuffer &&
                    r.Content.byteLength > 0,
                  s = "string" == typeof r.Content && "" !== r.Content;
                if (e || s) {
                  const e = this.parseImage(n[i]);
                  t[r.RelativeFilename || r.Filename] = e;
                }
              }
            }
          }
          for (const n in e) {
            const i = e[n];
            void 0 !== t[i] ? (e[n] = t[i]) : (e[n] = e[n].split("\\").pop());
          }
          return e;
        }
        parseImage(e) {
          const t = e.Content,
            n = e.RelativeFilename || e.Filename,
            i = n.slice(n.lastIndexOf(".") + 1).toLowerCase();
          let r;
          switch (i) {
            case "bmp":
              r = "image/bmp";
              break;
            case "jpg":
            case "jpeg":
              r = "image/jpeg";
              break;
            case "png":
              r = "image/png";
              break;
            case "tif":
              r = "image/tiff";
              break;
            case "tga":
              null === this.manager.getHandler(".tga") &&
                console.warn("FBXLoader: TGA loader not found, skipping ", n),
                (r = "image/tga");
              break;
            default:
              return void console.warn(
                'FBXLoader: Image type "' + i + '" is not supported.'
              );
          }
          if ("string" == typeof t) return "data:" + r + ";base64," + t;
          {
            const e = new Uint8Array(t);
            return window.URL.createObjectURL(new Blob([e], { type: r }));
          }
        }
        parseTextures(e) {
          const t = new Map();
          if ("Texture" in JE.Objects) {
            const n = JE.Objects.Texture;
            for (const i in n) {
              const r = this.parseTexture(n[i], e);
              t.set(parseInt(i), r);
            }
          }
          return t;
        }
        parseTexture(e, t) {
          const n = this.loadTexture(e, t);
          (n.ID = e.id), (n.name = e.attrName);
          const i = e.WrapModeU,
            r = e.WrapModeV,
            s = void 0 !== i ? i.value : 0,
            a = void 0 !== r ? r.value : 0;
          if (
            ((n.wrapS = 0 === s ? Tn : Bn),
            (n.wrapT = 0 === a ? Tn : Bn),
            "Scaling" in e)
          ) {
            const t = e.Scaling.value;
            (n.repeat.x = t[0]), (n.repeat.y = t[1]);
          }
          if ("Translation" in e) {
            const t = e.Translation.value;
            (n.offset.x = t[0]), (n.offset.y = t[1]);
          }
          return n;
        }
        loadTexture(e, t) {
          const n = new Set([
              "tga",
              "tif",
              "tiff",
              "exr",
              "dds",
              "hdr",
              "ktx2",
            ]),
            i = e.FileName.split(".").pop().toLowerCase(),
            r = n.has(i)
              ? this.manager.getHandler(`.${i}`)
              : this.textureLoader;
          if (!r)
            return (
              console.warn(
                `FBXLoader: ${i.toUpperCase()} loader not found, creating placeholder texture for`,
                e.RelativeFilename
              ),
              new Hr()
            );
          const s = r.path;
          s || r.setPath(this.textureLoader.path);
          const a = ZE.get(e.id).children;
          let o;
          void 0 !== a &&
            a.length > 0 &&
            void 0 !== t[a[0].ID] &&
            ((o = t[a[0].ID]),
            (0 !== o.indexOf("blob:") && 0 !== o.indexOf("data:")) ||
              r.setPath(void 0));
          const c = r.load(o);
          return r.setPath(s), c;
        }
        parseMaterials(e) {
          const t = new Map();
          if ("Material" in JE.Objects) {
            const n = JE.Objects.Material;
            for (const i in n) {
              const r = this.parseMaterial(n[i], e);
              null !== r && t.set(parseInt(i), r);
            }
          }
          return t;
        }
        parseMaterial(e, t) {
          const n = e.id,
            i = e.attrName;
          let r = e.ShadingModel;
          if (("object" == typeof r && (r = r.value), !ZE.has(n))) return null;
          const s = this.parseParameters(e, t, n);
          let a;
          switch (r.toLowerCase()) {
            case "phong":
              a = new Jh();
              break;
            case "lambert":
              a = new Zh();
              break;
            default:
              console.warn(
                'THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.',
                r
              ),
                (a = new Jh());
          }
          return a.setValues(s), (a.name = i), a;
        }
        parseParameters(e, t, n) {
          const i = {};
          e.BumpFactor && (i.bumpScale = e.BumpFactor.value),
            e.Diffuse
              ? (i.color = Mr.toWorkingColorSpace(
                  new ma().fromArray(e.Diffuse.value),
                  Zi
                ))
              : !e.DiffuseColor ||
                ("Color" !== e.DiffuseColor.type &&
                  "ColorRGB" !== e.DiffuseColor.type) ||
                (i.color = Mr.toWorkingColorSpace(
                  new ma().fromArray(e.DiffuseColor.value),
                  Zi
                )),
            e.DisplacementFactor &&
              (i.displacementScale = e.DisplacementFactor.value),
            e.Emissive
              ? (i.emissive = Mr.toWorkingColorSpace(
                  new ma().fromArray(e.Emissive.value),
                  Zi
                ))
              : !e.EmissiveColor ||
                ("Color" !== e.EmissiveColor.type &&
                  "ColorRGB" !== e.EmissiveColor.type) ||
                (i.emissive = Mr.toWorkingColorSpace(
                  new ma().fromArray(e.EmissiveColor.value),
                  Zi
                )),
            e.EmissiveFactor &&
              (i.emissiveIntensity = parseFloat(e.EmissiveFactor.value)),
            (i.opacity =
              1 -
              (e.TransparencyFactor
                ? parseFloat(e.TransparencyFactor.value)
                : 0)),
            (1 !== i.opacity && 0 !== i.opacity) ||
              ((i.opacity = e.Opacity ? parseFloat(e.Opacity.value) : null),
              null === i.opacity &&
                (i.opacity =
                  1 -
                  (e.TransparentColor
                    ? parseFloat(e.TransparentColor.value[0])
                    : 0))),
            i.opacity < 1 && (i.transparent = !0),
            e.ReflectionFactor && (i.reflectivity = e.ReflectionFactor.value),
            e.Shininess && (i.shininess = e.Shininess.value),
            e.Specular
              ? (i.specular = Mr.toWorkingColorSpace(
                  new ma().fromArray(e.Specular.value),
                  Zi
                ))
              : e.SpecularColor &&
                "Color" === e.SpecularColor.type &&
                (i.specular = Mr.toWorkingColorSpace(
                  new ma().fromArray(e.SpecularColor.value),
                  Zi
                ));
          const r = this;
          return (
            ZE.get(n).children.forEach(function (e) {
              const n = e.relationship;
              switch (n) {
                case "Bump":
                  i.bumpMap = r.getTexture(t, e.ID);
                  break;
                case "Maya|TEX_ao_map":
                  i.aoMap = r.getTexture(t, e.ID);
                  break;
                case "DiffuseColor":
                case "Maya|TEX_color_map":
                  (i.map = r.getTexture(t, e.ID)),
                    void 0 !== i.map && (i.map.colorSpace = Zi);
                  break;
                case "DisplacementColor":
                  i.displacementMap = r.getTexture(t, e.ID);
                  break;
                case "EmissiveColor":
                  (i.emissiveMap = r.getTexture(t, e.ID)),
                    void 0 !== i.emissiveMap && (i.emissiveMap.colorSpace = Zi);
                  break;
                case "NormalMap":
                case "Maya|TEX_normal_map":
                  i.normalMap = r.getTexture(t, e.ID);
                  break;
                case "ReflectionColor":
                  (i.envMap = r.getTexture(t, e.ID)),
                    void 0 !== i.envMap &&
                      ((i.envMap.mapping = Sn), (i.envMap.colorSpace = Zi));
                  break;
                case "SpecularColor":
                  (i.specularMap = r.getTexture(t, e.ID)),
                    void 0 !== i.specularMap && (i.specularMap.colorSpace = Zi);
                  break;
                case "TransparentColor":
                case "TransparencyFactor":
                  (i.alphaMap = r.getTexture(t, e.ID)), (i.transparent = !0);
                  break;
                default:
                  console.warn(
                    "THREE.FBXLoader: %s map is not supported in three.js, skipping texture.",
                    n
                  );
              }
            }),
            i
          );
        }
        getTexture(e, t) {
          return (
            "LayeredTexture" in JE.Objects &&
              t in JE.Objects.LayeredTexture &&
              (console.warn(
                "THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."
              ),
              (t = ZE.get(t).children[0].ID)),
            e.get(t)
          );
        }
        parseDeformers() {
          const e = {},
            t = {};
          if ("Deformer" in JE.Objects) {
            const n = JE.Objects.Deformer;
            for (const i in n) {
              const r = n[i],
                s = ZE.get(parseInt(i));
              if ("Skin" === r.attrType) {
                const t = this.parseSkeleton(s, n);
                (t.ID = i),
                  s.parents.length > 1 &&
                    console.warn(
                      "THREE.FBXLoader: skeleton attached to more than one geometry is not supported."
                    ),
                  (t.geometryID = s.parents[0].ID),
                  (e[i] = t);
              } else if ("BlendShape" === r.attrType) {
                const e = { id: i };
                (e.rawTargets = this.parseMorphTargets(s, n)),
                  (e.id = i),
                  s.parents.length > 1 &&
                    console.warn(
                      "THREE.FBXLoader: morph target attached to more than one geometry is not supported."
                    ),
                  (t[i] = e);
              }
            }
          }
          return { skeletons: e, morphTargets: t };
        }
        parseSkeleton(e, t) {
          const n = [];
          return (
            e.children.forEach(function (e) {
              const i = t[e.ID];
              if ("Cluster" !== i.attrType) return;
              const r = {
                ID: e.ID,
                indices: [],
                weights: [],
                transformLink: new Cs().fromArray(i.TransformLink.a),
              };
              "Indexes" in i &&
                ((r.indices = i.Indexes.a), (r.weights = i.Weights.a)),
                n.push(r);
            }),
            { rawBones: n, bones: [] }
          );
        }
        parseMorphTargets(e, t) {
          const n = [];
          for (let i = 0; i < e.children.length; i++) {
            const r = e.children[i],
              s = t[r.ID],
              a = {
                name: s.attrName,
                initialWeight: s.DeformPercent,
                id: s.id,
                fullWeights: s.FullWeights.a,
              };
            if ("BlendShapeChannel" !== s.attrType) return;
            (a.geoID = ZE.get(parseInt(r.ID)).children.filter(function (e) {
              return void 0 === e.relationship;
            })[0].ID),
              n.push(a);
          }
          return n;
        }
        parseScene(e, t, n) {
          $E = new au();
          const i = this.parseModels(e.skeletons, t, n),
            r = JE.Objects.Model,
            s = this;
          i.forEach(function (e) {
            const t = r[e.ID];
            s.setLookAtProperties(e, t);
            ZE.get(e.ID).parents.forEach(function (t) {
              const n = i.get(t.ID);
              void 0 !== n && n.add(e);
            }),
              null === e.parent && $E.add(e);
          }),
            this.bindSkeleton(e.skeletons, t, i),
            this.addGlobalSceneSettings(),
            $E.traverse(function (e) {
              if (e.userData.transformData) {
                e.parent &&
                  ((e.userData.transformData.parentMatrix = e.parent.matrix),
                  (e.userData.transformData.parentMatrixWorld =
                    e.parent.matrixWorld));
                const t = fw(e.userData.transformData);
                e.applyMatrix4(t), e.updateWorldMatrix();
              }
            });
          const a = new iw().parse();
          1 === $E.children.length &&
            $E.children[0].isGroup &&
            (($E.children[0].animations = a), ($E = $E.children[0])),
            ($E.animations = a);
        }
        parseModels(e, t, n) {
          const i = new Map(),
            r = JE.Objects.Model;
          for (const s in r) {
            const a = parseInt(s),
              o = r[s],
              c = ZE.get(a);
            let l = this.buildSkeleton(c, e, a, o.attrName);
            if (!l) {
              switch (o.attrType) {
                case "Camera":
                  l = this.createCamera(c);
                  break;
                case "Light":
                  l = this.createLight(c);
                  break;
                case "Mesh":
                  l = this.createMesh(c, t, n);
                  break;
                case "NurbsCurve":
                  l = this.createCurve(c, t);
                  break;
                case "LimbNode":
                case "Root":
                  l = new Ru();
                  break;
                default:
                  l = new au();
              }
              (l.name = o.attrName ? ep.sanitizeNodeName(o.attrName) : ""),
                (l.userData.originalName = o.attrName),
                (l.ID = a);
            }
            this.getTransformData(l, o), i.set(a, l);
          }
          return i;
        }
        buildSkeleton(e, t, n, i) {
          let r = null;
          return (
            e.parents.forEach(function (e) {
              for (const s in t) {
                const a = t[s];
                a.rawBones.forEach(function (t, s) {
                  if (t.ID === e.ID) {
                    const e = r;
                    (r = new Ru()),
                      r.matrixWorld.copy(t.transformLink),
                      (r.name = i ? ep.sanitizeNodeName(i) : ""),
                      (r.userData.originalName = i),
                      (r.ID = n),
                      (a.bones[s] = r),
                      null !== e && r.add(e);
                  }
                });
              }
            }),
            r
          );
        }
        createCamera(e) {
          let t, n;
          if (
            (e.children.forEach(function (e) {
              const t = JE.Objects.NodeAttribute[e.ID];
              void 0 !== t && (n = t);
            }),
            void 0 === n)
          )
            t = new Zs();
          else {
            let e = 0;
            void 0 !== n.CameraProjectionType &&
              1 === n.CameraProjectionType.value &&
              (e = 1);
            let i = 1;
            void 0 !== n.NearPlane && (i = n.NearPlane.value / 1e3);
            let r = 1e3;
            void 0 !== n.FarPlane && (r = n.FarPlane.value / 1e3);
            let s = window.innerWidth,
              a = window.innerHeight;
            void 0 !== n.AspectWidth &&
              void 0 !== n.AspectHeight &&
              ((s = n.AspectWidth.value), (a = n.AspectHeight.value));
            const o = s / a;
            let c = 45;
            void 0 !== n.FieldOfView && (c = n.FieldOfView.value);
            const l = n.FocalLength ? n.FocalLength.value : null;
            switch (e) {
              case 0:
                (t = new uo(c, o, i, r)), null !== l && t.setFocalLength(l);
                break;
              case 1:
                console.warn(
                  "THREE.FBXLoader: Orthographic cameras not supported yet."
                ),
                  (t = new Zs());
                break;
              default:
                console.warn("THREE.FBXLoader: Unknown camera type " + e + "."),
                  (t = new Zs());
            }
          }
          return t;
        }
        createLight(e) {
          let t, n;
          if (
            (e.children.forEach(function (e) {
              const t = JE.Objects.NodeAttribute[e.ID];
              void 0 !== t && (n = t);
            }),
            void 0 === n)
          )
            t = new Zs();
          else {
            let e;
            e = void 0 === n.LightType ? 0 : n.LightType.value;
            let i = 16777215;
            void 0 !== n.Color &&
              (i = Mr.toWorkingColorSpace(
                new ma().fromArray(n.Color.value),
                Zi
              ));
            let r = void 0 === n.Intensity ? 1 : n.Intensity.value / 100;
            void 0 !== n.CastLightOnObject &&
              0 === n.CastLightOnObject.value &&
              (r = 0);
            let s = 0;
            void 0 !== n.FarAttenuationEnd &&
              (s =
                void 0 !== n.EnableFarAttenuation &&
                0 === n.EnableFarAttenuation.value
                  ? 0
                  : n.FarAttenuationEnd.value);
            const a = 1;
            switch (e) {
              case 0:
                t = new kd(i, r, s, a);
                break;
              case 1:
                t = new Gd(i, r);
                break;
              case 2:
                let e = Math.PI / 3;
                void 0 !== n.InnerAngle &&
                  (e = yr.degToRad(n.InnerAngle.value));
                let o = 0;
                void 0 !== n.OuterAngle &&
                  ((o = yr.degToRad(n.OuterAngle.value)), (o = Math.max(o, 1))),
                  (t = new Ld(i, r, s, e, o, a));
                break;
              default:
                console.warn(
                  "THREE.FBXLoader: Unknown light type " +
                    n.LightType.value +
                    ", defaulting to a PointLight."
                ),
                  (t = new kd(i, r));
            }
            void 0 !== n.CastShadows &&
              1 === n.CastShadows.value &&
              (t.castShadow = !0);
          }
          return t;
        }
        createMesh(e, t, n) {
          let i,
            r = null,
            s = null;
          const a = [];
          return (
            e.children.forEach(function (e) {
              t.has(e.ID) && (r = t.get(e.ID)),
                n.has(e.ID) && a.push(n.get(e.ID));
            }),
            a.length > 1
              ? (s = a)
              : a.length > 0
              ? (s = a[0])
              : ((s = new Jh({
                  name: _d.DEFAULT_MATERIAL_NAME,
                  color: 13421772,
                })),
                a.push(s)),
            "color" in r.attributes &&
              a.forEach(function (e) {
                e.vertexColors = !0;
              }),
            r.FBX_Deformer
              ? ((i = new Bu(r, s)), i.normalizeSkinWeights())
              : (i = new Za(r, s)),
            i
          );
        }
        createCurve(e, t) {
          const n = e.children.reduce(function (e, n) {
              return t.has(n.ID) && (e = t.get(n.ID)), e;
            }, null),
            i = new ju({
              name: _d.DEFAULT_MATERIAL_NAME,
              color: 3342591,
              linewidth: 1,
            });
          return new $u(n, i);
        }
        getTransformData(e, t) {
          const n = {};
          "InheritType" in t && (n.inheritType = parseInt(t.InheritType.value)),
            (n.eulerOrder = Aw(
              "RotationOrder" in t ? t.RotationOrder.value : 0
            )),
            "Lcl_Translation" in t && (n.translation = t.Lcl_Translation.value),
            "PreRotation" in t && (n.preRotation = t.PreRotation.value),
            "Lcl_Rotation" in t && (n.rotation = t.Lcl_Rotation.value),
            "PostRotation" in t && (n.postRotation = t.PostRotation.value),
            "Lcl_Scaling" in t && (n.scale = t.Lcl_Scaling.value),
            "ScalingOffset" in t && (n.scalingOffset = t.ScalingOffset.value),
            "ScalingPivot" in t && (n.scalingPivot = t.ScalingPivot.value),
            "RotationOffset" in t &&
              (n.rotationOffset = t.RotationOffset.value),
            "RotationPivot" in t && (n.rotationPivot = t.RotationPivot.value),
            (e.userData.transformData = n);
        }
        setLookAtProperties(e, t) {
          if ("LookAtProperty" in t) {
            ZE.get(e.ID).children.forEach(function (t) {
              if ("LookAtProperty" === t.relationship) {
                const n = JE.Objects.Model[t.ID];
                if ("Lcl_Translation" in n) {
                  const t = n.Lcl_Translation.value;
                  void 0 !== e.target
                    ? (e.target.position.fromArray(t), $E.add(e.target))
                    : e.lookAt(new Yr().fromArray(t));
                }
              }
            });
          }
        }
        bindSkeleton(e, t, n) {
          const i = this.parsePoseNodes();
          for (const r in e) {
            const s = e[r];
            ZE.get(parseInt(s.ID)).parents.forEach(function (e) {
              if (t.has(e.ID)) {
                const t = e.ID;
                ZE.get(t).parents.forEach(function (e) {
                  if (n.has(e.ID)) {
                    n.get(e.ID).bind(new Uu(s.bones), i[e.ID]);
                  }
                });
              }
            });
          }
        }
        parsePoseNodes() {
          const e = {};
          if ("Pose" in JE.Objects) {
            const t = JE.Objects.Pose;
            for (const n in t)
              if ("BindPose" === t[n].attrType && t[n].NbPoseNodes > 0) {
                const i = t[n].PoseNode;
                Array.isArray(i)
                  ? i.forEach(function (t) {
                      e[t.Node] = new Cs().fromArray(t.Matrix.a);
                    })
                  : (e[i.Node] = new Cs().fromArray(i.Matrix.a));
              }
          }
          return e;
        }
        addGlobalSceneSettings() {
          if ("GlobalSettings" in JE) {
            if ("AmbientColor" in JE.GlobalSettings) {
              const e = JE.GlobalSettings.AmbientColor.value,
                t = e[0],
                n = e[1],
                i = e[2];
              if (0 !== t || 0 !== n || 0 !== i) {
                const e = new ma().setRGB(t, n, i, Zi);
                $E.add(new Hd(e, 1));
              }
            }
            "UnitScaleFactor" in JE.GlobalSettings &&
              ($E.userData.unitScaleFactor =
                JE.GlobalSettings.UnitScaleFactor.value);
          }
        }
      }
      class nw {
        constructor() {
          this.negativeMaterialIndices = !1;
        }
        parse(e) {
          const t = new Map();
          if ("Geometry" in JE.Objects) {
            const n = JE.Objects.Geometry;
            for (const i in n) {
              const r = ZE.get(parseInt(i)),
                s = this.parseGeometry(r, n[i], e);
              t.set(parseInt(i), s);
            }
          }
          return (
            !0 === this.negativeMaterialIndices &&
              console.warn(
                "THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."
              ),
            t
          );
        }
        parseGeometry(e, t, n) {
          switch (t.attrType) {
            case "Mesh":
              return this.parseMeshGeometry(e, t, n);
            case "NurbsCurve":
              return this.parseNurbsGeometry(t);
          }
        }
        parseMeshGeometry(e, t, n) {
          const i = n.skeletons,
            r = [],
            s = e.parents.map(function (e) {
              return JE.Objects.Model[e.ID];
            });
          if (0 === s.length) return;
          const a = e.children.reduce(function (e, t) {
            return void 0 !== i[t.ID] && (e = i[t.ID]), e;
          }, null);
          e.children.forEach(function (e) {
            void 0 !== n.morphTargets[e.ID] && r.push(n.morphTargets[e.ID]);
          });
          const o = s[0],
            c = {};
          "RotationOrder" in o && (c.eulerOrder = Aw(o.RotationOrder.value)),
            "InheritType" in o &&
              (c.inheritType = parseInt(o.InheritType.value)),
            "GeometricTranslation" in o &&
              (c.translation = o.GeometricTranslation.value),
            "GeometricRotation" in o &&
              (c.rotation = o.GeometricRotation.value),
            "GeometricScaling" in o && (c.scale = o.GeometricScaling.value);
          const l = fw(c);
          return this.genGeometry(t, a, r, l);
        }
        genGeometry(e, t, n, i) {
          const r = new Qa();
          e.attrName && (r.name = e.attrName);
          const s = this.parseGeoNode(e, t),
            a = this.genBuffers(s),
            o = new Da(a.vertex, 3);
          if (
            (o.applyMatrix4(i),
            r.setAttribute("position", o),
            a.colors.length > 0 && r.setAttribute("color", new Da(a.colors, 3)),
            t &&
              (r.setAttribute("skinIndex", new Ba(a.weightsIndices, 4)),
              r.setAttribute("skinWeight", new Da(a.vertexWeights, 4)),
              (r.FBX_Deformer = t)),
            a.normal.length > 0)
          ) {
            const e = new _r().getNormalMatrix(i),
              t = new Da(a.normal, 3);
            t.applyNormalMatrix(e), r.setAttribute("normal", t);
          }
          if (
            (a.uvs.forEach(function (e, t) {
              const n = 0 === t ? "uv" : `uv${t}`;
              r.setAttribute(n, new Da(a.uvs[t], 2));
            }),
            s.material && "AllSame" !== s.material.mappingType)
          ) {
            let e = a.materialIndex[0],
              t = 0;
            if (
              (a.materialIndex.forEach(function (n, i) {
                n !== e && (r.addGroup(t, i - t, e), (e = n), (t = i));
              }),
              r.groups.length > 0)
            ) {
              const t = r.groups[r.groups.length - 1],
                n = t.start + t.count;
              n !== a.materialIndex.length &&
                r.addGroup(n, a.materialIndex.length - n, e);
            }
            0 === r.groups.length &&
              r.addGroup(0, a.materialIndex.length, a.materialIndex[0]);
          }
          return this.addMorphTargets(r, e, n, i), r;
        }
        parseGeoNode(e, t) {
          const n = {};
          if (
            ((n.vertexPositions = void 0 !== e.Vertices ? e.Vertices.a : []),
            (n.vertexIndices =
              void 0 !== e.PolygonVertexIndex ? e.PolygonVertexIndex.a : []),
            e.LayerElementColor &&
              (n.color = this.parseVertexColors(e.LayerElementColor[0])),
            e.LayerElementMaterial &&
              (n.material = this.parseMaterialIndices(
                e.LayerElementMaterial[0]
              )),
            e.LayerElementNormal &&
              (n.normal = this.parseNormals(e.LayerElementNormal[0])),
            e.LayerElementUV)
          ) {
            n.uv = [];
            let t = 0;
            for (; e.LayerElementUV[t]; )
              e.LayerElementUV[t].UV &&
                n.uv.push(this.parseUVs(e.LayerElementUV[t])),
                t++;
          }
          return (
            (n.weightTable = {}),
            null !== t &&
              ((n.skeleton = t),
              t.rawBones.forEach(function (e, t) {
                e.indices.forEach(function (i, r) {
                  void 0 === n.weightTable[i] && (n.weightTable[i] = []),
                    n.weightTable[i].push({ id: t, weight: e.weights[r] });
                });
              })),
            n
          );
        }
        genBuffers(e) {
          const t = {
            vertex: [],
            normal: [],
            colors: [],
            uvs: [],
            materialIndex: [],
            vertexWeights: [],
            weightsIndices: [],
          };
          let n = 0,
            i = 0,
            r = !1,
            s = [],
            a = [],
            o = [],
            c = [],
            l = [],
            u = [];
          const h = this;
          return (
            e.vertexIndices.forEach(function (d, p) {
              let f,
                A = !1;
              d < 0 && ((d = ~d), (A = !0));
              let g = [],
                m = [];
              if ((s.push(3 * d, 3 * d + 1, 3 * d + 2), e.color)) {
                const t = hw(p, n, d, e.color);
                o.push(t[0], t[1], t[2]);
              }
              if (e.skeleton) {
                if (
                  (void 0 !== e.weightTable[d] &&
                    e.weightTable[d].forEach(function (e) {
                      m.push(e.weight), g.push(e.id);
                    }),
                  m.length > 4)
                ) {
                  r ||
                    (console.warn(
                      "THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."
                    ),
                    (r = !0));
                  const e = [0, 0, 0, 0],
                    t = [0, 0, 0, 0];
                  m.forEach(function (n, i) {
                    let r = n,
                      s = g[i];
                    t.forEach(function (t, n, i) {
                      if (r > t) {
                        (i[n] = r), (r = t);
                        const a = e[n];
                        (e[n] = s), (s = a);
                      }
                    });
                  }),
                    (g = e),
                    (m = t);
                }
                for (; m.length < 4; ) m.push(0), g.push(0);
                for (let e = 0; e < 4; ++e) l.push(m[e]), u.push(g[e]);
              }
              if (e.normal) {
                const t = hw(p, n, d, e.normal);
                a.push(t[0], t[1], t[2]);
              }
              e.material &&
                "AllSame" !== e.material.mappingType &&
                ((f = hw(p, n, d, e.material)[0]),
                f < 0 && ((h.negativeMaterialIndices = !0), (f = 0))),
                e.uv &&
                  e.uv.forEach(function (e, t) {
                    const i = hw(p, n, d, e);
                    void 0 === c[t] && (c[t] = []),
                      c[t].push(i[0]),
                      c[t].push(i[1]);
                  }),
                i++,
                A &&
                  (h.genFace(t, e, s, f, a, o, c, l, u, i),
                  n++,
                  (i = 0),
                  (s = []),
                  (a = []),
                  (o = []),
                  (c = []),
                  (l = []),
                  (u = []));
            }),
            t
          );
        }
        getNormalNewell(e) {
          const t = new Yr(0, 0, 0);
          for (let n = 0; n < e.length; n++) {
            const i = e[n],
              r = e[(n + 1) % e.length];
            (t.x += (i.y - r.y) * (i.z + r.z)),
              (t.y += (i.z - r.z) * (i.x + r.x)),
              (t.z += (i.x - r.x) * (i.y + r.y));
          }
          return t.normalize(), t;
        }
        getNormalTangentAndBitangent(e) {
          const t = this.getNormalNewell(e),
            n = (Math.abs(t.z) > 0.5 ? new Yr(0, 1, 0) : new Yr(0, 0, 1))
              .cross(t)
              .normalize(),
            i = t.clone().cross(n).normalize();
          return { normal: t, tangent: n, bitangent: i };
        }
        flattenVertex(e, t, n) {
          return new br(e.dot(t), e.dot(n));
        }
        genFace(e, t, n, i, r, s, a, o, c, l) {
          let u;
          if (l > 3) {
            const e = [],
              i = t.baseVertexPositions || t.vertexPositions;
            for (let t = 0; t < n.length; t += 3)
              e.push(new Yr(i[n[t]], i[n[t + 1]], i[n[t + 2]]));
            const { tangent: r, bitangent: s } =
                this.getNormalTangentAndBitangent(e),
              a = [];
            for (const t of e) a.push(this.flattenVertex(t, r, s));
            u = Vh.triangulateShape(a, []);
          } else u = [[0, 1, 2]];
          for (const [l, h, d] of u)
            e.vertex.push(t.vertexPositions[n[3 * l]]),
              e.vertex.push(t.vertexPositions[n[3 * l + 1]]),
              e.vertex.push(t.vertexPositions[n[3 * l + 2]]),
              e.vertex.push(t.vertexPositions[n[3 * h]]),
              e.vertex.push(t.vertexPositions[n[3 * h + 1]]),
              e.vertex.push(t.vertexPositions[n[3 * h + 2]]),
              e.vertex.push(t.vertexPositions[n[3 * d]]),
              e.vertex.push(t.vertexPositions[n[3 * d + 1]]),
              e.vertex.push(t.vertexPositions[n[3 * d + 2]]),
              t.skeleton &&
                (e.vertexWeights.push(o[4 * l]),
                e.vertexWeights.push(o[4 * l + 1]),
                e.vertexWeights.push(o[4 * l + 2]),
                e.vertexWeights.push(o[4 * l + 3]),
                e.vertexWeights.push(o[4 * h]),
                e.vertexWeights.push(o[4 * h + 1]),
                e.vertexWeights.push(o[4 * h + 2]),
                e.vertexWeights.push(o[4 * h + 3]),
                e.vertexWeights.push(o[4 * d]),
                e.vertexWeights.push(o[4 * d + 1]),
                e.vertexWeights.push(o[4 * d + 2]),
                e.vertexWeights.push(o[4 * d + 3]),
                e.weightsIndices.push(c[4 * l]),
                e.weightsIndices.push(c[4 * l + 1]),
                e.weightsIndices.push(c[4 * l + 2]),
                e.weightsIndices.push(c[4 * l + 3]),
                e.weightsIndices.push(c[4 * h]),
                e.weightsIndices.push(c[4 * h + 1]),
                e.weightsIndices.push(c[4 * h + 2]),
                e.weightsIndices.push(c[4 * h + 3]),
                e.weightsIndices.push(c[4 * d]),
                e.weightsIndices.push(c[4 * d + 1]),
                e.weightsIndices.push(c[4 * d + 2]),
                e.weightsIndices.push(c[4 * d + 3])),
              t.color &&
                (e.colors.push(s[3 * l]),
                e.colors.push(s[3 * l + 1]),
                e.colors.push(s[3 * l + 2]),
                e.colors.push(s[3 * h]),
                e.colors.push(s[3 * h + 1]),
                e.colors.push(s[3 * h + 2]),
                e.colors.push(s[3 * d]),
                e.colors.push(s[3 * d + 1]),
                e.colors.push(s[3 * d + 2])),
              t.material &&
                "AllSame" !== t.material.mappingType &&
                (e.materialIndex.push(i),
                e.materialIndex.push(i),
                e.materialIndex.push(i)),
              t.normal &&
                (e.normal.push(r[3 * l]),
                e.normal.push(r[3 * l + 1]),
                e.normal.push(r[3 * l + 2]),
                e.normal.push(r[3 * h]),
                e.normal.push(r[3 * h + 1]),
                e.normal.push(r[3 * h + 2]),
                e.normal.push(r[3 * d]),
                e.normal.push(r[3 * d + 1]),
                e.normal.push(r[3 * d + 2])),
              t.uv &&
                t.uv.forEach(function (t, n) {
                  void 0 === e.uvs[n] && (e.uvs[n] = []),
                    e.uvs[n].push(a[n][2 * l]),
                    e.uvs[n].push(a[n][2 * l + 1]),
                    e.uvs[n].push(a[n][2 * h]),
                    e.uvs[n].push(a[n][2 * h + 1]),
                    e.uvs[n].push(a[n][2 * d]),
                    e.uvs[n].push(a[n][2 * d + 1]);
                });
        }
        addMorphTargets(e, t, n, i) {
          if (0 === n.length) return;
          (e.morphTargetsRelative = !0), (e.morphAttributes.position = []);
          const r = this;
          n.forEach(function (n) {
            n.rawTargets.forEach(function (n) {
              const s = JE.Objects.Geometry[n.geoID];
              void 0 !== s && r.genMorphGeometry(e, t, s, i, n.name);
            });
          });
        }
        genMorphGeometry(e, t, n, i, r) {
          const s = void 0 !== t.Vertices ? t.Vertices.a : [],
            a = void 0 !== t.PolygonVertexIndex ? t.PolygonVertexIndex.a : [],
            o = void 0 !== n.Vertices ? n.Vertices.a : [],
            c = void 0 !== n.Indexes ? n.Indexes.a : [],
            l = 3 * e.attributes.position.count,
            u = new Float32Array(l);
          for (let e = 0; e < c.length; e++) {
            const t = 3 * c[e];
            (u[t] = o[3 * e]),
              (u[t + 1] = o[3 * e + 1]),
              (u[t + 2] = o[3 * e + 2]);
          }
          const h = {
              vertexIndices: a,
              vertexPositions: u,
              baseVertexPositions: s,
            },
            d = this.genBuffers(h),
            p = new Da(d.vertex, 3);
          (p.name = r || n.attrName),
            p.applyMatrix4(i),
            e.morphAttributes.position.push(p);
        }
        parseNormals(e) {
          const t = e.MappingInformationType,
            n = e.ReferenceInformationType,
            i = e.Normals.a;
          let r = [];
          return (
            "IndexToDirect" === n &&
              ("NormalIndex" in e
                ? (r = e.NormalIndex.a)
                : "NormalsIndex" in e && (r = e.NormalsIndex.a)),
            {
              dataSize: 3,
              buffer: i,
              indices: r,
              mappingType: t,
              referenceType: n,
            }
          );
        }
        parseUVs(e) {
          const t = e.MappingInformationType,
            n = e.ReferenceInformationType,
            i = e.UV.a;
          let r = [];
          return (
            "IndexToDirect" === n && (r = e.UVIndex.a),
            {
              dataSize: 2,
              buffer: i,
              indices: r,
              mappingType: t,
              referenceType: n,
            }
          );
        }
        parseVertexColors(e) {
          const t = e.MappingInformationType,
            n = e.ReferenceInformationType,
            i = e.Colors.a;
          let r = [];
          "IndexToDirect" === n && (r = e.ColorIndex.a);
          for (let e = 0, t = new ma(); e < i.length; e += 4)
            t.fromArray(i, e), Mr.toWorkingColorSpace(t, Zi), t.toArray(i, e);
          return {
            dataSize: 4,
            buffer: i,
            indices: r,
            mappingType: t,
            referenceType: n,
          };
        }
        parseMaterialIndices(e) {
          const t = e.MappingInformationType,
            n = e.ReferenceInformationType;
          if ("NoMappingInformation" === t)
            return {
              dataSize: 1,
              buffer: [0],
              indices: [0],
              mappingType: "AllSame",
              referenceType: n,
            };
          const i = e.Materials.a,
            r = [];
          for (let e = 0; e < i.length; ++e) r.push(e);
          return {
            dataSize: 1,
            buffer: i,
            indices: r,
            mappingType: t,
            referenceType: n,
          };
        }
        parseNurbsGeometry(e) {
          const t = parseInt(e.Order);
          if (isNaN(t))
            return (
              console.error(
                "THREE.FBXLoader: Invalid Order %s given for geometry ID: %s",
                e.Order,
                e.id
              ),
              new Qa()
            );
          const n = t - 1,
            i = e.KnotVector.a,
            r = [],
            s = e.Points.a;
          for (let e = 0, t = s.length; e < t; e += 4)
            r.push(new zr().fromArray(s, e));
          let a, o;
          if ("Closed" === e.Form) r.push(r[0]);
          else if ("Periodic" === e.Form) {
            (a = n), (o = i.length - 1 - a);
            for (let e = 0; e < n; ++e) r.push(r[e]);
          }
          const c = new KE(n, i, r, a, o).getPoints(12 * r.length);
          return new Qa().setFromPoints(c);
        }
      }
      class iw {
        parse() {
          const e = [],
            t = this.parseClips();
          if (void 0 !== t)
            for (const n in t) {
              const i = t[n],
                r = this.addClip(i);
              e.push(r);
            }
          return e;
        }
        parseClips() {
          if (void 0 === JE.Objects.AnimationCurve) return;
          const e = this.parseAnimationCurveNodes();
          this.parseAnimationCurves(e);
          const t = this.parseAnimationLayers(e);
          return this.parseAnimStacks(t);
        }
        parseAnimationCurveNodes() {
          const e = JE.Objects.AnimationCurveNode,
            t = new Map();
          for (const n in e) {
            const i = e[n];
            if (null !== i.attrName.match(/S|R|T|DeformPercent/)) {
              const e = { id: i.id, attr: i.attrName, curves: {} };
              t.set(e.id, e);
            }
          }
          return t;
        }
        parseAnimationCurves(e) {
          const t = JE.Objects.AnimationCurve;
          for (const n in t) {
            const i = {
                id: t[n].id,
                times: t[n].KeyTime.a.map(lw),
                values: t[n].KeyValueFloat.a,
              },
              r = ZE.get(i.id);
            if (void 0 !== r) {
              const t = r.parents[0].ID,
                n = r.parents[0].relationship;
              n.match(/X/)
                ? (e.get(t).curves.x = i)
                : n.match(/Y/)
                ? (e.get(t).curves.y = i)
                : n.match(/Z/)
                ? (e.get(t).curves.z = i)
                : n.match(/DeformPercent/) &&
                  e.has(t) &&
                  (e.get(t).curves.morph = i);
            }
          }
        }
        parseAnimationLayers(e) {
          const t = JE.Objects.AnimationLayer,
            n = new Map();
          for (const i in t) {
            const t = [],
              r = ZE.get(parseInt(i));
            if (void 0 !== r) {
              r.children.forEach(function (n, i) {
                if (e.has(n.ID)) {
                  const r = e.get(n.ID);
                  if (
                    void 0 !== r.curves.x ||
                    void 0 !== r.curves.y ||
                    void 0 !== r.curves.z
                  ) {
                    if (void 0 === t[i]) {
                      const e = ZE.get(n.ID).parents.filter(function (e) {
                        return void 0 !== e.relationship;
                      })[0].ID;
                      if (void 0 !== e) {
                        const r = JE.Objects.Model[e.toString()];
                        if (void 0 === r)
                          return void console.warn(
                            "THREE.FBXLoader: Encountered a unused curve.",
                            n
                          );
                        const s = {
                          modelName: r.attrName
                            ? ep.sanitizeNodeName(r.attrName)
                            : "",
                          ID: r.id,
                          initialPosition: [0, 0, 0],
                          initialRotation: [0, 0, 0],
                          initialScale: [1, 1, 1],
                        };
                        $E.traverse(function (e) {
                          e.ID === r.id &&
                            ((s.transform = e.matrix),
                            e.userData.transformData &&
                              (s.eulerOrder =
                                e.userData.transformData.eulerOrder));
                        }),
                          s.transform || (s.transform = new Cs()),
                          "PreRotation" in r &&
                            (s.preRotation = r.PreRotation.value),
                          "PostRotation" in r &&
                            (s.postRotation = r.PostRotation.value),
                          (t[i] = s);
                      }
                    }
                    t[i] && (t[i][r.attr] = r);
                  } else if (void 0 !== r.curves.morph) {
                    if (void 0 === t[i]) {
                      const e = ZE.get(n.ID).parents.filter(function (e) {
                          return void 0 !== e.relationship;
                        })[0].ID,
                        r = ZE.get(e).parents[0].ID,
                        s = ZE.get(r).parents[0].ID,
                        a = ZE.get(s).parents[0].ID,
                        o = JE.Objects.Model[a],
                        c = {
                          modelName: o.attrName
                            ? ep.sanitizeNodeName(o.attrName)
                            : "",
                          morphName: JE.Objects.Deformer[e].attrName,
                        };
                      t[i] = c;
                    }
                    t[i][r.attr] = r;
                  }
                }
              }),
                n.set(parseInt(i), t);
            }
          }
          return n;
        }
        parseAnimStacks(e) {
          const t = JE.Objects.AnimationStack,
            n = {};
          for (const i in t) {
            const r = ZE.get(parseInt(i)).children;
            r.length > 1 &&
              console.warn(
                "THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers."
              );
            const s = e.get(r[0].ID);
            n[i] = { name: t[i].attrName, layer: s };
          }
          return n;
        }
        addClip(e) {
          let t = [];
          const n = this;
          return (
            e.layer.forEach(function (e) {
              t = t.concat(n.generateTracks(e));
            }),
            new gd(e.name, -1, t)
          );
        }
        generateTracks(e) {
          const t = [];
          let n = new Yr(),
            i = new Yr();
          if (
            (e.transform && e.transform.decompose(n, new qr(), i),
            (n = n.toArray()),
            (i = i.toArray()),
            void 0 !== e.T && Object.keys(e.T.curves).length > 0)
          ) {
            const i = this.generateVectorTrack(
              e.modelName,
              e.T.curves,
              n,
              "position"
            );
            void 0 !== i && t.push(i);
          }
          if (void 0 !== e.R && Object.keys(e.R.curves).length > 0) {
            const n = this.generateRotationTrack(
              e.modelName,
              e.R.curves,
              e.preRotation,
              e.postRotation,
              e.eulerOrder
            );
            void 0 !== n && t.push(n);
          }
          if (void 0 !== e.S && Object.keys(e.S.curves).length > 0) {
            const n = this.generateVectorTrack(
              e.modelName,
              e.S.curves,
              i,
              "scale"
            );
            void 0 !== n && t.push(n);
          }
          if (void 0 !== e.DeformPercent) {
            const n = this.generateMorphTrack(e);
            void 0 !== n && t.push(n);
          }
          return t;
        }
        generateVectorTrack(e, t, n, i) {
          const r = this.getTimesForAllAxes(t),
            s = this.getKeyframeTrackValues(r, t, n);
          return new Ad(e + "." + i, r, s);
        }
        generateRotationTrack(e, t, n, i, r) {
          let s, a;
          if (void 0 !== t.x && void 0 !== t.y && void 0 !== t.z) {
            const e = this.interpolateRotations(t.x, t.y, t.z, r);
            (s = e[0]), (a = e[1]);
          }
          const o = Aw(0);
          void 0 !== n &&
            ((n = n.map(yr.degToRad)).push(o),
            (n = new Us().fromArray(n)),
            (n = new qr().setFromEuler(n))),
            void 0 !== i &&
              ((i = i.map(yr.degToRad)).push(o),
              (i = new Us().fromArray(i)),
              (i = new qr().setFromEuler(i).invert()));
          const c = new qr(),
            l = new Us(),
            u = [];
          if (!a || !s) return new pd(e + ".quaternion", [0], [0]);
          for (let e = 0; e < a.length; e += 3) {
            if (
              (l.set(a[e], a[e + 1], a[e + 2], r),
              c.setFromEuler(l),
              void 0 !== n && c.premultiply(n),
              void 0 !== i && c.multiply(i),
              e > 2)
            ) {
              new qr().fromArray(u, ((e - 3) / 3) * 4).dot(c) < 0 &&
                c.set(-c.x, -c.y, -c.z, -c.w);
            }
            c.toArray(u, (e / 3) * 4);
          }
          return new pd(e + ".quaternion", s, u);
        }
        generateMorphTrack(e) {
          const t = e.DeformPercent.curves.morph,
            n = t.values.map(function (e) {
              return e / 100;
            }),
            i = $E.getObjectByName(e.modelName).morphTargetDictionary[
              e.morphName
            ];
          return new hd(
            e.modelName + ".morphTargetInfluences[" + i + "]",
            t.times,
            n
          );
        }
        getTimesForAllAxes(e) {
          let t = [];
          if (
            (void 0 !== e.x && (t = t.concat(e.x.times)),
            void 0 !== e.y && (t = t.concat(e.y.times)),
            void 0 !== e.z && (t = t.concat(e.z.times)),
            (t = t.sort(function (e, t) {
              return e - t;
            })),
            t.length > 1)
          ) {
            let e = 1,
              n = t[0];
            for (let i = 1; i < t.length; i++) {
              const r = t[i];
              r !== n && ((t[e] = r), (n = r), e++);
            }
            t = t.slice(0, e);
          }
          return t;
        }
        getKeyframeTrackValues(e, t, n) {
          const i = n,
            r = [];
          let s = -1,
            a = -1,
            o = -1;
          return (
            e.forEach(function (e) {
              if (
                (t.x && (s = t.x.times.indexOf(e)),
                t.y && (a = t.y.times.indexOf(e)),
                t.z && (o = t.z.times.indexOf(e)),
                -1 !== s)
              ) {
                const e = t.x.values[s];
                r.push(e), (i[0] = e);
              } else r.push(i[0]);
              if (-1 !== a) {
                const e = t.y.values[a];
                r.push(e), (i[1] = e);
              } else r.push(i[1]);
              if (-1 !== o) {
                const e = t.z.values[o];
                r.push(e), (i[2] = e);
              } else r.push(i[2]);
            }),
            r
          );
        }
        interpolateRotations(e, t, n, i) {
          const r = [],
            s = [];
          r.push(e.times[0]),
            s.push(yr.degToRad(e.values[0])),
            s.push(yr.degToRad(t.values[0])),
            s.push(yr.degToRad(n.values[0]));
          for (let a = 1; a < e.values.length; a++) {
            const o = [e.values[a - 1], t.values[a - 1], n.values[a - 1]];
            if (isNaN(o[0]) || isNaN(o[1]) || isNaN(o[2])) continue;
            const c = o.map(yr.degToRad),
              l = [e.values[a], t.values[a], n.values[a]];
            if (isNaN(l[0]) || isNaN(l[1]) || isNaN(l[2])) continue;
            const u = l.map(yr.degToRad),
              h = [l[0] - o[0], l[1] - o[1], l[2] - o[2]],
              d = [Math.abs(h[0]), Math.abs(h[1]), Math.abs(h[2])];
            if (d[0] >= 180 || d[1] >= 180 || d[2] >= 180) {
              const t = Math.max(...d) / 180,
                n = new Us(...c, i),
                o = new Us(...u, i),
                l = new qr().setFromEuler(n),
                h = new qr().setFromEuler(o);
              l.dot(h) && h.set(-h.x, -h.y, -h.z, -h.w);
              const p = e.times[a - 1],
                f = e.times[a] - p,
                A = new qr(),
                g = new Us();
              for (let e = 0; e < 1; e += 1 / t)
                A.copy(l.clone().slerp(h.clone(), e)),
                  r.push(p + e * f),
                  g.setFromQuaternion(A, i),
                  s.push(g.x),
                  s.push(g.y),
                  s.push(g.z);
            } else
              r.push(e.times[a]),
                s.push(yr.degToRad(e.values[a])),
                s.push(yr.degToRad(t.values[a])),
                s.push(yr.degToRad(n.values[a]));
          }
          return [r, s];
        }
      }
      class rw {
        getPrevNode() {
          return this.nodeStack[this.currentIndent - 2];
        }
        getCurrentNode() {
          return this.nodeStack[this.currentIndent - 1];
        }
        getCurrentProp() {
          return this.currentProp;
        }
        pushStack(e) {
          this.nodeStack.push(e), (this.currentIndent += 1);
        }
        popStack() {
          this.nodeStack.pop(), (this.currentIndent -= 1);
        }
        setCurrentProp(e, t) {
          (this.currentProp = e), (this.currentPropName = t);
        }
        parse(e) {
          (this.currentIndent = 0),
            (this.allNodes = new ow()),
            (this.nodeStack = []),
            (this.currentProp = []),
            (this.currentPropName = "");
          const t = this,
            n = e.split(/[\r\n]+/);
          return (
            n.forEach(function (e, i) {
              const r = e.match(/^[\s\t]*;/),
                s = e.match(/^[\s\t]*$/);
              if (r || s) return;
              const a = e.match(
                  "^\\t{" + t.currentIndent + "}(\\w+):(.*){",
                  ""
                ),
                o = e.match(
                  "^\\t{" + t.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"
                ),
                c = e.match("^\\t{" + (t.currentIndent - 1) + "}}");
              a
                ? t.parseNodeBegin(e, a)
                : o
                ? t.parseNodeProperty(e, o, n[++i])
                : c
                ? t.popStack()
                : e.match(/^[^\s\t}]/) && t.parseNodePropertyContinued(e);
            }),
            this.allNodes
          );
        }
        parseNodeBegin(e, t) {
          const n = t[1].trim().replace(/^"/, "").replace(/"$/, ""),
            i = t[2].split(",").map(function (e) {
              return e.trim().replace(/^"/, "").replace(/"$/, "");
            }),
            r = { name: n },
            s = this.parseNodeAttr(i),
            a = this.getCurrentNode();
          0 === this.currentIndent
            ? this.allNodes.add(n, r)
            : n in a
            ? ("PoseNode" === n
                ? a.PoseNode.push(r)
                : void 0 !== a[n].id && ((a[n] = {}), (a[n][a[n].id] = a[n])),
              "" !== s.id && (a[n][s.id] = r))
            : "number" == typeof s.id
            ? ((a[n] = {}), (a[n][s.id] = r))
            : "Properties70" !== n && (a[n] = "PoseNode" === n ? [r] : r),
            "number" == typeof s.id && (r.id = s.id),
            "" !== s.name && (r.attrName = s.name),
            "" !== s.type && (r.attrType = s.type),
            this.pushStack(r);
        }
        parseNodeAttr(e) {
          let t = e[0];
          "" !== e[0] && ((t = parseInt(e[0])), isNaN(t) && (t = e[0]));
          let n = "",
            i = "";
          return (
            e.length > 1 && ((n = e[1].replace(/^(\w+)::/, "")), (i = e[2])),
            { id: t, name: n, type: i }
          );
        }
        parseNodeProperty(e, t, n) {
          let i = t[1].replace(/^"/, "").replace(/"$/, "").trim(),
            r = t[2].replace(/^"/, "").replace(/"$/, "").trim();
          "Content" === i &&
            "," === r &&
            (r = n.replace(/"/g, "").replace(/,$/, "").trim());
          const s = this.getCurrentNode();
          if ("Properties70" !== s.name) {
            if ("C" === i) {
              const e = r.split(",").slice(1),
                t = parseInt(e[0]),
                n = parseInt(e[1]);
              let a = r.split(",").slice(3);
              (a = a.map(function (e) {
                return e.trim().replace(/^"/, "");
              })),
                (i = "connections"),
                (r = [t, n]),
                (function (e, t) {
                  for (let n = 0, i = e.length, r = t.length; n < r; n++, i++)
                    e[i] = t[n];
                })(r, a),
                void 0 === s[i] && (s[i] = []);
            }
            "Node" === i && (s.id = r),
              i in s && Array.isArray(s[i])
                ? s[i].push(r)
                : "a" !== i
                ? (s[i] = r)
                : (s.a = r),
              this.setCurrentProp(s, i),
              "a" === i && "," !== r.slice(-1) && (s.a = gw(r));
          } else this.parseNodeSpecialProperty(e, i, r);
        }
        parseNodePropertyContinued(e) {
          const t = this.getCurrentNode();
          (t.a += e), "," !== e.slice(-1) && (t.a = gw(t.a));
        }
        parseNodeSpecialProperty(e, t, n) {
          const i = n.split('",').map(function (e) {
              return e.trim().replace(/^\"/, "").replace(/\s/, "_");
            }),
            r = i[0],
            s = i[1],
            a = i[2],
            o = i[3];
          let c = i[4];
          switch (s) {
            case "int":
            case "enum":
            case "bool":
            case "ULongLong":
            case "double":
            case "Number":
            case "FieldOfView":
              c = parseFloat(c);
              break;
            case "Color":
            case "ColorRGB":
            case "Vector3D":
            case "Lcl_Translation":
            case "Lcl_Rotation":
            case "Lcl_Scaling":
              c = gw(c);
          }
          (this.getPrevNode()[r] = { type: s, type2: a, flag: o, value: c }),
            this.setCurrentProp(this.getPrevNode(), r);
        }
      }
      class sw {
        parse(e) {
          const t = new aw(e);
          t.skip(23);
          const n = t.getUint32();
          if (n < 6400)
            throw new Error(
              "THREE.FBXLoader: FBX version not supported, FileVersion: " + n
            );
          const i = new ow();
          for (; !this.endOfContent(t); ) {
            const e = this.parseNode(t, n);
            null !== e && i.add(e.name, e);
          }
          return i;
        }
        endOfContent(e) {
          return e.size() % 16 == 0
            ? ((e.getOffset() + 160 + 16) & -16) >= e.size()
            : e.getOffset() + 160 + 16 >= e.size();
        }
        parseNode(e, t) {
          const n = {},
            i = t >= 7500 ? e.getUint64() : e.getUint32(),
            r = t >= 7500 ? e.getUint64() : e.getUint32();
          t >= 7500 ? e.getUint64() : e.getUint32();
          const s = e.getUint8(),
            a = e.getString(s);
          if (0 === i) return null;
          const o = [];
          for (let t = 0; t < r; t++) o.push(this.parseProperty(e));
          const c = o.length > 0 ? o[0] : "",
            l = o.length > 1 ? o[1] : "",
            u = o.length > 2 ? o[2] : "";
          for (
            n.singleProperty = 1 === r && e.getOffset() === i;
            i > e.getOffset();

          ) {
            const i = this.parseNode(e, t);
            null !== i && this.parseSubNode(a, n, i);
          }
          return (
            (n.propertyList = o),
            "number" == typeof c && (n.id = c),
            "" !== l && (n.attrName = l),
            "" !== u && (n.attrType = u),
            "" !== a && (n.name = a),
            n
          );
        }
        parseSubNode(e, t, n) {
          if (!0 === n.singleProperty) {
            const e = n.propertyList[0];
            Array.isArray(e) ? ((t[n.name] = n), (n.a = e)) : (t[n.name] = e);
          } else if ("Connections" === e && "C" === n.name) {
            const e = [];
            n.propertyList.forEach(function (t, n) {
              0 !== n && e.push(t);
            }),
              void 0 === t.connections && (t.connections = []),
              t.connections.push(e);
          } else if ("Properties70" === n.name) {
            Object.keys(n).forEach(function (e) {
              t[e] = n[e];
            });
          } else if ("Properties70" === e && "P" === n.name) {
            let e = n.propertyList[0],
              i = n.propertyList[1];
            const r = n.propertyList[2],
              s = n.propertyList[3];
            let a;
            0 === e.indexOf("Lcl ") && (e = e.replace("Lcl ", "Lcl_")),
              0 === i.indexOf("Lcl ") && (i = i.replace("Lcl ", "Lcl_")),
              (a =
                "Color" === i ||
                "ColorRGB" === i ||
                "Vector" === i ||
                "Vector3D" === i ||
                0 === i.indexOf("Lcl_")
                  ? [n.propertyList[4], n.propertyList[5], n.propertyList[6]]
                  : n.propertyList[4]),
              (t[e] = { type: i, type2: r, flag: s, value: a });
          } else
            void 0 === t[n.name]
              ? "number" == typeof n.id
                ? ((t[n.name] = {}), (t[n.name][n.id] = n))
                : (t[n.name] = n)
              : "PoseNode" === n.name
              ? (Array.isArray(t[n.name]) || (t[n.name] = [t[n.name]]),
                t[n.name].push(n))
              : void 0 === t[n.name][n.id] && (t[n.name][n.id] = n);
        }
        parseProperty(e) {
          const t = e.getString(1);
          let n;
          switch (t) {
            case "C":
              return e.getBoolean();
            case "D":
              return e.getFloat64();
            case "F":
              return e.getFloat32();
            case "I":
              return e.getInt32();
            case "L":
              return e.getInt64();
            case "R":
              return (n = e.getUint32()), e.getArrayBuffer(n);
            case "S":
              return (n = e.getUint32()), e.getString(n);
            case "Y":
              return e.getInt16();
            case "b":
            case "c":
            case "d":
            case "f":
            case "i":
            case "l":
              const i = e.getUint32(),
                r = e.getUint32(),
                s = e.getUint32();
              if (0 === r)
                switch (t) {
                  case "b":
                  case "c":
                    return e.getBooleanArray(i);
                  case "d":
                    return e.getFloat64Array(i);
                  case "f":
                    return e.getFloat32Array(i);
                  case "i":
                    return e.getInt32Array(i);
                  case "l":
                    return e.getInt64Array(i);
                }
              const a = BE(new Uint8Array(e.getArrayBuffer(s))),
                o = new aw(a.buffer);
              switch (t) {
                case "b":
                case "c":
                  return o.getBooleanArray(i);
                case "d":
                  return o.getFloat64Array(i);
                case "f":
                  return o.getFloat32Array(i);
                case "i":
                  return o.getInt32Array(i);
                case "l":
                  return o.getInt64Array(i);
              }
              break;
            default:
              throw new Error("THREE.FBXLoader: Unknown property type " + t);
          }
        }
      }
      class aw {
        constructor(e, t) {
          (this.dv = new DataView(e)),
            (this.offset = 0),
            (this.littleEndian = void 0 === t || t),
            (this._textDecoder = new TextDecoder());
        }
        getOffset() {
          return this.offset;
        }
        size() {
          return this.dv.buffer.byteLength;
        }
        skip(e) {
          this.offset += e;
        }
        getBoolean() {
          return !(1 & ~this.getUint8());
        }
        getBooleanArray(e) {
          const t = [];
          for (let n = 0; n < e; n++) t.push(this.getBoolean());
          return t;
        }
        getUint8() {
          const e = this.dv.getUint8(this.offset);
          return (this.offset += 1), e;
        }
        getInt16() {
          const e = this.dv.getInt16(this.offset, this.littleEndian);
          return (this.offset += 2), e;
        }
        getInt32() {
          const e = this.dv.getInt32(this.offset, this.littleEndian);
          return (this.offset += 4), e;
        }
        getInt32Array(e) {
          const t = [];
          for (let n = 0; n < e; n++) t.push(this.getInt32());
          return t;
        }
        getUint32() {
          const e = this.dv.getUint32(this.offset, this.littleEndian);
          return (this.offset += 4), e;
        }
        getInt64() {
          let e, t;
          return (
            this.littleEndian
              ? ((e = this.getUint32()), (t = this.getUint32()))
              : ((t = this.getUint32()), (e = this.getUint32())),
            2147483648 & t
              ? ((t = 4294967295 & ~t),
                (e = 4294967295 & ~e),
                4294967295 === e && (t = (t + 1) & 4294967295),
                (e = (e + 1) & 4294967295),
                -(4294967296 * t + e))
              : 4294967296 * t + e
          );
        }
        getInt64Array(e) {
          const t = [];
          for (let n = 0; n < e; n++) t.push(this.getInt64());
          return t;
        }
        getUint64() {
          let e, t;
          return (
            this.littleEndian
              ? ((e = this.getUint32()), (t = this.getUint32()))
              : ((t = this.getUint32()), (e = this.getUint32())),
            4294967296 * t + e
          );
        }
        getFloat32() {
          const e = this.dv.getFloat32(this.offset, this.littleEndian);
          return (this.offset += 4), e;
        }
        getFloat32Array(e) {
          const t = [];
          for (let n = 0; n < e; n++) t.push(this.getFloat32());
          return t;
        }
        getFloat64() {
          const e = this.dv.getFloat64(this.offset, this.littleEndian);
          return (this.offset += 8), e;
        }
        getFloat64Array(e) {
          const t = [];
          for (let n = 0; n < e; n++) t.push(this.getFloat64());
          return t;
        }
        getArrayBuffer(e) {
          const t = this.dv.buffer.slice(this.offset, this.offset + e);
          return (this.offset += e), t;
        }
        getString(e) {
          const t = this.offset;
          let n = new Uint8Array(this.dv.buffer, t, e);
          this.skip(e);
          const i = n.indexOf(0);
          return (
            i >= 0 && (n = new Uint8Array(this.dv.buffer, t, i)),
            this._textDecoder.decode(n)
          );
        }
      }
      class ow {
        add(e, t) {
          this[e] = t;
        }
      }
      function cw(e) {
        const t = e.match(/FBXVersion: (\d+)/);
        if (t) {
          return parseInt(t[1]);
        }
        throw new Error(
          "THREE.FBXLoader: Cannot find the version number for the file given."
        );
      }
      function lw(e) {
        return e / 46186158e3;
      }
      const uw = [];
      function hw(e, t, n, i) {
        let r;
        switch (i.mappingType) {
          case "ByPolygonVertex":
            r = e;
            break;
          case "ByPolygon":
            r = t;
            break;
          case "ByVertice":
            r = n;
            break;
          case "AllSame":
            r = i.indices[0];
            break;
          default:
            console.warn(
              "THREE.FBXLoader: unknown attribute mapping type " + i.mappingType
            );
        }
        "IndexToDirect" === i.referenceType && (r = i.indices[r]);
        const s = r * i.dataSize,
          a = s + i.dataSize;
        return (function (e, t, n, i) {
          for (let r = n, s = 0; r < i; r++, s++) e[s] = t[r];
          return e;
        })(uw, i.buffer, s, a);
      }
      const dw = new Us(),
        pw = new Yr();
      function fw(e) {
        const t = new Cs(),
          n = new Cs(),
          i = new Cs(),
          r = new Cs(),
          s = new Cs(),
          a = new Cs(),
          o = new Cs(),
          c = new Cs(),
          l = new Cs(),
          u = new Cs(),
          h = new Cs(),
          d = new Cs(),
          p = e.inheritType ? e.inheritType : 0;
        e.translation && t.setPosition(pw.fromArray(e.translation));
        const f = Aw(0);
        if (e.preRotation) {
          const t = e.preRotation.map(yr.degToRad);
          t.push(f), n.makeRotationFromEuler(dw.fromArray(t));
        }
        if (e.rotation) {
          const t = e.rotation.map(yr.degToRad);
          t.push(e.eulerOrder || f), i.makeRotationFromEuler(dw.fromArray(t));
        }
        if (e.postRotation) {
          const t = e.postRotation.map(yr.degToRad);
          t.push(f), r.makeRotationFromEuler(dw.fromArray(t)), r.invert();
        }
        e.scale && s.scale(pw.fromArray(e.scale)),
          e.scalingOffset && o.setPosition(pw.fromArray(e.scalingOffset)),
          e.scalingPivot && a.setPosition(pw.fromArray(e.scalingPivot)),
          e.rotationOffset && c.setPosition(pw.fromArray(e.rotationOffset)),
          e.rotationPivot && l.setPosition(pw.fromArray(e.rotationPivot)),
          e.parentMatrixWorld &&
            (h.copy(e.parentMatrix), u.copy(e.parentMatrixWorld));
        const A = n.clone().multiply(i).multiply(r),
          g = new Cs();
        g.extractRotation(u);
        const m = new Cs();
        m.copyPosition(u);
        const v = m.clone().invert().multiply(u),
          y = g.clone().invert().multiply(v),
          b = s,
          _ = new Cs();
        if (0 === p) _.copy(g).multiply(A).multiply(y).multiply(b);
        else if (1 === p) _.copy(g).multiply(y).multiply(A).multiply(b);
        else {
          const e = new Cs()
              .scale(new Yr().setFromMatrixScale(h))
              .clone()
              .invert(),
            t = y.clone().multiply(e);
          _.copy(g).multiply(A).multiply(t).multiply(b);
        }
        const x = l.clone().invert(),
          E = a.clone().invert();
        let w = t
          .clone()
          .multiply(c)
          .multiply(l)
          .multiply(n)
          .multiply(i)
          .multiply(r)
          .multiply(x)
          .multiply(o)
          .multiply(a)
          .multiply(s)
          .multiply(E);
        const C = new Cs().copyPosition(w),
          S = u.clone().multiply(C);
        return (
          d.copyPosition(S),
          (w = d.clone().multiply(_)),
          w.premultiply(u.invert()),
          w
        );
      }
      function Aw(e) {
        const t = ["ZYX", "YZX", "XZY", "ZXY", "YXZ", "XYZ"];
        return 6 === (e = e || 0)
          ? (console.warn(
              "THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."
            ),
            t[0])
          : t[e];
      }
      function gw(e) {
        const t = e.split(",").map(function (e) {
          return parseFloat(e);
        });
        return t;
      }
      function mw(e, t, n) {
        return (
          void 0 === t && (t = 0),
          void 0 === n && (n = e.byteLength),
          new TextDecoder().decode(new Uint8Array(e, t, n))
        );
      }
      class vw {
        constructor(e = 4) {
          (this.pool = e),
            (this.queue = []),
            (this.workers = []),
            (this.workersResolve = []),
            (this.workerStatus = 0);
        }
        _initWorker(e) {
          if (!this.workers[e]) {
            const t = this.workerCreator();
            t.addEventListener("message", this._onMessage.bind(this, e)),
              (this.workers[e] = t);
          }
        }
        _getIdleWorker() {
          for (let e = 0; e < this.pool; e++)
            if (!(this.workerStatus & (1 << e))) return e;
          return -1;
        }
        _onMessage(e, t) {
          const n = this.workersResolve[e];
          if ((n && n(t), this.queue.length)) {
            const { resolve: t, msg: n, transfer: i } = this.queue.shift();
            (this.workersResolve[e] = t), this.workers[e].postMessage(n, i);
          } else this.workerStatus ^= 1 << e;
        }
        setWorkerCreator(e) {
          this.workerCreator = e;
        }
        setWorkerLimit(e) {
          this.pool = e;
        }
        postMessage(e, t) {
          return new Promise((n) => {
            const i = this._getIdleWorker();
            -1 !== i
              ? (this._initWorker(i),
                (this.workerStatus |= 1 << i),
                (this.workersResolve[i] = n),
                this.workers[i].postMessage(e, t))
              : this.queue.push({ resolve: n, msg: e, transfer: t });
          });
        }
        dispose() {
          this.workers.forEach((e) => e.terminate()),
            (this.workersResolve.length = 0),
            (this.workers.length = 0),
            (this.queue.length = 0),
            (this.workerStatus = 0);
        }
      }
      const yw = 2,
        bw = 0,
        _w = 1,
        xw = 10,
        Ew = 1000066e3;
      class ww {
        constructor() {
          (this.vkFormat = 0),
            (this.typeSize = 1),
            (this.pixelWidth = 0),
            (this.pixelHeight = 0),
            (this.pixelDepth = 0),
            (this.layerCount = 0),
            (this.faceCount = 1),
            (this.supercompressionScheme = 0),
            (this.levels = []),
            (this.dataFormatDescriptor = [
              {
                vendorId: 0,
                descriptorType: 0,
                descriptorBlockSize: 0,
                versionNumber: 2,
                colorModel: 0,
                colorPrimaries: 1,
                transferFunction: 2,
                flags: 0,
                texelBlockDimension: [0, 0, 0, 0],
                bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0],
                samples: [],
              },
            ]),
            (this.keyValue = {}),
            (this.globalData = null);
        }
      }
      class Cw {
        constructor(e, t, n, i) {
          (this._dataView = void 0),
            (this._littleEndian = void 0),
            (this._offset = void 0),
            (this._dataView = new DataView(e.buffer, e.byteOffset + t, n)),
            (this._littleEndian = i),
            (this._offset = 0);
        }
        _nextUint8() {
          const e = this._dataView.getUint8(this._offset);
          return (this._offset += 1), e;
        }
        _nextUint16() {
          const e = this._dataView.getUint16(this._offset, this._littleEndian);
          return (this._offset += 2), e;
        }
        _nextUint32() {
          const e = this._dataView.getUint32(this._offset, this._littleEndian);
          return (this._offset += 4), e;
        }
        _nextUint64() {
          const e =
            this._dataView.getUint32(this._offset, this._littleEndian) +
            2 ** 32 *
              this._dataView.getUint32(this._offset + 4, this._littleEndian);
          return (this._offset += 8), e;
        }
        _nextInt32() {
          const e = this._dataView.getInt32(this._offset, this._littleEndian);
          return (this._offset += 4), e;
        }
        _nextUint8Array(e) {
          const t = new Uint8Array(
            this._dataView.buffer,
            this._dataView.byteOffset + this._offset,
            e
          );
          return (this._offset += e), t;
        }
        _skip(e) {
          return (this._offset += e), this;
        }
        _scan(e, t) {
          void 0 === t && (t = 0);
          const n = this._offset;
          let i = 0;
          for (; this._dataView.getUint8(this._offset) !== t && i < e; )
            i++, this._offset++;
          return (
            i < e && this._offset++,
            new Uint8Array(
              this._dataView.buffer,
              this._dataView.byteOffset + n,
              i
            )
          );
        }
      }
      new Uint8Array([0]);
      const Sw = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
      function Iw(e) {
        return new TextDecoder().decode(e);
      }
      let Mw, Tw, Bw;
      const Rw = {
        env: {
          emscripten_notify_memory_growth: function (e) {
            Bw = new Uint8Array(Tw.exports.memory.buffer);
          },
        },
      };
      class Dw {
        init() {
          return (
            Mw ||
            ((Mw =
              "undefined" != typeof fetch
                ? fetch("data:application/wasm;base64," + Pw)
                    .then((e) => e.arrayBuffer())
                    .then((e) => WebAssembly.instantiate(e, Rw))
                    .then(this._init)
                : WebAssembly.instantiate(Buffer.from(Pw, "base64"), Rw).then(
                    this._init
                  )),
            Mw)
          );
        }
        _init(e) {
          (Tw = e.instance), Rw.env.emscripten_notify_memory_growth(0);
        }
        decode(e, t = 0) {
          if (!Tw)
            throw new Error("ZSTDDecoder: Await .init() before decoding.");
          const n = e.byteLength,
            i = Tw.exports.malloc(n);
          Bw.set(e, i),
            (t = t || Number(Tw.exports.ZSTD_findDecompressedSize(i, n)));
          const r = Tw.exports.malloc(t),
            s = Tw.exports.ZSTD_decompress(r, t, i, n),
            a = Bw.slice(r, r + s);
          return Tw.exports.free(i), Tw.exports.free(r), a;
        }
      }
      const Pw =
          "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IAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQh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ASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigC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C0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdB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IAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY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wOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEE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",
        Lw = "display-p3",
        Uw = "display-p3-linear",
        Fw = new WeakMap();
      let Ow,
        Nw = 0;
      class kw extends _d {
        constructor(e) {
          super(e),
            (this.transcoderPath = ""),
            (this.transcoderBinary = null),
            (this.transcoderPending = null),
            (this.workerPool = new vw()),
            (this.workerSourceURL = ""),
            (this.workerConfig = null),
            "undefined" != typeof MSC_TRANSCODER &&
              console.warn(
                'THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.'
              );
        }
        setTranscoderPath(e) {
          return (this.transcoderPath = e), this;
        }
        setWorkerLimit(e) {
          return this.workerPool.setWorkerLimit(e), this;
        }
        async detectSupportAsync(e) {
          return (
            (this.workerConfig = {
              astcSupported: await e.hasFeatureAsync(
                "texture-compression-astc"
              ),
              astcHDRSupported: !1,
              etc1Supported: await e.hasFeatureAsync(
                "texture-compression-etc1"
              ),
              etc2Supported: await e.hasFeatureAsync(
                "texture-compression-etc2"
              ),
              dxtSupported: await e.hasFeatureAsync("texture-compression-bc"),
              bptcSupported: await e.hasFeatureAsync(
                "texture-compression-bptc"
              ),
              pvrtcSupported: await e.hasFeatureAsync(
                "texture-compression-pvrtc"
              ),
            }),
            this
          );
        }
        detectSupport(e) {
          return (
            !0 === e.isWebGPURenderer
              ? (this.workerConfig = {
                  astcSupported: e.hasFeature("texture-compression-astc"),
                  astcHDRSupported: !1,
                  etc1Supported: e.hasFeature("texture-compression-etc1"),
                  etc2Supported: e.hasFeature("texture-compression-etc2"),
                  dxtSupported: e.hasFeature("texture-compression-bc"),
                  bptcSupported: e.hasFeature("texture-compression-bptc"),
                  pvrtcSupported: e.hasFeature("texture-compression-pvrtc"),
                })
              : (this.workerConfig = {
                  astcSupported: e.extensions.has(
                    "WEBGL_compressed_texture_astc"
                  ),
                  astcHDRSupported:
                    e.extensions.has("WEBGL_compressed_texture_astc") &&
                    e.extensions
                      .get("WEBGL_compressed_texture_astc")
                      .getSupportedProfiles()
                      .includes("hdr"),
                  etc1Supported: e.extensions.has(
                    "WEBGL_compressed_texture_etc1"
                  ),
                  etc2Supported: e.extensions.has(
                    "WEBGL_compressed_texture_etc"
                  ),
                  dxtSupported: e.extensions.has(
                    "WEBGL_compressed_texture_s3tc"
                  ),
                  bptcSupported: e.extensions.has(
                    "EXT_texture_compression_bptc"
                  ),
                  pvrtcSupported:
                    e.extensions.has("WEBGL_compressed_texture_pvrtc") ||
                    e.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc"),
                }),
            this
          );
        }
        init() {
          if (!this.transcoderPending) {
            const e = new wd(this.manager);
            e.setPath(this.transcoderPath),
              e.setWithCredentials(this.withCredentials);
            const t = e.loadAsync("basis_transcoder.js"),
              n = new wd(this.manager);
            n.setPath(this.transcoderPath),
              n.setResponseType("arraybuffer"),
              n.setWithCredentials(this.withCredentials);
            const i = n.loadAsync("basis_transcoder.wasm");
            (this.transcoderPending = Promise.all([t, i]).then(([e, t]) => {
              const n = kw.BasisWorker.toString(),
                i = [
                  "/* constants */",
                  "let _EngineFormat = " + JSON.stringify(kw.EngineFormat),
                  "let _EngineType = " + JSON.stringify(kw.EngineType),
                  "let _TranscoderFormat = " +
                    JSON.stringify(kw.TranscoderFormat),
                  "let _BasisFormat = " + JSON.stringify(kw.BasisFormat),
                  "/* basis_transcoder.js */",
                  e,
                  "/* worker */",
                  n.substring(n.indexOf("{") + 1, n.lastIndexOf("}")),
                ].join("\n");
              (this.workerSourceURL = URL.createObjectURL(new Blob([i]))),
                (this.transcoderBinary = t),
                this.workerPool.setWorkerCreator(() => {
                  const e = new Worker(this.workerSourceURL),
                    t = this.transcoderBinary.slice(0);
                  return (
                    e.postMessage(
                      {
                        type: "init",
                        config: this.workerConfig,
                        transcoderBinary: t,
                      },
                      [t]
                    ),
                    e
                  );
                });
            })),
              Nw > 0 &&
                console.warn(
                  "THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."
                ),
              Nw++;
          }
          return this.transcoderPending;
        }
        load(e, t, n, i) {
          if (null === this.workerConfig)
            throw new Error(
              "THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`."
            );
          const r = new wd(this.manager);
          r.setResponseType("arraybuffer"),
            r.setWithCredentials(this.withCredentials),
            r.load(
              e,
              (e) => {
                this.parse(e, t, i);
              },
              n,
              i
            );
        }
        parse(e, t, n) {
          if (null === this.workerConfig)
            throw new Error(
              "THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`."
            );
          if (Fw.has(e)) {
            return Fw.get(e).promise.then(t).catch(n);
          }
          this._createTexture(e)
            .then((e) => (t ? t(e) : null))
            .catch(n);
        }
        _createTextureFrom(e, t) {
          const {
            type: n,
            error: i,
            data: {
              faces: r,
              width: s,
              height: a,
              format: o,
              type: c,
              dfdFlags: l,
            },
          } = e;
          if ("error" === n) return Promise.reject(i);
          let u;
          if (6 === t.faceCount) u = new Ah(r, o, c);
          else {
            const e = r[0].mipmaps;
            u =
              t.layerCount > 1
                ? new fh(e, s, a, t.layerCount, o, c)
                : new ph(e, s, a, o, c);
          }
          return (
            (u.minFilter = 1 === r[0].mipmaps.length ? Un : On),
            (u.magFilter = Un),
            (u.generateMipmaps = !1),
            (u.needsUpdate = !0),
            (u.colorSpace = zw(t)),
            (u.premultiplyAlpha = !!(1 & l)),
            u
          );
        }
        async _createTexture(e, t = {}) {
          const n = (function (e) {
              const t = new Uint8Array(e.buffer, e.byteOffset, Sw.length);
              if (
                t[0] !== Sw[0] ||
                t[1] !== Sw[1] ||
                t[2] !== Sw[2] ||
                t[3] !== Sw[3] ||
                t[4] !== Sw[4] ||
                t[5] !== Sw[5] ||
                t[6] !== Sw[6] ||
                t[7] !== Sw[7] ||
                t[8] !== Sw[8] ||
                t[9] !== Sw[9] ||
                t[10] !== Sw[10] ||
                t[11] !== Sw[11]
              )
                throw new Error("Missing KTX 2.0 identifier.");
              const n = new ww(),
                i = 17 * Uint32Array.BYTES_PER_ELEMENT,
                r = new Cw(e, Sw.length, i, !0);
              (n.vkFormat = r._nextUint32()),
                (n.typeSize = r._nextUint32()),
                (n.pixelWidth = r._nextUint32()),
                (n.pixelHeight = r._nextUint32()),
                (n.pixelDepth = r._nextUint32()),
                (n.layerCount = r._nextUint32()),
                (n.faceCount = r._nextUint32());
              const s = r._nextUint32();
              n.supercompressionScheme = r._nextUint32();
              const a = r._nextUint32(),
                o = r._nextUint32(),
                c = r._nextUint32(),
                l = r._nextUint32(),
                u = r._nextUint64(),
                h = r._nextUint64(),
                d = new Cw(e, Sw.length + i, 3 * s * 8, !0);
              for (let t = 0; t < s; t++)
                n.levels.push({
                  levelData: new Uint8Array(
                    e.buffer,
                    e.byteOffset + d._nextUint64(),
                    d._nextUint64()
                  ),
                  uncompressedByteLength: d._nextUint64(),
                });
              const p = new Cw(e, a, o, !0),
                f = {
                  vendorId: p._skip(4)._nextUint16(),
                  descriptorType: p._nextUint16(),
                  versionNumber: p._nextUint16(),
                  descriptorBlockSize: p._nextUint16(),
                  colorModel: p._nextUint8(),
                  colorPrimaries: p._nextUint8(),
                  transferFunction: p._nextUint8(),
                  flags: p._nextUint8(),
                  texelBlockDimension: [
                    p._nextUint8(),
                    p._nextUint8(),
                    p._nextUint8(),
                    p._nextUint8(),
                  ],
                  bytesPlane: [
                    p._nextUint8(),
                    p._nextUint8(),
                    p._nextUint8(),
                    p._nextUint8(),
                    p._nextUint8(),
                    p._nextUint8(),
                    p._nextUint8(),
                    p._nextUint8(),
                  ],
                  samples: [],
                },
                A = (f.descriptorBlockSize / 4 - 6) / 4;
              for (let e = 0; e < A; e++) {
                const t = {
                  bitOffset: p._nextUint16(),
                  bitLength: p._nextUint8(),
                  channelType: p._nextUint8(),
                  samplePosition: [
                    p._nextUint8(),
                    p._nextUint8(),
                    p._nextUint8(),
                    p._nextUint8(),
                  ],
                  sampleLower: -1 / 0,
                  sampleUpper: 1 / 0,
                };
                64 & t.channelType
                  ? ((t.sampleLower = p._nextInt32()),
                    (t.sampleUpper = p._nextInt32()))
                  : ((t.sampleLower = p._nextUint32()),
                    (t.sampleUpper = p._nextUint32())),
                  (f.samples[e] = t);
              }
              (n.dataFormatDescriptor.length = 0),
                n.dataFormatDescriptor.push(f);
              const g = new Cw(e, c, l, !0);
              for (; g._offset < l; ) {
                const e = g._nextUint32(),
                  t = g._scan(e),
                  i = Iw(t);
                if (
                  ((n.keyValue[i] = g._nextUint8Array(e - t.byteLength - 1)),
                  i.match(/^ktx/i))
                ) {
                  const e = Iw(n.keyValue[i]);
                  n.keyValue[i] = e.substring(0, e.lastIndexOf("\0"));
                }
                g._skip(e % 4 ? 4 - (e % 4) : 0);
              }
              if (h <= 0) return n;
              const m = new Cw(e, u, h, !0),
                v = m._nextUint16(),
                y = m._nextUint16(),
                b = m._nextUint32(),
                _ = m._nextUint32(),
                x = m._nextUint32(),
                E = m._nextUint32(),
                w = [];
              for (let e = 0; e < s; e++)
                w.push({
                  imageFlags: m._nextUint32(),
                  rgbSliceByteOffset: m._nextUint32(),
                  rgbSliceByteLength: m._nextUint32(),
                  alphaSliceByteOffset: m._nextUint32(),
                  alphaSliceByteLength: m._nextUint32(),
                });
              const C = u + m._offset,
                S = C + b,
                I = S + _,
                M = I + x,
                T = new Uint8Array(e.buffer, e.byteOffset + C, b),
                B = new Uint8Array(e.buffer, e.byteOffset + S, _),
                R = new Uint8Array(e.buffer, e.byteOffset + I, x),
                D = new Uint8Array(e.buffer, e.byteOffset + M, E);
              return (
                (n.globalData = {
                  endpointCount: v,
                  selectorCount: y,
                  imageDescs: w,
                  endpointsData: T,
                  selectorsData: B,
                  tablesData: R,
                  extendedData: D,
                }),
                n
              );
            })(new Uint8Array(e)),
            i =
              n.vkFormat === Ew && 167 === n.dataFormatDescriptor[0].colorModel;
          if (!(0 === n.vkFormat || (i && !this.workerConfig.astcHDRSupported)))
            return (async function (e) {
              const { vkFormat: t } = e;
              if (void 0 === Gw[t])
                throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
              let n;
              2 === e.supercompressionScheme &&
                (Ow ||
                  (Ow = new Promise(async (e) => {
                    const t = new Dw();
                    await t.init(), e(t);
                  })),
                (n = await Ow));
              const i = [];
              for (let r = 0; r < e.levels.length; r++) {
                const s = Math.max(1, e.pixelWidth >> r),
                  a = Math.max(1, e.pixelHeight >> r),
                  o = e.pixelDepth ? Math.max(1, e.pixelDepth >> r) : 0,
                  c = e.levels[r];
                let l, u;
                if (0 === e.supercompressionScheme) l = c.levelData;
                else {
                  if (2 !== e.supercompressionScheme)
                    throw new Error(
                      "THREE.KTX2Loader: Unsupported supercompressionScheme."
                    );
                  l = n.decode(c.levelData, c.uncompressedByteLength);
                }
                (u =
                  Hw[t] === Vn
                    ? new Float32Array(
                        l.buffer,
                        l.byteOffset,
                        l.byteLength / Float32Array.BYTES_PER_ELEMENT
                      )
                    : Hw[t] === jn
                    ? new Uint16Array(
                        l.buffer,
                        l.byteOffset,
                        l.byteLength / Uint16Array.BYTES_PER_ELEMENT
                      )
                    : l),
                  i.push({ data: u, width: s, height: a, depth: o });
              }
              let r;
              if (Qw.has(Gw[t]))
                r =
                  0 === e.pixelDepth
                    ? new Du(i[0].data, e.pixelWidth, e.pixelHeight)
                    : new Xr(
                        i[0].data,
                        e.pixelWidth,
                        e.pixelHeight,
                        e.pixelDepth
                      );
              else {
                if (e.pixelDepth > 0)
                  throw new Error("THREE.KTX2Loader: Unsupported pixelDepth.");
                r = new ph(i, e.pixelWidth, e.pixelHeight);
              }
              return (
                (r.mipmaps = i),
                (r.type = Hw[t]),
                (r.format = Gw[t]),
                (r.colorSpace = zw(e)),
                (r.needsUpdate = !0),
                Promise.resolve(r)
              );
            })(n);
          const r = t,
            s = this.init()
              .then(() =>
                this.workerPool.postMessage(
                  { type: "transcode", buffer: e, taskConfig: r },
                  [e]
                )
              )
              .then((e) => this._createTextureFrom(e.data, n));
          return Fw.set(e, { promise: s }), s;
        }
        dispose() {
          return (
            this.workerPool.dispose(),
            this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL),
            Nw--,
            this
          );
        }
      }
      (kw.BasisFormat = { ETC1S: 0, UASTC: 1, UASTC_HDR: 2 }),
        (kw.TranscoderFormat = {
          ETC1: 0,
          ETC2: 1,
          BC1: 2,
          BC3: 3,
          BC4: 4,
          BC5: 5,
          BC7_M6_OPAQUE_ONLY: 6,
          BC7_M5: 7,
          PVRTC1_4_RGB: 8,
          PVRTC1_4_RGBA: 9,
          ASTC_4x4: 10,
          ATC_RGB: 11,
          ATC_RGBA_INTERPOLATED_ALPHA: 12,
          RGBA32: 13,
          RGB565: 14,
          BGR565: 15,
          RGBA4444: 16,
          BC6H: 22,
          RGB_HALF: 24,
          RGBA_HALF: 25,
        }),
        (kw.EngineFormat = {
          RGBAFormat: Zn,
          RGBA_ASTC_4x4_Format: yi,
          RGB_BPTC_UNSIGNED_Format: Ui,
          RGBA_BPTC_Format: Pi,
          RGBA_ETC2_EAC_Format: vi,
          RGBA_PVRTC_4BPPV1_Format: fi,
          RGBA_S3TC_DXT5_Format: hi,
          RGB_ETC1_Format: gi,
          RGB_ETC2_Format: mi,
          RGB_PVRTC_4BPPV1_Format: di,
          RGBA_S3TC_DXT1_Format: li,
        }),
        (kw.EngineType = {
          UnsignedByteType: Nn,
          HalfFloatType: jn,
          FloatType: Vn,
        }),
        (kw.BasisWorker = function () {
          let e, t, n;
          const i = _EngineFormat,
            r = _EngineType,
            s = _TranscoderFormat,
            a = _BasisFormat;
          self.addEventListener("message", function (i) {
            const s = i.data;
            switch (s.type) {
              case "init":
                (e = s.config),
                  (o = s.transcoderBinary),
                  (t = new Promise((e) => {
                    (n = { wasmBinary: o, onRuntimeInitialized: e }), BASIS(n);
                  }).then(() => {
                    n.initializeBasis(),
                      void 0 === n.KTX2File &&
                        console.warn(
                          "THREE.KTX2Loader: Please update Basis Universal transcoder."
                        );
                  }));
                break;
              case "transcode":
                t.then(() => {
                  try {
                    const {
                      faces: t,
                      buffers: i,
                      width: o,
                      height: h,
                      hasAlpha: d,
                      format: p,
                      type: f,
                      dfdFlags: A,
                    } = (function (t) {
                      const i = new n.KTX2File(new Uint8Array(t));
                      function s() {
                        i.close(), i.delete();
                      }
                      if (!i.isValid())
                        throw (
                          (s(),
                          new Error(
                            "THREE.KTX2Loader:\tInvalid or unsupported .ktx2 file"
                          ))
                        );
                      let o;
                      if (i.isUASTC()) o = a.UASTC;
                      else if (i.isETC1S()) o = a.ETC1S;
                      else {
                        if (!i.isHDR())
                          throw new Error(
                            "THREE.KTX2Loader: Unknown Basis encoding"
                          );
                        o = a.UASTC_HDR;
                      }
                      const h = i.getWidth(),
                        d = i.getHeight(),
                        p = i.getLayers() || 1,
                        f = i.getLevels(),
                        A = i.getFaces(),
                        g = i.getHasAlpha(),
                        m = i.getDFDFlags(),
                        {
                          transcoderFormat: v,
                          engineFormat: y,
                          engineType: b,
                        } = (function (t, n, i, r) {
                          const s = c[t];
                          for (let a = 0; a < s.length; a++) {
                            const o = s[a];
                            if (o.if && !e[o.if]) continue;
                            if (!o.basisFormat.includes(t)) continue;
                            if (r && o.transcoderFormat.length < 2) continue;
                            if (o.needsPowerOfTwo && (!l(n) || !l(i))) continue;
                            return {
                              transcoderFormat: o.transcoderFormat[r ? 1 : 0],
                              engineFormat: o.engineFormat[r ? 1 : 0],
                              engineType: o.engineType[0],
                            };
                          }
                          throw new Error(
                            "THREE.KTX2Loader: Failed to identify transcoding target."
                          );
                        })(o, h, d, g);
                      if (!h || !d || !f)
                        throw (
                          (s(), new Error("THREE.KTX2Loader:\tInvalid texture"))
                        );
                      if (!i.startTranscoding())
                        throw (
                          (s(),
                          new Error(
                            "THREE.KTX2Loader: .startTranscoding failed"
                          ))
                        );
                      const _ = [],
                        x = [];
                      for (let e = 0; e < A; e++) {
                        const t = [];
                        for (let n = 0; n < f; n++) {
                          const a = [];
                          let o, c;
                          for (let t = 0; t < p; t++) {
                            const l = i.getImageLevelInfo(n, t, e);
                            0 !== e ||
                              0 !== n ||
                              0 !== t ||
                              (l.origWidth % 4 == 0 && l.origHeight % 4 == 0) ||
                              console.warn(
                                "THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions."
                              ),
                              f > 1
                                ? ((o = l.origWidth), (c = l.origHeight))
                                : ((o = l.width), (c = l.height));
                            let u = new Uint8Array(
                              i.getImageTranscodedSizeInBytes(n, t, 0, v)
                            );
                            const h = i.transcodeImage(
                              u,
                              n,
                              t,
                              e,
                              v,
                              0,
                              -1,
                              -1
                            );
                            if (
                              (b === r.HalfFloatType &&
                                (u = new Uint16Array(
                                  u.buffer,
                                  u.byteOffset,
                                  u.byteLength / Uint16Array.BYTES_PER_ELEMENT
                                )),
                              !h)
                            )
                              throw (
                                (s(),
                                new Error(
                                  "THREE.KTX2Loader: .transcodeImage failed."
                                ))
                              );
                            a.push(u);
                          }
                          const l = u(a);
                          t.push({ data: l, width: o, height: c }),
                            x.push(l.buffer);
                        }
                        _.push({
                          mipmaps: t,
                          width: h,
                          height: d,
                          format: y,
                          type: b,
                        });
                      }
                      return (
                        s(),
                        {
                          faces: _,
                          buffers: x,
                          width: h,
                          height: d,
                          hasAlpha: g,
                          dfdFlags: m,
                          format: y,
                          type: b,
                        }
                      );
                    })(s.buffer);
                    self.postMessage(
                      {
                        type: "transcode",
                        id: s.id,
                        data: {
                          faces: t,
                          width: o,
                          height: h,
                          hasAlpha: d,
                          format: p,
                          type: f,
                          dfdFlags: A,
                        },
                      },
                      i
                    );
                  } catch (e) {
                    console.error(e),
                      self.postMessage({
                        type: "error",
                        id: s.id,
                        error: e.message,
                      });
                  }
                });
            }
            var o;
          });
          const o = [
              {
                if: "astcSupported",
                basisFormat: [a.UASTC],
                transcoderFormat: [s.ASTC_4x4, s.ASTC_4x4],
                engineFormat: [i.RGBA_ASTC_4x4_Format, i.RGBA_ASTC_4x4_Format],
                engineType: [r.UnsignedByteType],
                priorityETC1S: 1 / 0,
                priorityUASTC: 1,
                needsPowerOfTwo: !1,
              },
              {
                if: "bptcSupported",
                basisFormat: [a.ETC1S, a.UASTC],
                transcoderFormat: [s.BC7_M5, s.BC7_M5],
                engineFormat: [i.RGBA_BPTC_Format, i.RGBA_BPTC_Format],
                engineType: [r.UnsignedByteType],
                priorityETC1S: 3,
                priorityUASTC: 2,
                needsPowerOfTwo: !1,
              },
              {
                if: "dxtSupported",
                basisFormat: [a.ETC1S, a.UASTC],
                transcoderFormat: [s.BC1, s.BC3],
                engineFormat: [
                  i.RGBA_S3TC_DXT1_Format,
                  i.RGBA_S3TC_DXT5_Format,
                ],
                engineType: [r.UnsignedByteType],
                priorityETC1S: 4,
                priorityUASTC: 5,
                needsPowerOfTwo: !1,
              },
              {
                if: "etc2Supported",
                basisFormat: [a.ETC1S, a.UASTC],
                transcoderFormat: [s.ETC1, s.ETC2],
                engineFormat: [i.RGB_ETC2_Format, i.RGBA_ETC2_EAC_Format],
                engineType: [r.UnsignedByteType],
                priorityETC1S: 1,
                priorityUASTC: 3,
                needsPowerOfTwo: !1,
              },
              {
                if: "etc1Supported",
                basisFormat: [a.ETC1S, a.UASTC],
                transcoderFormat: [s.ETC1],
                engineFormat: [i.RGB_ETC1_Format],
                engineType: [r.UnsignedByteType],
                priorityETC1S: 2,
                priorityUASTC: 4,
                needsPowerOfTwo: !1,
              },
              {
                if: "pvrtcSupported",
                basisFormat: [a.ETC1S, a.UASTC],
                transcoderFormat: [s.PVRTC1_4_RGB, s.PVRTC1_4_RGBA],
                engineFormat: [
                  i.RGB_PVRTC_4BPPV1_Format,
                  i.RGBA_PVRTC_4BPPV1_Format,
                ],
                engineType: [r.UnsignedByteType],
                priorityETC1S: 5,
                priorityUASTC: 6,
                needsPowerOfTwo: !0,
              },
              {
                if: "bptcSupported",
                basisFormat: [a.UASTC_HDR],
                transcoderFormat: [s.BC6H],
                engineFormat: [i.RGB_BPTC_UNSIGNED_Format],
                engineType: [r.HalfFloatType],
                priorityHDR: 1,
                needsPowerOfTwo: !1,
              },
              {
                basisFormat: [a.ETC1S, a.UASTC],
                transcoderFormat: [s.RGBA32, s.RGBA32],
                engineFormat: [i.RGBAFormat, i.RGBAFormat],
                engineType: [r.UnsignedByteType, r.UnsignedByteType],
                priorityETC1S: 100,
                priorityUASTC: 100,
                needsPowerOfTwo: !1,
              },
              {
                basisFormat: [a.UASTC_HDR],
                transcoderFormat: [s.RGBA_HALF],
                engineFormat: [i.RGBAFormat],
                engineType: [r.HalfFloatType],
                priorityHDR: 100,
                needsPowerOfTwo: !1,
              },
            ],
            c = {
              [a.ETC1S]: o
                .filter((e) => e.basisFormat.includes(a.ETC1S))
                .sort((e, t) => e.priorityUASTC - t.priorityUASTC),
              [a.UASTC]: o
                .filter((e) => e.basisFormat.includes(a.UASTC))
                .sort((e, t) => e.priorityUASTC - t.priorityUASTC),
              [a.UASTC_HDR]: o
                .filter((e) => e.basisFormat.includes(a.UASTC_HDR))
                .sort((e, t) => e.priorityHDR - t.priorityHDR),
            };
          function l(e) {
            return e <= 2 || (!(e & (e - 1)) && 0 !== e);
          }
          function u(e) {
            if (1 === e.length) return e[0];
            let t = 0;
            for (let n = 0; n < e.length; n++) {
              t += e[n].byteLength;
            }
            const n = new Uint8Array(t);
            let i = 0;
            for (let t = 0; t < e.length; t++) {
              const r = e[t];
              n.set(r, i), (i += r.byteLength);
            }
            return n;
          }
        });
      const Qw = new Set([Zn, si, ii]),
        Gw = {
          109: Zn,
          97: Zn,
          37: Zn,
          43: Zn,
          103: si,
          83: si,
          16: si,
          22: si,
          100: ii,
          76: ii,
          15: ii,
          9: ii,
          [Ew]: yi,
          166: Ei,
          165: Ei,
        },
        Hw = {
          109: Vn,
          97: jn,
          37: Nn,
          43: Nn,
          103: Vn,
          83: jn,
          16: Nn,
          22: Nn,
          100: Vn,
          76: jn,
          15: Nn,
          9: Nn,
          [Ew]: jn,
          166: Nn,
          165: Nn,
        };
      function zw(e) {
        const t = e.dataFormatDescriptor[0];
        return t.colorPrimaries === _w
          ? t.transferFunction === yw
            ? Zi
            : $i
          : t.colorPrimaries === xw
          ? t.transferFunction === yw
            ? Lw
            : Uw
          : (t.colorPrimaries === bw ||
              console.warn(
                `THREE.KTX2Loader: Unsupported color primaries, "${t.colorPrimaries}"`
              ),
            Ji);
      }
      var Vw = (function () {
        var e = new Uint8Array([
            0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3,
            1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10,
            0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11,
          ]),
          t = new Uint8Array([
            32, 0, 65, 2, 1, 106, 34, 33, 3, 128, 11, 4, 13, 64, 6, 253, 10, 7,
            15, 116, 127, 5, 8, 12, 40, 16, 19, 54, 20, 9, 27, 255, 113, 17, 42,
            67, 24, 23, 146, 148, 18, 14, 22, 45, 70, 69, 56, 114, 101, 21, 25,
            63, 75, 136, 108, 28, 118, 29, 73, 115,
          ]);
        if ("object" != typeof WebAssembly) return { supported: !1 };
        var n,
          i = WebAssembly.validate(e)
            ? "b9H79TebbbeKl9Gbb9Gvuuuuueu9Giuuub9Geueuikqbbebeedddilve9Weeeviebeoweuec:q;Aekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbdY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVblE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtboK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbrL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbwl79IV9RbDq;t9tqlbzik9:evu8Jjjjjbcz9Rhbcbheincbhdcbhiinabcwfadfaicjuaead4ceGglE86bbaialfhiadcefgdcw9hmbkaec:q:yjjbfai86bbaecitc:q1jjbfab8Piw83ibaecefgecjd9hmbkk;h8JlHud97euo978Jjjjjbcj;kb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Rad;8qbbcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhwcbhDinaDae9pmeawaeaD9RaDawfae6Egqcsfgoc9WGgkci2hxakcethmaocl4cifcd4hPabaDad2fhscbhzdnincehHalhOcbhAdninaraO9RaP6miavcj;cbfaAak2fhCaOaPfhlcbhidnakc;ab6mbaral9Rc;Gb6mbcbhoinaCaofhidndndndndnaOaoco4fRbbgXciGPlbedibkaipxbbbbbbbbbbbbbbbbpklbxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklbalczfhlkdndndndndnaXcd4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklzxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklzalczfhlkdndndndndnaXcl4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklaxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklaalczfhlkdndndndndnaXco4Plbedibkaipxbbbbbbbbbbbbbbbbpkl8WxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalclfaYpQbfaXc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalcwfaYpQbfaXc:q:yjjbfRbbfhlxekaialpbbbpkl8Walczfhlkaoc;abfhiaocjefak0meaihoaral9Rc;Fb0mbkkdndnaiak9pmbaici4hoinaral9RcK6mdaCaifhXdndndndndnaOaico4fRbbaocoG4ciGPlbedibkaXpxbbbbbbbbbbbbbbbbpklbxikaXalpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaXalpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaXalpbbbpklbalczfhlkaocdfhoaiczfgiak6mbkkalTmbaAci6hHalhOaAcefgohAaoclSmdxekkcbhlaHceGmdkdnakTmbavcjdfazfhiavazfpbdbhYcbhXinaiavcj;cbfaXfgopblbgLcep9TaLpxeeeeeeeeeeeeeeeegQp9op9Hp9rgLaoakfpblbg8Acep9Ta8AaQp9op9Hp9rg8ApmbzeHdOiAlCvXoQrLgEaoamfpblbg3cep9Ta3aQp9op9Hp9rg3aoaxfpblbg5cep9Ta5aQp9op9Hp9rg5pmbzeHdOiAlCvXoQrLg8EpmbezHdiOAlvCXorQLgQaQpmbedibedibedibediaYp9UgYp9AdbbaiadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaEa8EpmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwKDYq8AkEx3m5P8Es8FgLa3a5pmwKDYq8AkEx3m5P8Es8Fg8ApmbezHdiOAlvCXorQLgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfhiaXczfgXak6mbkkazclfgzad6mbkasavcjdfaqad2;8qbbavavcjdfaqcufad2fad;8qbbaqaDfhDc9:hoalmexikkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;kbf8Kjjjjbaokwbz:bjjjbk;uzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecje;8kbavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:EPliuo97eue978Jjjjjbca9Rhidndnadcl9hmbdnaec98GglTmbcbhvabhdinadadpbbbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpkbbadczfhdavclfgval6mbkkalae9pmeaiaeciGgvcdtgdVcbczad9R;8kbaiabalcdtfglad;8qbbdnavTmbaiaipblbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpklbkalaiad;8qbbskdnaec98GgxTmbcbhvabhdinadczfglalpbbbgopxbbbbbbFFbbbbbbFFgkp9oadpbbbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpkbbadaDakp9oawaopmbezHdiOAlvCXorQLp9qpkbbadcafhdavclfgvax6mbkkaxae9pmbaiaeciGgvcitgdfcbcaad9R;8kbaiabaxcitfglad;8qbbdnavTmbaiaipblzgopxbbbbbbFFbbbbbbFFgkp9oaipblbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpklzaiaDakp9oawaopmbezHdiOAlvCXorQLp9qpklbkalaiad;8qbbkk;4wllue97euv978Jjjjjbc8W9Rhidnaec98GglTmbcbhvabhoinaiaopbbbgraoczfgwpbbbgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklbaopxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblbpEb:T:j83ibaocwfarp5eaipblbpEe:T:j83ibawaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblbpEd:T:j83ibaocKfakp5eaipblbpEi:T:j83ibaocafhoavclfgval6mbkkdnalae9pmbaiaeciGgvcitgofcbcaao9R;8kbaiabalcitfgwao;8qbbdnavTmbaiaipblbgraipblzgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklaaipxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblapEb:T:j83ibaiarp5eaipblapEe:T:j83iwaiaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblapEd:T:j83izaiakp5eaipblapEi:T:j83iKkawaiao;8qbbkk:Pddiue978Jjjjjbc;ab9Rhidnadcd4ae2glc98GgvTmbcbhdabheinaeaepbbbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepkbbaeczfheadclfgdav6mbkkdnaval9pmbaialciGgdcdtgeVcbc;abae9R;8kbaiabavcdtfgvae;8qbbdnadTmbaiaipblbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepklbkavaiae;8qbbkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaikkkebcjwklz9Tbb"
            : "b9H79Tebbbe8Fv9Gbb9Gvuuuuueu9Giuuub9Geueu9Giuuueuikqbeeedddillviebeoweuec:q;iekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbeY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVbdE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbiL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtblK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbol79IV9Rbrq:P8Yqdbk;3sezu8Jjjjjbcj;eb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Radz1jjjbhwcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhDcbhqinaqae9pmeaDaeaq9RaqaDfae6Egkcsfgocl4cifcd4hxdndndndnaoc9WGgmTmbcbhPcehsawcjdfhzalhHinaraH9Rax6midnaraHaxfgl9RcK6mbczhoinawcj;cbfaogifgoc9WfhOdndndndndnaHaic9WfgAco4fRbbaAci4coG4ciGPlbedibkaO9cb83ibaOcwf9cb83ibxikaOalRblalRbbgAco4gCaCciSgCE86bbaocGfalclfaCfgORbbaAcl4ciGgCaCciSgCE86bbaocVfaOaCfgORbbaAcd4ciGgCaCciSgCE86bbaoc7faOaCfgORbbaAciGgAaAciSgAE86bbaoctfaOaAfgARbbalRbegOco4gCaCciSgCE86bbaoc91faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc4faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc93faAaCfgARbbaOciGgOaOciSgOE86bbaoc94faAaOfgARbbalRbdgOco4gCaCciSgCE86bbaoc95faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc96faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc97faAaCfgARbbaOciGgOaOciSgOE86bbaoc98faAaOfgORbbalRbiglco4gAaAciSgAE86bbaoc99faOaAfgORbbalcl4ciGgAaAciSgAE86bbaoc9:faOaAfgORbbalcd4ciGgAaAciSgAE86bbaocufaOaAfgoRbbalciGglalciSglE86bbaoalfhlxdkaOalRbwalRbbgAcl4gCaCcsSgCE86bbaocGfalcwfaCfgORbbaAcsGgAaAcsSgAE86bbaocVfaOaAfgORbbalRbegAcl4gCaCcsSgCE86bbaoc7faOaCfgORbbaAcsGgAaAcsSgAE86bbaoctfaOaAfgORbbalRbdgAcl4gCaCcsSgCE86bbaoc91faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc4faOaAfgORbbalRbigAcl4gCaCcsSgCE86bbaoc93faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc94faOaAfgORbbalRblgAcl4gCaCcsSgCE86bbaoc95faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc96faOaAfgORbbalRbvgAcl4gCaCcsSgCE86bbaoc97faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc98faOaAfgORbbalRbogAcl4gCaCcsSgCE86bbaoc99faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc9:faOaAfgORbbalRbrglcl4gAaAcsSgAE86bbaocufaOaAfgoRbbalcsGglalcsSglE86bbaoalfhlxekaOal8Pbb83bbaOcwfalcwf8Pbb83bbalczfhlkdnaiam9pmbaiczfhoaral9RcL0mekkaiam6mialTmidnakTmbawaPfRbbhOcbhoazhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkkazcefhzaPcefgPad6hsalhHaPad9hmexvkkcbhlasceGmdxikalaxad2fhCdnakTmbcbhHcehsawcjdfhminaral9Rax6mialTmdalaxfhlawaHfRbbhOcbhoamhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkamcefhmaHcefgHad6hsaHad9hmbkaChlxikcbhocehsinaral9Rax6mdalTmealaxfhlaocefgoad6hsadao9hmbkaChlxdkcbhlasceGTmekc9:hoxikabaqad2fawcjdfakad2z1jjjb8Aawawcjdfakcufad2fadz1jjjb8Aakaqfhqalmbkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;ebf8Kjjjjbaok;yzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecjez:jjjjb8AavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:Lvoeue99dud99eud99dndnadcl9hmbaeTmeindndnabcdfgd8Sbb:Yab8Sbbgi:Ygl:l:tabcefgv8Sbbgo:Ygr:l:tgwJbb;:9cawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai86bbdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad86bbdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad86bbabclfhbaecufgembxdkkaeTmbindndnabclfgd8Ueb:Yab8Uebgi:Ygl:l:tabcdfgv8Uebgo:Ygr:l:tgwJb;:FSawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai87ebdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad87ebdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad87ebabcwfhbaecufgembkkk;siliui99iue99dnaeTmbcbhiabhlindndnJ;Zl81Zalcof8UebgvciV:Y:vgoal8Ueb:YNgrJb;:FSNJbbbZJbbb:;arJbbbb9GEMgw:lJbbb9p9DTmbaw:OhDxekcjjjj94hDkalclf8Uebhqalcdf8UebhkabavcefciGaiVcetfaD87ebdndnaoak:YNgwJb;:FSNJbbbZJbbb:;awJbbbb9GEMgx:lJbbb9p9DTmbax:Ohkxekcjjjj94hkkabavcdfciGaiVcetfak87ebdndnaoaq:YNgoJb;:FSNJbbbZJbbb:;aoJbbbb9GEMgx:lJbbb9p9DTmbax:Ohqxekcjjjj94hqkabavcufciGaiVcetfaq87ebdndnJbbjZararN:tawawN:taoaoN:tgrJbbbbarJbbbb9GE:rJb;:FSNJbbbZMgr:lJbbb9p9DTmbar:Ohqxekcjjjj94hqkabavciGaiVcetfaq87ebalcwfhlaiclfhiaecufgembkkk9mbdnadcd4ae2geTmbinababydbgdcwtcw91:Yadce91cjjj;8ifcjjj98G::NUdbabclfhbaecufgembkkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaik;LeeeudndnaeabVciGTmbabhixekdndnadcz9pmbabhixekabhiinaiaeydbBdbaiclfaeclfydbBdbaicwfaecwfydbBdbaicxfaecxfydbBdbaiczfhiaeczfheadc9Wfgdcs0mbkkadcl6mbinaiaeydbBdbaeclfheaiclfhiadc98fgdci0mbkkdnadTmbinaiaeRbb86bbaicefhiaecefheadcufgdmbkkabk;aeedudndnabciGTmbabhixekaecFeGc:b:c:ew2hldndnadcz9pmbabhixekabhiinaialBdbaicxfalBdbaicwfalBdbaiclfalBdbaiczfhiadc9Wfgdcs0mbkkadcl6mbinaialBdbaiclfhiadc98fgdci0mbkkdnadTmbinaiae86bbaicefhiadcufgdmbkkabkkkebcjwklz9Kbb",
          r = WebAssembly.instantiate(s(i), {}).then(function (e) {
            (n = e.instance).exports.__wasm_call_ctors();
          });
        function s(e) {
          for (var n = new Uint8Array(e.length), i = 0; i < e.length; ++i) {
            var r = e.charCodeAt(i);
            n[i] = r > 96 ? r - 97 : r > 64 ? r - 39 : r + 4;
          }
          var s = 0;
          for (i = 0; i < e.length; ++i)
            n[s++] = n[i] < 60 ? t[n[i]] : 64 * (n[i] - 60) + n[++i];
          return n.buffer.slice(0, s);
        }
        function a(e, t, i, r, s, a) {
          var o = n.exports.sbrk,
            c = (i + 3) & -4,
            l = o(c * r),
            u = o(s.length),
            h = new Uint8Array(n.exports.memory.buffer);
          h.set(s, u);
          var d = e(l, i, r, u, s.length);
          if (
            (0 == d && a && a(l, c, r),
            t.set(h.subarray(l, l + i * r)),
            o(l - o(0)),
            0 != d)
          )
            throw new Error("Malformed buffer data: " + d);
        }
        var o = {
            NONE: "",
            OCTAHEDRAL: "meshopt_decodeFilterOct",
            QUATERNION: "meshopt_decodeFilterQuat",
            EXPONENTIAL: "meshopt_decodeFilterExp",
          },
          c = {
            ATTRIBUTES: "meshopt_decodeVertexBuffer",
            TRIANGLES: "meshopt_decodeIndexBuffer",
            INDICES: "meshopt_decodeIndexSequence",
          },
          l = [],
          u = 0;
        function h(e) {
          var t = { object: new Worker(e), pending: 0, requests: {} };
          return (
            (t.object.onmessage = function (e) {
              var n = e.data;
              (t.pending -= n.count),
                t.requests[n.id][n.action](n.value),
                delete t.requests[n.id];
            }),
            t
          );
        }
        function d(e) {
          for (
            var t =
                "var instance; var ready = WebAssembly.instantiate(new Uint8Array([" +
                new Uint8Array(s(i)) +
                "]), {}).then(function(result) { instance = result.instance; instance.exports.__wasm_call_ctors(); });self.onmessage = workerProcess;" +
                a.toString() +
                p.toString(),
              n = new Blob([t], { type: "text/javascript" }),
              r = URL.createObjectURL(n),
              o = 0;
            o < e;
            ++o
          )
            l[o] = h(r);
          URL.revokeObjectURL(r);
        }
        function p(e) {
          r.then(function () {
            var t = e.data;
            try {
              var i = new Uint8Array(t.count * t.size);
              a(
                n.exports[t.mode],
                i,
                t.count,
                t.size,
                t.source,
                n.exports[t.filter]
              ),
                self.postMessage(
                  { id: t.id, count: t.count, action: "resolve", value: i },
                  [i.buffer]
                );
            } catch (e) {
              self.postMessage({
                id: t.id,
                count: t.count,
                action: "reject",
                value: e,
              });
            }
          });
        }
        return {
          ready: r,
          supported: !0,
          useWorkers: function (e) {
            d(e);
          },
          decodeVertexBuffer: function (e, t, i, r, s) {
            a(
              n.exports.meshopt_decodeVertexBuffer,
              e,
              t,
              i,
              r,
              n.exports[o[s]]
            );
          },
          decodeIndexBuffer: function (e, t, i, r) {
            a(n.exports.meshopt_decodeIndexBuffer, e, t, i, r);
          },
          decodeIndexSequence: function (e, t, i, r) {
            a(n.exports.meshopt_decodeIndexSequence, e, t, i, r);
          },
          decodeGltfBuffer: function (e, t, i, r, s, l) {
            a(n.exports[c[s]], e, t, i, r, n.exports[o[l]]);
          },
          decodeGltfBufferAsync: function (e, t, i, s, h) {
            return l.length > 0
              ? (function (e, t, n, i, r) {
                  for (var s = l[0], a = 1; a < l.length; ++a)
                    l[a].pending < s.pending && (s = l[a]);
                  return new Promise(function (a, o) {
                    var c = new Uint8Array(n),
                      l = u++;
                    (s.pending += e),
                      (s.requests[l] = { resolve: a, reject: o }),
                      s.object.postMessage(
                        {
                          id: l,
                          count: e,
                          size: t,
                          source: c,
                          mode: i,
                          filter: r,
                        },
                        [c.buffer]
                      );
                  });
                })(e, t, i, c[s], o[h])
              : r.then(function () {
                  var r = new Uint8Array(e * t);
                  return a(n.exports[c[s]], r, e, t, i, n.exports[o[h]]), r;
                });
          },
        };
      })();
      class jw extends _d {
        loadAsync() {
          return Promise.resolve();
        }
        load() {}
      }
      var Ww = 0.001,
        Xw = class {
          constructor() {
            (this.startTime = performance.now()),
              (this.previousTime = 0),
              (this.currentTime = 0),
              (this._delta = 0),
              (this._elapsed = 0),
              (this._fixedDelta = 1e3 / 60),
              (this.timescale = 1),
              (this.useFixedDelta = !1),
              (this._autoReset = !1);
          }
          get autoReset() {
            return this._autoReset;
          }
          set autoReset(e) {
            "undefined" != typeof document &&
              void 0 !== document.hidden &&
              (e
                ? document.addEventListener("visibilitychange", this)
                : document.removeEventListener("visibilitychange", this),
              (this._autoReset = e));
          }
          get delta() {
            return this._delta * Ww;
          }
          get fixedDelta() {
            return this._fixedDelta * Ww;
          }
          set fixedDelta(e) {
            this._fixedDelta = 1e3 * e;
          }
          get elapsed() {
            return this._elapsed * Ww;
          }
          update(e) {
            this.useFixedDelta
              ? (this._delta = this.fixedDelta)
              : ((this.previousTime = this.currentTime),
                (this.currentTime =
                  (void 0 !== e ? e : performance.now()) - this.startTime),
                (this._delta = this.currentTime - this.previousTime)),
              (this._delta *= this.timescale),
              (this._elapsed += this._delta);
          }
          reset() {
            (this._delta = 0),
              (this._elapsed = 0),
              (this.currentTime = performance.now() - this.startTime);
          }
          getDelta() {
            return this.delta;
          }
          getElapsed() {
            return this.elapsed;
          }
          handleEvent(e) {
            document.hidden ||
              (this.currentTime = performance.now() - this.startTime);
          }
          dispose() {
            this.autoReset = !1;
          }
        },
        qw = (() => {
          const e = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]),
            t = new Float32Array([0, 0, 2, 0, 0, 2]),
            n = new Qa();
          return (
            n.setAttribute("position", new Ta(e, 3)),
            n.setAttribute("uv", new Ta(t, 2)),
            n
          );
        })(),
        Yw = class e {
          static get fullscreenGeometry() {
            return qw;
          }
          constructor(e = "Pass", t = new mu(), n = new ao()) {
            (this.name = e),
              (this.renderer = null),
              (this.scene = t),
              (this.camera = n),
              (this.screen = null),
              (this.rtt = !0),
              (this.needsSwap = !0),
              (this.needsDepthTexture = !1),
              (this.enabled = !0);
          }
          get renderToScreen() {
            return !this.rtt;
          }
          set renderToScreen(e) {
            if (this.rtt === e) {
              const t = this.fullscreenMaterial;
              null !== t && (t.needsUpdate = !0), (this.rtt = !e);
            }
          }
          set mainScene(e) {}
          set mainCamera(e) {}
          setRenderer(e) {
            this.renderer = e;
          }
          isEnabled() {
            return this.enabled;
          }
          setEnabled(e) {
            this.enabled = e;
          }
          get fullscreenMaterial() {
            return null !== this.screen ? this.screen.material : null;
          }
          set fullscreenMaterial(t) {
            let n = this.screen;
            null !== n
              ? (n.material = t)
              : ((n = new Za(e.fullscreenGeometry, t)),
                (n.frustumCulled = !1),
                null === this.scene && (this.scene = new mu()),
                this.scene.add(n),
                (this.screen = n));
          }
          getFullscreenMaterial() {
            return this.fullscreenMaterial;
          }
          setFullscreenMaterial(e) {
            this.fullscreenMaterial = e;
          }
          getDepthTexture() {
            return null;
          }
          setDepthTexture(e, t = 3200) {}
          render(e, t, n, i, r) {
            throw new Error("Render method not implemented!");
          }
          setSize(e, t) {}
          initialize(e, t, n) {}
          dispose() {
            for (const t of Object.keys(this)) {
              const n = this[t];
              (n instanceof jr ||
                n instanceof ba ||
                n instanceof Hr ||
                n instanceof e) &&
                this[t].dispose();
            }
            null !== this.fullscreenMaterial &&
              this.fullscreenMaterial.dispose();
          }
        },
        Kw = class extends Yw {
          constructor() {
            super("ClearMaskPass", null, null), (this.needsSwap = !1);
          }
          render(e, t, n, i, r) {
            const s = e.state.buffers.stencil;
            s.setLocked(!1), s.setTest(!1);
          }
        },
        Jw =
          "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}",
        Zw = class extends so {
          constructor() {
            super({
              name: "CopyMaterial",
              uniforms: { inputBuffer: new rp(null), opacity: new rp(1) },
              blending: 0,
              toneMapped: !1,
              depthWrite: !1,
              depthTest: !1,
              fragmentShader:
                "#include <common>\n#include <dithering_pars_fragment>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;\n#include <colorspace_fragment>\n#include <dithering_fragment>\n}",
              vertexShader: Jw,
            });
          }
          set inputBuffer(e) {
            this.uniforms.inputBuffer.value = e;
          }
          setInputBuffer(e) {
            this.uniforms.inputBuffer.value = e;
          }
          getOpacity(e) {
            return this.uniforms.opacity.value;
          }
          setOpacity(e) {
            this.uniforms.opacity.value = e;
          }
        },
        $w = class extends Yw {
          constructor(e, t = !0) {
            super("CopyPass"),
              (this.fullscreenMaterial = new Zw()),
              (this.needsSwap = !1),
              (this.renderTarget = e),
              void 0 === e &&
                ((this.renderTarget = new jr(1, 1, {
                  minFilter: Un,
                  magFilter: Un,
                  stencilBuffer: !1,
                  depthBuffer: !1,
                })),
                (this.renderTarget.texture.name = "CopyPass.Target")),
              (this.autoResize = t);
          }
          get resize() {
            return this.autoResize;
          }
          set resize(e) {
            this.autoResize = e;
          }
          get texture() {
            return this.renderTarget.texture;
          }
          getTexture() {
            return this.renderTarget.texture;
          }
          setAutoResizeEnabled(e) {
            this.autoResize = e;
          }
          render(e, t, n, i, r) {
            (this.fullscreenMaterial.inputBuffer = t.texture),
              e.setRenderTarget(this.renderToScreen ? null : this.renderTarget),
              e.render(this.scene, this.camera);
          }
          setSize(e, t) {
            this.autoResize && this.renderTarget.setSize(e, t);
          }
          initialize(e, t, n) {
            void 0 !== n &&
              ((this.renderTarget.texture.type = n),
              n !== Nn
                ? (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH =
                    "1")
                : null !== e &&
                  e.outputColorSpace === Zi &&
                  (this.renderTarget.texture.colorSpace = Zi));
          }
        },
        eC = new ma(),
        tC = class extends Yw {
          constructor(e = !0, t = !0, n = !1) {
            super("ClearPass", null, null),
              (this.needsSwap = !1),
              (this.color = e),
              (this.depth = t),
              (this.stencil = n),
              (this.overrideClearColor = null),
              (this.overrideClearAlpha = -1);
          }
          setClearFlags(e, t, n) {
            (this.color = e), (this.depth = t), (this.stencil = n);
          }
          getOverrideClearColor() {
            return this.overrideClearColor;
          }
          setOverrideClearColor(e) {
            this.overrideClearColor = e;
          }
          getOverrideClearAlpha() {
            return this.overrideClearAlpha;
          }
          setOverrideClearAlpha(e) {
            this.overrideClearAlpha = e;
          }
          render(e, t, n, i, r) {
            const s = this.overrideClearColor,
              a = this.overrideClearAlpha,
              o = e.getClearAlpha(),
              c = null !== s,
              l = a >= 0;
            c
              ? (e.getClearColor(eC), e.setClearColor(s, l ? a : o))
              : l && e.setClearAlpha(a),
              e.setRenderTarget(this.renderToScreen ? null : t),
              e.clear(this.color, this.depth, this.stencil),
              c ? e.setClearColor(eC, o) : l && e.setClearAlpha(o);
          }
        },
        nC = class extends Yw {
          constructor(e, t) {
            super("MaskPass", e, t),
              (this.needsSwap = !1),
              (this.clearPass = new tC(!1, !1, !0)),
              (this.inverse = !1);
          }
          set mainScene(e) {
            this.scene = e;
          }
          set mainCamera(e) {
            this.camera = e;
          }
          get inverted() {
            return this.inverse;
          }
          set inverted(e) {
            this.inverse = e;
          }
          get clear() {
            return this.clearPass.enabled;
          }
          set clear(e) {
            this.clearPass.enabled = e;
          }
          getClearPass() {
            return this.clearPass;
          }
          isInverted() {
            return this.inverted;
          }
          setInverted(e) {
            this.inverted = e;
          }
          render(e, t, n, i, r) {
            const s = e.getContext(),
              a = e.state.buffers,
              o = this.scene,
              c = this.camera,
              l = this.clearPass,
              u = this.inverted ? 0 : 1,
              h = 1 - u;
            a.color.setMask(!1),
              a.depth.setMask(!1),
              a.color.setLocked(!0),
              a.depth.setLocked(!0),
              a.stencil.setTest(!0),
              a.stencil.setOp(s.REPLACE, s.REPLACE, s.REPLACE),
              a.stencil.setFunc(s.ALWAYS, u, 4294967295),
              a.stencil.setClear(h),
              a.stencil.setLocked(!0),
              this.clearPass.enabled &&
                (this.renderToScreen
                  ? l.render(e, null)
                  : (l.render(e, t), l.render(e, n))),
              this.renderToScreen
                ? (e.setRenderTarget(null), e.render(o, c))
                : (e.setRenderTarget(t),
                  e.render(o, c),
                  e.setRenderTarget(n),
                  e.render(o, c)),
              a.color.setLocked(!1),
              a.depth.setLocked(!1),
              a.stencil.setLocked(!1),
              a.stencil.setFunc(s.EQUAL, 1, 4294967295),
              a.stencil.setOp(s.KEEP, s.KEEP, s.KEEP),
              a.stencil.setLocked(!0);
          }
        },
        iC = class {
          constructor(
            e = null,
            {
              depthBuffer: t = !0,
              stencilBuffer: n = !1,
              multisampling: i = 0,
              frameBufferType: r,
            } = {}
          ) {
            (this.renderer = null),
              (this.inputBuffer = this.createBuffer(t, n, r, i)),
              (this.outputBuffer = this.inputBuffer.clone()),
              (this.copyPass = new $w()),
              (this.depthTexture = null),
              (this.passes = []),
              (this.timer = new Xw()),
              (this.autoRenderToScreen = !0),
              this.setRenderer(e);
          }
          get multisampling() {
            return this.inputBuffer.samples || 0;
          }
          set multisampling(e) {
            const t = this.inputBuffer,
              n = this.multisampling;
            n > 0 && e > 0
              ? ((this.inputBuffer.samples = e),
                (this.outputBuffer.samples = e),
                this.inputBuffer.dispose(),
                this.outputBuffer.dispose())
              : n !== e &&
                (this.inputBuffer.dispose(),
                this.outputBuffer.dispose(),
                (this.inputBuffer = this.createBuffer(
                  t.depthBuffer,
                  t.stencilBuffer,
                  t.texture.type,
                  e
                )),
                (this.inputBuffer.depthTexture = this.depthTexture),
                (this.outputBuffer = this.inputBuffer.clone()));
          }
          getTimer() {
            return this.timer;
          }
          getRenderer() {
            return this.renderer;
          }
          setRenderer(e) {
            if (((this.renderer = e), null !== e)) {
              const t = e.getSize(new br()),
                n = e.getContext().getContextAttributes().alpha,
                i = this.inputBuffer.texture.type;
              i === Nn &&
                e.outputColorSpace === Zi &&
                ((this.inputBuffer.texture.colorSpace = Zi),
                (this.outputBuffer.texture.colorSpace = Zi),
                this.inputBuffer.dispose(),
                this.outputBuffer.dispose()),
                (e.autoClear = !1),
                this.setSize(t.width, t.height);
              for (const t of this.passes) t.initialize(e, n, i);
            }
          }
          replaceRenderer(e, t = !0) {
            const n = this.renderer,
              i = n.domElement.parentNode;
            return (
              this.setRenderer(e),
              t &&
                null !== i &&
                (i.removeChild(n.domElement), i.appendChild(e.domElement)),
              n
            );
          }
          createDepthTexture() {
            const e = (this.depthTexture = new lc());
            return (
              (this.inputBuffer.depthTexture = e),
              this.inputBuffer.dispose(),
              this.inputBuffer.stencilBuffer
                ? ((e.format = ni), (e.type = qn))
                : (e.type = zn),
              e
            );
          }
          deleteDepthTexture() {
            if (null !== this.depthTexture) {
              this.depthTexture.dispose(),
                (this.depthTexture = null),
                (this.inputBuffer.depthTexture = null),
                this.inputBuffer.dispose();
              for (const e of this.passes) e.setDepthTexture(null);
            }
          }
          createBuffer(e, t, n, i) {
            const r = this.renderer,
              s = null === r ? new br() : r.getDrawingBufferSize(new br()),
              a = {
                minFilter: Un,
                magFilter: Un,
                stencilBuffer: t,
                depthBuffer: e,
                type: n,
              },
              o = new jr(s.width, s.height, a);
            return (
              i > 0 &&
                ((o.ignoreDepthForMultisampleCopy = !1), (o.samples = i)),
              n === Nn &&
                null !== r &&
                r.outputColorSpace === Zi &&
                (o.texture.colorSpace = Zi),
              (o.texture.name = "EffectComposer.Buffer"),
              (o.texture.generateMipmaps = !1),
              o
            );
          }
          setMainScene(e) {
            for (const t of this.passes) t.mainScene = e;
          }
          setMainCamera(e) {
            for (const t of this.passes) t.mainCamera = e;
          }
          addPass(e, t) {
            const n = this.passes,
              i = this.renderer,
              r = i.getDrawingBufferSize(new br()),
              s = i.getContext().getContextAttributes().alpha,
              a = this.inputBuffer.texture.type;
            if (
              (e.setRenderer(i),
              e.setSize(r.width, r.height),
              e.initialize(i, s, a),
              this.autoRenderToScreen &&
                (n.length > 0 && (n[n.length - 1].renderToScreen = !1),
                e.renderToScreen && (this.autoRenderToScreen = !1)),
              void 0 !== t ? n.splice(t, 0, e) : n.push(e),
              this.autoRenderToScreen && (n[n.length - 1].renderToScreen = !0),
              e.needsDepthTexture || null !== this.depthTexture)
            )
              if (null === this.depthTexture) {
                const t = this.createDepthTexture();
                for (e of n) e.setDepthTexture(t);
              } else e.setDepthTexture(this.depthTexture);
          }
          removePass(e) {
            const t = this.passes,
              n = t.indexOf(e);
            if (-1 !== n && t.splice(n, 1).length > 0) {
              if (null !== this.depthTexture) {
                const n = (e, t) => e || t.needsDepthTexture;
                t.reduce(n, !1) ||
                  (e.getDepthTexture() === this.depthTexture &&
                    e.setDepthTexture(null),
                  this.deleteDepthTexture());
              }
              this.autoRenderToScreen &&
                n === t.length &&
                ((e.renderToScreen = !1),
                t.length > 0 && (t[t.length - 1].renderToScreen = !0));
            }
          }
          removeAllPasses() {
            const e = this.passes;
            this.deleteDepthTexture(),
              e.length > 0 &&
                (this.autoRenderToScreen &&
                  (e[e.length - 1].renderToScreen = !1),
                (this.passes = []));
          }
          render(e) {
            const t = this.renderer,
              n = this.copyPass;
            let i,
              r,
              s,
              a = this.inputBuffer,
              o = this.outputBuffer,
              c = !1;
            void 0 === e && (this.timer.update(), (e = this.timer.getDelta()));
            for (const l of this.passes)
              l.enabled &&
                (l.render(t, a, o, e, c),
                l.needsSwap &&
                  (c &&
                    ((n.renderToScreen = l.renderToScreen),
                    (i = t.getContext()),
                    (r = t.state.buffers.stencil),
                    r.setFunc(i.NOTEQUAL, 1, 4294967295),
                    n.render(t, a, o, e, c),
                    r.setFunc(i.EQUAL, 1, 4294967295)),
                  (s = a),
                  (a = o),
                  (o = s)),
                l instanceof nC ? (c = !0) : l instanceof Kw && (c = !1));
          }
          setSize(e, t, n) {
            const i = this.renderer,
              r = i.getSize(new br());
            (void 0 !== e && void 0 !== t) || ((e = r.width), (t = r.height)),
              (r.width === e && r.height === t) || i.setSize(e, t, n);
            const s = i.getDrawingBufferSize(new br());
            this.inputBuffer.setSize(s.width, s.height),
              this.outputBuffer.setSize(s.width, s.height);
            for (const e of this.passes) e.setSize(s.width, s.height);
          }
          reset() {
            this.dispose(), (this.autoRenderToScreen = !0);
          }
          dispose() {
            for (const e of this.passes) e.dispose();
            (this.passes = []),
              null !== this.inputBuffer && this.inputBuffer.dispose(),
              null !== this.outputBuffer && this.outputBuffer.dispose(),
              this.deleteDepthTexture(),
              this.copyPass.dispose(),
              this.timer.dispose(),
              Yw.fullscreenGeometry.dispose();
          }
        },
        rC = { NONE: 0, DEPTH: 1, CONVOLUTION: 2 },
        sC = {
          FRAGMENT_HEAD: "FRAGMENT_HEAD",
          FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV",
          FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE",
          VERTEX_HEAD: "VERTEX_HEAD",
          VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT",
        },
        aC = class {
          constructor() {
            (this.shaderParts = new Map([
              [sC.FRAGMENT_HEAD, null],
              [sC.FRAGMENT_MAIN_UV, null],
              [sC.FRAGMENT_MAIN_IMAGE, null],
              [sC.VERTEX_HEAD, null],
              [sC.VERTEX_MAIN_SUPPORT, null],
            ])),
              (this.defines = new Map()),
              (this.uniforms = new Map()),
              (this.blendModes = new Map()),
              (this.extensions = new Set()),
              (this.attributes = rC.NONE),
              (this.varyings = new Set()),
              (this.uvTransformation = !1),
              (this.readDepth = !1),
              (this.colorSpace = $i);
          }
        };
      var oC = !1,
        cC = class {
          constructor(e = null) {
            (this.originalMaterials = new Map()),
              (this.material = null),
              (this.materials = null),
              (this.materialsBackSide = null),
              (this.materialsDoubleSide = null),
              (this.materialsFlatShaded = null),
              (this.materialsFlatShadedBackSide = null),
              (this.materialsFlatShadedDoubleSide = null),
              this.setMaterial(e),
              (this.meshCount = 0),
              (this.replaceMaterial = (e) => {
                if (e.isMesh) {
                  let t;
                  if (e.material.flatShading)
                    switch (e.material.side) {
                      case un:
                        t = this.materialsFlatShadedDoubleSide;
                        break;
                      case ln:
                        t = this.materialsFlatShadedBackSide;
                        break;
                      default:
                        t = this.materialsFlatShaded;
                    }
                  else
                    switch (e.material.side) {
                      case un:
                        t = this.materialsDoubleSide;
                        break;
                      case ln:
                        t = this.materialsBackSide;
                        break;
                      default:
                        t = this.materials;
                    }
                  this.originalMaterials.set(e, e.material),
                    e.isSkinnedMesh
                      ? (e.material = t[2])
                      : e.isInstancedMesh
                      ? (e.material = t[1])
                      : (e.material = t[0]),
                    ++this.meshCount;
                }
              });
          }
          cloneMaterial(e) {
            if (!(e instanceof so)) return e.clone();
            const t = e.uniforms,
              n = new Map();
            for (const e in t) {
              const i = t[e].value;
              i.isRenderTargetTexture && ((t[e].value = null), n.set(e, i));
            }
            const i = e.clone();
            for (const e of n)
              (t[e[0]].value = e[1]), (i.uniforms[e[0]].value = e[1]);
            return i;
          }
          setMaterial(e) {
            if ((this.disposeMaterials(), (this.material = e), null !== e)) {
              const t = (this.materials = [
                this.cloneMaterial(e),
                this.cloneMaterial(e),
                this.cloneMaterial(e),
              ]);
              for (const n of t)
                (n.uniforms = Object.assign({}, e.uniforms)), (n.side = cn);
              (t[2].skinning = !0),
                (this.materialsBackSide = t.map((t) => {
                  const n = this.cloneMaterial(t);
                  return (
                    (n.uniforms = Object.assign({}, e.uniforms)),
                    (n.side = ln),
                    n
                  );
                })),
                (this.materialsDoubleSide = t.map((t) => {
                  const n = this.cloneMaterial(t);
                  return (
                    (n.uniforms = Object.assign({}, e.uniforms)),
                    (n.side = un),
                    n
                  );
                })),
                (this.materialsFlatShaded = t.map((t) => {
                  const n = this.cloneMaterial(t);
                  return (
                    (n.uniforms = Object.assign({}, e.uniforms)),
                    (n.flatShading = !0),
                    n
                  );
                })),
                (this.materialsFlatShadedBackSide = t.map((t) => {
                  const n = this.cloneMaterial(t);
                  return (
                    (n.uniforms = Object.assign({}, e.uniforms)),
                    (n.flatShading = !0),
                    (n.side = ln),
                    n
                  );
                })),
                (this.materialsFlatShadedDoubleSide = t.map((t) => {
                  const n = this.cloneMaterial(t);
                  return (
                    (n.uniforms = Object.assign({}, e.uniforms)),
                    (n.flatShading = !0),
                    (n.side = un),
                    n
                  );
                }));
            }
          }
          render(e, t, n) {
            const i = e.shadowMap.enabled;
            if (((e.shadowMap.enabled = !1), oC)) {
              const i = this.originalMaterials;
              (this.meshCount = 0),
                t.traverse(this.replaceMaterial),
                e.render(t, n);
              for (const e of i) e[0].material = e[1];
              this.meshCount !== i.size && i.clear();
            } else {
              const i = t.overrideMaterial;
              (t.overrideMaterial = this.material),
                e.render(t, n),
                (t.overrideMaterial = i);
            }
            e.shadowMap.enabled = i;
          }
          disposeMaterials() {
            if (null !== this.material) {
              const e = this.materials
                .concat(this.materialsBackSide)
                .concat(this.materialsDoubleSide)
                .concat(this.materialsFlatShaded)
                .concat(this.materialsFlatShadedBackSide)
                .concat(this.materialsFlatShadedDoubleSide);
              for (const t of e) t.dispose();
            }
          }
          dispose() {
            this.originalMaterials.clear(), this.disposeMaterials();
          }
          static get workaroundEnabled() {
            return oC;
          }
          static set workaroundEnabled(e) {
            oC = e;
          }
        },
        lC = -1,
        uC = class extends cr {
          constructor(e, t = -1, n = -1, i = 1) {
            super(),
              (this.resizable = e),
              (this.baseSize = new br(1, 1)),
              (this.preferredSize = new br(t, n)),
              (this.target = this.preferredSize),
              (this.s = i),
              (this.effectiveSize = new br()),
              this.addEventListener("change", () => this.updateEffectiveSize()),
              this.updateEffectiveSize();
          }
          updateEffectiveSize() {
            const e = this.baseSize,
              t = this.preferredSize,
              n = this.effectiveSize,
              i = this.scale;
            t.width !== lC
              ? (n.width = t.width)
              : t.height !== lC
              ? (n.width = Math.round(
                  t.height * (e.width / Math.max(e.height, 1))
                ))
              : (n.width = Math.round(e.width * i)),
              t.height !== lC
                ? (n.height = t.height)
                : t.width !== lC
                ? (n.height = Math.round(
                    t.width / Math.max(e.width / Math.max(e.height, 1), 1)
                  ))
                : (n.height = Math.round(e.height * i));
          }
          get width() {
            return this.effectiveSize.width;
          }
          set width(e) {
            this.preferredWidth = e;
          }
          get height() {
            return this.effectiveSize.height;
          }
          set height(e) {
            this.preferredHeight = e;
          }
          getWidth() {
            return this.width;
          }
          getHeight() {
            return this.height;
          }
          get scale() {
            return this.s;
          }
          set scale(e) {
            this.s !== e &&
              ((this.s = e),
              this.preferredSize.setScalar(lC),
              this.dispatchEvent({ type: "change" }),
              this.resizable.setSize(
                this.baseSize.width,
                this.baseSize.height
              ));
          }
          getScale() {
            return this.scale;
          }
          setScale(e) {
            this.scale = e;
          }
          get baseWidth() {
            return this.baseSize.width;
          }
          set baseWidth(e) {
            this.baseSize.width !== e &&
              ((this.baseSize.width = e),
              this.dispatchEvent({ type: "change" }),
              this.resizable.setSize(
                this.baseSize.width,
                this.baseSize.height
              ));
          }
          getBaseWidth() {
            return this.baseWidth;
          }
          setBaseWidth(e) {
            this.baseWidth = e;
          }
          get baseHeight() {
            return this.baseSize.height;
          }
          set baseHeight(e) {
            this.baseSize.height !== e &&
              ((this.baseSize.height = e),
              this.dispatchEvent({ type: "change" }),
              this.resizable.setSize(
                this.baseSize.width,
                this.baseSize.height
              ));
          }
          getBaseHeight() {
            return this.baseHeight;
          }
          setBaseHeight(e) {
            this.baseHeight = e;
          }
          setBaseSize(e, t) {
            (this.baseSize.width === e && this.baseSize.height === t) ||
              (this.baseSize.set(e, t),
              this.dispatchEvent({ type: "change" }),
              this.resizable.setSize(
                this.baseSize.width,
                this.baseSize.height
              ));
          }
          get preferredWidth() {
            return this.preferredSize.width;
          }
          set preferredWidth(e) {
            this.preferredSize.width !== e &&
              ((this.preferredSize.width = e),
              this.dispatchEvent({ type: "change" }),
              this.resizable.setSize(
                this.baseSize.width,
                this.baseSize.height
              ));
          }
          getPreferredWidth() {
            return this.preferredWidth;
          }
          setPreferredWidth(e) {
            this.preferredWidth = e;
          }
          get preferredHeight() {
            return this.preferredSize.height;
          }
          set preferredHeight(e) {
            this.preferredSize.height !== e &&
              ((this.preferredSize.height = e),
              this.dispatchEvent({ type: "change" }),
              this.resizable.setSize(
                this.baseSize.width,
                this.baseSize.height
              ));
          }
          getPreferredHeight() {
            return this.preferredHeight;
          }
          setPreferredHeight(e) {
            this.preferredHeight = e;
          }
          setPreferredSize(e, t) {
            (this.preferredSize.width === e &&
              this.preferredSize.height === t) ||
              (this.preferredSize.set(e, t),
              this.dispatchEvent({ type: "change" }),
              this.resizable.setSize(
                this.baseSize.width,
                this.baseSize.height
              ));
          }
          copy(e) {
            (this.s = e.scale),
              this.baseSize.set(e.baseWidth, e.baseHeight),
              this.preferredSize.set(e.preferredWidth, e.preferredHeight),
              this.dispatchEvent({ type: "change" }),
              this.resizable.setSize(this.baseSize.width, this.baseSize.height);
          }
          static get AUTO_SIZE() {
            return lC;
          }
        },
        hC = new (class {
          constructor(e = 0) {
            this.nextId = e;
          }
          getNextId() {
            return this.nextId++;
          }
          reset(e = 0) {
            return (this.nextId = e), this;
          }
        })(2),
        dC = class extends Set {
          constructor(e, t = hC.getNextId()) {
            super(),
              (this.exclusive = !1),
              (this._layer = t),
              (this._layer < 1 || this._layer > 31) &&
                (console.warn("Layer out of range, resetting to 2"),
                hC.reset(2),
                (this._layer = hC.getNextId())),
              void 0 !== e && this.set(e);
          }
          get layer() {
            return this._layer;
          }
          set layer(e) {
            const t = this._layer;
            for (const n of this) n.layers.disable(t), n.layers.enable(e);
            this._layer = e;
          }
          getLayer() {
            return this.layer;
          }
          setLayer(e) {
            this.layer = e;
          }
          isExclusive() {
            return this.exclusive;
          }
          setExclusive(e) {
            this.exclusive = e;
          }
          clear() {
            const e = this.layer;
            for (const t of this) t.layers.disable(e);
            return super.clear();
          }
          set(e) {
            this.clear();
            for (const t of e) this.add(t);
            return this;
          }
          indexOf(e) {
            return this.has(e) ? 0 : -1;
          }
          add(e) {
            return (
              this.exclusive
                ? e.layers.set(this.layer)
                : e.layers.enable(this.layer),
              super.add(e)
            );
          }
          delete(e) {
            return this.has(e) && e.layers.disable(this.layer), super.delete(e);
          }
          toggle(e) {
            let t;
            return (
              this.has(e)
                ? (this.delete(e), (t = !1))
                : (this.add(e), (t = !0)),
              t
            );
          }
          setVisible(e) {
            for (const t of this) e ? t.layers.enable(0) : t.layers.disable(0);
            return this;
          }
        },
        pC = 1,
        fC = 9,
        AC = 21,
        gC = 23,
        mC = 24,
        vC = 28,
        yC = 30,
        bC = new Map([
          [
            0,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y,opacity);}",
          ],
          [
            pC,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,min(y.a,opacity));}",
          ],
          [
            2,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y)*0.5,opacity);}",
          ],
          [
            3,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.rg,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",
          ],
          [
            4,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(step(0.0,y)*(1.0-min(vec4(1.0),(1.0-x)/y)),vec4(1.0),step(1.0,x));return mix(x,z,opacity);}",
          ],
          [
            5,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=step(0.0,x)*mix(min(vec4(1.0),x/max(1.0-y,1e-9)),vec4(1.0),step(1.0,y));return mix(x,z,opacity);}",
          ],
          [
            6,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x,y),opacity);}",
          ],
          [
            7,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,abs(x-y),opacity);}",
          ],
          [
            8,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x/max(y,1e-12),opacity);}",
          ],
          [fC, null],
          [
            10,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y-2.0*x*y),opacity);}",
          ],
          [
            11,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 a=min(x,1.0),b=min(y,1.0);vec4 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,y));return mix(x,z,opacity);}",
          ],
          [
            12,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,step(1.0,x+y),opacity);}",
          ],
          [
            13,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.r,xHSL.gb));return vec4(mix(x.rgb,z,opacity),y.a);}",
          ],
          [
            14,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-y,opacity);}",
          ],
          [
            15,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y*(1.0-x),opacity);}",
          ],
          [
            16,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x,y),opacity);}",
          ],
          [
            17,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(y+x-1.0,0.0,1.0),opacity);}",
          ],
          [
            18,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x+y,1.0),opacity);}",
          ],
          [
            19,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(2.0*y+x-1.0,0.0,1.0),opacity);}",
          ],
          [
            20,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.rg,yHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",
          ],
          [
            AC,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x*y,opacity);}",
          ],
          [
            22,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-abs(1.0-x-y),opacity);}",
          ],
          [
            gC,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}",
          ],
          [
            mC,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(2.0*y*x,1.0-2.0*(1.0-y)*(1.0-x),step(0.5,x));return mix(x,z,opacity);}",
          ],
          [
            25,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 z=mix(mix(y2,x,step(0.5*x,y)),max(vec4(0.0),y2-1.0),step(x,(y2-1.0)));return mix(x,z,opacity);}",
          ],
          [
            26,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(min(x*x/max(1.0-y,1e-12),1.0),y,step(1.0,y));return mix(x,z,opacity);}",
          ],
          [
            27,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.r,yHSL.g,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",
          ],
          [
            vC,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y-min(x*y,1.0),opacity);}",
          ],
          [
            29,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 w=step(0.5,y);vec4 z=mix(x-(1.0-y2)*x*(1.0-x),mix(x+(y2-1.0)*(sqrt(x)-x),x+(y2-1.0)*x*((16.0*x-12.0)*x+3.0),w*(1.0-step(0.25,x))),w);return mix(x,z,opacity);}",
          ],
          [
            yC,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}",
          ],
          [
            31,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x+y-1.0,0.0),opacity);}",
          ],
          [
            32,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(max(1.0-min((1.0-x)/(2.0*y),1.0),0.0),min(x/(2.0*(1.0-y)),1.0),step(0.5,y));return mix(x,z,opacity);}",
          ],
        ]),
        _C = class extends cr {
          constructor(e, t = 1) {
            super(), (this._blendFunction = e), (this.opacity = new rp(t));
          }
          getOpacity() {
            return this.opacity.value;
          }
          setOpacity(e) {
            this.opacity.value = e;
          }
          get blendFunction() {
            return this._blendFunction;
          }
          set blendFunction(e) {
            (this._blendFunction = e), this.dispatchEvent({ type: "change" });
          }
          getBlendFunction() {
            return this.blendFunction;
          }
          setBlendFunction(e) {
            this.blendFunction = e;
          }
          getShaderCode() {
            return bC.get(this.blendFunction);
          }
        },
        xC = 2,
        EC = 3,
        wC = [
          new Float32Array([0, 0]),
          new Float32Array([0, 1, 1]),
          new Float32Array([0, 1, 1, 2]),
          new Float32Array([0, 1, 2, 2, 3]),
          new Float32Array([0, 1, 2, 3, 4, 4, 5]),
          new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10]),
        ],
        CC = class extends so {
          constructor(e = new zr()) {
            super({
              name: "KawaseBlurMaterial",
              uniforms: {
                inputBuffer: new rp(null),
                texelSize: new rp(new zr()),
                scale: new rp(1),
                kernel: new rp(0),
              },
              blending: 0,
              toneMapped: !1,
              depthWrite: !1,
              depthTest: !1,
              fragmentShader:
                "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nvarying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;\n#include <colorspace_fragment>\n}",
              vertexShader:
                "uniform vec4 texelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}",
            }),
              this.setTexelSize(e.x, e.y),
              (this.kernelSize = xC);
          }
          set inputBuffer(e) {
            this.uniforms.inputBuffer.value = e;
          }
          setInputBuffer(e) {
            this.inputBuffer = e;
          }
          get kernelSequence() {
            return wC[this.kernelSize];
          }
          get scale() {
            return this.uniforms.scale.value;
          }
          set scale(e) {
            this.uniforms.scale.value = e;
          }
          getScale() {
            return this.uniforms.scale.value;
          }
          setScale(e) {
            this.uniforms.scale.value = e;
          }
          getKernel() {
            return null;
          }
          get kernel() {
            return this.uniforms.kernel.value;
          }
          set kernel(e) {
            this.uniforms.kernel.value = e;
          }
          setKernel(e) {
            this.kernel = e;
          }
          setTexelSize(e, t) {
            this.uniforms.texelSize.value.set(e, t, 0.5 * e, 0.5 * t);
          }
          setSize(e, t) {
            const n = 1 / e,
              i = 1 / t;
            this.uniforms.texelSize.value.set(n, i, 0.5 * n, 0.5 * i);
          }
        },
        SC = class extends Yw {
          constructor({
            kernelSize: e = xC,
            resolutionScale: t = 0.5,
            width: n = uC.AUTO_SIZE,
            height: i = uC.AUTO_SIZE,
            resolutionX: r = n,
            resolutionY: s = i,
          } = {}) {
            super("KawaseBlurPass"),
              (this.renderTargetA = new jr(1, 1, { depthBuffer: !1 })),
              (this.renderTargetA.texture.name = "Blur.Target.A"),
              (this.renderTargetB = this.renderTargetA.clone()),
              (this.renderTargetB.texture.name = "Blur.Target.B");
            const a = (this.resolution = new uC(this, r, s, t));
            a.addEventListener("change", (e) =>
              this.setSize(a.baseWidth, a.baseHeight)
            ),
              (this._blurMaterial = new CC()),
              (this._blurMaterial.kernelSize = e),
              (this.copyMaterial = new Zw());
          }
          getResolution() {
            return this.resolution;
          }
          get blurMaterial() {
            return this._blurMaterial;
          }
          set blurMaterial(e) {
            this._blurMaterial = e;
          }
          get dithering() {
            return this.copyMaterial.dithering;
          }
          set dithering(e) {
            this.copyMaterial.dithering = e;
          }
          get kernelSize() {
            return this.blurMaterial.kernelSize;
          }
          set kernelSize(e) {
            this.blurMaterial.kernelSize = e;
          }
          get width() {
            return this.resolution.width;
          }
          set width(e) {
            this.resolution.preferredWidth = e;
          }
          get height() {
            return this.resolution.height;
          }
          set height(e) {
            this.resolution.preferredHeight = e;
          }
          get scale() {
            return this.blurMaterial.scale;
          }
          set scale(e) {
            this.blurMaterial.scale = e;
          }
          getScale() {
            return this.blurMaterial.scale;
          }
          setScale(e) {
            this.blurMaterial.scale = e;
          }
          getKernelSize() {
            return this.kernelSize;
          }
          setKernelSize(e) {
            this.kernelSize = e;
          }
          getResolutionScale() {
            return this.resolution.scale;
          }
          setResolutionScale(e) {
            this.resolution.scale = e;
          }
          render(e, t, n, i, r) {
            const s = this.scene,
              a = this.camera,
              o = this.renderTargetA,
              c = this.renderTargetB,
              l = this.blurMaterial,
              u = l.kernelSequence;
            let h = t;
            this.fullscreenMaterial = l;
            for (let t = 0, n = u.length; t < n; ++t) {
              const n = 1 & t ? c : o;
              (l.kernel = u[t]),
                (l.inputBuffer = h.texture),
                e.setRenderTarget(n),
                e.render(s, a),
                (h = n);
            }
            (this.fullscreenMaterial = this.copyMaterial),
              (this.copyMaterial.inputBuffer = h.texture),
              e.setRenderTarget(this.renderToScreen ? null : n),
              e.render(s, a);
          }
          setSize(e, t) {
            const n = this.resolution;
            n.setBaseSize(e, t);
            const i = n.width,
              r = n.height;
            this.renderTargetA.setSize(i, r),
              this.renderTargetB.setSize(i, r),
              this.blurMaterial.setSize(e, t);
          }
          initialize(e, t, n) {
            void 0 !== n &&
              ((this.renderTargetA.texture.type = n),
              (this.renderTargetB.texture.type = n),
              n !== Nn
                ? ((this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1"),
                  (this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1"))
                : null !== e &&
                  e.outputColorSpace === Zi &&
                  ((this.renderTargetA.texture.colorSpace = Zi),
                  (this.renderTargetB.texture.colorSpace = Zi)));
          }
          static get AUTO_SIZE() {
            return uC.AUTO_SIZE;
          }
        },
        IC = class extends so {
          constructor(e = !1, t = null) {
            super({
              name: "LuminanceMaterial",
              defines: { THREE_REVISION: rn.replace(/\D+/g, "") },
              uniforms: {
                inputBuffer: new rp(null),
                threshold: new rp(0),
                smoothing: new rp(1),
                range: new rp(null),
              },
              blending: 0,
              toneMapped: !1,
              depthWrite: !1,
              depthTest: !1,
              fragmentShader:
                "#include <common>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#ifdef RANGE\nuniform vec2 range;\n#elif defined(THRESHOLD)\nuniform float threshold;uniform float smoothing;\n#endif\nvarying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);\n#ifdef RANGE\nfloat low=step(range.x,l);float high=step(l,range.y);l*=low*high;\n#elif defined(THRESHOLD)\nl=smoothstep(threshold,threshold+smoothing,l)*l;\n#endif\n#ifdef COLOR\ngl_FragColor=vec4(texel.rgb*clamp(l,0.0,1.0),l);\n#else\ngl_FragColor=vec4(l);\n#endif\n}",
              vertexShader: Jw,
            }),
              (this.colorOutput = e),
              (this.luminanceRange = t);
          }
          set inputBuffer(e) {
            this.uniforms.inputBuffer.value = e;
          }
          setInputBuffer(e) {
            this.uniforms.inputBuffer.value = e;
          }
          get threshold() {
            return this.uniforms.threshold.value;
          }
          set threshold(e) {
            this.smoothing > 0 || e > 0
              ? (this.defines.THRESHOLD = "1")
              : delete this.defines.THRESHOLD,
              (this.uniforms.threshold.value = e);
          }
          getThreshold() {
            return this.threshold;
          }
          setThreshold(e) {
            this.threshold = e;
          }
          get smoothing() {
            return this.uniforms.smoothing.value;
          }
          set smoothing(e) {
            this.threshold > 0 || e > 0
              ? (this.defines.THRESHOLD = "1")
              : delete this.defines.THRESHOLD,
              (this.uniforms.smoothing.value = e);
          }
          getSmoothingFactor() {
            return this.smoothing;
          }
          setSmoothingFactor(e) {
            this.smoothing = e;
          }
          get useThreshold() {
            return this.threshold > 0 || this.smoothing > 0;
          }
          set useThreshold(e) {}
          get colorOutput() {
            return void 0 !== this.defines.COLOR;
          }
          set colorOutput(e) {
            e ? (this.defines.COLOR = "1") : delete this.defines.COLOR,
              (this.needsUpdate = !0);
          }
          isColorOutputEnabled(e) {
            return this.colorOutput;
          }
          setColorOutputEnabled(e) {
            this.colorOutput = e;
          }
          get useRange() {
            return null !== this.luminanceRange;
          }
          set useRange(e) {
            this.luminanceRange = null;
          }
          get luminanceRange() {
            return this.uniforms.range.value;
          }
          set luminanceRange(e) {
            null !== e ? (this.defines.RANGE = "1") : delete this.defines.RANGE,
              (this.uniforms.range.value = e),
              (this.needsUpdate = !0);
          }
          getLuminanceRange() {
            return this.luminanceRange;
          }
          setLuminanceRange(e) {
            this.luminanceRange = e;
          }
        },
        MC = class extends Yw {
          constructor({
            renderTarget: e,
            luminanceRange: t,
            colorOutput: n,
            resolutionScale: i = 1,
            width: r = uC.AUTO_SIZE,
            height: s = uC.AUTO_SIZE,
            resolutionX: a = r,
            resolutionY: o = s,
          } = {}) {
            super("LuminancePass"),
              (this.fullscreenMaterial = new IC(n, t)),
              (this.needsSwap = !1),
              (this.renderTarget = e),
              void 0 === this.renderTarget &&
                ((this.renderTarget = new jr(1, 1, { depthBuffer: !1 })),
                (this.renderTarget.texture.name = "LuminancePass.Target"));
            const c = (this.resolution = new uC(this, a, o, i));
            c.addEventListener("change", (e) =>
              this.setSize(c.baseWidth, c.baseHeight)
            );
          }
          get texture() {
            return this.renderTarget.texture;
          }
          getTexture() {
            return this.renderTarget.texture;
          }
          getResolution() {
            return this.resolution;
          }
          render(e, t, n, i, r) {
            (this.fullscreenMaterial.inputBuffer = t.texture),
              e.setRenderTarget(this.renderToScreen ? null : this.renderTarget),
              e.render(this.scene, this.camera);
          }
          setSize(e, t) {
            const n = this.resolution;
            n.setBaseSize(e, t), this.renderTarget.setSize(n.width, n.height);
          }
          initialize(e, t, n) {
            void 0 !== n &&
              n !== Nn &&
              ((this.renderTarget.texture.type = n),
              (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH =
                "1"));
          }
        },
        TC = class extends so {
          constructor() {
            super({
              name: "DownsamplingMaterial",
              uniforms: {
                inputBuffer: new rp(null),
                texelSize: new rp(new br()),
              },
              blending: 0,
              toneMapped: !1,
              depthWrite: !1,
              depthTest: !1,
              fragmentShader:
                "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#define WEIGHT_INNER 0.125\n#define WEIGHT_OUTER 0.0555555\nvarying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;float clampToBorder(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void main(){vec4 c=vec4(0.0);vec4 w=WEIGHT_INNER*vec4(clampToBorder(vUv00),clampToBorder(vUv01),clampToBorder(vUv02),clampToBorder(vUv03));c+=w.x*texture2D(inputBuffer,vUv00);c+=w.y*texture2D(inputBuffer,vUv01);c+=w.z*texture2D(inputBuffer,vUv02);c+=w.w*texture2D(inputBuffer,vUv03);w=WEIGHT_OUTER*vec4(clampToBorder(vUv04),clampToBorder(vUv05),clampToBorder(vUv06),clampToBorder(vUv07));c+=w.x*texture2D(inputBuffer,vUv04);c+=w.y*texture2D(inputBuffer,vUv05);c+=w.z*texture2D(inputBuffer,vUv06);c+=w.w*texture2D(inputBuffer,vUv07);w=WEIGHT_OUTER*vec4(clampToBorder(vUv08),clampToBorder(vUv09),clampToBorder(vUv10),clampToBorder(vUv11));c+=w.x*texture2D(inputBuffer,vUv08);c+=w.y*texture2D(inputBuffer,vUv09);c+=w.z*texture2D(inputBuffer,vUv10);c+=w.w*texture2D(inputBuffer,vUv11);c+=WEIGHT_OUTER*texture2D(inputBuffer,vUv);gl_FragColor=c;\n#include <colorspace_fragment>\n}",
              vertexShader:
                "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;void main(){vUv=position.xy*0.5+0.5;vUv00=vUv+texelSize*vec2(-1.0,1.0);vUv01=vUv+texelSize*vec2(1.0,1.0);vUv02=vUv+texelSize*vec2(-1.0,-1.0);vUv03=vUv+texelSize*vec2(1.0,-1.0);vUv04=vUv+texelSize*vec2(-2.0,2.0);vUv05=vUv+texelSize*vec2(0.0,2.0);vUv06=vUv+texelSize*vec2(2.0,2.0);vUv07=vUv+texelSize*vec2(-2.0,0.0);vUv08=vUv+texelSize*vec2(2.0,0.0);vUv09=vUv+texelSize*vec2(-2.0,-2.0);vUv10=vUv+texelSize*vec2(0.0,-2.0);vUv11=vUv+texelSize*vec2(2.0,-2.0);gl_Position=vec4(position.xy,1.0,1.0);}",
            });
          }
          set inputBuffer(e) {
            this.uniforms.inputBuffer.value = e;
          }
          setSize(e, t) {
            this.uniforms.texelSize.value.set(1 / e, 1 / t);
          }
        },
        BC = class extends so {
          constructor() {
            super({
              name: "UpsamplingMaterial",
              uniforms: {
                inputBuffer: new rp(null),
                supportBuffer: new rp(null),
                texelSize: new rp(new br()),
                radius: new rp(0.85),
              },
              blending: 0,
              toneMapped: !1,
              depthWrite: !1,
              depthTest: !1,
              fragmentShader:
                "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;uniform mediump sampler2D supportBuffer;\n#else\nuniform lowp sampler2D inputBuffer;uniform lowp sampler2D supportBuffer;\n#endif\nuniform float radius;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vec4 c=vec4(0.0);c+=texture2D(inputBuffer,vUv0)*0.0625;c+=texture2D(inputBuffer,vUv1)*0.125;c+=texture2D(inputBuffer,vUv2)*0.0625;c+=texture2D(inputBuffer,vUv3)*0.125;c+=texture2D(inputBuffer,vUv)*0.25;c+=texture2D(inputBuffer,vUv4)*0.125;c+=texture2D(inputBuffer,vUv5)*0.0625;c+=texture2D(inputBuffer,vUv6)*0.125;c+=texture2D(inputBuffer,vUv7)*0.0625;vec4 baseColor=texture2D(supportBuffer,vUv);gl_FragColor=mix(baseColor,c,radius);\n#include <colorspace_fragment>\n}",
              vertexShader:
                "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,1.0);vUv1=vUv+texelSize*vec2(0.0,1.0);vUv2=vUv+texelSize*vec2(1.0,1.0);vUv3=vUv+texelSize*vec2(-1.0,0.0);vUv4=vUv+texelSize*vec2(1.0,0.0);vUv5=vUv+texelSize*vec2(-1.0,-1.0);vUv6=vUv+texelSize*vec2(0.0,-1.0);vUv7=vUv+texelSize*vec2(1.0,-1.0);gl_Position=vec4(position.xy,1.0,1.0);}",
            });
          }
          set inputBuffer(e) {
            this.uniforms.inputBuffer.value = e;
          }
          set supportBuffer(e) {
            this.uniforms.supportBuffer.value = e;
          }
          get radius() {
            return this.uniforms.radius.value;
          }
          set radius(e) {
            this.uniforms.radius.value = e;
          }
          setSize(e, t) {
            this.uniforms.texelSize.value.set(1 / e, 1 / t);
          }
        },
        RC = class extends Yw {
          constructor() {
            super("MipmapBlurPass"),
              (this.needsSwap = !1),
              (this.renderTarget = new jr(1, 1, { depthBuffer: !1 })),
              (this.renderTarget.texture.name = "Upsampling.Mipmap0"),
              (this.downsamplingMipmaps = []),
              (this.upsamplingMipmaps = []),
              (this.downsamplingMaterial = new TC()),
              (this.upsamplingMaterial = new BC()),
              (this.resolution = new br());
          }
          get texture() {
            return this.renderTarget.texture;
          }
          get levels() {
            return this.downsamplingMipmaps.length;
          }
          set levels(e) {
            if (this.levels !== e) {
              const t = this.renderTarget;
              this.dispose(),
                (this.downsamplingMipmaps = []),
                (this.upsamplingMipmaps = []);
              for (let n = 0; n < e; ++n) {
                const e = t.clone();
                (e.texture.name = "Downsampling.Mipmap" + n),
                  this.downsamplingMipmaps.push(e);
              }
              this.upsamplingMipmaps.push(t);
              for (let n = 1, i = e - 1; n < i; ++n) {
                const e = t.clone();
                (e.texture.name = "Upsampling.Mipmap" + n),
                  this.upsamplingMipmaps.push(e);
              }
              this.setSize(this.resolution.x, this.resolution.y);
            }
          }
          get radius() {
            return this.upsamplingMaterial.radius;
          }
          set radius(e) {
            this.upsamplingMaterial.radius = e;
          }
          render(e, t, n, i, r) {
            const { scene: s, camera: a } = this,
              { downsamplingMaterial: o, upsamplingMaterial: c } = this,
              { downsamplingMipmaps: l, upsamplingMipmaps: u } = this;
            let h = t;
            this.fullscreenMaterial = o;
            for (let t = 0, n = l.length; t < n; ++t) {
              const n = l[t];
              o.setSize(h.width, h.height),
                (o.inputBuffer = h.texture),
                e.setRenderTarget(n),
                e.render(s, a),
                (h = n);
            }
            this.fullscreenMaterial = c;
            for (let t = u.length - 1; t >= 0; --t) {
              const n = u[t];
              c.setSize(h.width, h.height),
                (c.inputBuffer = h.texture),
                (c.supportBuffer = l[t].texture),
                e.setRenderTarget(n),
                e.render(s, a),
                (h = n);
            }
          }
          setSize(e, t) {
            const n = this.resolution;
            n.set(e, t);
            let i = n.width,
              r = n.height;
            for (let e = 0, t = this.downsamplingMipmaps.length; e < t; ++e)
              (i = Math.round(0.5 * i)),
                (r = Math.round(0.5 * r)),
                this.downsamplingMipmaps[e].setSize(i, r),
                e < this.upsamplingMipmaps.length &&
                  this.upsamplingMipmaps[e].setSize(i, r);
          }
          initialize(e, t, n) {
            if (void 0 !== n) {
              const t = this.downsamplingMipmaps.concat(this.upsamplingMipmaps);
              for (const e of t) e.texture.type = n;
              if (n !== Nn)
                (this.downsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH =
                  "1"),
                  (this.upsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH =
                    "1");
              else if (null !== e && e.outputColorSpace === Zi)
                for (const e of t) e.texture.colorSpace = Zi;
            }
          }
          dispose() {
            super.dispose();
            for (const e of this.downsamplingMipmaps.concat(
              this.upsamplingMipmaps
            ))
              e.dispose();
          }
        },
        DC = class extends cr {
          constructor(
            e,
            t,
            {
              attributes: n = rC.NONE,
              blendFunction: i = gC,
              defines: r = new Map(),
              uniforms: s = new Map(),
              extensions: a = null,
              vertexShader: o = null,
            } = {}
          ) {
            super(),
              (this.name = e),
              (this.renderer = null),
              (this.attributes = n),
              (this.fragmentShader = t),
              (this.vertexShader = o),
              (this.defines = r),
              (this.uniforms = s),
              (this.extensions = a),
              (this.blendMode = new _C(i)),
              this.blendMode.addEventListener("change", (e) =>
                this.setChanged()
              ),
              (this._inputColorSpace = $i),
              (this._outputColorSpace = Ji);
          }
          get inputColorSpace() {
            return this._inputColorSpace;
          }
          set inputColorSpace(e) {
            (this._inputColorSpace = e), this.setChanged();
          }
          get outputColorSpace() {
            return this._outputColorSpace;
          }
          set outputColorSpace(e) {
            (this._outputColorSpace = e), this.setChanged();
          }
          set mainScene(e) {}
          set mainCamera(e) {}
          getName() {
            return this.name;
          }
          setRenderer(e) {
            this.renderer = e;
          }
          getDefines() {
            return this.defines;
          }
          getUniforms() {
            return this.uniforms;
          }
          getExtensions() {
            return this.extensions;
          }
          getBlendMode() {
            return this.blendMode;
          }
          getAttributes() {
            return this.attributes;
          }
          setAttributes(e) {
            (this.attributes = e), this.setChanged();
          }
          getFragmentShader() {
            return this.fragmentShader;
          }
          setFragmentShader(e) {
            (this.fragmentShader = e), this.setChanged();
          }
          getVertexShader() {
            return this.vertexShader;
          }
          setVertexShader(e) {
            (this.vertexShader = e), this.setChanged();
          }
          setChanged() {
            this.dispatchEvent({ type: "change" });
          }
          setDepthTexture(e, t = 3200) {}
          update(e, t, n) {}
          setSize(e, t) {}
          initialize(e, t, n) {}
          dispose() {
            for (const e of Object.keys(this)) {
              const t = this[e];
              (t instanceof jr ||
                t instanceof ba ||
                t instanceof Hr ||
                t instanceof Yw) &&
                this[e].dispose();
            }
          }
        },
        PC = class extends DC {
          constructor({
            blendFunction: e = vC,
            luminanceThreshold: t = 0.9,
            luminanceSmoothing: n = 0.025,
            mipmapBlur: i = !1,
            intensity: r = 1,
            radius: s = 0.85,
            levels: a = 8,
            kernelSize: o = EC,
            resolutionScale: c = 0.5,
            width: l = uC.AUTO_SIZE,
            height: u = uC.AUTO_SIZE,
            resolutionX: h = l,
            resolutionY: d = u,
          } = {}) {
            super(
              "BloomEffect",
              "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D map;\n#else\nuniform lowp sampler2D map;\n#endif\nuniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 texel=texture2D(map,uv);outputColor=vec4(texel.rgb*intensity,texel.a);}",
              {
                blendFunction: e,
                uniforms: new Map([
                  ["map", new rp(null)],
                  ["intensity", new rp(r)],
                ]),
              }
            ),
              (this.renderTarget = new jr(1, 1, { depthBuffer: !1 })),
              (this.renderTarget.texture.name = "Bloom.Target"),
              (this.blurPass = new SC({ kernelSize: o })),
              (this.luminancePass = new MC({ colorOutput: !0 })),
              (this.luminanceMaterial.threshold = t),
              (this.luminanceMaterial.smoothing = n),
              (this.mipmapBlurPass = new RC()),
              (this.mipmapBlurPass.enabled = i),
              (this.mipmapBlurPass.radius = s),
              (this.mipmapBlurPass.levels = a),
              (this.uniforms.get("map").value = i
                ? this.mipmapBlurPass.texture
                : this.renderTarget.texture);
            const p = (this.resolution = new uC(this, h, d, c));
            p.addEventListener("change", (e) =>
              this.setSize(p.baseWidth, p.baseHeight)
            );
          }
          get texture() {
            return this.mipmapBlurPass.enabled
              ? this.mipmapBlurPass.texture
              : this.renderTarget.texture;
          }
          getTexture() {
            return this.texture;
          }
          getResolution() {
            return this.resolution;
          }
          getBlurPass() {
            return this.blurPass;
          }
          getLuminancePass() {
            return this.luminancePass;
          }
          get luminanceMaterial() {
            return this.luminancePass.fullscreenMaterial;
          }
          getLuminanceMaterial() {
            return this.luminancePass.fullscreenMaterial;
          }
          get width() {
            return this.resolution.width;
          }
          set width(e) {
            this.resolution.preferredWidth = e;
          }
          get height() {
            return this.resolution.height;
          }
          set height(e) {
            this.resolution.preferredHeight = e;
          }
          get dithering() {
            return this.blurPass.dithering;
          }
          set dithering(e) {
            this.blurPass.dithering = e;
          }
          get kernelSize() {
            return this.blurPass.kernelSize;
          }
          set kernelSize(e) {
            this.blurPass.kernelSize = e;
          }
          get distinction() {
            return console.warn(this.name, "distinction was removed"), 1;
          }
          set distinction(e) {
            console.warn(this.name, "distinction was removed");
          }
          get intensity() {
            return this.uniforms.get("intensity").value;
          }
          set intensity(e) {
            this.uniforms.get("intensity").value = e;
          }
          getIntensity() {
            return this.intensity;
          }
          setIntensity(e) {
            this.intensity = e;
          }
          getResolutionScale() {
            return this.resolution.scale;
          }
          setResolutionScale(e) {
            this.resolution.scale = e;
          }
          update(e, t, n) {
            const i = this.renderTarget,
              r = this.luminancePass;
            r.enabled
              ? (r.render(e, t),
                this.mipmapBlurPass.enabled
                  ? this.mipmapBlurPass.render(e, r.renderTarget)
                  : this.blurPass.render(e, r.renderTarget, i))
              : this.mipmapBlurPass.enabled
              ? this.mipmapBlurPass.render(e, t)
              : this.blurPass.render(e, t, i);
          }
          setSize(e, t) {
            const n = this.resolution;
            n.setBaseSize(e, t),
              this.renderTarget.setSize(n.width, n.height),
              this.blurPass.resolution.copy(n),
              this.luminancePass.setSize(e, t),
              this.mipmapBlurPass.setSize(e, t);
          }
          initialize(e, t, n) {
            this.blurPass.initialize(e, t, n),
              this.luminancePass.initialize(e, t, n),
              this.mipmapBlurPass.initialize(e, t, n),
              void 0 !== n &&
                ((this.renderTarget.texture.type = n),
                null !== e &&
                  e.outputColorSpace === Zi &&
                  (this.renderTarget.texture.colorSpace = Zi));
          }
        },
        LC = class extends DC {
          constructor({
            blendFunction: e = yC,
            brightness: t = 0,
            contrast: n = 0,
          } = {}) {
            super(
              "BrightnessContrastEffect",
              "uniform float brightness;uniform float contrast;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=inputColor.rgb+vec3(brightness-0.5);if(contrast>0.0){color/=vec3(1.0-contrast);}else{color*=vec3(1.0+contrast);}outputColor=vec4(color+vec3(0.5),inputColor.a);}",
              {
                blendFunction: e,
                uniforms: new Map([
                  ["brightness", new rp(t)],
                  ["contrast", new rp(n)],
                ]),
              }
            ),
              (this.inputColorSpace = Zi);
          }
          get brightness() {
            return this.uniforms.get("brightness").value;
          }
          set brightness(e) {
            this.uniforms.get("brightness").value = e;
          }
          getBrightness() {
            return this.brightness;
          }
          setBrightness(e) {
            this.brightness = e;
          }
          get contrast() {
            return this.uniforms.get("contrast").value;
          }
          set contrast(e) {
            this.uniforms.get("contrast").value = e;
          }
          getContrast() {
            return this.contrast;
          }
          setContrast(e) {
            this.contrast = e;
          }
        },
        UC = class extends DC {
          constructor({ blendFunction: e, bits: t = 16 } = {}) {
            super(
              "ColorDepthEffect",
              "uniform float factor;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=vec4(floor(inputColor.rgb*factor+0.5)/factor,inputColor.a);}",
              { blendFunction: e, uniforms: new Map([["factor", new rp(1)]]) }
            ),
              (this.bits = 0),
              (this.bitDepth = t);
          }
          get bitDepth() {
            return this.bits;
          }
          set bitDepth(e) {
            (this.bits = e),
              (this.uniforms.get("factor").value = Math.pow(2, e / 3));
          }
          getBitDepth() {
            return this.bitDepth;
          }
          setBitDepth(e) {
            this.bitDepth = e;
          }
        },
        FC = 0,
        OC = 1,
        NC = 0,
        kC = 3,
        QC = class extends so {
          constructor(e = !1, t = !1) {
            super({
              name: "BokehMaterial",
              defines: { PASS: e ? "2" : "1" },
              uniforms: {
                inputBuffer: new rp(null),
                cocBuffer: new rp(null),
                texelSize: new rp(new br()),
                kernel64: new rp(null),
                kernel16: new rp(null),
                scale: new rp(1),
              },
              blending: 0,
              toneMapped: !1,
              depthWrite: !1,
              depthTest: !1,
              fragmentShader:
                "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#if PASS == 1\nuniform vec4 kernel64[32];\n#else\nuniform vec4 kernel16[8];\n#endif\nuniform lowp sampler2D cocBuffer;uniform vec2 texelSize;uniform float scale;varying vec2 vUv;void main(){\n#ifdef FOREGROUND\nvec2 cocNearFar=texture2D(cocBuffer,vUv).rg*scale;float coc=cocNearFar.x;\n#else\nfloat coc=texture2D(cocBuffer,vUv).g*scale;\n#endif\nif(coc==0.0){gl_FragColor=texture2D(inputBuffer,vUv);}else{\n#ifdef FOREGROUND\nvec2 step=texelSize*max(cocNearFar.x,cocNearFar.y);\n#else\nvec2 step=texelSize*coc;\n#endif\n#if PASS == 1\nvec4 acc=vec4(0.0);for(int i=0;i<32;++i){vec4 kernel=kernel64[i];vec2 uv=step*kernel.xy+vUv;acc+=texture2D(inputBuffer,uv);uv=step*kernel.zw+vUv;acc+=texture2D(inputBuffer,uv);}gl_FragColor=acc/64.0;\n#else\nvec4 maxValue=texture2D(inputBuffer,vUv);for(int i=0;i<8;++i){vec4 kernel=kernel16[i];vec2 uv=step*kernel.xy+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);uv=step*kernel.zw+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);}gl_FragColor=maxValue;\n#endif\n}}",
              vertexShader: Jw,
            }),
              t && (this.defines.FOREGROUND = "1"),
              this.generateKernel();
          }
          set inputBuffer(e) {
            this.uniforms.inputBuffer.value = e;
          }
          setInputBuffer(e) {
            this.uniforms.inputBuffer.value = e;
          }
          set cocBuffer(e) {
            this.uniforms.cocBuffer.value = e;
          }
          setCoCBuffer(e) {
            this.uniforms.cocBuffer.value = e;
          }
          get scale() {
            return this.uniforms.scale.value;
          }
          set scale(e) {
            this.uniforms.scale.value = e;
          }
          getScale(e) {
            return this.scale;
          }
          setScale(e) {
            this.scale = e;
          }
          generateKernel() {
            const e = new Float64Array(128),
              t = new Float64Array(32);
            let n = 0,
              i = 0;
            for (let r = 0, s = Math.sqrt(80); r < 80; ++r) {
              const a = 2.39996323 * r,
                o = Math.sqrt(r) / s,
                c = o * Math.cos(a),
                l = o * Math.sin(a);
              r % 5 == 0
                ? ((t[i++] = c), (t[i++] = l))
                : ((e[n++] = c), (e[n++] = l));
            }
            (this.uniforms.kernel64.value = e),
              (this.uniforms.kernel16.value = t);
          }
          setTexelSize(e, t) {
            this.uniforms.texelSize.value.set(e, t);
          }
          setSize(e, t) {
            this.uniforms.texelSize.value.set(1 / e, 1 / t);
          }
        };
      function GC(e, t, n) {
        return e * (t - n) - t;
      }
      function HC(e, t, n) {
        return Math.min(Math.max((e + t) / (t - n), 0), 1);
      }
      var zC = class extends so {
          constructor(e) {
            super({
              name: "CircleOfConfusionMaterial",
              defines: { DEPTH_PACKING: "0" },
              uniforms: {
                depthBuffer: new rp(null),
                focusDistance: new rp(0),
                focusRange: new rp(0),
                cameraNear: new rp(0.3),
                cameraFar: new rp(1e3),
              },
              blending: 0,
              toneMapped: !1,
              depthWrite: !1,
              depthTest: !1,
              fragmentShader:
                "#include <common>\n#include <packing>\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform float focusDistance;uniform float focusRange;uniform float cameraNear;uniform float cameraFar;varying vec2 vUv;float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nfloat depth=unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nfloat depth=texture2D(depthBuffer,uv).r;\n#endif\n#ifdef LOG_DEPTH\nfloat d=pow(2.0,depth*log2(cameraFar+1.0))-1.0;float a=cameraFar/(cameraFar-cameraNear);float b=cameraFar*cameraNear/(cameraNear-cameraFar);depth=a+b/d;\n#endif\nreturn depth;}void main(){float depth=readDepth(vUv);\n#ifdef PERSPECTIVE_CAMERA\nfloat viewZ=perspectiveDepthToViewZ(depth,cameraNear,cameraFar);float linearDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);\n#else\nfloat linearDepth=depth;\n#endif\nfloat signedDistance=linearDepth-focusDistance;float magnitude=smoothstep(0.0,focusRange,abs(signedDistance));gl_FragColor.rg=magnitude*vec2(step(signedDistance,0.0),step(0.0,signedDistance));}",
              vertexShader: Jw,
            }),
              (this.uniforms.focalLength = this.uniforms.focusRange),
              this.copyCameraSettings(e);
          }
          get near() {
            return this.uniforms.cameraNear.value;
          }
          get far() {
            return this.uniforms.cameraFar.value;
          }
          set depthBuffer(e) {
            this.uniforms.depthBuffer.value = e;
          }
          set depthPacking(e) {
            (this.defines.DEPTH_PACKING = e.toFixed(0)),
              (this.needsUpdate = !0);
          }
          setDepthBuffer(e, t = 3200) {
            (this.depthBuffer = e), (this.depthPacking = t);
          }
          get focusDistance() {
            return this.uniforms.focusDistance.value;
          }
          set focusDistance(e) {
            this.uniforms.focusDistance.value = e;
          }
          get worldFocusDistance() {
            return -GC(this.focusDistance, this.near, this.far);
          }
          set worldFocusDistance(e) {
            this.focusDistance = HC(-e, this.near, this.far);
          }
          getFocusDistance(e) {
            this.uniforms.focusDistance.value = e;
          }
          setFocusDistance(e) {
            this.uniforms.focusDistance.value = e;
          }
          get focalLength() {
            return this.focusRange;
          }
          set focalLength(e) {
            this.focusRange = e;
          }
          get focusRange() {
            return this.uniforms.focusRange.value;
          }
          set focusRange(e) {
            this.uniforms.focusRange.value = e;
          }
          get worldFocusRange() {
            return -GC(this.focusRange, this.near, this.far);
          }
          set worldFocusRange(e) {
            this.focusRange = HC(-e, this.near, this.far);
          }
          getFocalLength(e) {
            return this.focusRange;
          }
          setFocalLength(e) {
            this.focusRange = e;
          }
          adoptCameraSettings(e) {
            this.copyCameraSettings(e);
          }
          copyCameraSettings(e) {
            e &&
              ((this.uniforms.cameraNear.value = e.near),
              (this.uniforms.cameraFar.value = e.far),
              e instanceof uo
                ? (this.defines.PERSPECTIVE_CAMERA = "1")
                : delete this.defines.PERSPECTIVE_CAMERA,
              (this.needsUpdate = !0));
          }
        },
        VC = class extends so {
          constructor(e = null) {
            super({
              name: "MaskMaterial",
              uniforms: {
                maskTexture: new rp(e),
                inputBuffer: new rp(null),
                strength: new rp(1),
              },
              blending: 0,
              toneMapped: !1,
              depthWrite: !1,
              depthTest: !1,
              fragmentShader:
                "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#ifdef MASK_PRECISION_HIGH\nuniform mediump sampler2D maskTexture;\n#else\nuniform lowp sampler2D maskTexture;\n#endif\n#if MASK_FUNCTION != 0\nuniform float strength;\n#endif\nvarying vec2 vUv;void main(){\n#if COLOR_CHANNEL == 0\nfloat mask=texture2D(maskTexture,vUv).r;\n#elif COLOR_CHANNEL == 1\nfloat mask=texture2D(maskTexture,vUv).g;\n#elif COLOR_CHANNEL == 2\nfloat mask=texture2D(maskTexture,vUv).b;\n#else\nfloat mask=texture2D(maskTexture,vUv).a;\n#endif\n#if MASK_FUNCTION == 0\n#ifdef INVERTED\nmask=step(mask,0.0);\n#else\nmask=1.0-step(mask,0.0);\n#endif\n#else\nmask=clamp(mask*strength,0.0,1.0);\n#ifdef INVERTED\nmask=1.0-mask;\n#endif\n#endif\n#if MASK_FUNCTION == 3\nvec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=vec4(mask*texel.rgb,texel.a);\n#elif MASK_FUNCTION == 2\ngl_FragColor=vec4(mask*texture2D(inputBuffer,vUv).rgb,mask);\n#else\ngl_FragColor=mask*texture2D(inputBuffer,vUv);\n#endif\n}",
              vertexShader: Jw,
            }),
              (this.colorChannel = FC),
              (this.maskFunction = NC);
          }
          set inputBuffer(e) {
            this.uniforms.inputBuffer.value = e;
          }
          setInputBuffer(e) {
            this.uniforms.inputBuffer.value = e;
          }
          set maskTexture(e) {
            (this.uniforms.maskTexture.value = e),
              delete this.defines.MASK_PRECISION_HIGH,
              e.type !== Nn && (this.defines.MASK_PRECISION_HIGH = "1"),
              (this.needsUpdate = !0);
          }
          setMaskTexture(e) {
            this.maskTexture = e;
          }
          set colorChannel(e) {
            (this.defines.COLOR_CHANNEL = e.toFixed(0)),
              (this.needsUpdate = !0);
          }
          setColorChannel(e) {
            this.colorChannel = e;
          }
          set maskFunction(e) {
            (this.defines.MASK_FUNCTION = e.toFixed(0)),
              (this.needsUpdate = !0);
          }
          setMaskFunction(e) {
            this.maskFunction = e;
          }
          get inverted() {
            return void 0 !== this.defines.INVERTED;
          }
          set inverted(e) {
            this.inverted && !e
              ? delete this.defines.INVERTED
              : e && (this.defines.INVERTED = "1"),
              (this.needsUpdate = !0);
          }
          isInverted() {
            return this.inverted;
          }
          setInverted(e) {
            this.inverted = e;
          }
          get strength() {
            return this.uniforms.strength.value;
          }
          set strength(e) {
            this.uniforms.strength.value = e;
          }
          getStrength() {
            return this.strength;
          }
          setStrength(e) {
            this.strength = e;
          }
        },
        jC = class extends Yw {
          constructor(e, t = "inputBuffer") {
            super("ShaderPass"),
              (this.fullscreenMaterial = e),
              (this.input = t);
          }
          setInput(e) {
            this.input = e;
          }
          render(e, t, n, i, r) {
            const s = this.fullscreenMaterial.uniforms;
            null !== t &&
              void 0 !== s &&
              void 0 !== s[this.input] &&
              (s[this.input].value = t.texture),
              e.setRenderTarget(this.renderToScreen ? null : n),
              e.render(this.scene, this.camera);
          }
          initialize(e, t, n) {
            void 0 !== n &&
              n !== Nn &&
              (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH =
                "1");
          }
        },
        WC = class extends DC {
          constructor(
            e,
            {
              blendFunction: t,
              worldFocusDistance: n,
              worldFocusRange: i,
              focusDistance: r = 0,
              focalLength: s = 0.1,
              focusRange: a = s,
              bokehScale: o = 1,
              resolutionScale: c = 1,
              width: l = uC.AUTO_SIZE,
              height: u = uC.AUTO_SIZE,
              resolutionX: h = l,
              resolutionY: d = u,
            } = {}
          ) {
            super(
              "DepthOfFieldEffect",
              "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D nearColorBuffer;uniform mediump sampler2D farColorBuffer;\n#else\nuniform lowp sampler2D nearColorBuffer;uniform lowp sampler2D farColorBuffer;\n#endif\nuniform lowp sampler2D nearCoCBuffer;uniform lowp sampler2D farCoCBuffer;uniform float scale;void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){vec4 colorNear=texture2D(nearColorBuffer,uv);vec4 colorFar=texture2D(farColorBuffer,uv);\n#if MASK_FUNCTION == 1\nvec2 cocNearFar=vec2(texture2D(nearCoCBuffer,uv).r,colorFar.a);cocNearFar.x=min(cocNearFar.x*scale,1.0);\n#else\nvec2 cocNearFar=vec2(texture2D(nearCoCBuffer,uv).r,texture2D(farCoCBuffer,uv).g);cocNearFar=min(cocNearFar*scale,1.0);\n#endif\nvec4 result=inputColor*(1.0-cocNearFar.y)+colorFar;result=mix(result,colorNear,cocNearFar.x);outputColor=result;}",
              {
                blendFunction: t,
                attributes: rC.DEPTH,
                uniforms: new Map([
                  ["nearColorBuffer", new rp(null)],
                  ["farColorBuffer", new rp(null)],
                  ["nearCoCBuffer", new rp(null)],
                  ["farCoCBuffer", new rp(null)],
                  ["scale", new rp(1)],
                ]),
              }
            ),
              (this.camera = e),
              (this.renderTarget = new jr(1, 1, { depthBuffer: !1 })),
              (this.renderTarget.texture.name = "DoF.Intermediate"),
              (this.renderTargetMasked = this.renderTarget.clone()),
              (this.renderTargetMasked.texture.name = "DoF.Masked.Far"),
              (this.renderTargetNear = this.renderTarget.clone()),
              (this.renderTargetNear.texture.name = "DoF.Bokeh.Near"),
              (this.uniforms.get("nearColorBuffer").value =
                this.renderTargetNear.texture),
              (this.renderTargetFar = this.renderTarget.clone()),
              (this.renderTargetFar.texture.name = "DoF.Bokeh.Far"),
              (this.uniforms.get("farColorBuffer").value =
                this.renderTargetFar.texture),
              (this.renderTargetCoC = this.renderTarget.clone()),
              (this.renderTargetCoC.texture.name = "DoF.CoC"),
              (this.uniforms.get("farCoCBuffer").value =
                this.renderTargetCoC.texture),
              (this.renderTargetCoCBlurred = this.renderTargetCoC.clone()),
              (this.renderTargetCoCBlurred.texture.name = "DoF.CoC.Blurred"),
              (this.uniforms.get("nearCoCBuffer").value =
                this.renderTargetCoCBlurred.texture),
              (this.cocPass = new jC(new zC(e)));
            const p = this.cocMaterial;
            (p.focusDistance = r),
              (p.focusRange = a),
              void 0 !== n && (p.worldFocusDistance = n),
              void 0 !== i && (p.worldFocusRange = i),
              (this.blurPass = new SC({
                resolutionScale: c,
                resolutionX: h,
                resolutionY: d,
                kernelSize: xC,
              })),
              (this.maskPass = new jC(new VC(this.renderTargetCoC.texture)));
            (this.maskPass.fullscreenMaterial.colorChannel = OC),
              (this.maskFunction = kC),
              (this.bokehNearBasePass = new jC(new QC(!1, !0))),
              (this.bokehNearBasePass.fullscreenMaterial.cocBuffer =
                this.renderTargetCoCBlurred.texture),
              (this.bokehNearFillPass = new jC(new QC(!0, !0))),
              (this.bokehNearFillPass.fullscreenMaterial.cocBuffer =
                this.renderTargetCoCBlurred.texture),
              (this.bokehFarBasePass = new jC(new QC(!1, !1))),
              (this.bokehFarBasePass.fullscreenMaterial.cocBuffer =
                this.renderTargetCoC.texture),
              (this.bokehFarFillPass = new jC(new QC(!0, !1))),
              (this.bokehFarFillPass.fullscreenMaterial.cocBuffer =
                this.renderTargetCoC.texture),
              (this.target = null);
            const f = (this.resolution = new uC(this, h, d, c));
            f.addEventListener("change", (e) =>
              this.setSize(f.baseWidth, f.baseHeight)
            ),
              (this.bokehScale = o);
          }
          set mainCamera(e) {
            (this.camera = e), this.cocMaterial.copyCameraSettings(e);
          }
          get cocTexture() {
            return this.renderTargetCoC.texture;
          }
          get maskFunction() {
            return this.maskPass.fullscreenMaterial.maskFunction;
          }
          set maskFunction(e) {
            this.maskFunction !== e &&
              (this.defines.set("MASK_FUNCTION", e.toFixed(0)),
              (this.maskPass.fullscreenMaterial.maskFunction = e),
              this.setChanged());
          }
          get cocMaterial() {
            return this.cocPass.fullscreenMaterial;
          }
          get circleOfConfusionMaterial() {
            return this.cocMaterial;
          }
          getCircleOfConfusionMaterial() {
            return this.cocMaterial;
          }
          getBlurPass() {
            return this.blurPass;
          }
          getResolution() {
            return this.resolution;
          }
          get bokehScale() {
            return this.uniforms.get("scale").value;
          }
          set bokehScale(e) {
            (this.bokehNearBasePass.fullscreenMaterial.scale = e),
              (this.bokehNearFillPass.fullscreenMaterial.scale = e),
              (this.bokehFarBasePass.fullscreenMaterial.scale = e),
              (this.bokehFarFillPass.fullscreenMaterial.scale = e),
              (this.maskPass.fullscreenMaterial.strength = e),
              (this.uniforms.get("scale").value = e);
          }
          getBokehScale() {
            return this.bokehScale;
          }
          setBokehScale(e) {
            this.bokehScale = e;
          }
          getTarget() {
            return this.target;
          }
          setTarget(e) {
            this.target = e;
          }
          calculateFocusDistance(e) {
            const t = this.camera;
            return HC(-t.position.distanceTo(e), t.near, t.far);
          }
          setDepthTexture(e, t = 3200) {
            (this.cocMaterial.depthBuffer = e),
              (this.cocMaterial.depthPacking = t);
          }
          update(e, t, n) {
            const i = this.renderTarget,
              r = this.renderTargetCoC,
              s = this.renderTargetCoCBlurred,
              a = this.renderTargetMasked;
            if (null !== this.target) {
              const e = this.calculateFocusDistance(this.target);
              this.cocMaterial.focusDistance = e;
            }
            this.cocPass.render(e, null, r),
              this.blurPass.render(e, r, s),
              this.maskPass.render(e, t, a),
              this.bokehFarBasePass.render(e, a, i),
              this.bokehFarFillPass.render(e, i, this.renderTargetFar),
              this.bokehNearBasePass.render(e, t, i),
              this.bokehNearFillPass.render(e, i, this.renderTargetNear);
          }
          setSize(e, t) {
            const n = this.resolution;
            n.setBaseSize(e, t);
            const i = n.width,
              r = n.height;
            this.cocPass.setSize(e, t),
              this.blurPass.setSize(e, t),
              this.maskPass.setSize(e, t),
              this.renderTargetFar.setSize(e, t),
              this.renderTargetCoC.setSize(e, t),
              this.renderTargetMasked.setSize(e, t),
              this.renderTarget.setSize(i, r),
              this.renderTargetNear.setSize(i, r),
              this.renderTargetCoCBlurred.setSize(i, r),
              this.bokehNearBasePass.fullscreenMaterial.setSize(e, t),
              this.bokehNearFillPass.fullscreenMaterial.setSize(e, t),
              this.bokehFarBasePass.fullscreenMaterial.setSize(e, t),
              this.bokehFarFillPass.fullscreenMaterial.setSize(e, t);
          }
          initialize(e, t, n) {
            this.cocPass.initialize(e, t, n),
              this.maskPass.initialize(e, t, n),
              this.bokehNearBasePass.initialize(e, t, n),
              this.bokehNearFillPass.initialize(e, t, n),
              this.bokehFarBasePass.initialize(e, t, n),
              this.bokehFarFillPass.initialize(e, t, n),
              this.blurPass.initialize(e, t, Nn),
              e.capabilities.logarithmicDepthBuffer &&
                (this.cocPass.fullscreenMaterial.defines.LOG_DEPTH = "1"),
              void 0 !== n &&
                ((this.renderTarget.texture.type = n),
                (this.renderTargetNear.texture.type = n),
                (this.renderTargetFar.texture.type = n),
                (this.renderTargetMasked.texture.type = n),
                null !== e &&
                  e.outputColorSpace === Zi &&
                  ((this.renderTarget.texture.colorSpace = Zi),
                  (this.renderTargetNear.texture.colorSpace = Zi),
                  (this.renderTargetFar.texture.colorSpace = Zi),
                  (this.renderTargetMasked.texture.colorSpace = Zi)));
          }
        };
      var XC = class extends Yw {
          constructor(e, t, n = null) {
            super("RenderPass", e, t),
              (this.needsSwap = !1),
              (this.clearPass = new tC()),
              (this.overrideMaterialManager = null === n ? null : new cC(n)),
              (this.ignoreBackground = !1),
              (this.skipShadowMapUpdate = !1),
              (this.selection = null);
          }
          set mainScene(e) {
            this.scene = e;
          }
          set mainCamera(e) {
            this.camera = e;
          }
          get renderToScreen() {
            return super.renderToScreen;
          }
          set renderToScreen(e) {
            (super.renderToScreen = e), (this.clearPass.renderToScreen = e);
          }
          get overrideMaterial() {
            const e = this.overrideMaterialManager;
            return null !== e ? e.material : null;
          }
          set overrideMaterial(e) {
            const t = this.overrideMaterialManager;
            null !== e
              ? null !== t
                ? t.setMaterial(e)
                : (this.overrideMaterialManager = new cC(e))
              : null !== t &&
                (t.dispose(), (this.overrideMaterialManager = null));
          }
          getOverrideMaterial() {
            return this.overrideMaterial;
          }
          setOverrideMaterial(e) {
            this.overrideMaterial = e;
          }
          get clear() {
            return this.clearPass.enabled;
          }
          set clear(e) {
            this.clearPass.enabled = e;
          }
          getSelection() {
            return this.selection;
          }
          setSelection(e) {
            this.selection = e;
          }
          isBackgroundDisabled() {
            return this.ignoreBackground;
          }
          setBackgroundDisabled(e) {
            this.ignoreBackground = e;
          }
          isShadowMapDisabled() {
            return this.skipShadowMapUpdate;
          }
          setShadowMapDisabled(e) {
            this.skipShadowMapUpdate = e;
          }
          getClearPass() {
            return this.clearPass;
          }
          render(e, t, n, i, r) {
            const s = this.scene,
              a = this.camera,
              o = this.selection,
              c = a.layers.mask,
              l = s.background,
              u = e.shadowMap.autoUpdate,
              h = this.renderToScreen ? null : t;
            null !== o && a.layers.set(o.getLayer()),
              this.skipShadowMapUpdate && (e.shadowMap.autoUpdate = !1),
              (this.ignoreBackground ||
                null !== this.clearPass.overrideClearColor) &&
                (s.background = null),
              this.clearPass.enabled && this.clearPass.render(e, t),
              e.setRenderTarget(h),
              null !== this.overrideMaterialManager
                ? this.overrideMaterialManager.render(e, s, a)
                : e.render(s, a),
              (a.layers.mask = c),
              (s.background = l),
              (e.shadowMap.autoUpdate = u);
          }
        },
        qC = class extends DC {
          constructor({
            blendFunction: e = yC,
            hue: t = 0,
            saturation: n = 0,
          } = {}) {
            super(
              "HueSaturationEffect",
              "uniform vec3 hue;uniform float saturation;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,hue.xyz),dot(inputColor.rgb,hue.zxy),dot(inputColor.rgb,hue.yzx));float average=(color.r+color.g+color.b)/3.0;vec3 diff=average-color;if(saturation>0.0){color+=diff*(1.0-1.0/(1.001-saturation));}else{color+=diff*-saturation;}outputColor=vec4(min(color,1.0),inputColor.a);}",
              {
                blendFunction: e,
                uniforms: new Map([
                  ["hue", new rp(new Yr())],
                  ["saturation", new rp(n)],
                ]),
              }
            ),
              (this.hue = t);
          }
          get saturation() {
            return this.uniforms.get("saturation").value;
          }
          set saturation(e) {
            this.uniforms.get("saturation").value = e;
          }
          getSaturation() {
            return this.saturation;
          }
          setSaturation(e) {
            this.saturation = e;
          }
          get hue() {
            const e = this.uniforms.get("hue").value;
            return Math.acos((3 * e.x - 1) / 2);
          }
          set hue(e) {
            const t = Math.sin(e),
              n = Math.cos(e);
            this.uniforms
              .get("hue")
              .value.set(
                (2 * n + 1) / 3,
                (-Math.sqrt(3) * t - n + 1) / 3,
                (Math.sqrt(3) * t - n + 1) / 3
              );
          }
          getHue() {
            return this.hue;
          }
          setHue(e) {
            this.hue = e;
          }
        };
      var YC = 2,
        KC = 0,
        JC = 0,
        ZC = 1,
        $C = 2,
        eS = 3,
        tS = 0,
        nS = 1,
        iS = 2,
        rS = 3,
        sS = 5,
        aS = 5,
        oS = 6,
        cS = 7,
        lS = 8,
        uS = 0,
        hS = 1,
        dS = class extends DC {
          constructor({ blendFunction: e = vC, premultiply: t = !1 } = {}) {
            super(
              "NoiseEffect",
              "void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 noise=vec3(rand(uv*(1.0+time)));\n#ifdef PREMULTIPLY\noutputColor=vec4(min(inputColor.rgb*noise,vec3(1.0)),inputColor.a);\n#else\noutputColor=vec4(noise,inputColor.a);\n#endif\n}",
              { blendFunction: e }
            ),
              (this.premultiply = t);
          }
          get premultiply() {
            return this.defines.has("PREMULTIPLY");
          }
          set premultiply(e) {
            this.premultiply !== e &&
              (e
                ? this.defines.set("PREMULTIPLY", "1")
                : this.defines.delete("PREMULTIPLY"),
              this.setChanged());
          }
          isPremultiplied() {
            return this.premultiply;
          }
          setPremultiplied(e) {
            this.premultiply = e;
          }
        },
        pS = class extends DC {
          constructor(e = 30) {
            super(
              "PixelationEffect",
              "uniform bool active;uniform vec4 d;void mainUv(inout vec2 uv){if(active){uv=d.xy*(floor(uv*d.zw)+0.5);}}",
              {
                uniforms: new Map([
                  ["active", new rp(!1)],
                  ["d", new rp(new zr())],
                ]),
              }
            ),
              (this.resolution = new br()),
              (this._granularity = 0),
              (this.granularity = e);
          }
          get granularity() {
            return this._granularity;
          }
          set granularity(e) {
            let t = Math.floor(e);
            t % 2 > 0 && (t += 1),
              (this._granularity = t),
              (this.uniforms.get("active").value = t > 0),
              this.setSize(this.resolution.width, this.resolution.height);
          }
          getGranularity() {
            return this.granularity;
          }
          setGranularity(e) {
            this.granularity = e;
          }
          setSize(e, t) {
            const n = this.resolution;
            n.set(e, t);
            const i = this.granularity,
              r = i / n.x,
              s = i / n.y;
            this.uniforms.get("d").value.set(r, s, 1 / r, 1 / s);
          }
        },
        fS =
          (Math.PI,
          class extends so {
            constructor(e = new br(), t = YC) {
              super({
                name: "EdgeDetectionMaterial",
                defines: {
                  THREE_REVISION: rn.replace(/\D+/g, ""),
                  LOCAL_CONTRAST_ADAPTATION_FACTOR: "2.0",
                  EDGE_THRESHOLD: "0.1",
                  DEPTH_THRESHOLD: "0.01",
                  PREDICATION_MODE: "0",
                  PREDICATION_THRESHOLD: "0.01",
                  PREDICATION_SCALE: "2.0",
                  PREDICATION_STRENGTH: "1.0",
                  DEPTH_PACKING: "0",
                },
                uniforms: {
                  inputBuffer: new rp(null),
                  depthBuffer: new rp(null),
                  predicationBuffer: new rp(null),
                  texelSize: new rp(e),
                },
                blending: 0,
                toneMapped: !1,
                depthWrite: !1,
                depthTest: !1,
                fragmentShader:
                  "varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\n#if EDGE_DETECTION_MODE != 0\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\n#endif\n#if EDGE_DETECTION_MODE == 1\n#include <common>\n#endif\n#if EDGE_DETECTION_MODE == 0 || PREDICATION_MODE == 1\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}vec3 gatherNeighbors(){float p=readDepth(vUv);float pLeft=readDepth(vUv0);float pTop=readDepth(vUv1);return vec3(p,pLeft,pTop);}\n#elif PREDICATION_MODE == 2\nuniform sampler2D predicationBuffer;vec3 gatherNeighbors(){float p=texture2D(predicationBuffer,vUv).r;float pLeft=texture2D(predicationBuffer,vUv0).r;float pTop=texture2D(predicationBuffer,vUv1).r;return vec3(p,pLeft,pTop);}\n#endif\n#if PREDICATION_MODE != 0\nvec2 calculatePredicatedThreshold(){vec3 neighbours=gatherNeighbors();vec2 delta=abs(neighbours.xx-neighbours.yz);vec2 edges=step(PREDICATION_THRESHOLD,delta);return PREDICATION_SCALE*EDGE_THRESHOLD*(1.0-PREDICATION_STRENGTH*edges);}\n#endif\n#if EDGE_DETECTION_MODE != 0\nuniform sampler2D inputBuffer;\n#endif\nvoid main(){\n#if EDGE_DETECTION_MODE == 0\nconst vec2 threshold=vec2(DEPTH_THRESHOLD);\n#elif PREDICATION_MODE != 0\nvec2 threshold=calculatePredicatedThreshold();\n#else\nconst vec2 threshold=vec2(EDGE_THRESHOLD);\n#endif\n#if EDGE_DETECTION_MODE == 0\nvec3 neighbors=gatherNeighbors();vec2 delta=abs(neighbors.xx-vec2(neighbors.y,neighbors.z));vec2 edges=step(threshold,delta);if(dot(edges,vec2(1.0))==0.0){discard;}gl_FragColor=vec4(edges,0.0,1.0);\n#elif EDGE_DETECTION_MODE == 1\nfloat l=luminance(texture2D(inputBuffer,vUv).rgb);float lLeft=luminance(texture2D(inputBuffer,vUv0).rgb);float lTop=luminance(texture2D(inputBuffer,vUv1).rgb);vec4 delta;delta.xy=abs(l-vec2(lLeft,lTop));vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}float lRight=luminance(texture2D(inputBuffer,vUv2).rgb);float lBottom=luminance(texture2D(inputBuffer,vUv3).rgb);delta.zw=abs(l-vec2(lRight,lBottom));vec2 maxDelta=max(delta.xy,delta.zw);float lLeftLeft=luminance(texture2D(inputBuffer,vUv4).rgb);float lTopTop=luminance(texture2D(inputBuffer,vUv5).rgb);delta.zw=abs(vec2(lLeft,lTop)-vec2(lLeftLeft,lTopTop));maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges.xy*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\n#elif EDGE_DETECTION_MODE == 2\nvec4 delta;vec3 c=texture2D(inputBuffer,vUv).rgb;vec3 cLeft=texture2D(inputBuffer,vUv0).rgb;vec3 t=abs(c-cLeft);delta.x=max(max(t.r,t.g),t.b);vec3 cTop=texture2D(inputBuffer,vUv1).rgb;t=abs(c-cTop);delta.y=max(max(t.r,t.g),t.b);vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}vec3 cRight=texture2D(inputBuffer,vUv2).rgb;t=abs(c-cRight);delta.z=max(max(t.r,t.g),t.b);vec3 cBottom=texture2D(inputBuffer,vUv3).rgb;t=abs(c-cBottom);delta.w=max(max(t.r,t.g),t.b);vec2 maxDelta=max(delta.xy,delta.zw);vec3 cLeftLeft=texture2D(inputBuffer,vUv4).rgb;t=abs(c-cLeftLeft);delta.z=max(max(t.r,t.g),t.b);vec3 cTopTop=texture2D(inputBuffer,vUv5).rgb;t=abs(c-cTopTop);delta.w=max(max(t.r,t.g),t.b);maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\n#endif\n}",
                vertexShader:
                  "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\n#if EDGE_DETECTION_MODE != 0\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\n#endif\nvoid main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,0.0);vUv1=vUv+texelSize*vec2(0.0,-1.0);\n#if EDGE_DETECTION_MODE != 0\nvUv2=vUv+texelSize*vec2(1.0,0.0);vUv3=vUv+texelSize*vec2(0.0,1.0);vUv4=vUv+texelSize*vec2(-2.0,0.0);vUv5=vUv+texelSize*vec2(0.0,-2.0);\n#endif\ngl_Position=vec4(position.xy,1.0,1.0);}",
              }),
                (this.edgeDetectionMode = t);
            }
            set depthBuffer(e) {
              this.uniforms.depthBuffer.value = e;
            }
            set depthPacking(e) {
              (this.defines.DEPTH_PACKING = e.toFixed(0)),
                (this.needsUpdate = !0);
            }
            setDepthBuffer(e, t = 3200) {
              (this.depthBuffer = e), (this.depthPacking = t);
            }
            get edgeDetectionMode() {
              return Number(this.defines.EDGE_DETECTION_MODE);
            }
            set edgeDetectionMode(e) {
              (this.defines.EDGE_DETECTION_MODE = e.toFixed(0)),
                (this.needsUpdate = !0);
            }
            getEdgeDetectionMode() {
              return this.edgeDetectionMode;
            }
            setEdgeDetectionMode(e) {
              this.edgeDetectionMode = e;
            }
            get localContrastAdaptationFactor() {
              return Number(this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR);
            }
            set localContrastAdaptationFactor(e) {
              (this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR = e.toFixed("6")),
                (this.needsUpdate = !0);
            }
            getLocalContrastAdaptationFactor() {
              return this.localContrastAdaptationFactor;
            }
            setLocalContrastAdaptationFactor(e) {
              this.localContrastAdaptationFactor = e;
            }
            get edgeDetectionThreshold() {
              return Number(this.defines.EDGE_THRESHOLD);
            }
            set edgeDetectionThreshold(e) {
              (this.defines.EDGE_THRESHOLD = e.toFixed("6")),
                (this.defines.DEPTH_THRESHOLD = (0.1 * e).toFixed("6")),
                (this.needsUpdate = !0);
            }
            getEdgeDetectionThreshold() {
              return this.edgeDetectionThreshold;
            }
            setEdgeDetectionThreshold(e) {
              this.edgeDetectionThreshold = e;
            }
            get predicationMode() {
              return Number(this.defines.PREDICATION_MODE);
            }
            set predicationMode(e) {
              (this.defines.PREDICATION_MODE = e.toFixed(0)),
                (this.needsUpdate = !0);
            }
            getPredicationMode() {
              return this.predicationMode;
            }
            setPredicationMode(e) {
              this.predicationMode = e;
            }
            set predicationBuffer(e) {
              this.uniforms.predicationBuffer.value = e;
            }
            setPredicationBuffer(e) {
              this.uniforms.predicationBuffer.value = e;
            }
            get predicationThreshold() {
              return Number(this.defines.PREDICATION_THRESHOLD);
            }
            set predicationThreshold(e) {
              (this.defines.PREDICATION_THRESHOLD = e.toFixed("6")),
                (this.needsUpdate = !0);
            }
            getPredicationThreshold() {
              return this.predicationThreshold;
            }
            setPredicationThreshold(e) {
              this.predicationThreshold = e;
            }
            get predicationScale() {
              return Number(this.defines.PREDICATION_SCALE);
            }
            set predicationScale(e) {
              (this.defines.PREDICATION_SCALE = e.toFixed("6")),
                (this.needsUpdate = !0);
            }
            getPredicationScale() {
              return this.predicationScale;
            }
            setPredicationScale(e) {
              this.predicationScale = e;
            }
            get predicationStrength() {
              return Number(this.defines.PREDICATION_STRENGTH);
            }
            set predicationStrength(e) {
              (this.defines.PREDICATION_STRENGTH = e.toFixed("6")),
                (this.needsUpdate = !0);
            }
            getPredicationStrength() {
              return this.predicationStrength;
            }
            setPredicationStrength(e) {
              this.predicationStrength = e;
            }
            setSize(e, t) {
              this.uniforms.texelSize.value.set(1 / e, 1 / t);
            }
          }),
        AS = class extends so {
          constructor(e = new br(), t = new br()) {
            super({
              name: "SMAAWeightsMaterial",
              defines: {
                MAX_SEARCH_STEPS_INT: "16",
                MAX_SEARCH_STEPS_FLOAT: "16.0",
                MAX_SEARCH_STEPS_DIAG_INT: "8",
                MAX_SEARCH_STEPS_DIAG_FLOAT: "8.0",
                CORNER_ROUNDING: "25",
                CORNER_ROUNDING_NORM: "0.25",
                AREATEX_MAX_DISTANCE: "16.0",
                AREATEX_MAX_DISTANCE_DIAG: "20.0",
                AREATEX_PIXEL_SIZE: "(1.0 / vec2(160.0, 560.0))",
                AREATEX_SUBTEX_SIZE: "(1.0 / 7.0)",
                SEARCHTEX_SIZE: "vec2(66.0, 33.0)",
                SEARCHTEX_PACKED_SIZE: "vec2(64.0, 16.0)",
              },
              uniforms: {
                inputBuffer: new rp(null),
                searchTexture: new rp(null),
                areaTexture: new rp(null),
                resolution: new rp(t),
                texelSize: new rp(e),
              },
              blending: 0,
              toneMapped: !1,
              depthWrite: !1,
              depthTest: !1,
              fragmentShader:
                "#define sampleLevelZeroOffset(t, coord, offset) texture2D(t, coord + offset * texelSize)\n#if __VERSION__ < 300\n#define round(v) floor(v + 0.5)\n#endif\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform lowp sampler2D areaTexture;uniform lowp sampler2D searchTexture;uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}vec2 decodeDiagBilinearAccess(in vec2 e){e.r=e.r*abs(5.0*e.r-5.0*0.75);return round(e);}vec4 decodeDiagBilinearAccess(in vec4 e){e.rb=e.rb*abs(5.0*e.rb-5.0*0.75);return round(e);}vec2 searchDiag1(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 searchDiag2(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);coord.x+=0.25*texelSize.x;vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;e=decodeDiagBilinearAccess(e);coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 areaDiag(const in vec2 dist,const in vec2 e,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE_DIAG,AREATEX_MAX_DISTANCE_DIAG)*e+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.x+=0.5;texCoord.y+=AREATEX_SUBTEX_SIZE*offset;return texture2D(areaTexture,texCoord).rg;}vec2 calculateDiagWeights(const in vec2 texCoord,const in vec2 e,const in vec4 subsampleIndices){vec2 weights=vec2(0.0);vec4 d;vec2 end;if(e.r>0.0){d.xz=searchDiag1(texCoord,vec2(-1.0,1.0),end);d.x+=float(end.y>0.9);}else{d.xz=vec2(0.0);}d.yw=searchDiag1(texCoord,vec2(1.0,-1.0),end);if(d.x+d.y>2.0){vec4 coords=vec4(-d.x+0.25,d.x,d.y,-d.y-0.25)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.xy=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).rg;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).rg;c.yxwz=decodeDiagBilinearAccess(c.xyzw);vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.z);}d.xz=searchDiag2(texCoord,vec2(-1.0,-1.0),end);if(sampleLevelZeroOffset(inputBuffer,texCoord,vec2(1,0)).r>0.0){d.yw=searchDiag2(texCoord,vec2(1.0),end);d.y+=float(end.y>0.9);}else{d.yw=vec2(0.0);}if(d.x+d.y>2.0){vec4 coords=vec4(-d.x,-d.x,d.y,d.y)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.x=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).g;c.y=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(0,-1)).r;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).gr;vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.w).gr;}return weights;}float searchLength(const in vec2 e,const in float offset){vec2 scale=SEARCHTEX_SIZE*vec2(0.5,-1.0);vec2 bias=SEARCHTEX_SIZE*vec2(offset,1.0);scale+=vec2(-1.0,1.0);bias+=vec2(0.5,-0.5);scale*=1.0/SEARCHTEX_PACKED_SIZE;bias*=1.0/SEARCHTEX_PACKED_SIZE;return texture2D(searchTexture,scale*e+bias).r;}float searchXLeft(in vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x>end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(-2.0,0.0)*texelSize+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.0)+3.25;return texelSize.x*offset+texCoord.x;}float searchXRight(vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x<end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(2.0,0.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.5)+3.25;return-texelSize.x*offset+texCoord.x;}float searchYUp(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.y>end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=-vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.0)+3.25;return texelSize.y*offset+texCoord.y;}float searchYDown(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;i++){if(!(texCoord.y<end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.5)+3.25;return-texelSize.y*offset+texCoord.y;}vec2 area(const in vec2 dist,const in float e1,const in float e2,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE)*round(4.0*vec2(e1,e2))+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.y=AREATEX_SUBTEX_SIZE*offset+texCoord.y;return texture2D(areaTexture,texCoord).rg;}void detectHorizontalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\n#if !defined(DISABLE_CORNER_DETECTION)\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,1)).r;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).r;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,-2)).r;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,-2)).r;weights*=clamp(factor,0.0,1.0);\n#endif\n}void detectVerticalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\n#if !defined(DISABLE_CORNER_DETECTION)\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(1,0)).g;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).g;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(-2,0)).g;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(-2,1)).g;weights*=clamp(factor,0.0,1.0);\n#endif\n}void main(){vec4 weights=vec4(0.0);vec4 subsampleIndices=vec4(0.0);vec2 e=texture2D(inputBuffer,vUv).rg;if(e.g>0.0){\n#if !defined(DISABLE_DIAG_DETECTION)\nweights.rg=calculateDiagWeights(vUv,e,subsampleIndices);if(weights.r==-weights.g){\n#endif\nvec2 d;vec3 coords;coords.x=searchXLeft(vOffset[0].xy,vOffset[2].x);coords.y=vOffset[1].y;d.x=coords.x;float e1=texture2D(inputBuffer,coords.xy).r;coords.z=searchXRight(vOffset[0].zw,vOffset[2].y);d.y=coords.z;d=round(resolution.xx*d+-vPixCoord.xx);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.zy,vec2(1,0)).r;weights.rg=area(sqrtD,e1,e2,subsampleIndices.y);coords.y=vUv.y;detectHorizontalCornerPattern(weights.rg,coords.xyzy,d);\n#if !defined(DISABLE_DIAG_DETECTION)\n}else{e.r=0.0;}\n#endif\n}if(e.r>0.0){vec2 d;vec3 coords;coords.y=searchYUp(vOffset[1].xy,vOffset[2].z);coords.x=vOffset[0].x;d.x=coords.y;float e1=texture2D(inputBuffer,coords.xy).g;coords.z=searchYDown(vOffset[1].zw,vOffset[2].w);d.y=coords.z;d=round(resolution.yy*d-vPixCoord.yy);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.xz,vec2(0,1)).g;weights.ba=area(sqrtD,e1,e2,subsampleIndices.x);coords.x=vUv.x;detectVerticalCornerPattern(weights.ba,coords.xyxz,d);}gl_FragColor=weights;}",
              vertexShader:
                "uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void main(){vUv=position.xy*0.5+0.5;vPixCoord=vUv*resolution;vOffset[0]=vUv.xyxy+texelSize.xyxy*vec4(-0.25,-0.125,1.25,-0.125);vOffset[1]=vUv.xyxy+texelSize.xyxy*vec4(-0.125,-0.25,-0.125,1.25);vOffset[2]=vec4(vOffset[0].xz,vOffset[1].yw)+vec4(-2.0,2.0,-2.0,2.0)*texelSize.xxyy*MAX_SEARCH_STEPS_FLOAT;gl_Position=vec4(position.xy,1.0,1.0);}",
            });
          }
          set inputBuffer(e) {
            this.uniforms.inputBuffer.value = e;
          }
          setInputBuffer(e) {
            this.uniforms.inputBuffer.value = e;
          }
          get searchTexture() {
            return this.uniforms.searchTexture.value;
          }
          set searchTexture(e) {
            this.uniforms.searchTexture.value = e;
          }
          get areaTexture() {
            return this.uniforms.areaTexture.value;
          }
          set areaTexture(e) {
            this.uniforms.areaTexture.value = e;
          }
          setLookupTextures(e, t) {
            (this.searchTexture = e), (this.areaTexture = t);
          }
          get orthogonalSearchSteps() {
            return Number(this.defines.MAX_SEARCH_STEPS_INT);
          }
          set orthogonalSearchSteps(e) {
            const t = Math.min(Math.max(e, 0), 112);
            (this.defines.MAX_SEARCH_STEPS_INT = t.toFixed("0")),
              (this.defines.MAX_SEARCH_STEPS_FLOAT = t.toFixed("1")),
              (this.needsUpdate = !0);
          }
          setOrthogonalSearchSteps(e) {
            this.orthogonalSearchSteps = e;
          }
          get diagonalSearchSteps() {
            return Number(this.defines.MAX_SEARCH_STEPS_DIAG_INT);
          }
          set diagonalSearchSteps(e) {
            const t = Math.min(Math.max(e, 0), 20);
            (this.defines.MAX_SEARCH_STEPS_DIAG_INT = t.toFixed("0")),
              (this.defines.MAX_SEARCH_STEPS_DIAG_FLOAT = t.toFixed("1")),
              (this.needsUpdate = !0);
          }
          setDiagonalSearchSteps(e) {
            this.diagonalSearchSteps = e;
          }
          get diagonalDetection() {
            return void 0 === this.defines.DISABLE_DIAG_DETECTION;
          }
          set diagonalDetection(e) {
            e
              ? delete this.defines.DISABLE_DIAG_DETECTION
              : (this.defines.DISABLE_DIAG_DETECTION = "1"),
              (this.needsUpdate = !0);
          }
          isDiagonalDetectionEnabled() {
            return this.diagonalDetection;
          }
          setDiagonalDetectionEnabled(e) {
            this.diagonalDetection = e;
          }
          get cornerRounding() {
            return Number(this.defines.CORNER_ROUNDING);
          }
          set cornerRounding(e) {
            const t = Math.min(Math.max(e, 0), 100);
            (this.defines.CORNER_ROUNDING = t.toFixed("4")),
              (this.defines.CORNER_ROUNDING_NORM = (t / 100).toFixed("4")),
              (this.needsUpdate = !0);
          }
          setCornerRounding(e) {
            this.cornerRounding = e;
          }
          get cornerDetection() {
            return void 0 === this.defines.DISABLE_CORNER_DETECTION;
          }
          set cornerDetection(e) {
            e
              ? delete this.defines.DISABLE_CORNER_DETECTION
              : (this.defines.DISABLE_CORNER_DETECTION = "1"),
              (this.needsUpdate = !0);
          }
          isCornerRoundingEnabled() {
            return this.cornerDetection;
          }
          setCornerRoundingEnabled(e) {
            this.cornerDetection = e;
          }
          setSize(e, t) {
            const n = this.uniforms;
            n.texelSize.value.set(1 / e, 1 / t), n.resolution.value.set(e, t);
          }
        },
        gS =
          "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAeElEQVRYR+2XSwqAMAxEJ168ePEqwRSKhIIiuHjJqiU0gWE+1CQdApcVAMUAuARaMGCX1MIL/Ow13++9lW2s3mW9MWvsnWc/2fvGygwPAN4E8QzAA4CXAB6AHjG4JTHYI1ey3pcx6FHnEfhLDOIBKAmUBK6/ANUDTlROXAHd9EC1AAAAAElFTkSuQmCC",
        mS =
          "data:image/png;base64,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",
        vS = class extends DC {
          constructor({
            blendFunction: e = yC,
            preset: t = ZC,
            edgeDetectionMode: n = YC,
            predicationMode: i = KC,
          } = {}) {
            let r, s;
            super(
              "SMAAEffect",
              "uniform sampler2D weightMap;varying vec2 vOffset0;varying vec2 vOffset1;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 a;a.x=texture2D(weightMap,vOffset0).a;a.y=texture2D(weightMap,vOffset1).g;a.wz=texture2D(weightMap,uv).rb;vec4 color=inputColor;if(dot(a,vec4(1.0))>=1e-5){bool h=max(a.x,a.z)>max(a.y,a.w);vec4 blendingOffset=vec4(0.0,a.y,0.0,a.w);vec2 blendingWeight=a.yw;movec(bvec4(h),blendingOffset,vec4(a.x,0.0,a.z,0.0));movec(bvec2(h),blendingWeight,a.xz);blendingWeight/=dot(blendingWeight,vec2(1.0));vec4 blendingCoord=blendingOffset*vec4(texelSize,-texelSize)+uv.xyxy;color=blendingWeight.x*texture2D(inputBuffer,blendingCoord.xy);color+=blendingWeight.y*texture2D(inputBuffer,blendingCoord.zw);}outputColor=color;}",
              {
                vertexShader:
                  "varying vec2 vOffset0;varying vec2 vOffset1;void mainSupport(const in vec2 uv){vOffset0=uv+texelSize*vec2(1.0,0.0);vOffset1=uv+texelSize*vec2(0.0,1.0);}",
                blendFunction: e,
                attributes: rC.CONVOLUTION | rC.DEPTH,
                uniforms: new Map([["weightMap", new rp(null)]]),
              }
            ),
              arguments.length > 1 &&
                ((r = arguments[0]),
                (s = arguments[1]),
                arguments.length > 2 && (t = arguments[2]),
                arguments.length > 3 && (n = arguments[3])),
              (this.renderTargetEdges = new jr(1, 1, { depthBuffer: !1 })),
              (this.renderTargetEdges.texture.name = "SMAA.Edges"),
              (this.renderTargetWeights = this.renderTargetEdges.clone()),
              (this.renderTargetWeights.texture.name = "SMAA.Weights"),
              (this.uniforms.get("weightMap").value =
                this.renderTargetWeights.texture),
              (this.clearPass = new tC(!0, !1, !1)),
              (this.clearPass.overrideClearColor = new ma(0)),
              (this.clearPass.overrideClearAlpha = 1),
              (this.edgeDetectionPass = new jC(new fS())),
              (this.edgeDetectionMaterial.edgeDetectionMode = n),
              (this.edgeDetectionMaterial.predicationMode = i),
              (this.weightsPass = new jC(new AS()));
            const a = new yd();
            (a.onLoad = () => {
              const e = new Hr(r);
              (e.name = "SMAA.Search"),
                (e.magFilter = Dn),
                (e.minFilter = Dn),
                (e.generateMipmaps = !1),
                (e.needsUpdate = !0),
                (e.flipY = !0),
                (this.weightsMaterial.searchTexture = e);
              const t = new Hr(s);
              (t.name = "SMAA.Area"),
                (t.magFilter = Un),
                (t.minFilter = Un),
                (t.generateMipmaps = !1),
                (t.needsUpdate = !0),
                (t.flipY = !1),
                (this.weightsMaterial.areaTexture = t),
                this.dispatchEvent({ type: "load" });
            }),
              a.itemStart("search"),
              a.itemStart("area"),
              void 0 !== r && void 0 !== s
                ? (a.itemEnd("search"), a.itemEnd("area"))
                : "undefined" != typeof Image &&
                  ((r = new Image()),
                  (s = new Image()),
                  r.addEventListener("load", () => a.itemEnd("search")),
                  s.addEventListener("load", () => a.itemEnd("area")),
                  (r.src = gS),
                  (s.src = mS)),
              this.applyPreset(t);
          }
          get edgesTexture() {
            return this.renderTargetEdges.texture;
          }
          getEdgesTexture() {
            return this.edgesTexture;
          }
          get weightsTexture() {
            return this.renderTargetWeights.texture;
          }
          getWeightsTexture() {
            return this.weightsTexture;
          }
          get edgeDetectionMaterial() {
            return this.edgeDetectionPass.fullscreenMaterial;
          }
          get colorEdgesMaterial() {
            return this.edgeDetectionMaterial;
          }
          getEdgeDetectionMaterial() {
            return this.edgeDetectionMaterial;
          }
          get weightsMaterial() {
            return this.weightsPass.fullscreenMaterial;
          }
          getWeightsMaterial() {
            return this.weightsMaterial;
          }
          setEdgeDetectionThreshold(e) {
            this.edgeDetectionMaterial.edgeDetectionThreshold = e;
          }
          setOrthogonalSearchSteps(e) {
            this.weightsMaterial.orthogonalSearchSteps = e;
          }
          applyPreset(e) {
            const t = this.edgeDetectionMaterial,
              n = this.weightsMaterial;
            switch (e) {
              case JC:
                (t.edgeDetectionThreshold = 0.15),
                  (n.orthogonalSearchSteps = 4),
                  (n.diagonalDetection = !1),
                  (n.cornerDetection = !1);
                break;
              case ZC:
                (t.edgeDetectionThreshold = 0.1),
                  (n.orthogonalSearchSteps = 8),
                  (n.diagonalDetection = !1),
                  (n.cornerDetection = !1);
                break;
              case $C:
                (t.edgeDetectionThreshold = 0.1),
                  (n.orthogonalSearchSteps = 16),
                  (n.diagonalSearchSteps = 8),
                  (n.cornerRounding = 25),
                  (n.diagonalDetection = !0),
                  (n.cornerDetection = !0);
                break;
              case eS:
                (t.edgeDetectionThreshold = 0.05),
                  (n.orthogonalSearchSteps = 32),
                  (n.diagonalSearchSteps = 16),
                  (n.cornerRounding = 25),
                  (n.diagonalDetection = !0),
                  (n.cornerDetection = !0);
            }
          }
          setDepthTexture(e, t = 3200) {
            (this.edgeDetectionMaterial.depthBuffer = e),
              (this.edgeDetectionMaterial.depthPacking = t);
          }
          update(e, t, n) {
            this.clearPass.render(e, this.renderTargetEdges),
              this.edgeDetectionPass.render(e, t, this.renderTargetEdges),
              this.weightsPass.render(
                e,
                this.renderTargetEdges,
                this.renderTargetWeights
              );
          }
          setSize(e, t) {
            this.edgeDetectionMaterial.setSize(e, t),
              this.weightsMaterial.setSize(e, t),
              this.renderTargetEdges.setSize(e, t),
              this.renderTargetWeights.setSize(e, t);
          }
          dispose() {
            const { searchTexture: e, areaTexture: t } = this.weightsMaterial;
            null !== e && null !== t && (e.dispose(), t.dispose()),
              super.dispose();
          }
          static get searchImageDataURL() {
            return gS;
          }
          static get areaImageDataURL() {
            return mS;
          }
        },
        yS = class extends so {
          constructor() {
            super({
              name: "AdaptiveLuminanceMaterial",
              defines: { MIP_LEVEL_1X1: "0.0" },
              uniforms: {
                luminanceBuffer0: new rp(null),
                luminanceBuffer1: new rp(null),
                minLuminance: new rp(0.01),
                deltaTime: new rp(0),
                tau: new rp(1),
              },
              extensions: { shaderTextureLOD: !0 },
              blending: 0,
              toneMapped: !1,
              depthWrite: !1,
              depthTest: !1,
              fragmentShader:
                "#include <packing>\n#define packFloatToRGBA(v) packDepthToRGBA(v)\n#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)\nuniform lowp sampler2D luminanceBuffer0;uniform lowp sampler2D luminanceBuffer1;uniform float minLuminance;uniform float deltaTime;uniform float tau;varying vec2 vUv;void main(){float l0=unpackRGBAToFloat(texture2D(luminanceBuffer0,vUv));\n#if __VERSION__ < 300\nfloat l1=texture2DLodEXT(luminanceBuffer1,vUv,MIP_LEVEL_1X1).r;\n#else\nfloat l1=textureLod(luminanceBuffer1,vUv,MIP_LEVEL_1X1).r;\n#endif\nl0=max(minLuminance,l0);l1=max(minLuminance,l1);float adaptedLum=l0+(l1-l0)*(1.0-exp(-deltaTime*tau));gl_FragColor=(adaptedLum==1.0)?vec4(1.0):packFloatToRGBA(adaptedLum);}",
              vertexShader: Jw,
            });
          }
          set luminanceBuffer0(e) {
            this.uniforms.luminanceBuffer0.value = e;
          }
          setLuminanceBuffer0(e) {
            this.uniforms.luminanceBuffer0.value = e;
          }
          set luminanceBuffer1(e) {
            this.uniforms.luminanceBuffer1.value = e;
          }
          setLuminanceBuffer1(e) {
            this.uniforms.luminanceBuffer1.value = e;
          }
          set mipLevel1x1(e) {
            (this.defines.MIP_LEVEL_1X1 = e.toFixed(1)),
              (this.needsUpdate = !0);
          }
          setMipLevel1x1(e) {
            this.mipLevel1x1 = e;
          }
          set deltaTime(e) {
            this.uniforms.deltaTime.value = e;
          }
          setDeltaTime(e) {
            this.uniforms.deltaTime.value = e;
          }
          get minLuminance() {
            return this.uniforms.minLuminance.value;
          }
          set minLuminance(e) {
            this.uniforms.minLuminance.value = e;
          }
          getMinLuminance() {
            return this.uniforms.minLuminance.value;
          }
          setMinLuminance(e) {
            this.uniforms.minLuminance.value = e;
          }
          get adaptationRate() {
            return this.uniforms.tau.value;
          }
          set adaptationRate(e) {
            this.uniforms.tau.value = e;
          }
          getAdaptationRate() {
            return this.uniforms.tau.value;
          }
          setAdaptationRate(e) {
            this.uniforms.tau.value = e;
          }
        },
        bS = class extends Yw {
          constructor(
            e,
            { minLuminance: t = 0.01, adaptationRate: n = 1 } = {}
          ) {
            super("AdaptiveLuminancePass"),
              (this.fullscreenMaterial = new yS()),
              (this.needsSwap = !1),
              (this.renderTargetPrevious = new jr(1, 1, {
                minFilter: Dn,
                magFilter: Dn,
                depthBuffer: !1,
              })),
              (this.renderTargetPrevious.texture.name = "Luminance.Previous");
            const i = this.fullscreenMaterial;
            (i.luminanceBuffer0 = this.renderTargetPrevious.texture),
              (i.luminanceBuffer1 = e),
              (i.minLuminance = t),
              (i.adaptationRate = n),
              (this.renderTargetAdapted = this.renderTargetPrevious.clone()),
              (this.renderTargetAdapted.texture.name = "Luminance.Adapted"),
              (this.copyPass = new $w(this.renderTargetPrevious, !1));
          }
          get texture() {
            return this.renderTargetAdapted.texture;
          }
          getTexture() {
            return this.renderTargetAdapted.texture;
          }
          set mipLevel1x1(e) {
            this.fullscreenMaterial.mipLevel1x1 = e;
          }
          get adaptationRate() {
            return this.fullscreenMaterial.adaptationRate;
          }
          set adaptationRate(e) {
            this.fullscreenMaterial.adaptationRate = e;
          }
          render(e, t, n, i, r) {
            (this.fullscreenMaterial.deltaTime = i),
              e.setRenderTarget(
                this.renderToScreen ? null : this.renderTargetAdapted
              ),
              e.render(this.scene, this.camera),
              this.copyPass.render(e, this.renderTargetAdapted);
          }
        },
        _S = class extends DC {
          constructor({
            blendFunction: e = yC,
            adaptive: t = !1,
            mode: n = t ? rS : cS,
            resolution: i = 256,
            maxLuminance: r = 4,
            whitePoint: s = r,
            middleGrey: a = 0.6,
            minLuminance: o = 0.01,
            averageLuminance: c = 1,
            adaptationRate: l = 1,
          } = {}) {
            super(
              "ToneMappingEffect",
              "#include <tonemapping_pars_fragment>\nuniform float whitePoint;\n#if TONE_MAPPING_MODE == 2 || TONE_MAPPING_MODE == 3\nuniform float middleGrey;\n#if TONE_MAPPING_MODE == 3\nuniform lowp sampler2D luminanceBuffer;\n#else\nuniform float averageLuminance;\n#endif\nvec3 Reinhard2ToneMapping(vec3 color){color*=toneMappingExposure;float l=luminance(color);\n#if TONE_MAPPING_MODE == 3\nfloat lumAvg=unpackRGBAToFloat(texture2D(luminanceBuffer,vec2(0.5)));\n#else\nfloat lumAvg=averageLuminance;\n#endif\nfloat lumScaled=(l*middleGrey)/max(lumAvg,1e-6);float lumCompressed=lumScaled*(1.0+lumScaled/(whitePoint*whitePoint));lumCompressed/=(1.0+lumScaled);return clamp(lumCompressed*color,0.0,1.0);}\n#elif TONE_MAPPING_MODE == 4\n#define A 0.15\n#define B 0.50\n#define C 0.10\n#define D 0.20\n#define E 0.02\n#define F 0.30\nvec3 Uncharted2Helper(const in vec3 x){return((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}vec3 Uncharted2ToneMapping(vec3 color){color*=toneMappingExposure;return clamp(Uncharted2Helper(color)/Uncharted2Helper(vec3(whitePoint)),0.0,1.0);}\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){\n#if TONE_MAPPING_MODE == 2 || TONE_MAPPING_MODE == 3\noutputColor=vec4(Reinhard2ToneMapping(inputColor.rgb),inputColor.a);\n#elif TONE_MAPPING_MODE == 4\noutputColor=vec4(Uncharted2ToneMapping(inputColor.rgb),inputColor.a);\n#else\noutputColor=vec4(toneMapping(inputColor.rgb),inputColor.a);\n#endif\n}",
              {
                blendFunction: e,
                uniforms: new Map([
                  ["luminanceBuffer", new rp(null)],
                  ["maxLuminance", new rp(r)],
                  ["whitePoint", new rp(s)],
                  ["middleGrey", new rp(a)],
                  ["averageLuminance", new rp(c)],
                ]),
              }
            ),
              (this.renderTargetLuminance = new jr(1, 1, {
                minFilter: On,
                depthBuffer: !1,
              })),
              (this.renderTargetLuminance.texture.generateMipmaps = !0),
              (this.renderTargetLuminance.texture.name = "Luminance"),
              (this.luminancePass = new MC({
                renderTarget: this.renderTargetLuminance,
              })),
              (this.adaptiveLuminancePass = new bS(this.luminancePass.texture, {
                minLuminance: o,
                adaptationRate: l,
              })),
              (this.uniforms.get("luminanceBuffer").value =
                this.adaptiveLuminancePass.texture),
              (this.resolution = i),
              (this.mode = n);
          }
          get mode() {
            return Number(this.defines.get("TONE_MAPPING_MODE"));
          }
          set mode(e) {
            if (this.mode === e) return;
            const t =
              rn.replace(/\D+/g, "") >= 168
                ? "CineonToneMapping(texel)"
                : "OptimizedCineonToneMapping(texel)";
            switch (
              (this.defines.clear(),
              this.defines.set("TONE_MAPPING_MODE", e.toFixed(0)),
              e)
            ) {
              case tS:
                this.defines.set(
                  "toneMapping(texel)",
                  "LinearToneMapping(texel)"
                );
                break;
              case nS:
                this.defines.set(
                  "toneMapping(texel)",
                  "ReinhardToneMapping(texel)"
                );
                break;
              case aS:
              case sS:
                this.defines.set("toneMapping(texel)", t);
                break;
              case oS:
                this.defines.set(
                  "toneMapping(texel)",
                  "ACESFilmicToneMapping(texel)"
                );
                break;
              case cS:
                this.defines.set("toneMapping(texel)", "AgXToneMapping(texel)");
                break;
              case lS:
                this.defines.set(
                  "toneMapping(texel)",
                  "NeutralToneMapping(texel)"
                );
                break;
              default:
                this.defines.set("toneMapping(texel)", "texel");
            }
            (this.adaptiveLuminancePass.enabled = e === rS), this.setChanged();
          }
          getMode() {
            return this.mode;
          }
          setMode(e) {
            this.mode = e;
          }
          get whitePoint() {
            return this.uniforms.get("whitePoint").value;
          }
          set whitePoint(e) {
            this.uniforms.get("whitePoint").value = e;
          }
          get middleGrey() {
            return this.uniforms.get("middleGrey").value;
          }
          set middleGrey(e) {
            this.uniforms.get("middleGrey").value = e;
          }
          get averageLuminance() {
            return this.uniforms.get("averageLuminance").value;
          }
          set averageLuminance(e) {
            this.uniforms.get("averageLuminance").value = e;
          }
          get adaptiveLuminanceMaterial() {
            return this.adaptiveLuminancePass.fullscreenMaterial;
          }
          getAdaptiveLuminanceMaterial() {
            return this.adaptiveLuminanceMaterial;
          }
          get resolution() {
            return this.luminancePass.resolution.width;
          }
          set resolution(e) {
            const t = Math.max(0, Math.ceil(Math.log2(e))),
              n = Math.pow(2, t);
            this.luminancePass.resolution.setPreferredSize(n, n),
              (this.adaptiveLuminanceMaterial.mipLevel1x1 = t);
          }
          getResolution() {
            return this.resolution;
          }
          setResolution(e) {
            this.resolution = e;
          }
          get adaptive() {
            return this.mode === rS;
          }
          set adaptive(e) {
            this.mode = e ? rS : iS;
          }
          get adaptationRate() {
            return this.adaptiveLuminanceMaterial.adaptationRate;
          }
          set adaptationRate(e) {
            this.adaptiveLuminanceMaterial.adaptationRate = e;
          }
          get distinction() {
            return console.warn(this.name, "distinction was removed."), 1;
          }
          set distinction(e) {
            console.warn(this.name, "distinction was removed.");
          }
          update(e, t, n) {
            this.adaptiveLuminancePass.enabled &&
              (this.luminancePass.render(e, t),
              this.adaptiveLuminancePass.render(e, null, null, n));
          }
          initialize(e, t, n) {
            this.adaptiveLuminancePass.initialize(e, t, n);
          }
        },
        xS = class extends DC {
          constructor({
            blendFunction: e,
            eskil: t = !1,
            technique: n = t ? hS : uS,
            offset: i = 0.5,
            darkness: r = 0.5,
          } = {}) {
            super(
              "VignetteEffect",
              "uniform float offset;uniform float darkness;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){const vec2 center=vec2(0.5);vec3 color=inputColor.rgb;\n#if VIGNETTE_TECHNIQUE == 0\nfloat d=distance(uv,center);color*=smoothstep(0.8,offset*0.799,d*(darkness+offset));\n#else\nvec2 coord=(uv-center)*vec2(offset);color=mix(color,vec3(1.0-darkness),dot(coord,coord));\n#endif\noutputColor=vec4(color,inputColor.a);}",
              {
                blendFunction: e,
                defines: new Map([["VIGNETTE_TECHNIQUE", n.toFixed(0)]]),
                uniforms: new Map([
                  ["offset", new rp(i)],
                  ["darkness", new rp(r)],
                ]),
              }
            );
          }
          get technique() {
            return Number(this.defines.get("VIGNETTE_TECHNIQUE"));
          }
          set technique(e) {
            this.technique !== e &&
              (this.defines.set("VIGNETTE_TECHNIQUE", e.toFixed(0)),
              this.setChanged());
          }
          get eskil() {
            return this.technique === hS;
          }
          set eskil(e) {
            this.technique = e ? hS : uS;
          }
          getTechnique() {
            return this.technique;
          }
          setTechnique(e) {
            this.technique = e;
          }
          get offset() {
            return this.uniforms.get("offset").value;
          }
          set offset(e) {
            this.uniforms.get("offset").value = e;
          }
          getOffset() {
            return this.offset;
          }
          setOffset(e) {
            this.offset = e;
          }
          get darkness() {
            return this.uniforms.get("darkness").value;
          }
          set darkness(e) {
            this.uniforms.get("darkness").value = e;
          }
          getDarkness() {
            return this.darkness;
          }
          setDarkness(e) {
            this.darkness = e;
          }
        },
        ES = class extends so {
          constructor(e, t, n, i, r = !1) {
            super({
              name: "EffectMaterial",
              defines: {
                THREE_REVISION: rn.replace(/\D+/g, ""),
                DEPTH_PACKING: "0",
                ENCODE_OUTPUT: "1",
              },
              uniforms: {
                inputBuffer: new rp(null),
                depthBuffer: new rp(null),
                resolution: new rp(new br()),
                texelSize: new rp(new br()),
                cameraNear: new rp(0.3),
                cameraFar: new rp(1e3),
                aspect: new rp(1),
                time: new rp(0),
              },
              blending: 0,
              toneMapped: !1,
              depthWrite: !1,
              depthTest: !1,
              dithering: r,
            }),
              e && this.setShaderParts(e),
              t && this.setDefines(t),
              n && this.setUniforms(n),
              this.copyCameraSettings(i);
          }
          set inputBuffer(e) {
            this.uniforms.inputBuffer.value = e;
          }
          setInputBuffer(e) {
            this.uniforms.inputBuffer.value = e;
          }
          get depthBuffer() {
            return this.uniforms.depthBuffer.value;
          }
          set depthBuffer(e) {
            this.uniforms.depthBuffer.value = e;
          }
          get depthPacking() {
            return Number(this.defines.DEPTH_PACKING);
          }
          set depthPacking(e) {
            (this.defines.DEPTH_PACKING = e.toFixed(0)),
              (this.needsUpdate = !0);
          }
          setDepthBuffer(e, t = 3200) {
            (this.depthBuffer = e), (this.depthPacking = t);
          }
          setShaderData(e) {
            this.setShaderParts(e.shaderParts),
              this.setDefines(e.defines),
              this.setUniforms(e.uniforms),
              this.setExtensions(e.extensions);
          }
          setShaderParts(e) {
            return (
              (this.fragmentShader =
                "#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#define packFloatToRGBA(v) packDepthToRGBA(v)\n#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#if DEPTH_PACKING == 3201\nuniform lowp sampler2D depthBuffer;\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNear,cameraFar);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNear,cameraFar);\n#endif\n}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEAD void main(){FRAGMENT_MAIN_UV vec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGE color0.a=clamp(color0.a,0.0,1.0);gl_FragColor=color0;\n#ifdef ENCODE_OUTPUT\n#include <colorspace_fragment>\n#endif\n#include <dithering_fragment>\n}"
                  .replace(sC.FRAGMENT_HEAD, e.get(sC.FRAGMENT_HEAD) || "")
                  .replace(
                    sC.FRAGMENT_MAIN_UV,
                    e.get(sC.FRAGMENT_MAIN_UV) || ""
                  )
                  .replace(
                    sC.FRAGMENT_MAIN_IMAGE,
                    e.get(sC.FRAGMENT_MAIN_IMAGE) || ""
                  )),
              (this.vertexShader =
                "uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEAD void main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORT gl_Position=vec4(position.xy,1.0,1.0);}"
                  .replace(sC.VERTEX_HEAD, e.get(sC.VERTEX_HEAD) || "")
                  .replace(
                    sC.VERTEX_MAIN_SUPPORT,
                    e.get(sC.VERTEX_MAIN_SUPPORT) || ""
                  )),
              (this.needsUpdate = !0),
              this
            );
          }
          setDefines(e) {
            for (const t of e.entries()) this.defines[t[0]] = t[1];
            return (this.needsUpdate = !0), this;
          }
          setUniforms(e) {
            for (const t of e.entries()) this.uniforms[t[0]] = t[1];
            return this;
          }
          setExtensions(e) {
            this.extensions = {};
            for (const t of e) this.extensions[t] = !0;
            return this;
          }
          get encodeOutput() {
            return void 0 !== this.defines.ENCODE_OUTPUT;
          }
          set encodeOutput(e) {
            this.encodeOutput !== e &&
              (e
                ? (this.defines.ENCODE_OUTPUT = "1")
                : delete this.defines.ENCODE_OUTPUT,
              (this.needsUpdate = !0));
          }
          isOutputEncodingEnabled(e) {
            return this.encodeOutput;
          }
          setOutputEncodingEnabled(e) {
            this.encodeOutput = e;
          }
          get time() {
            return this.uniforms.time.value;
          }
          set time(e) {
            this.uniforms.time.value = e;
          }
          setDeltaTime(e) {
            this.uniforms.time.value += e;
          }
          adoptCameraSettings(e) {
            this.copyCameraSettings(e);
          }
          copyCameraSettings(e) {
            e &&
              ((this.uniforms.cameraNear.value = e.near),
              (this.uniforms.cameraFar.value = e.far),
              e instanceof uo
                ? (this.defines.PERSPECTIVE_CAMERA = "1")
                : delete this.defines.PERSPECTIVE_CAMERA,
              (this.needsUpdate = !0));
          }
          setSize(e, t) {
            const n = this.uniforms;
            n.resolution.value.set(e, t),
              n.texelSize.value.set(1 / e, 1 / t),
              (n.aspect.value = e / t);
          }
          static get Section() {
            return sC;
          }
        },
        wS = (Number(rn.replace(/\D+/g, "")), 255 / 256);
      new Float32Array([
        5.9371814131736755e-8,
        wS / 65536,
        0.0038909912109375,
        wS,
      ]),
        new Float32Array([wS, 0.0038909912109375, wS / 65536, 1 / 256 ** 3]);
      function CS(e, t, n) {
        for (const i of t) {
          const t = "$1" + e + i.charAt(0).toUpperCase() + i.slice(1),
            r = new RegExp("([^\\.])(\\b" + i + "\\b)", "g");
          for (const e of n.entries())
            null !== e[1] && n.set(e[0], e[1].replace(r, t));
        }
      }
      function SS(e, t, n) {
        let i = t.getFragmentShader(),
          r = t.getVertexShader();
        const s = void 0 !== i && /mainImage/.test(i),
          a = void 0 !== i && /mainUv/.test(i);
        if (((n.attributes |= t.getAttributes()), void 0 === i))
          throw new Error(`Missing fragment shader (${t.name})`);
        if (a && n.attributes & rC.CONVOLUTION)
          throw new Error(
            `Effects that transform UVs are incompatible with convolution effects (${t.name})`
          );
        if (!s && !a)
          throw new Error(
            `Could not find mainImage or mainUv function (${t.name})`
          );
        {
          const o = /\w+\s+(\w+)\([\w\s,]*\)\s*{/g,
            c = n.shaderParts;
          let l = c.get(sC.FRAGMENT_HEAD) || "",
            u = c.get(sC.FRAGMENT_MAIN_UV) || "",
            h = c.get(sC.FRAGMENT_MAIN_IMAGE) || "",
            d = c.get(sC.VERTEX_HEAD) || "",
            p = c.get(sC.VERTEX_MAIN_SUPPORT) || "";
          const f = new Set(),
            A = new Set();
          if (
            (a && ((u += `\t${e}MainUv(UV);\n`), (n.uvTransformation = !0)),
            null !== r && /mainSupport/.test(r))
          ) {
            const t = /mainSupport *\([\w\s]*?uv\s*?\)/.test(r);
            (p += `\t${e}MainSupport(`), (p += t ? "vUv);\n" : ");\n");
            for (const e of r.matchAll(/(?:varying\s+\w+\s+([\S\s]*?);)/g))
              for (const t of e[1].split(/\s*,\s*/))
                n.varyings.add(t), f.add(t), A.add(t);
            for (const e of r.matchAll(o)) A.add(e[1]);
          }
          for (const e of i.matchAll(o)) A.add(e[1]);
          for (const e of t.defines.keys())
            A.add(e.replace(/\([\w\s,]*\)/g, ""));
          for (const e of t.uniforms.keys()) A.add(e);
          A.delete("while"),
            A.delete("for"),
            A.delete("if"),
            t.uniforms.forEach((t, i) =>
              n.uniforms.set(e + i.charAt(0).toUpperCase() + i.slice(1), t)
            ),
            t.defines.forEach((t, i) =>
              n.defines.set(e + i.charAt(0).toUpperCase() + i.slice(1), t)
            );
          const g = new Map([
            ["fragment", i],
            ["vertex", r],
          ]);
          CS(e, A, n.defines),
            CS(e, A, g),
            (i = g.get("fragment")),
            (r = g.get("vertex"));
          const m = t.blendMode;
          if ((n.blendModes.set(m.blendFunction, m), s)) {
            null !== t.inputColorSpace &&
              t.inputColorSpace !== n.colorSpace &&
              (h +=
                t.inputColorSpace === Zi
                  ? "color0 = sRGBTransferOETF(color0);\n\t"
                  : "color0 = sRGBToLinear(color0);\n\t"),
              t.outputColorSpace !== Ji
                ? (n.colorSpace = t.outputColorSpace)
                : null !== t.inputColorSpace &&
                  (n.colorSpace = t.inputColorSpace);
            const r = /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;
            (h += `${e}MainImage(color0, UV, `),
              n.attributes & rC.DEPTH &&
                r.test(i) &&
                ((h += "depth, "), (n.readDepth = !0)),
              (h += "color1);\n\t");
            const s = e + "BlendOpacity";
            n.uniforms.set(s, m.opacity),
              (h += `color0 = blend${m.blendFunction}(color0, color1, ${s});\n\n\t`),
              (l += `uniform float ${s};\n\n`);
          }
          if (
            ((l += i + "\n"),
            null !== r && (d += r + "\n"),
            c.set(sC.FRAGMENT_HEAD, l),
            c.set(sC.FRAGMENT_MAIN_UV, u),
            c.set(sC.FRAGMENT_MAIN_IMAGE, h),
            c.set(sC.VERTEX_HEAD, d),
            c.set(sC.VERTEX_MAIN_SUPPORT, p),
            null !== t.extensions)
          )
            for (const e of t.extensions) n.extensions.add(e);
        }
      }
      var IS = class extends Yw {
        constructor(e, ...t) {
          super("EffectPass"),
            (this.fullscreenMaterial = new ES(null, null, null, e)),
            (this.listener = (e) => this.handleEvent(e)),
            (this.effects = []),
            this.setEffects(t),
            (this.skipRendering = !1),
            (this.minTime = 1),
            (this.maxTime = Number.POSITIVE_INFINITY),
            (this.timeScale = 1);
        }
        set mainScene(e) {
          for (const t of this.effects) t.mainScene = e;
        }
        set mainCamera(e) {
          this.fullscreenMaterial.copyCameraSettings(e);
          for (const t of this.effects) t.mainCamera = e;
        }
        get encodeOutput() {
          return this.fullscreenMaterial.encodeOutput;
        }
        set encodeOutput(e) {
          this.fullscreenMaterial.encodeOutput = e;
        }
        get dithering() {
          return this.fullscreenMaterial.dithering;
        }
        set dithering(e) {
          const t = this.fullscreenMaterial;
          (t.dithering = e), (t.needsUpdate = !0);
        }
        setEffects(e) {
          for (const e of this.effects)
            e.removeEventListener("change", this.listener);
          this.effects = e.sort((e, t) => t.attributes - e.attributes);
          for (const e of this.effects)
            e.addEventListener("change", this.listener);
        }
        updateMaterial() {
          const e = new aC();
          let t = 0;
          for (const n of this.effects)
            if (n.blendMode.blendFunction === fC)
              e.attributes |= n.getAttributes() & rC.DEPTH;
            else {
              if (e.attributes & n.getAttributes() & rC.CONVOLUTION)
                throw new Error(
                  `Convolution effects cannot be merged (${n.name})`
                );
              SS("e" + t++, n, e);
            }
          let n = e.shaderParts.get(sC.FRAGMENT_HEAD),
            i = e.shaderParts.get(sC.FRAGMENT_MAIN_IMAGE),
            r = e.shaderParts.get(sC.FRAGMENT_MAIN_UV);
          const s = /\bblend\b/g;
          for (const t of e.blendModes.values())
            n += t.getShaderCode().replace(s, `blend${t.blendFunction}`) + "\n";
          e.attributes & rC.DEPTH
            ? (e.readDepth && (i = "float depth = readDepth(UV);\n\n\t" + i),
              (this.needsDepthTexture = null === this.getDepthTexture()))
            : (this.needsDepthTexture = !1),
            e.colorSpace === Zi && (i += "color0 = sRGBToLinear(color0);\n\t"),
            e.uvTransformation
              ? ((r = "vec2 transformedUv = vUv;\n" + r),
                e.defines.set("UV", "transformedUv"))
              : e.defines.set("UV", "vUv"),
            e.shaderParts.set(sC.FRAGMENT_HEAD, n),
            e.shaderParts.set(sC.FRAGMENT_MAIN_IMAGE, i),
            e.shaderParts.set(sC.FRAGMENT_MAIN_UV, r);
          for (const [t, n] of e.shaderParts)
            null !== n && e.shaderParts.set(t, n.trim().replace(/^#/, "\n#"));
          (this.skipRendering = 0 === t),
            (this.needsSwap = !this.skipRendering),
            this.fullscreenMaterial.setShaderData(e);
        }
        recompile() {
          this.updateMaterial();
        }
        getDepthTexture() {
          return this.fullscreenMaterial.depthBuffer;
        }
        setDepthTexture(e, t = 3200) {
          (this.fullscreenMaterial.depthBuffer = e),
            (this.fullscreenMaterial.depthPacking = t);
          for (const n of this.effects) n.setDepthTexture(e, t);
        }
        render(e, t, n, i, r) {
          for (const n of this.effects) n.update(e, t, i);
          if (!this.skipRendering || this.renderToScreen) {
            const r = this.fullscreenMaterial;
            (r.inputBuffer = t.texture),
              (r.time += i * this.timeScale),
              e.setRenderTarget(this.renderToScreen ? null : n),
              e.render(this.scene, this.camera);
          }
        }
        setSize(e, t) {
          this.fullscreenMaterial.setSize(e, t);
          for (const n of this.effects) n.setSize(e, t);
        }
        initialize(e, t, n) {
          this.renderer = e;
          for (const i of this.effects) i.initialize(e, t, n);
          this.updateMaterial(),
            void 0 !== n &&
              n !== Nn &&
              (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH =
                "1");
        }
        dispose() {
          super.dispose();
          for (const e of this.effects)
            e.removeEventListener("change", this.listener), e.dispose();
        }
        handleEvent(e) {
          if ("change" === e.type) this.recompile();
        }
      };
      new Float32Array(3),
        new Float32Array(3),
        new Float32Array(3),
        new Float32Array(3),
        new Float32Array(3),
        new Float32Array(3),
        new Float32Array([0, 0, 0]),
        new Float32Array([1, 0, 0]),
        new Float32Array([1, 1, 0]),
        new Float32Array([1, 1, 1]),
        new Float32Array([0, 0, 0]),
        new Float32Array([1, 0, 0]),
        new Float32Array([1, 0, 1]),
        new Float32Array([1, 1, 1]),
        new Float32Array([0, 0, 0]),
        new Float32Array([0, 0, 1]),
        new Float32Array([1, 0, 1]),
        new Float32Array([1, 1, 1]),
        new Float32Array([0, 0, 0]),
        new Float32Array([0, 1, 0]),
        new Float32Array([1, 1, 0]),
        new Float32Array([1, 1, 1]),
        new Float32Array([0, 0, 0]),
        new Float32Array([0, 1, 0]),
        new Float32Array([0, 1, 1]),
        new Float32Array([1, 1, 1]),
        new Float32Array([0, 0, 0]),
        new Float32Array([0, 0, 1]),
        new Float32Array([0, 1, 1]),
        new Float32Array([1, 1, 1]);
      new Float32Array(2),
        new Float32Array(2),
        new Float32Array([0, -0.25, 0.25, -0.125, 0.125, -0.375, 0.375]),
        new Float32Array([0, 0]),
        new Float32Array([0.25, -0.25]),
        new Float32Array([-0.25, 0.25]),
        new Float32Array([0.125, -0.125]),
        new Float32Array([-0.125, 0.125]),
        new Uint8Array([0, 0]),
        new Uint8Array([3, 0]),
        new Uint8Array([0, 3]),
        new Uint8Array([3, 3]),
        new Uint8Array([1, 0]),
        new Uint8Array([4, 0]),
        new Uint8Array([1, 3]),
        new Uint8Array([4, 3]),
        new Uint8Array([0, 1]),
        new Uint8Array([3, 1]),
        new Uint8Array([0, 4]),
        new Uint8Array([3, 4]),
        new Uint8Array([1, 1]),
        new Uint8Array([4, 1]),
        new Uint8Array([1, 4]),
        new Uint8Array([4, 4]),
        new Uint8Array([0, 0]),
        new Uint8Array([1, 0]),
        new Uint8Array([0, 2]),
        new Uint8Array([1, 2]),
        new Uint8Array([2, 0]),
        new Uint8Array([3, 0]),
        new Uint8Array([2, 2]),
        new Uint8Array([3, 2]),
        new Uint8Array([0, 1]),
        new Uint8Array([1, 1]),
        new Uint8Array([0, 3]),
        new Uint8Array([1, 3]),
        new Uint8Array([2, 1]),
        new Uint8Array([3, 1]),
        new Uint8Array([2, 3]),
        new Uint8Array([3, 3]);
      TS(0, 0, 0, 0),
        new Float32Array([0, 0, 0, 0]),
        TS(0, 0, 0, 1),
        new Float32Array([0, 0, 0, 1]),
        TS(0, 0, 1, 0),
        new Float32Array([0, 0, 1, 0]),
        TS(0, 0, 1, 1),
        new Float32Array([0, 0, 1, 1]),
        TS(0, 1, 0, 0),
        new Float32Array([0, 1, 0, 0]),
        TS(0, 1, 0, 1),
        new Float32Array([0, 1, 0, 1]),
        TS(0, 1, 1, 0),
        new Float32Array([0, 1, 1, 0]),
        TS(0, 1, 1, 1),
        new Float32Array([0, 1, 1, 1]),
        TS(1, 0, 0, 0),
        new Float32Array([1, 0, 0, 0]),
        TS(1, 0, 0, 1),
        new Float32Array([1, 0, 0, 1]),
        TS(1, 0, 1, 0),
        new Float32Array([1, 0, 1, 0]),
        TS(1, 0, 1, 1),
        new Float32Array([1, 0, 1, 1]),
        TS(1, 1, 0, 0),
        new Float32Array([1, 1, 0, 0]),
        TS(1, 1, 0, 1),
        new Float32Array([1, 1, 0, 1]),
        TS(1, 1, 1, 0),
        new Float32Array([1, 1, 1, 0]),
        TS(1, 1, 1, 1),
        new Float32Array([1, 1, 1, 1]);
      function MS(e, t, n) {
        return e + (t - e) * n;
      }
      function TS(e, t, n, i) {
        const r = MS(e, t, 0.75),
          s = MS(n, i, 0.75);
        return MS(r, s, 0.875);
      }
      var BS;
      function RS(e, t) {
        function n(e, t) {
          const { blendFunction: n, opacity: i, bits: r } = t;
          (e.bitDepth = r),
            (e.blendMode.blendFunction = n),
            e.blendMode.setOpacity(i);
        }
        return {
          updateEffect: function (i) {
            var r;
            const { type: s } = i,
              a = null === (r = e.get(s)) || void 0 === r ? void 0 : r.effect;
            if (!a)
              throw new Error(
                "Effect that you are trying to update doesn't exist!"
              );
            Dt(i) &&
              (function (e, t) {
                const {
                  blendFunction: n,
                  filter: i,
                  intensity: r,
                  luminanceSmoothing: s,
                  luminanceThreshold: a,
                  opacity: o,
                  radius: c,
                } = t;
                (e.luminanceMaterial.threshold = a),
                  (e.luminanceMaterial.smoothing = s),
                  (e.blendMode.blendFunction = n),
                  e.blendMode.setOpacity(o),
                  (e.blurPass.kernelSize = Math.round(c)),
                  (e.intensity = r),
                  (e.luminancePass.enabled = i),
                  (e.luminanceMaterial.needsUpdate = !0);
              })(a, i),
              Pt(i) &&
                (function (e, t) {
                  const {
                    blendFunction: n,
                    technique: i,
                    offset: r,
                    opacity: s,
                    darkness: a,
                  } = t;
                  (e.darkness = a),
                    (e.offset = r),
                    (e.technique = i),
                    (e.blendMode.blendFunction = n),
                    e.blendMode.setOpacity(s);
                })(a, i),
              Ft(i) &&
                (function (e, t) {
                  const {
                    bokehScale: n,
                    focusRange: i,
                    focusDistance: r,
                    resolutionScale: s,
                    blendFunction: a,
                    opacity: o,
                  } = t;
                  (e.bokehScale = n),
                    (e.resolution.scale = s),
                    (e.cocMaterial.focusDistance = r),
                    (e.cocMaterial.focusRange = i),
                    (e.cocMaterial.needsUpdate = !0),
                    (e.blendMode.blendFunction = a),
                    e.blendMode.setOpacity(o);
                })(a, i),
              Ot(i) &&
                (function (e, t) {
                  const { granularity: n } = t;
                  e.granularity = n;
                })(a, i),
              Nt(i) &&
                (function (e, t) {
                  const {
                    blendFunction: n,
                    opacity: i,
                    hue: r,
                    saturation: s,
                  } = t;
                  (e.hue = r),
                    (e.saturation = s),
                    (e.blendMode.blendFunction = n),
                    e.blendMode.setOpacity(i);
                })(a, i),
              kt(i) && n(a, i),
              Qt(i) &&
                (function (e, t) {
                  const {
                    blendFunction: n,
                    opacity: i,
                    contrast: r,
                    brightness: s,
                  } = t;
                  (e.contrast = r),
                    (e.brightness = s),
                    (e.blendMode.blendFunction = n),
                    e.blendMode.setOpacity(i);
                })(a, i),
              Lt(i) &&
                (function (e, t) {
                  const { blendFunction: n, opacity: i } = t;
                  (e.blendMode.blendFunction = n), e.blendMode.setOpacity(i);
                })(a, i),
              kt(i) && n(a, i),
              Ut(i) &&
                (function (e, t) {
                  const {
                    edgeContrastFactor: n,
                    edgeMode: i,
                    edgeThreshold: r,
                    predicationMode: s,
                    predicationScale: a,
                    predicationStrength: o,
                    predicationThreshold: c,
                    preset: l,
                  } = t;
                  e.applyPreset(l);
                  const u = e.edgeDetectionMaterial;
                  (u.edgeDetectionMode = Number(i)),
                    (u.predicationMode = Number(s)),
                    (u.predicationScale = a),
                    (u.predicationStrength = o),
                    (u.predicationThreshold = c),
                    (u.edgeDetectionThreshold = r),
                    (u.localContrastAdaptationFactor = n),
                    (u.needsUpdate = !0);
                })(a, i),
              Gt(i) &&
                (function (e, n) {
                  const {
                    adaptationRate: i,
                    averageLuminance: r,
                    exposure: s,
                    middleGrey: a,
                    minLuminance: o,
                    mode: c,
                    whitePoint: l,
                    resolution: u,
                    blendFunction: h,
                    opacity: d,
                  } = n;
                  (e.resolution = u),
                    (e.mode = Number(c)),
                    (e.adaptationRate = i),
                    e.uniforms.get("averageLuminance") &&
                      (e.uniforms.get("averageLuminance").value = r),
                    e.uniforms.get("middleGrey") &&
                      (e.uniforms.get("middleGrey").value = a),
                    e.uniforms.get("whitePoint") &&
                      (e.uniforms.get("whitePoint").value = l),
                    (e.adaptiveLuminanceMaterial.minLuminance = o),
                    (t.getRenderer().toneMappingExposure = s),
                    (e.blendMode.blendFunction = h),
                    e.blendMode.setOpacity(d);
                })(a, i);
          },
        };
      }
      function DS(e, t, n) {
        const { updateEffect: i } = RS(e, t);
        return {
          updateEffect: i,
          createEffect: function (r) {
            var s;
            const { type: a, opacity: o } = r;
            if (null === (s = e.get(a)) || void 0 === s ? void 0 : s.effect)
              throw Error(
                `Trying to create an effect that's already added ${a}`
              );
            let c;
            if (
              (Dt(r) &&
                (c = (function (e) {
                  const {
                      filter: t,
                      intensity: n,
                      luminanceSmoothing: i,
                      luminanceThreshold: r,
                      radius: s,
                      blendFunction: a,
                    } = e,
                    o = new PC({
                      luminanceSmoothing: i,
                      luminanceThreshold: r,
                      intensity: n,
                      blendFunction: a,
                      radius: s,
                    });
                  return (o.luminancePass.enabled = !!t), o;
                })(r)),
              Pt(r) &&
                (c = (function (e) {
                  const {
                    offset: t,
                    darkness: n,
                    technique: i,
                    blendFunction: r,
                  } = e;
                  return new xS({
                    offset: t,
                    darkness: n,
                    technique: i,
                    blendFunction: r,
                  });
                })(r)),
              Lt(r) &&
                (c = (function (e) {
                  const { blendFunction: t } = e;
                  return new dS({ blendFunction: t });
                })(r)),
              Ft(r) &&
                (c = (function (e) {
                  const {
                    bokehScale: t,
                    focusRange: n,
                    focusDistance: i,
                    resolutionScale: r,
                    blendFunction: s,
                  } = e;
                  return new WC(void 0, {
                    bokehScale: t,
                    focusRange: n,
                    focusDistance: i,
                    resolutionScale: r,
                    blendFunction: s,
                  });
                })(r)),
              Ot(r) &&
                (c = (function (e) {
                  const { granularity: t } = e;
                  return new pS(t);
                })(r)),
              Nt(r) &&
                (c = (function (e) {
                  const { hue: t, saturation: n, blendFunction: i } = e;
                  return new qC({ blendFunction: i, hue: t, saturation: n });
                })(r)),
              kt(r) &&
                (c = (function (e) {
                  const { bits: t, blendFunction: n } = e;
                  return new UC({ blendFunction: n, bits: t });
                })(r)),
              Qt(r) &&
                (c = (function (e) {
                  const { brightness: t, contrast: n, blendFunction: i } = e;
                  return new LC({
                    blendFunction: i,
                    brightness: t,
                    contrast: n,
                  });
                })(r)),
              Ut(r) &&
                (c = (function (e) {
                  const { edgeMode: t, predicationMode: n, preset: i } = e;
                  return new vS({
                    edgeDetectionMode: Number(t),
                    predicationMode: Number(n),
                    preset: i,
                  });
                })(r)),
              Gt(r) &&
                (c = (function (e) {
                  const {
                      mode: n,
                      adaptationRate: i,
                      averageLuminance: r,
                      middleGrey: s,
                      minLuminance: a,
                      resolution: o,
                      whitePoint: c,
                      exposure: l,
                    } = e,
                    u = new _S({
                      mode: Number(n),
                      adaptationRate: i,
                      averageLuminance: r,
                      middleGrey: s,
                      minLuminance: a,
                      resolution: o,
                      whitePoint: c,
                    });
                  return (t.getRenderer().toneMappingExposure = l), u;
                })(r)),
              !c)
            )
              throw new Error(`Object type <${a}> is not supported!`);
            c.blendMode.setOpacity(o),
              c.initialize(t.getRenderer(), !0, jn),
              e.set(a, { order: qe.get(a), effect: c }),
              i(r),
              n();
          },
          deleteEffect: function (i) {
            var r;
            const s =
              null === (r = e.get(i)) || void 0 === r ? void 0 : r.effect;
            if (!s)
              throw Error(`Trying to delete an effect that doesn't exist ${i}`);
            i === We.ToneMapping && (t.getRenderer().toneMappingExposure = 1),
              e.delete(i),
              s.dispose(),
              n();
          },
        };
      }
      class PS extends IS {
        disposeWithoutDisposingEffects() {
          for (const e of Object.keys(this)) {
            const t = this[e];
            (t instanceof jr ||
              t instanceof ba ||
              t instanceof Hr ||
              t instanceof Yw) &&
              this[e].dispose();
          }
          this.setEffects([]);
        }
      }
      !(function (e) {
        (e[(e.PWObjects = 0)] = "PWObjects"),
          (e[(e.Effects = 1)] = "Effects"),
          (e[(e.Copy = 2)] = "Copy"),
          (e[(e.Helpers = 3)] = "Helpers");
      })(BS || (BS = {}));
      const LS = (function () {
          const e = [BS.PWObjects, BS.Effects, BS.Copy, BS.Helpers],
            t = new Map();
          return (
            e.forEach((e, n) => {
              t.set(e, n);
            }),
            t
          );
        })(),
        US = [We.SMAA];
      function FS(e, t, n, i, r) {
        let s = 1,
          a = !1;
        const o = new iC(e, {
            alpha: !0,
            depthBuffer: !0,
            frameBufferType: jn,
          }),
          c = new XC();
        let l = [];
        const u = (e) =>
            LS.get(e) > LS.get(BS.Effects)
              ? LS.get(e) + l.length - 1
              : LS.get(e),
          h = (e, t) => {
            o.addPass(e, u(t));
          };
        if ((h(c, BS.PWObjects), GL)) {
          const e = new XC();
          (e.selection = new dC(void 0, De.Helpers)),
            (e.clearPass.enabled = !1),
            (e.ignoreBackground = !0),
            (e.skipShadowMapUpdate = !0);
          const t = new $w();
          (c.renderToScreen = !1),
            l.forEach((e) => (e.renderToScreen = !1)),
            (t.renderToScreen = !0),
            (e.renderToScreen = !0),
            h(e, BS.Helpers),
            h(t, BS.Copy);
        }
        const d = new Map(),
          { createEffect: p, updateEffect: f, deleteEffect: A } = DS(d, o, g);
        function g() {
          l.forEach((e) => {
            o.removePass(e), e.disposeWithoutDisposingEffects();
          });
          const t = a
              ? [...d.entries()]
              : [...d.entries()].filter((e) => US.includes(e[0])),
            r = t
              .sort((e, t) => e[1].order - t[1].order)
              .map((e) => e[1].effect);
          if (0 === r.length || !e.getContext().getContextAttributes())
            return void (l = []);
          const s = [[]];
          let c = !1,
            u = !1;
          r.forEach((e) => {
            const t = e.getFragmentShader(),
              n = void 0 !== t && /mainUv/.test(t),
              i = !!(e.getAttributes() & rC.CONVOLUTION);
            (u || c) && i
              ? (s.push([e]), (c = !1))
              : u && n
              ? (s.push([e]), (u = !1))
              : s[s.length - 1].push(e),
              (c = c || n),
              (u = u || i);
          }),
            (l = []),
            s.forEach((e) => {
              const t = new PS(void 0, ...e);
              GL && (t.renderToScreen = !1),
                (t.mainCamera = n()),
                (t.mainScene = i()),
                h(t, BS.Effects),
                l.push(t);
            });
        }
        function m() {
          const e = r(),
            i = n();
          if ((null == e ? void 0 : e.camera) && e.camera !== i) {
            const t = e.htmlElement.clientWidth / e.htmlElement.clientHeight;
            e.camera instanceof uo &&
              ((e.camera.aspect = t), e.camera.updateProjectionMatrix()),
              e.camera instanceof No &&
                ((e.camera.left = -t),
                (e.camera.right = t),
                e.camera.updateProjectionMatrix());
          }
          if (i) {
            const e = t.x / t.y;
            i instanceof uo && ((i.aspect = e), i.updateProjectionMatrix()),
              i instanceof No &&
                ((i.left = -e), (i.right = e), i.updateProjectionMatrix());
          }
        }
        return {
          createEffect: p,
          deleteEffect: A,
          updateEffect: f,
          setMainCamera: function (e) {
            o.setMainCamera(e);
          },
          setMainScene: function (e) {
            o.setMainScene(e);
          },
          setUsePostProcessing: function (e) {
            (a = e),
              a || US.find((e) => d.has(e))
                ? g()
                : l.forEach((e) => o.removePass(e));
          },
          render: function (i) {
            const a = r(),
              l = n(),
              h = e.domElement.parentElement;
            if (!h)
              throw new Error(
                "Canvas parent element is not found! Cannot update canvas size"
              );
            var d, p, f;
            if (
              ((d = h.clientWidth),
              (p = h.clientHeight),
              (f = e.getPixelRatio()),
              (d === t.x && p === t.y && s === f) ||
                (t.set(d, p), (s = f), o.setSize(d, p, !1), m()),
              a && a.camera !== l)
            ) {
              const t = a.htmlElement.getBoundingClientRect(),
                n = h.getBoundingClientRect();
              o.render(i);
              const { width: r, height: s } = t,
                d = t.x - n.x,
                p = n.height - (t.y - n.y) - s;
              e.setViewport(d, p, r, s),
                e.setScissorTest(!0),
                e.setScissor(d, p, r, s),
                c.clearPass.setClearFlags(!1, !0, !0),
                o.setMainCamera(a.camera),
                (o.passes[u(BS.Helpers)].enabled = !1),
                o.render(i),
                e.setViewport(0, 0, n.width, n.height),
                e.setScissorTest(!1),
                c.clearPass.setClearFlags(!0, !0, !0),
                (o.passes[u(BS.Helpers)].enabled = !0),
                o.setMainCamera(l);
            } else o.render(i);
          },
          effects: d,
          dispose: function () {
            d.clear(), o.dispose(), l.forEach((e) => e.dispose());
          },
          updateCameraProjectionMatrix: m,
          setMultiSampling: function (t) {
            o.multisampling = Math.min(t, e.capabilities.maxSamples);
          },
        };
      }
      var OS = n(52),
        NS = n.n(OS);
      function kS(e) {
        if (void 0 === e)
          throw new ReferenceError(
            "this hasn't been initialised - super() hasn't been called"
          );
        return e;
      }
      function QS(e, t) {
        (e.prototype = Object.create(t.prototype)),
          (e.prototype.constructor = e),
          (e.__proto__ = t);
      }
      var GS,
        HS,
        zS,
        VS,
        jS,
        WS,
        XS,
        qS,
        YS,
        KS,
        JS,
        ZS = {
          autoSleep: 120,
          force3D: "auto",
          nullTargetWarn: 1,
          units: { lineHeight: "" },
        },
        $S = { duration: 0.5, overwrite: !1, delay: 0 },
        eI = 1e8,
        tI = 1e-8,
        nI = 2 * Math.PI,
        iI = nI / 4,
        rI = 0,
        sI = Math.sqrt,
        aI = Math.cos,
        oI = Math.sin,
        cI = function (e) {
          return "string" == typeof e;
        },
        lI = function (e) {
          return "function" == typeof e;
        },
        uI = function (e) {
          return "number" == typeof e;
        },
        hI = function (e) {
          return void 0 === e;
        },
        dI = function (e) {
          return "object" == typeof e;
        },
        pI = function (e) {
          return !1 !== e;
        },
        fI = function () {
          return "undefined" != typeof window;
        },
        AI = function (e) {
          return lI(e) || cI(e);
        },
        gI =
          ("function" == typeof ArrayBuffer && ArrayBuffer.isView) ||
          function () {},
        mI = Array.isArray,
        vI = /(?:-?\.?\d|\.)+/gi,
        yI = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
        bI = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
        _I = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
        xI = /[+-]=-?[.\d]+/,
        EI = /[^,'"\[\]\s]+/gi,
        wI = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
        CI = {},
        SI = {},
        II = function (e) {
          return (SI = nM(e, CI)) && iB;
        },
        MI = function (e, t) {
          return console.warn(
            "Invalid property",
            e,
            "set to",
            t,
            "Missing plugin? gsap.registerPlugin()"
          );
        },
        TI = function (e, t) {
          return !t && console.warn(e);
        },
        BI = function (e, t) {
          return (e && (CI[e] = t) && SI && (SI[e] = t)) || CI;
        },
        RI = function () {
          return 0;
        },
        DI = { suppressEvents: !0, isStart: !0, kill: !1 },
        PI = { suppressEvents: !0, kill: !1 },
        LI = { suppressEvents: !0 },
        UI = {},
        FI = [],
        OI = {},
        NI = {},
        kI = {},
        QI = 30,
        GI = [],
        HI = "",
        zI = function (e) {
          var t,
            n,
            i = e[0];
          if ((dI(i) || lI(i) || (e = [e]), !(t = (i._gsap || {}).harness))) {
            for (n = GI.length; n-- && !GI[n].targetTest(i); );
            t = GI[n];
          }
          for (n = e.length; n--; )
            (e[n] && (e[n]._gsap || (e[n]._gsap = new mT(e[n], t)))) ||
              e.splice(n, 1);
          return e;
        },
        VI = function (e) {
          return e._gsap || zI(LM(e))[0]._gsap;
        },
        jI = function (e, t, n) {
          return (n = e[t]) && lI(n)
            ? e[t]()
            : (hI(n) && e.getAttribute && e.getAttribute(t)) || n;
        },
        WI = function (e, t) {
          return (e = e.split(",")).forEach(t) || e;
        },
        XI = function (e) {
          return Math.round(1e5 * e) / 1e5 || 0;
        },
        qI = function (e) {
          return Math.round(1e7 * e) / 1e7 || 0;
        },
        YI = function (e, t) {
          var n = t.charAt(0),
            i = parseFloat(t.substr(2));
          return (
            (e = parseFloat(e)),
            "+" === n ? e + i : "-" === n ? e - i : "*" === n ? e * i : e / i
          );
        },
        KI = function (e, t) {
          for (var n = t.length, i = 0; e.indexOf(t[i]) < 0 && ++i < n; );
          return i < n;
        },
        JI = function () {
          var e,
            t,
            n = FI.length,
            i = FI.slice(0);
          for (OI = {}, FI.length = 0, e = 0; e < n; e++)
            (t = i[e]) &&
              t._lazy &&
              (t.render(t._lazy[0], t._lazy[1], !0)._lazy = 0);
        },
        ZI = function (e, t, n, i) {
          FI.length && !HS && JI(),
            e.render(t, n, i || (HS && t < 0 && (e._initted || e._startAt))),
            FI.length && !HS && JI();
        },
        $I = function (e) {
          var t = parseFloat(e);
          return (t || 0 === t) && (e + "").match(EI).length < 2
            ? t
            : cI(e)
            ? e.trim()
            : e;
        },
        eM = function (e) {
          return e;
        },
        tM = function (e, t) {
          for (var n in t) n in e || (e[n] = t[n]);
          return e;
        },
        nM = function (e, t) {
          for (var n in t) e[n] = t[n];
          return e;
        },
        iM = function e(t, n) {
          for (var i in n)
            "__proto__" !== i &&
              "constructor" !== i &&
              "prototype" !== i &&
              (t[i] = dI(n[i]) ? e(t[i] || (t[i] = {}), n[i]) : n[i]);
          return t;
        },
        rM = function (e, t) {
          var n,
            i = {};
          for (n in e) n in t || (i[n] = e[n]);
          return i;
        },
        sM = function (e) {
          var t,
            n = e.parent || VS,
            i = e.keyframes
              ? ((t = mI(e.keyframes)),
                function (e, n) {
                  for (var i in n)
                    i in e ||
                      ("duration" === i && t) ||
                      "ease" === i ||
                      (e[i] = n[i]);
                })
              : tM;
          if (pI(e.inherit))
            for (; n; ) i(e, n.vars.defaults), (n = n.parent || n._dp);
          return e;
        },
        aM = function (e, t, n, i, r) {
          void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
          var s,
            a = e[i];
          if (r) for (s = t[r]; a && a[r] > s; ) a = a._prev;
          return (
            a
              ? ((t._next = a._next), (a._next = t))
              : ((t._next = e[n]), (e[n] = t)),
            t._next ? (t._next._prev = t) : (e[i] = t),
            (t._prev = a),
            (t.parent = t._dp = e),
            t
          );
        },
        oM = function (e, t, n, i) {
          void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
          var r = t._prev,
            s = t._next;
          r ? (r._next = s) : e[n] === t && (e[n] = s),
            s ? (s._prev = r) : e[i] === t && (e[i] = r),
            (t._next = t._prev = t.parent = null);
        },
        cM = function (e, t) {
          e.parent &&
            (!t || e.parent.autoRemoveChildren) &&
            e.parent.remove &&
            e.parent.remove(e),
            (e._act = 0);
        },
        lM = function (e, t) {
          if (e && (!t || t._end > e._dur || t._start < 0))
            for (var n = e; n; ) (n._dirty = 1), (n = n.parent);
          return e;
        },
        uM = function (e, t, n, i) {
          return (
            e._startAt &&
            (HS
              ? e._startAt.revert(PI)
              : (e.vars.immediateRender && !e.vars.autoRevert) ||
                e._startAt.render(t, !0, i))
          );
        },
        hM = function e(t) {
          return !t || (t._ts && e(t.parent));
        },
        dM = function (e) {
          return e._repeat
            ? pM(e._tTime, (e = e.duration() + e._rDelay)) * e
            : 0;
        },
        pM = function (e, t) {
          var n = Math.floor((e /= t));
          return e && n === e ? n - 1 : n;
        },
        fM = function (e, t) {
          return (
            (e - t._start) * t._ts +
            (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur)
          );
        },
        AM = function (e) {
          return (e._end = qI(
            e._start + (e._tDur / Math.abs(e._ts || e._rts || tI) || 0)
          ));
        },
        gM = function (e, t) {
          var n = e._dp;
          return (
            n &&
              n.smoothChildTiming &&
              e._ts &&
              ((e._start = qI(
                n._time -
                  (e._ts > 0
                    ? t / e._ts
                    : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)
              )),
              AM(e),
              n._dirty || lM(n, e)),
            e
          );
        },
        mM = function (e, t) {
          var n;
          if (
            ((t._time ||
              (!t._dur && t._initted) ||
              (t._start < e._time && (t._dur || !t.add))) &&
              ((n = fM(e.rawTime(), t)),
              (!t._dur || TM(0, t.totalDuration(), n) - t._tTime > tI) &&
                t.render(n, !0)),
            lM(e, t)._dp && e._initted && e._time >= e._dur && e._ts)
          ) {
            if (e._dur < e.duration())
              for (n = e; n._dp; )
                n.rawTime() >= 0 && n.totalTime(n._tTime), (n = n._dp);
            e._zTime = -1e-8;
          }
        },
        vM = function (e, t, n, i) {
          return (
            t.parent && cM(t),
            (t._start = qI(
              (uI(n) ? n : n || e !== VS ? SM(e, n, t) : e._time) + t._delay
            )),
            (t._end = qI(
              t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)
            )),
            aM(e, t, "_first", "_last", e._sort ? "_start" : 0),
            xM(t) || (e._recent = t),
            i || mM(e, t),
            e._ts < 0 && gM(e, e._tTime),
            e
          );
        },
        yM = function (e, t) {
          return (
            (CI.ScrollTrigger || MI("scrollTrigger", t)) &&
            CI.ScrollTrigger.create(t, e)
          );
        },
        bM = function (e, t, n, i, r) {
          return (
            CT(e, t, r),
            e._initted
              ? !n &&
                e._pt &&
                !HS &&
                ((e._dur && !1 !== e.vars.lazy) || (!e._dur && e.vars.lazy)) &&
                YS !== rT.frame
                ? (FI.push(e), (e._lazy = [r, i]), 1)
                : void 0
              : 1
          );
        },
        _M = function e(t) {
          var n = t.parent;
          return (
            n && n._ts && n._initted && !n._lock && (n.rawTime() < 0 || e(n))
          );
        },
        xM = function (e) {
          var t = e.data;
          return "isFromStart" === t || "isStart" === t;
        },
        EM = function (e, t, n, i) {
          var r = e._repeat,
            s = qI(t) || 0,
            a = e._tTime / e._tDur;
          return (
            a && !i && (e._time *= s / e._dur),
            (e._dur = s),
            (e._tDur = r
              ? r < 0
                ? 1e10
                : qI(s * (r + 1) + e._rDelay * r)
              : s),
            a > 0 && !i && gM(e, (e._tTime = e._tDur * a)),
            e.parent && AM(e),
            n || lM(e.parent, e),
            e
          );
        },
        wM = function (e) {
          return e instanceof yT ? lM(e) : EM(e, e._dur);
        },
        CM = { _start: 0, endTime: RI, totalDuration: RI },
        SM = function e(t, n, i) {
          var r,
            s,
            a,
            o = t.labels,
            c = t._recent || CM,
            l = t.duration() >= eI ? c.endTime(!1) : t._dur;
          return cI(n) && (isNaN(n) || n in o)
            ? ((s = n.charAt(0)),
              (a = "%" === n.substr(-1)),
              (r = n.indexOf("=")),
              "<" === s || ">" === s
                ? (r >= 0 && (n = n.replace(/=/, "")),
                  ("<" === s ? c._start : c.endTime(c._repeat >= 0)) +
                    (parseFloat(n.substr(1)) || 0) *
                      (a ? (r < 0 ? c : i).totalDuration() / 100 : 1))
                : r < 0
                ? (n in o || (o[n] = l), o[n])
                : ((s = parseFloat(n.charAt(r - 1) + n.substr(r + 1))),
                  a &&
                    i &&
                    (s = (s / 100) * (mI(i) ? i[0] : i).totalDuration()),
                  r > 1 ? e(t, n.substr(0, r - 1), i) + s : l + s))
            : null == n
            ? l
            : +n;
        },
        IM = function (e, t, n) {
          var i,
            r,
            s = uI(t[1]),
            a = (s ? 2 : 1) + (e < 2 ? 0 : 1),
            o = t[a];
          if ((s && (o.duration = t[1]), (o.parent = n), e)) {
            for (i = o, r = n; r && !("immediateRender" in i); )
              (i = r.vars.defaults || {}), (r = pI(r.vars.inherit) && r.parent);
            (o.immediateRender = pI(i.immediateRender)),
              e < 2 ? (o.runBackwards = 1) : (o.startAt = t[a - 1]);
          }
          return new BT(t[0], o, t[a + 1]);
        },
        MM = function (e, t) {
          return e || 0 === e ? t(e) : t;
        },
        TM = function (e, t, n) {
          return n < e ? e : n > t ? t : n;
        },
        BM = function (e, t) {
          return cI(e) && (t = wI.exec(e)) ? t[1] : "";
        },
        RM = [].slice,
        DM = function (e, t) {
          return (
            e &&
            dI(e) &&
            "length" in e &&
            ((!t && !e.length) || (e.length - 1 in e && dI(e[0]))) &&
            !e.nodeType &&
            e !== jS
          );
        },
        PM = function (e, t, n) {
          return (
            void 0 === n && (n = []),
            e.forEach(function (e) {
              var i;
              return (cI(e) && !t) || DM(e, 1)
                ? (i = n).push.apply(i, LM(e))
                : n.push(e);
            }) || n
          );
        },
        LM = function (e, t, n) {
          return zS && !t && zS.selector
            ? zS.selector(e)
            : !cI(e) || n || (!WS && sT())
            ? mI(e)
              ? PM(e, n)
              : DM(e)
              ? RM.call(e, 0)
              : e
              ? [e]
              : []
            : RM.call((t || XS).querySelectorAll(e), 0);
        },
        UM = function (e) {
          return (
            (e = LM(e)[0] || TI("Invalid scope") || {}),
            function (t) {
              var n = e.current || e.nativeElement || e;
              return LM(
                t,
                n.querySelectorAll
                  ? n
                  : n === e
                  ? TI("Invalid scope") || XS.createElement("div")
                  : e
              );
            }
          );
        },
        FM = function (e) {
          return e.sort(function () {
            return 0.5 - Math.random();
          });
        },
        OM = function (e) {
          if (lI(e)) return e;
          var t = dI(e) ? e : { each: e },
            n = dT(t.ease),
            i = t.from || 0,
            r = parseFloat(t.base) || 0,
            s = {},
            a = i > 0 && i < 1,
            o = isNaN(i) || a,
            c = t.axis,
            l = i,
            u = i;
          return (
            cI(i)
              ? (l = u = { center: 0.5, edges: 0.5, end: 1 }[i] || 0)
              : !a && o && ((l = i[0]), (u = i[1])),
            function (e, a, h) {
              var d,
                p,
                f,
                A,
                g,
                m,
                v,
                y,
                b,
                _ = (h || t).length,
                x = s[_];
              if (!x) {
                if (!(b = "auto" === t.grid ? 0 : (t.grid || [1, eI])[1])) {
                  for (
                    v = -eI;
                    v < (v = h[b++].getBoundingClientRect().left) && b < _;

                  );
                  b < _ && b--;
                }
                for (
                  x = s[_] = [],
                    d = o ? Math.min(b, _) * l - 0.5 : i % b,
                    p = b === eI ? 0 : o ? (_ * u) / b - 0.5 : (i / b) | 0,
                    v = 0,
                    y = eI,
                    m = 0;
                  m < _;
                  m++
                )
                  (f = (m % b) - d),
                    (A = p - ((m / b) | 0)),
                    (x[m] = g =
                      c ? Math.abs("y" === c ? A : f) : sI(f * f + A * A)),
                    g > v && (v = g),
                    g < y && (y = g);
                "random" === i && FM(x),
                  (x.max = v - y),
                  (x.min = y),
                  (x.v = _ =
                    (parseFloat(t.amount) ||
                      parseFloat(t.each) *
                        (b > _
                          ? _ - 1
                          : c
                          ? "y" === c
                            ? _ / b
                            : b
                          : Math.max(b, _ / b)) ||
                      0) * ("edges" === i ? -1 : 1)),
                  (x.b = _ < 0 ? r - _ : r),
                  (x.u = BM(t.amount || t.each) || 0),
                  (n = n && _ < 0 ? uT(n) : n);
              }
              return (
                (_ = (x[e] - x.min) / x.max || 0),
                qI(x.b + (n ? n(_) : _) * x.v) + x.u
              );
            }
          );
        },
        NM = function (e) {
          var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
          return function (n) {
            var i = qI(Math.round(parseFloat(n) / e) * e * t);
            return (i - (i % 1)) / t + (uI(n) ? 0 : BM(n));
          };
        },
        kM = function (e, t) {
          var n,
            i,
            r = mI(e);
          return (
            !r &&
              dI(e) &&
              ((n = r = e.radius || eI),
              e.values
                ? ((e = LM(e.values)), (i = !uI(e[0])) && (n *= n))
                : (e = NM(e.increment))),
            MM(
              t,
              r
                ? lI(e)
                  ? function (t) {
                      return (i = e(t)), Math.abs(i - t) <= n ? i : t;
                    }
                  : function (t) {
                      for (
                        var r,
                          s,
                          a = parseFloat(i ? t.x : t),
                          o = parseFloat(i ? t.y : 0),
                          c = eI,
                          l = 0,
                          u = e.length;
                        u--;

                      )
                        (r = i
                          ? (r = e[u].x - a) * r + (s = e[u].y - o) * s
                          : Math.abs(e[u] - a)) < c && ((c = r), (l = u));
                      return (
                        (l = !n || c <= n ? e[l] : t),
                        i || l === t || uI(t) ? l : l + BM(t)
                      );
                    }
                : NM(e)
            )
          );
        },
        QM = function (e, t, n, i) {
          return MM(mI(e) ? !t : !0 === n ? !!(n = 0) : !i, function () {
            return mI(e)
              ? e[~~(Math.random() * e.length)]
              : (n = n || 1e-5) &&
                  (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) &&
                  Math.floor(
                    Math.round(
                      (e - n / 2 + Math.random() * (t - e + 0.99 * n)) / n
                    ) *
                      n *
                      i
                  ) / i;
          });
        },
        GM = function (e, t, n) {
          return MM(n, function (n) {
            return e[~~t(n)];
          });
        },
        HM = function (e) {
          for (var t, n, i, r, s = 0, a = ""; ~(t = e.indexOf("random(", s)); )
            (i = e.indexOf(")", t)),
              (r = "[" === e.charAt(t + 7)),
              (n = e.substr(t + 7, i - t - 7).match(r ? EI : vI)),
              (a +=
                e.substr(s, t - s) +
                QM(r ? n : +n[0], r ? 0 : +n[1], +n[2] || 1e-5)),
              (s = i + 1);
          return a + e.substr(s, e.length - s);
        },
        zM = function (e, t, n, i, r) {
          var s = t - e,
            a = i - n;
          return MM(r, function (t) {
            return n + (((t - e) / s) * a || 0);
          });
        },
        VM = function (e, t, n) {
          var i,
            r,
            s,
            a = e.labels,
            o = eI;
          for (i in a)
            (r = a[i] - t) < 0 == !!n &&
              r &&
              o > (r = Math.abs(r)) &&
              ((s = i), (o = r));
          return s;
        },
        jM = function (e, t, n) {
          var i,
            r,
            s,
            a = e.vars,
            o = a[t],
            c = zS,
            l = e._ctx;
          if (o)
            return (
              (i = a[t + "Params"]),
              (r = a.callbackScope || e),
              n && FI.length && JI(),
              l && (zS = l),
              (s = i ? o.apply(r, i) : o.call(r)),
              (zS = c),
              s
            );
        },
        WM = function (e) {
          return (
            cM(e),
            e.scrollTrigger && e.scrollTrigger.kill(!!HS),
            e.progress() < 1 && jM(e, "onInterrupt"),
            e
          );
        },
        XM = [],
        qM = function (e) {
          if (e)
            if (((e = (!e.name && e.default) || e), fI() || e.headless)) {
              var t = e.name,
                n = lI(e),
                i =
                  t && !n && e.init
                    ? function () {
                        this._props = [];
                      }
                    : e,
                r = {
                  init: RI,
                  render: kT,
                  add: ET,
                  kill: GT,
                  modifier: QT,
                  rawVars: 0,
                },
                s = {
                  targetTest: 0,
                  get: 0,
                  getSetter: UT,
                  aliases: {},
                  register: 0,
                };
              if ((sT(), e !== i)) {
                if (NI[t]) return;
                tM(i, tM(rM(e, r), s)),
                  nM(i.prototype, nM(r, rM(e, s))),
                  (NI[(i.prop = t)] = i),
                  e.targetTest && (GI.push(i), (UI[t] = 1)),
                  (t =
                    ("css" === t
                      ? "CSS"
                      : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin");
              }
              BI(t, i), e.register && e.register(iB, i, VT);
            } else XM.push(e);
        },
        YM = 255,
        KM = {
          aqua: [0, YM, YM],
          lime: [0, YM, 0],
          silver: [192, 192, 192],
          black: [0, 0, 0],
          maroon: [128, 0, 0],
          teal: [0, 128, 128],
          blue: [0, 0, YM],
          navy: [0, 0, 128],
          white: [YM, YM, YM],
          olive: [128, 128, 0],
          yellow: [YM, YM, 0],
          orange: [YM, 165, 0],
          gray: [128, 128, 128],
          purple: [128, 0, 128],
          green: [0, 128, 0],
          red: [YM, 0, 0],
          pink: [YM, 192, 203],
          cyan: [0, YM, YM],
          transparent: [YM, YM, YM, 0],
        },
        JM = function (e, t, n) {
          return (
            ((6 * (e += e < 0 ? 1 : e > 1 ? -1 : 0) < 1
              ? t + (n - t) * e * 6
              : e < 0.5
              ? n
              : 3 * e < 2
              ? t + (n - t) * (2 / 3 - e) * 6
              : t) *
              YM +
              0.5) |
            0
          );
        },
        ZM = function (e, t, n) {
          var i,
            r,
            s,
            a,
            o,
            c,
            l,
            u,
            h,
            d,
            p = e ? (uI(e) ? [e >> 16, (e >> 8) & YM, e & YM] : 0) : KM.black;
          if (!p) {
            if (
              ("," === e.substr(-1) && (e = e.substr(0, e.length - 1)), KM[e])
            )
              p = KM[e];
            else if ("#" === e.charAt(0)) {
              if (
                (e.length < 6 &&
                  ((i = e.charAt(1)),
                  (r = e.charAt(2)),
                  (s = e.charAt(3)),
                  (e =
                    "#" +
                    i +
                    i +
                    r +
                    r +
                    s +
                    s +
                    (5 === e.length ? e.charAt(4) + e.charAt(4) : ""))),
                9 === e.length)
              )
                return [
                  (p = parseInt(e.substr(1, 6), 16)) >> 16,
                  (p >> 8) & YM,
                  p & YM,
                  parseInt(e.substr(7), 16) / 255,
                ];
              p = [
                (e = parseInt(e.substr(1), 16)) >> 16,
                (e >> 8) & YM,
                e & YM,
              ];
            } else if ("hsl" === e.substr(0, 3))
              if (((p = d = e.match(vI)), t)) {
                if (~e.indexOf("="))
                  return (p = e.match(yI)), n && p.length < 4 && (p[3] = 1), p;
              } else
                (a = (+p[0] % 360) / 360),
                  (o = +p[1] / 100),
                  (i =
                    2 * (c = +p[2] / 100) -
                    (r = c <= 0.5 ? c * (o + 1) : c + o - c * o)),
                  p.length > 3 && (p[3] *= 1),
                  (p[0] = JM(a + 1 / 3, i, r)),
                  (p[1] = JM(a, i, r)),
                  (p[2] = JM(a - 1 / 3, i, r));
            else p = e.match(vI) || KM.transparent;
            p = p.map(Number);
          }
          return (
            t &&
              !d &&
              ((i = p[0] / YM),
              (r = p[1] / YM),
              (s = p[2] / YM),
              (c = ((l = Math.max(i, r, s)) + (u = Math.min(i, r, s))) / 2),
              l === u
                ? (a = o = 0)
                : ((h = l - u),
                  (o = c > 0.5 ? h / (2 - l - u) : h / (l + u)),
                  (a =
                    l === i
                      ? (r - s) / h + (r < s ? 6 : 0)
                      : l === r
                      ? (s - i) / h + 2
                      : (i - r) / h + 4),
                  (a *= 60)),
              (p[0] = ~~(a + 0.5)),
              (p[1] = ~~(100 * o + 0.5)),
              (p[2] = ~~(100 * c + 0.5))),
            n && p.length < 4 && (p[3] = 1),
            p
          );
        },
        $M = function (e) {
          var t = [],
            n = [],
            i = -1;
          return (
            e.split(tT).forEach(function (e) {
              var r = e.match(bI) || [];
              t.push.apply(t, r), n.push((i += r.length + 1));
            }),
            (t.c = n),
            t
          );
        },
        eT = function (e, t, n) {
          var i,
            r,
            s,
            a,
            o = "",
            c = (e + o).match(tT),
            l = t ? "hsla(" : "rgba(",
            u = 0;
          if (!c) return e;
          if (
            ((c = c.map(function (e) {
              return (
                (e = ZM(e, t, 1)) &&
                l +
                  (t
                    ? e[0] + "," + e[1] + "%," + e[2] + "%," + e[3]
                    : e.join(",")) +
                  ")"
              );
            })),
            n && ((s = $M(e)), (i = n.c).join(o) !== s.c.join(o)))
          )
            for (a = (r = e.replace(tT, "1").split(bI)).length - 1; u < a; u++)
              o +=
                r[u] +
                (~i.indexOf(u)
                  ? c.shift() || l + "0,0,0,0)"
                  : (s.length ? s : c.length ? c : n).shift());
          if (!r)
            for (a = (r = e.split(tT)).length - 1; u < a; u++) o += r[u] + c[u];
          return o + r[a];
        },
        tT = (function () {
          var e,
            t =
              "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
          for (e in KM) t += "|" + e + "\\b";
          return new RegExp(t + ")", "gi");
        })(),
        nT = /hsl[a]?\(/,
        iT = function (e) {
          var t,
            n = e.join(" ");
          if (((tT.lastIndex = 0), tT.test(n)))
            return (
              (t = nT.test(n)),
              (e[1] = eT(e[1], t)),
              (e[0] = eT(e[0], t, $M(e[1]))),
              !0
            );
        },
        rT = (function () {
          var e,
            t,
            n,
            i,
            r,
            s,
            a = Date.now,
            o = 500,
            c = 33,
            l = a(),
            u = l,
            h = 1e3 / 240,
            d = h,
            p = [],
            f = function n(f) {
              var A,
                g,
                m,
                v,
                y = a() - u,
                b = !0 === f;
              if (
                ((y > o || y < 0) && (l += y - c),
                ((A = (m = (u += y) - l) - d) > 0 || b) &&
                  ((v = ++i.frame),
                  (r = m - 1e3 * i.time),
                  (i.time = m /= 1e3),
                  (d += A + (A >= h ? 4 : h - A)),
                  (g = 1)),
                b || (e = t(n)),
                g)
              )
                for (s = 0; s < p.length; s++) p[s](m, r, v, f);
            };
          return (
            (i = {
              time: 0,
              frame: 0,
              tick: function () {
                f(!0);
              },
              deltaRatio: function (e) {
                return r / (1e3 / (e || 60));
              },
              wake: function () {
                qS &&
                  (!WS &&
                    fI() &&
                    ((jS = WS = window),
                    (XS = jS.document || {}),
                    (CI.gsap = iB),
                    (jS.gsapVersions || (jS.gsapVersions = [])).push(
                      iB.version
                    ),
                    II(SI || jS.GreenSockGlobals || (!jS.gsap && jS) || {}),
                    XM.forEach(qM)),
                  (n =
                    "undefined" != typeof requestAnimationFrame &&
                    requestAnimationFrame),
                  e && i.sleep(),
                  (t =
                    n ||
                    function (e) {
                      return setTimeout(e, (d - 1e3 * i.time + 1) | 0);
                    }),
                  (JS = 1),
                  f(2));
              },
              sleep: function () {
                (n ? cancelAnimationFrame : clearTimeout)(e),
                  (JS = 0),
                  (t = RI);
              },
              lagSmoothing: function (e, t) {
                (o = e || 1 / 0), (c = Math.min(t || 33, o));
              },
              fps: function (e) {
                (h = 1e3 / (e || 240)), (d = 1e3 * i.time + h);
              },
              add: function (e, t, n) {
                var r = t
                  ? function (t, n, s, a) {
                      e(t, n, s, a), i.remove(r);
                    }
                  : e;
                return i.remove(e), p[n ? "unshift" : "push"](r), sT(), r;
              },
              remove: function (e, t) {
                ~(t = p.indexOf(e)) && p.splice(t, 1) && s >= t && s--;
              },
              _listeners: p,
            }),
            i
          );
        })(),
        sT = function () {
          return !JS && rT.wake();
        },
        aT = {},
        oT = /^[\d.\-M][\d.\-,\s]/,
        cT = /["']/g,
        lT = function (e) {
          for (
            var t,
              n,
              i,
              r = {},
              s = e.substr(1, e.length - 3).split(":"),
              a = s[0],
              o = 1,
              c = s.length;
            o < c;
            o++
          )
            (n = s[o]),
              (t = o !== c - 1 ? n.lastIndexOf(",") : n.length),
              (i = n.substr(0, t)),
              (r[a] = isNaN(i) ? i.replace(cT, "").trim() : +i),
              (a = n.substr(t + 1).trim());
          return r;
        },
        uT = function (e) {
          return function (t) {
            return 1 - e(1 - t);
          };
        },
        hT = function e(t, n) {
          for (var i, r = t._first; r; )
            r instanceof yT
              ? e(r, n)
              : !r.vars.yoyoEase ||
                (r._yoyo && r._repeat) ||
                r._yoyo === n ||
                (r.timeline
                  ? e(r.timeline, n)
                  : ((i = r._ease),
                    (r._ease = r._yEase),
                    (r._yEase = i),
                    (r._yoyo = n))),
              (r = r._next);
        },
        dT = function (e, t) {
          return (
            (e &&
              (lI(e)
                ? e
                : aT[e] ||
                  (function (e) {
                    var t,
                      n,
                      i,
                      r,
                      s = (e + "").split("("),
                      a = aT[s[0]];
                    return a && s.length > 1 && a.config
                      ? a.config.apply(
                          null,
                          ~e.indexOf("{")
                            ? [lT(s[1])]
                            : ((t = e),
                              (n = t.indexOf("(") + 1),
                              (i = t.indexOf(")")),
                              (r = t.indexOf("(", n)),
                              t.substring(
                                n,
                                ~r && r < i ? t.indexOf(")", i + 1) : i
                              ))
                                .split(",")
                                .map($I)
                        )
                      : aT._CE && oT.test(e)
                      ? aT._CE("", e)
                      : a;
                  })(e))) ||
            t
          );
        },
        pT = function (e, t, n, i) {
          void 0 === n &&
            (n = function (e) {
              return 1 - t(1 - e);
            }),
            void 0 === i &&
              (i = function (e) {
                return e < 0.5 ? t(2 * e) / 2 : 1 - t(2 * (1 - e)) / 2;
              });
          var r,
            s = { easeIn: t, easeOut: n, easeInOut: i };
          return (
            WI(e, function (e) {
              for (var t in ((aT[e] = CI[e] = s),
              (aT[(r = e.toLowerCase())] = n),
              s))
                aT[
                  r +
                    ("easeIn" === t
                      ? ".in"
                      : "easeOut" === t
                      ? ".out"
                      : ".inOut")
                ] = aT[e + "." + t] = s[t];
            }),
            s
          );
        },
        fT = function (e) {
          return function (t) {
            return t < 0.5
              ? (1 - e(1 - 2 * t)) / 2
              : 0.5 + e(2 * (t - 0.5)) / 2;
          };
        },
        AT = function e(t, n, i) {
          var r = n >= 1 ? n : 1,
            s = (i || (t ? 0.3 : 0.45)) / (n < 1 ? n : 1),
            a = (s / nI) * (Math.asin(1 / r) || 0),
            o = function (e) {
              return 1 === e
                ? 1
                : r * Math.pow(2, -10 * e) * oI((e - a) * s) + 1;
            },
            c =
              "out" === t
                ? o
                : "in" === t
                ? function (e) {
                    return 1 - o(1 - e);
                  }
                : fT(o);
          return (
            (s = nI / s),
            (c.config = function (n, i) {
              return e(t, n, i);
            }),
            c
          );
        },
        gT = function e(t, n) {
          void 0 === n && (n = 1.70158);
          var i = function (e) {
              return e ? --e * e * ((n + 1) * e + n) + 1 : 0;
            },
            r =
              "out" === t
                ? i
                : "in" === t
                ? function (e) {
                    return 1 - i(1 - e);
                  }
                : fT(i);
          return (
            (r.config = function (n) {
              return e(t, n);
            }),
            r
          );
        };
      WI("Linear,Quad,Cubic,Quart,Quint,Strong", function (e, t) {
        var n = t < 5 ? t + 1 : t;
        pT(
          e + ",Power" + (n - 1),
          t
            ? function (e) {
                return Math.pow(e, n);
              }
            : function (e) {
                return e;
              },
          function (e) {
            return 1 - Math.pow(1 - e, n);
          },
          function (e) {
            return e < 0.5
              ? Math.pow(2 * e, n) / 2
              : 1 - Math.pow(2 * (1 - e), n) / 2;
          }
        );
      }),
        (aT.Linear.easeNone = aT.none = aT.Linear.easeIn),
        pT("Elastic", AT("in"), AT("out"), AT()),
        (function (e, t) {
          var n = 1 / t,
            i = function (i) {
              return i < n
                ? e * i * i
                : i < 0.7272727272727273
                ? e * Math.pow(i - 1.5 / t, 2) + 0.75
                : i < 0.9090909090909092
                ? e * (i -= 2.25 / t) * i + 0.9375
                : e * Math.pow(i - 2.625 / t, 2) + 0.984375;
            };
          pT(
            "Bounce",
            function (e) {
              return 1 - i(1 - e);
            },
            i
          );
        })(7.5625, 2.75),
        pT("Expo", function (e) {
          return e ? Math.pow(2, 10 * (e - 1)) : 0;
        }),
        pT("Circ", function (e) {
          return -(sI(1 - e * e) - 1);
        }),
        pT("Sine", function (e) {
          return 1 === e ? 1 : 1 - aI(e * iI);
        }),
        pT("Back", gT("in"), gT("out"), gT()),
        (aT.SteppedEase =
          aT.steps =
          CI.SteppedEase =
            {
              config: function (e, t) {
                void 0 === e && (e = 1);
                var n = 1 / e,
                  i = e + (t ? 0 : 1),
                  r = t ? 1 : 0;
                return function (e) {
                  return (((i * TM(0, 0.99999999, e)) | 0) + r) * n;
                };
              },
            }),
        ($S.ease = aT["quad.out"]),
        WI(
          "onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt",
          function (e) {
            return (HI += e + "," + e + "Params,");
          }
        );
      var mT = function (e, t) {
          (this.id = rI++),
            (e._gsap = this),
            (this.target = e),
            (this.harness = t),
            (this.get = t ? t.get : jI),
            (this.set = t ? t.getSetter : UT);
        },
        vT = (function () {
          function e(e) {
            (this.vars = e),
              (this._delay = +e.delay || 0),
              (this._repeat = e.repeat === 1 / 0 ? -2 : e.repeat || 0) &&
                ((this._rDelay = e.repeatDelay || 0),
                (this._yoyo = !!e.yoyo || !!e.yoyoEase)),
              (this._ts = 1),
              EM(this, +e.duration, 1, 1),
              (this.data = e.data),
              zS && ((this._ctx = zS), zS.data.push(this)),
              JS || rT.wake();
          }
          var t = e.prototype;
          return (
            (t.delay = function (e) {
              return e || 0 === e
                ? (this.parent &&
                    this.parent.smoothChildTiming &&
                    this.startTime(this._start + e - this._delay),
                  (this._delay = e),
                  this)
                : this._delay;
            }),
            (t.duration = function (e) {
              return arguments.length
                ? this.totalDuration(
                    this._repeat > 0 ? e + (e + this._rDelay) * this._repeat : e
                  )
                : this.totalDuration() && this._dur;
            }),
            (t.totalDuration = function (e) {
              return arguments.length
                ? ((this._dirty = 0),
                  EM(
                    this,
                    this._repeat < 0
                      ? e
                      : (e - this._repeat * this._rDelay) / (this._repeat + 1)
                  ))
                : this._tDur;
            }),
            (t.totalTime = function (e, t) {
              if ((sT(), !arguments.length)) return this._tTime;
              var n = this._dp;
              if (n && n.smoothChildTiming && this._ts) {
                for (
                  gM(this, e), !n._dp || n.parent || mM(n, this);
                  n && n.parent;

                )
                  n.parent._time !==
                    n._start +
                      (n._ts >= 0
                        ? n._tTime / n._ts
                        : (n.totalDuration() - n._tTime) / -n._ts) &&
                    n.totalTime(n._tTime, !0),
                    (n = n.parent);
                !this.parent &&
                  this._dp.autoRemoveChildren &&
                  ((this._ts > 0 && e < this._tDur) ||
                    (this._ts < 0 && e > 0) ||
                    (!this._tDur && !e)) &&
                  vM(this._dp, this, this._start - this._delay);
              }
              return (
                (this._tTime !== e ||
                  (!this._dur && !t) ||
                  (this._initted && Math.abs(this._zTime) === tI) ||
                  (!e && !this._initted && (this.add || this._ptLookup))) &&
                  (this._ts || (this._pTime = e), ZI(this, e, t)),
                this
              );
            }),
            (t.time = function (e, t) {
              return arguments.length
                ? this.totalTime(
                    Math.min(this.totalDuration(), e + dM(this)) %
                      (this._dur + this._rDelay) || (e ? this._dur : 0),
                    t
                  )
                : this._time;
            }),
            (t.totalProgress = function (e, t) {
              return arguments.length
                ? this.totalTime(this.totalDuration() * e, t)
                : this.totalDuration()
                ? Math.min(1, this._tTime / this._tDur)
                : this.rawTime() > 0
                ? 1
                : 0;
            }),
            (t.progress = function (e, t) {
              return arguments.length
                ? this.totalTime(
                    this.duration() *
                      (!this._yoyo || 1 & this.iteration() ? e : 1 - e) +
                      dM(this),
                    t
                  )
                : this.duration()
                ? Math.min(1, this._time / this._dur)
                : this.rawTime() > 0
                ? 1
                : 0;
            }),
            (t.iteration = function (e, t) {
              var n = this.duration() + this._rDelay;
              return arguments.length
                ? this.totalTime(this._time + (e - 1) * n, t)
                : this._repeat
                ? pM(this._tTime, n) + 1
                : 1;
            }),
            (t.timeScale = function (e, t) {
              if (!arguments.length) return -1e-8 === this._rts ? 0 : this._rts;
              if (this._rts === e) return this;
              var n =
                this.parent && this._ts
                  ? fM(this.parent._time, this)
                  : this._tTime;
              return (
                (this._rts = +e || 0),
                (this._ts = this._ps || -1e-8 === e ? 0 : this._rts),
                this.totalTime(
                  TM(-Math.abs(this._delay), this._tDur, n),
                  !1 !== t
                ),
                AM(this),
                (function (e) {
                  for (var t = e.parent; t && t.parent; )
                    (t._dirty = 1), t.totalDuration(), (t = t.parent);
                  return e;
                })(this)
              );
            }),
            (t.paused = function (e) {
              return arguments.length
                ? (this._ps !== e &&
                    ((this._ps = e),
                    e
                      ? ((this._pTime =
                          this._tTime ||
                          Math.max(-this._delay, this.rawTime())),
                        (this._ts = this._act = 0))
                      : (sT(),
                        (this._ts = this._rts),
                        this.totalTime(
                          this.parent && !this.parent.smoothChildTiming
                            ? this.rawTime()
                            : this._tTime || this._pTime,
                          1 === this.progress() &&
                            Math.abs(this._zTime) !== tI &&
                            (this._tTime -= tI)
                        ))),
                  this)
                : this._ps;
            }),
            (t.startTime = function (e) {
              if (arguments.length) {
                this._start = e;
                var t = this.parent || this._dp;
                return (
                  t &&
                    (t._sort || !this.parent) &&
                    vM(t, this, e - this._delay),
                  this
                );
              }
              return this._start;
            }),
            (t.endTime = function (e) {
              return (
                this._start +
                (pI(e) ? this.totalDuration() : this.duration()) /
                  Math.abs(this._ts || 1)
              );
            }),
            (t.rawTime = function (e) {
              var t = this.parent || this._dp;
              return t
                ? e &&
                  (!this._ts ||
                    (this._repeat && this._time && this.totalProgress() < 1))
                  ? this._tTime % (this._dur + this._rDelay)
                  : this._ts
                  ? fM(t.rawTime(e), this)
                  : this._tTime
                : this._tTime;
            }),
            (t.revert = function (e) {
              void 0 === e && (e = LI);
              var t = HS;
              return (
                (HS = e),
                (this._initted || this._startAt) &&
                  (this.timeline && this.timeline.revert(e),
                  this.totalTime(-0.01, e.suppressEvents)),
                "nested" !== this.data && !1 !== e.kill && this.kill(),
                (HS = t),
                this
              );
            }),
            (t.globalTime = function (e) {
              for (var t = this, n = arguments.length ? e : t.rawTime(); t; )
                (n = t._start + n / (Math.abs(t._ts) || 1)), (t = t._dp);
              return !this.parent && this._sat ? this._sat.globalTime(e) : n;
            }),
            (t.repeat = function (e) {
              return arguments.length
                ? ((this._repeat = e === 1 / 0 ? -2 : e), wM(this))
                : -2 === this._repeat
                ? 1 / 0
                : this._repeat;
            }),
            (t.repeatDelay = function (e) {
              if (arguments.length) {
                var t = this._time;
                return (this._rDelay = e), wM(this), t ? this.time(t) : this;
              }
              return this._rDelay;
            }),
            (t.yoyo = function (e) {
              return arguments.length ? ((this._yoyo = e), this) : this._yoyo;
            }),
            (t.seek = function (e, t) {
              return this.totalTime(SM(this, e), pI(t));
            }),
            (t.restart = function (e, t) {
              return this.play().totalTime(e ? -this._delay : 0, pI(t));
            }),
            (t.play = function (e, t) {
              return null != e && this.seek(e, t), this.reversed(!1).paused(!1);
            }),
            (t.reverse = function (e, t) {
              return (
                null != e && this.seek(e || this.totalDuration(), t),
                this.reversed(!0).paused(!1)
              );
            }),
            (t.pause = function (e, t) {
              return null != e && this.seek(e, t), this.paused(!0);
            }),
            (t.resume = function () {
              return this.paused(!1);
            }),
            (t.reversed = function (e) {
              return arguments.length
                ? (!!e !== this.reversed() &&
                    this.timeScale(-this._rts || (e ? -1e-8 : 0)),
                  this)
                : this._rts < 0;
            }),
            (t.invalidate = function () {
              return (
                (this._initted = this._act = 0), (this._zTime = -1e-8), this
              );
            }),
            (t.isActive = function () {
              var e,
                t = this.parent || this._dp,
                n = this._start;
              return !(
                t &&
                !(
                  this._ts &&
                  this._initted &&
                  t.isActive() &&
                  (e = t.rawTime(!0)) >= n &&
                  e < this.endTime(!0) - tI
                )
              );
            }),
            (t.eventCallback = function (e, t, n) {
              var i = this.vars;
              return arguments.length > 1
                ? (t
                    ? ((i[e] = t),
                      n && (i[e + "Params"] = n),
                      "onUpdate" === e && (this._onUpdate = t))
                    : delete i[e],
                  this)
                : i[e];
            }),
            (t.then = function (e) {
              var t = this;
              return new Promise(function (n) {
                var i = lI(e) ? e : eM,
                  r = function () {
                    var e = t.then;
                    (t.then = null),
                      lI(i) &&
                        (i = i(t)) &&
                        (i.then || i === t) &&
                        (t.then = e),
                      n(i),
                      (t.then = e);
                  };
                (t._initted && 1 === t.totalProgress() && t._ts >= 0) ||
                (!t._tTime && t._ts < 0)
                  ? r()
                  : (t._prom = r);
              });
            }),
            (t.kill = function () {
              WM(this);
            }),
            e
          );
        })();
      tM(vT.prototype, {
        _time: 0,
        _start: 0,
        _end: 0,
        _tTime: 0,
        _tDur: 0,
        _dirty: 0,
        _repeat: 0,
        _yoyo: !1,
        parent: null,
        _initted: !1,
        _rDelay: 0,
        _ts: 1,
        _dp: 0,
        ratio: 0,
        _zTime: -1e-8,
        _prom: 0,
        _ps: !1,
        _rts: 1,
      });
      var yT = (function (e) {
        function t(t, n) {
          var i;
          return (
            void 0 === t && (t = {}),
            ((i = e.call(this, t) || this).labels = {}),
            (i.smoothChildTiming = !!t.smoothChildTiming),
            (i.autoRemoveChildren = !!t.autoRemoveChildren),
            (i._sort = pI(t.sortChildren)),
            VS && vM(t.parent || VS, kS(i), n),
            t.reversed && i.reverse(),
            t.paused && i.paused(!0),
            t.scrollTrigger && yM(kS(i), t.scrollTrigger),
            i
          );
        }
        QS(t, e);
        var n = t.prototype;
        return (
          (n.to = function (e, t, n) {
            return IM(0, arguments, this), this;
          }),
          (n.from = function (e, t, n) {
            return IM(1, arguments, this), this;
          }),
          (n.fromTo = function (e, t, n, i) {
            return IM(2, arguments, this), this;
          }),
          (n.set = function (e, t, n) {
            return (
              (t.duration = 0),
              (t.parent = this),
              sM(t).repeatDelay || (t.repeat = 0),
              (t.immediateRender = !!t.immediateRender),
              new BT(e, t, SM(this, n), 1),
              this
            );
          }),
          (n.call = function (e, t, n) {
            return vM(this, BT.delayedCall(0, e, t), n);
          }),
          (n.staggerTo = function (e, t, n, i, r, s, a) {
            return (
              (n.duration = t),
              (n.stagger = n.stagger || i),
              (n.onComplete = s),
              (n.onCompleteParams = a),
              (n.parent = this),
              new BT(e, n, SM(this, r)),
              this
            );
          }),
          (n.staggerFrom = function (e, t, n, i, r, s, a) {
            return (
              (n.runBackwards = 1),
              (sM(n).immediateRender = pI(n.immediateRender)),
              this.staggerTo(e, t, n, i, r, s, a)
            );
          }),
          (n.staggerFromTo = function (e, t, n, i, r, s, a, o) {
            return (
              (i.startAt = n),
              (sM(i).immediateRender = pI(i.immediateRender)),
              this.staggerTo(e, t, i, r, s, a, o)
            );
          }),
          (n.render = function (e, t, n) {
            var i,
              r,
              s,
              a,
              o,
              c,
              l,
              u,
              h,
              d,
              p,
              f,
              A = this._time,
              g = this._dirty ? this.totalDuration() : this._tDur,
              m = this._dur,
              v = e <= 0 ? 0 : qI(e),
              y = this._zTime < 0 != e < 0 && (this._initted || !m);
            if (
              (this !== VS && v > g && e >= 0 && (v = g),
              v !== this._tTime || n || y)
            ) {
              if (
                (A !== this._time &&
                  m &&
                  ((v += this._time - A), (e += this._time - A)),
                (i = v),
                (h = this._start),
                (c = !(u = this._ts)),
                y && (m || (A = this._zTime), (e || !t) && (this._zTime = e)),
                this._repeat)
              ) {
                if (
                  ((p = this._yoyo),
                  (o = m + this._rDelay),
                  this._repeat < -1 && e < 0)
                )
                  return this.totalTime(100 * o + e, t, n);
                if (
                  ((i = qI(v % o)),
                  v === g
                    ? ((a = this._repeat), (i = m))
                    : ((a = ~~(v / o)) && a === v / o && ((i = m), a--),
                      i > m && (i = m)),
                  (d = pM(this._tTime, o)),
                  !A &&
                    this._tTime &&
                    d !== a &&
                    this._tTime - d * o - this._dur <= 0 &&
                    (d = a),
                  p && 1 & a && ((i = m - i), (f = 1)),
                  a !== d && !this._lock)
                ) {
                  var b = p && 1 & d,
                    _ = b === (p && 1 & a);
                  if (
                    (a < d && (b = !b),
                    (A = b ? 0 : v % m ? m : v),
                    (this._lock = 1),
                    (this.render(A || (f ? 0 : qI(a * o)), t, !m)._lock = 0),
                    (this._tTime = v),
                    !t && this.parent && jM(this, "onRepeat"),
                    this.vars.repeatRefresh &&
                      !f &&
                      (this.invalidate()._lock = 1),
                    (A && A !== this._time) ||
                      c !== !this._ts ||
                      (this.vars.onRepeat && !this.parent && !this._act))
                  )
                    return this;
                  if (
                    ((m = this._dur),
                    (g = this._tDur),
                    _ &&
                      ((this._lock = 2),
                      (A = b ? m : -1e-4),
                      this.render(A, !0),
                      this.vars.repeatRefresh && !f && this.invalidate()),
                    (this._lock = 0),
                    !this._ts && !c)
                  )
                    return this;
                  hT(this, f);
                }
              }
              if (
                (this._hasPause &&
                  !this._forcing &&
                  this._lock < 2 &&
                  ((l = (function (e, t, n) {
                    var i;
                    if (n > t)
                      for (i = e._first; i && i._start <= n; ) {
                        if ("isPause" === i.data && i._start > t) return i;
                        i = i._next;
                      }
                    else
                      for (i = e._last; i && i._start >= n; ) {
                        if ("isPause" === i.data && i._start < t) return i;
                        i = i._prev;
                      }
                  })(this, qI(A), qI(i))),
                  l && (v -= i - (i = l._start))),
                (this._tTime = v),
                (this._time = i),
                (this._act = !u),
                this._initted ||
                  ((this._onUpdate = this.vars.onUpdate),
                  (this._initted = 1),
                  (this._zTime = e),
                  (A = 0)),
                !A && i && !t && !a && (jM(this, "onStart"), this._tTime !== v))
              )
                return this;
              if (i >= A && e >= 0)
                for (r = this._first; r; ) {
                  if (
                    ((s = r._next),
                    (r._act || i >= r._start) && r._ts && l !== r)
                  ) {
                    if (r.parent !== this) return this.render(e, t, n);
                    if (
                      (r.render(
                        r._ts > 0
                          ? (i - r._start) * r._ts
                          : (r._dirty ? r.totalDuration() : r._tDur) +
                              (i - r._start) * r._ts,
                        t,
                        n
                      ),
                      i !== this._time || (!this._ts && !c))
                    ) {
                      (l = 0), s && (v += this._zTime = -1e-8);
                      break;
                    }
                  }
                  r = s;
                }
              else {
                r = this._last;
                for (var x = e < 0 ? e : i; r; ) {
                  if (
                    ((s = r._prev), (r._act || x <= r._end) && r._ts && l !== r)
                  ) {
                    if (r.parent !== this) return this.render(e, t, n);
                    if (
                      (r.render(
                        r._ts > 0
                          ? (x - r._start) * r._ts
                          : (r._dirty ? r.totalDuration() : r._tDur) +
                              (x - r._start) * r._ts,
                        t,
                        n || (HS && (r._initted || r._startAt))
                      ),
                      i !== this._time || (!this._ts && !c))
                    ) {
                      (l = 0), s && (v += this._zTime = x ? -1e-8 : tI);
                      break;
                    }
                  }
                  r = s;
                }
              }
              if (
                l &&
                !t &&
                (this.pause(),
                (l.render(i >= A ? 0 : -1e-8)._zTime = i >= A ? 1 : -1),
                this._ts)
              )
                return (this._start = h), AM(this), this.render(e, t, n);
              this._onUpdate && !t && jM(this, "onUpdate", !0),
                ((v === g && this._tTime >= this.totalDuration()) ||
                  (!v && A)) &&
                  ((h !== this._start && Math.abs(u) === Math.abs(this._ts)) ||
                    this._lock ||
                    ((e || !m) &&
                      ((v === g && this._ts > 0) || (!v && this._ts < 0)) &&
                      cM(this, 1),
                    t ||
                      (e < 0 && !A) ||
                      (!v && !A && g) ||
                      (jM(
                        this,
                        v === g && e >= 0 ? "onComplete" : "onReverseComplete",
                        !0
                      ),
                      this._prom &&
                        !(v < g && this.timeScale() > 0) &&
                        this._prom())));
            }
            return this;
          }),
          (n.add = function (e, t) {
            var n = this;
            if ((uI(t) || (t = SM(this, t, e)), !(e instanceof vT))) {
              if (mI(e))
                return (
                  e.forEach(function (e) {
                    return n.add(e, t);
                  }),
                  this
                );
              if (cI(e)) return this.addLabel(e, t);
              if (!lI(e)) return this;
              e = BT.delayedCall(0, e);
            }
            return this !== e ? vM(this, e, t) : this;
          }),
          (n.getChildren = function (e, t, n, i) {
            void 0 === e && (e = !0),
              void 0 === t && (t = !0),
              void 0 === n && (n = !0),
              void 0 === i && (i = -eI);
            for (var r = [], s = this._first; s; )
              s._start >= i &&
                (s instanceof BT
                  ? t && r.push(s)
                  : (n && r.push(s),
                    e && r.push.apply(r, s.getChildren(!0, t, n)))),
                (s = s._next);
            return r;
          }),
          (n.getById = function (e) {
            for (var t = this.getChildren(1, 1, 1), n = t.length; n--; )
              if (t[n].vars.id === e) return t[n];
          }),
          (n.remove = function (e) {
            return cI(e)
              ? this.removeLabel(e)
              : lI(e)
              ? this.killTweensOf(e)
              : (oM(this, e),
                e === this._recent && (this._recent = this._last),
                lM(this));
          }),
          (n.totalTime = function (t, n) {
            return arguments.length
              ? ((this._forcing = 1),
                !this._dp &&
                  this._ts &&
                  (this._start = qI(
                    rT.time -
                      (this._ts > 0
                        ? t / this._ts
                        : (this.totalDuration() - t) / -this._ts)
                  )),
                e.prototype.totalTime.call(this, t, n),
                (this._forcing = 0),
                this)
              : this._tTime;
          }),
          (n.addLabel = function (e, t) {
            return (this.labels[e] = SM(this, t)), this;
          }),
          (n.removeLabel = function (e) {
            return delete this.labels[e], this;
          }),
          (n.addPause = function (e, t, n) {
            var i = BT.delayedCall(0, t || RI, n);
            return (
              (i.data = "isPause"),
              (this._hasPause = 1),
              vM(this, i, SM(this, e))
            );
          }),
          (n.removePause = function (e) {
            var t = this._first;
            for (e = SM(this, e); t; )
              t._start === e && "isPause" === t.data && cM(t), (t = t._next);
          }),
          (n.killTweensOf = function (e, t, n) {
            for (var i = this.getTweensOf(e, n), r = i.length; r--; )
              bT !== i[r] && i[r].kill(e, t);
            return this;
          }),
          (n.getTweensOf = function (e, t) {
            for (var n, i = [], r = LM(e), s = this._first, a = uI(t); s; )
              s instanceof BT
                ? KI(s._targets, r) &&
                  (a
                    ? (!bT || (s._initted && s._ts)) &&
                      s.globalTime(0) <= t &&
                      s.globalTime(s.totalDuration()) > t
                    : !t || s.isActive()) &&
                  i.push(s)
                : (n = s.getTweensOf(r, t)).length && i.push.apply(i, n),
                (s = s._next);
            return i;
          }),
          (n.tweenTo = function (e, t) {
            t = t || {};
            var n,
              i = this,
              r = SM(i, e),
              s = t,
              a = s.startAt,
              o = s.onStart,
              c = s.onStartParams,
              l = s.immediateRender,
              u = BT.to(
                i,
                tM(
                  {
                    ease: t.ease || "none",
                    lazy: !1,
                    immediateRender: !1,
                    time: r,
                    overwrite: "auto",
                    duration:
                      t.duration ||
                      Math.abs(
                        (r - (a && "time" in a ? a.time : i._time)) /
                          i.timeScale()
                      ) ||
                      tI,
                    onStart: function () {
                      if ((i.pause(), !n)) {
                        var e =
                          t.duration ||
                          Math.abs(
                            (r - (a && "time" in a ? a.time : i._time)) /
                              i.timeScale()
                          );
                        u._dur !== e && EM(u, e, 0, 1).render(u._time, !0, !0),
                          (n = 1);
                      }
                      o && o.apply(u, c || []);
                    },
                  },
                  t
                )
              );
            return l ? u.render(0) : u;
          }),
          (n.tweenFromTo = function (e, t, n) {
            return this.tweenTo(t, tM({ startAt: { time: SM(this, e) } }, n));
          }),
          (n.recent = function () {
            return this._recent;
          }),
          (n.nextLabel = function (e) {
            return void 0 === e && (e = this._time), VM(this, SM(this, e));
          }),
          (n.previousLabel = function (e) {
            return void 0 === e && (e = this._time), VM(this, SM(this, e), 1);
          }),
          (n.currentLabel = function (e) {
            return arguments.length
              ? this.seek(e, !0)
              : this.previousLabel(this._time + tI);
          }),
          (n.shiftChildren = function (e, t, n) {
            void 0 === n && (n = 0);
            for (var i, r = this._first, s = this.labels; r; )
              r._start >= n && ((r._start += e), (r._end += e)), (r = r._next);
            if (t) for (i in s) s[i] >= n && (s[i] += e);
            return lM(this);
          }),
          (n.invalidate = function (t) {
            var n = this._first;
            for (this._lock = 0; n; ) n.invalidate(t), (n = n._next);
            return e.prototype.invalidate.call(this, t);
          }),
          (n.clear = function (e) {
            void 0 === e && (e = !0);
            for (var t, n = this._first; n; )
              (t = n._next), this.remove(n), (n = t);
            return (
              this._dp && (this._time = this._tTime = this._pTime = 0),
              e && (this.labels = {}),
              lM(this)
            );
          }),
          (n.totalDuration = function (e) {
            var t,
              n,
              i,
              r = 0,
              s = this,
              a = s._last,
              o = eI;
            if (arguments.length)
              return s.timeScale(
                (s._repeat < 0 ? s.duration() : s.totalDuration()) /
                  (s.reversed() ? -e : e)
              );
            if (s._dirty) {
              for (i = s.parent; a; )
                (t = a._prev),
                  a._dirty && a.totalDuration(),
                  (n = a._start) > o && s._sort && a._ts && !s._lock
                    ? ((s._lock = 1), (vM(s, a, n - a._delay, 1)._lock = 0))
                    : (o = n),
                  n < 0 &&
                    a._ts &&
                    ((r -= n),
                    ((!i && !s._dp) || (i && i.smoothChildTiming)) &&
                      ((s._start += n / s._ts),
                      (s._time -= n),
                      (s._tTime -= n)),
                    s.shiftChildren(-n, !1, -Infinity),
                    (o = 0)),
                  a._end > r && a._ts && (r = a._end),
                  (a = t);
              EM(s, s === VS && s._time > r ? s._time : r, 1, 1),
                (s._dirty = 0);
            }
            return s._tDur;
          }),
          (t.updateRoot = function (e) {
            if (
              (VS._ts && (ZI(VS, fM(e, VS)), (YS = rT.frame)), rT.frame >= QI)
            ) {
              QI += ZS.autoSleep || 120;
              var t = VS._first;
              if ((!t || !t._ts) && ZS.autoSleep && rT._listeners.length < 2) {
                for (; t && !t._ts; ) t = t._next;
                t || rT.sleep();
              }
            }
          }),
          t
        );
      })(vT);
      tM(yT.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 });
      var bT,
        _T,
        xT = function (e, t, n, i, r, s, a) {
          var o,
            c,
            l,
            u,
            h,
            d,
            p,
            f,
            A = new VT(this._pt, e, t, 0, 1, NT, null, r),
            g = 0,
            m = 0;
          for (
            A.b = n,
              A.e = i,
              n += "",
              (p = ~(i += "").indexOf("random(")) && (i = HM(i)),
              s && (s((f = [n, i]), e, t), (n = f[0]), (i = f[1])),
              c = n.match(_I) || [];
            (o = _I.exec(i));

          )
            (u = o[0]),
              (h = i.substring(g, o.index)),
              l ? (l = (l + 1) % 5) : "rgba(" === h.substr(-5) && (l = 1),
              u !== c[m++] &&
                ((d = parseFloat(c[m - 1]) || 0),
                (A._pt = {
                  _next: A._pt,
                  p: h || 1 === m ? h : ",",
                  s: d,
                  c: "=" === u.charAt(1) ? YI(d, u) - d : parseFloat(u) - d,
                  m: l && l < 4 ? Math.round : 0,
                }),
                (g = _I.lastIndex));
          return (
            (A.c = g < i.length ? i.substring(g, i.length) : ""),
            (A.fp = a),
            (xI.test(i) || p) && (A.e = 0),
            (this._pt = A),
            A
          );
        },
        ET = function (e, t, n, i, r, s, a, o, c, l) {
          lI(i) && (i = i(r || 0, e, s));
          var u,
            h = e[t],
            d =
              "get" !== n
                ? n
                : lI(h)
                ? c
                  ? e[
                      t.indexOf("set") || !lI(e["get" + t.substr(3)])
                        ? t
                        : "get" + t.substr(3)
                    ](c)
                  : e[t]()
                : h,
            p = lI(h) ? (c ? PT : DT) : RT;
          if (
            (cI(i) &&
              (~i.indexOf("random(") && (i = HM(i)),
              "=" === i.charAt(1) &&
                ((u = YI(d, i) + (BM(d) || 0)) || 0 === u) &&
                (i = u)),
            !l || d !== i || _T)
          )
            return isNaN(d * i) || "" === i
              ? (!h && !(t in e) && MI(t, i),
                xT.call(this, e, t, d, i, p, o || ZS.stringFilter, c))
              : ((u = new VT(
                  this._pt,
                  e,
                  t,
                  +d || 0,
                  i - (d || 0),
                  "boolean" == typeof h ? OT : FT,
                  0,
                  p
                )),
                c && (u.fp = c),
                a && u.modifier(a, this, e),
                (this._pt = u));
        },
        wT = function (e, t, n, i, r, s) {
          var a, o, c, l;
          if (
            NI[e] &&
            !1 !==
              (a = new NI[e]()).init(
                r,
                a.rawVars
                  ? t[e]
                  : (function (e, t, n, i, r) {
                      if (
                        (lI(e) && (e = IT(e, r, t, n, i)),
                        !dI(e) || (e.style && e.nodeType) || mI(e) || gI(e))
                      )
                        return cI(e) ? IT(e, r, t, n, i) : e;
                      var s,
                        a = {};
                      for (s in e) a[s] = IT(e[s], r, t, n, i);
                      return a;
                    })(t[e], i, r, s, n),
                n,
                i,
                s
              ) &&
            ((n._pt = o =
              new VT(n._pt, r, e, 0, 1, a.render, a, 0, a.priority)),
            n !== KS)
          )
            for (
              c = n._ptLookup[n._targets.indexOf(r)], l = a._props.length;
              l--;

            )
              c[a._props[l]] = o;
          return a;
        },
        CT = function e(t, n, i) {
          var r,
            s,
            a,
            o,
            c,
            l,
            u,
            h,
            d,
            p,
            f,
            A,
            g,
            m = t.vars,
            v = m.ease,
            y = m.startAt,
            b = m.immediateRender,
            _ = m.lazy,
            x = m.onUpdate,
            E = m.runBackwards,
            w = m.yoyoEase,
            C = m.keyframes,
            S = m.autoRevert,
            I = t._dur,
            M = t._startAt,
            T = t._targets,
            B = t.parent,
            R = B && "nested" === B.data ? B.vars.targets : T,
            D = "auto" === t._overwrite && !GS,
            P = t.timeline;
          if (
            (P && (!C || !v) && (v = "none"),
            (t._ease = dT(v, $S.ease)),
            (t._yEase = w ? uT(dT(!0 === w ? v : w, $S.ease)) : 0),
            w &&
              t._yoyo &&
              !t._repeat &&
              ((w = t._yEase), (t._yEase = t._ease), (t._ease = w)),
            (t._from = !P && !!m.runBackwards),
            !P || (C && !m.stagger))
          ) {
            if (
              ((A = (h = T[0] ? VI(T[0]).harness : 0) && m[h.prop]),
              (r = rM(m, UI)),
              M &&
                (M._zTime < 0 && M.progress(1),
                n < 0 && E && b && !S
                  ? M.render(-1, !0)
                  : M.revert(E && I ? PI : DI),
                (M._lazy = 0)),
              y)
            ) {
              if (
                (cM(
                  (t._startAt = BT.set(
                    T,
                    tM(
                      {
                        data: "isStart",
                        overwrite: !1,
                        parent: B,
                        immediateRender: !0,
                        lazy: !M && pI(_),
                        startAt: null,
                        delay: 0,
                        onUpdate:
                          x &&
                          function () {
                            return jM(t, "onUpdate");
                          },
                        stagger: 0,
                      },
                      y
                    )
                  ))
                ),
                (t._startAt._dp = 0),
                (t._startAt._sat = t),
                n < 0 && (HS || (!b && !S)) && t._startAt.revert(PI),
                b && I && n <= 0 && i <= 0)
              )
                return void (n && (t._zTime = n));
            } else if (E && I && !M)
              if (
                (n && (b = !1),
                (a = tM(
                  {
                    overwrite: !1,
                    data: "isFromStart",
                    lazy: b && !M && pI(_),
                    immediateRender: b,
                    stagger: 0,
                    parent: B,
                  },
                  r
                )),
                A && (a[h.prop] = A),
                cM((t._startAt = BT.set(T, a))),
                (t._startAt._dp = 0),
                (t._startAt._sat = t),
                n < 0 &&
                  (HS ? t._startAt.revert(PI) : t._startAt.render(-1, !0)),
                (t._zTime = n),
                b)
              ) {
                if (!n) return;
              } else e(t._startAt, tI, tI);
            for (
              t._pt = t._ptCache = 0, _ = (I && pI(_)) || (_ && !I), s = 0;
              s < T.length;
              s++
            ) {
              if (
                ((u = (c = T[s])._gsap || zI(T)[s]._gsap),
                (t._ptLookup[s] = p = {}),
                OI[u.id] && FI.length && JI(),
                (f = R === T ? s : R.indexOf(c)),
                h &&
                  !1 !== (d = new h()).init(c, A || r, t, f, R) &&
                  ((t._pt = o =
                    new VT(t._pt, c, d.name, 0, 1, d.render, d, 0, d.priority)),
                  d._props.forEach(function (e) {
                    p[e] = o;
                  }),
                  d.priority && (l = 1)),
                !h || A)
              )
                for (a in r)
                  NI[a] && (d = wT(a, r, t, f, c, R))
                    ? d.priority && (l = 1)
                    : (p[a] = o =
                        ET.call(t, c, a, "get", r[a], f, R, 0, m.stringFilter));
              t._op && t._op[s] && t.kill(c, t._op[s]),
                D &&
                  t._pt &&
                  ((bT = t),
                  VS.killTweensOf(c, p, t.globalTime(n)),
                  (g = !t.parent),
                  (bT = 0)),
                t._pt && _ && (OI[u.id] = 1);
            }
            l && zT(t), t._onInit && t._onInit(t);
          }
          (t._onUpdate = x),
            (t._initted = (!t._op || t._pt) && !g),
            C && n <= 0 && P.render(eI, !0, !0);
        },
        ST = function (e, t, n, i) {
          var r,
            s,
            a = t.ease || i || "power1.inOut";
          if (mI(t))
            (s = n[e] || (n[e] = [])),
              t.forEach(function (e, n) {
                return s.push({ t: (n / (t.length - 1)) * 100, v: e, e: a });
              });
          else
            for (r in t)
              (s = n[r] || (n[r] = [])),
                "ease" === r || s.push({ t: parseFloat(e), v: t[r], e: a });
        },
        IT = function (e, t, n, i, r) {
          return lI(e)
            ? e.call(t, n, i, r)
            : cI(e) && ~e.indexOf("random(")
            ? HM(e)
            : e;
        },
        MT = HI + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
        TT = {};
      WI(MT + ",id,stagger,delay,duration,paused,scrollTrigger", function (e) {
        return (TT[e] = 1);
      });
      var BT = (function (e) {
        function t(t, n, i, r) {
          var s;
          "number" == typeof n && ((i.duration = n), (n = i), (i = null));
          var a,
            o,
            c,
            l,
            u,
            h,
            d,
            p,
            f = (s = e.call(this, r ? n : sM(n)) || this).vars,
            A = f.duration,
            g = f.delay,
            m = f.immediateRender,
            v = f.stagger,
            y = f.overwrite,
            b = f.keyframes,
            _ = f.defaults,
            x = f.scrollTrigger,
            E = f.yoyoEase,
            w = n.parent || VS,
            C = (mI(t) || gI(t) ? uI(t[0]) : "length" in n) ? [t] : LM(t);
          if (
            ((s._targets = C.length
              ? zI(C)
              : TI(
                  "GSAP target " + t + " not found. https://gsap.com",
                  !ZS.nullTargetWarn
                ) || []),
            (s._ptLookup = []),
            (s._overwrite = y),
            b || v || AI(A) || AI(g))
          ) {
            if (
              ((n = s.vars),
              (a = s.timeline =
                new yT({
                  data: "nested",
                  defaults: _ || {},
                  targets: w && "nested" === w.data ? w.vars.targets : C,
                })).kill(),
              (a.parent = a._dp = kS(s)),
              (a._start = 0),
              v || AI(A) || AI(g))
            ) {
              if (((l = C.length), (d = v && OM(v)), dI(v)))
                for (u in v) ~MT.indexOf(u) && (p || (p = {}), (p[u] = v[u]));
              for (o = 0; o < l; o++)
                ((c = rM(n, TT)).stagger = 0),
                  E && (c.yoyoEase = E),
                  p && nM(c, p),
                  (h = C[o]),
                  (c.duration = +IT(A, kS(s), o, h, C)),
                  (c.delay = (+IT(g, kS(s), o, h, C) || 0) - s._delay),
                  !v &&
                    1 === l &&
                    c.delay &&
                    ((s._delay = g = c.delay), (s._start += g), (c.delay = 0)),
                  a.to(h, c, d ? d(o, h, C) : 0),
                  (a._ease = aT.none);
              a.duration() ? (A = g = 0) : (s.timeline = 0);
            } else if (b) {
              sM(tM(a.vars.defaults, { ease: "none" })),
                (a._ease = dT(b.ease || n.ease || "none"));
              var S,
                I,
                M,
                T = 0;
              if (mI(b))
                b.forEach(function (e) {
                  return a.to(C, e, ">");
                }),
                  a.duration();
              else {
                for (u in ((c = {}), b))
                  "ease" === u ||
                    "easeEach" === u ||
                    ST(u, b[u], c, b.easeEach);
                for (u in c)
                  for (
                    S = c[u].sort(function (e, t) {
                      return e.t - t.t;
                    }),
                      T = 0,
                      o = 0;
                    o < S.length;
                    o++
                  )
                    ((M = {
                      ease: (I = S[o]).e,
                      duration: ((I.t - (o ? S[o - 1].t : 0)) / 100) * A,
                    })[u] = I.v),
                      a.to(C, M, T),
                      (T += M.duration);
                a.duration() < A && a.to({}, { duration: A - a.duration() });
              }
            }
            A || s.duration((A = a.duration()));
          } else s.timeline = 0;
          return (
            !0 !== y || GS || ((bT = kS(s)), VS.killTweensOf(C), (bT = 0)),
            vM(w, kS(s), i),
            n.reversed && s.reverse(),
            n.paused && s.paused(!0),
            (m ||
              (!A &&
                !b &&
                s._start === qI(w._time) &&
                pI(m) &&
                hM(kS(s)) &&
                "nested" !== w.data)) &&
              ((s._tTime = -1e-8), s.render(Math.max(0, -g) || 0)),
            x && yM(kS(s), x),
            s
          );
        }
        QS(t, e);
        var n = t.prototype;
        return (
          (n.render = function (e, t, n) {
            var i,
              r,
              s,
              a,
              o,
              c,
              l,
              u,
              h,
              d = this._time,
              p = this._tDur,
              f = this._dur,
              A = e < 0,
              g = e > p - tI && !A ? p : e < tI ? 0 : e;
            if (f) {
              if (
                g !== this._tTime ||
                !e ||
                n ||
                (!this._initted && this._tTime) ||
                (this._startAt && this._zTime < 0 !== A)
              ) {
                if (((i = g), (u = this.timeline), this._repeat)) {
                  if (((a = f + this._rDelay), this._repeat < -1 && A))
                    return this.totalTime(100 * a + e, t, n);
                  if (
                    ((i = qI(g % a)),
                    g === p
                      ? ((s = this._repeat), (i = f))
                      : ((s = ~~(g / a)) && s === qI(g / a) && ((i = f), s--),
                        i > f && (i = f)),
                    (c = this._yoyo && 1 & s) &&
                      ((h = this._yEase), (i = f - i)),
                    (o = pM(this._tTime, a)),
                    i === d && !n && this._initted && s === o)
                  )
                    return (this._tTime = g), this;
                  s !== o &&
                    (u && this._yEase && hT(u, c),
                    this.vars.repeatRefresh &&
                      !c &&
                      !this._lock &&
                      this._time !== a &&
                      this._initted &&
                      ((this._lock = n = 1),
                      (this.render(qI(a * s), !0).invalidate()._lock = 0)));
                }
                if (!this._initted) {
                  if (bM(this, A ? e : i, n, t, g))
                    return (this._tTime = 0), this;
                  if (
                    !(
                      d === this._time ||
                      (n && this.vars.repeatRefresh && s !== o)
                    )
                  )
                    return this;
                  if (f !== this._dur) return this.render(e, t, n);
                }
                if (
                  ((this._tTime = g),
                  (this._time = i),
                  !this._act && this._ts && ((this._act = 1), (this._lazy = 0)),
                  (this.ratio = l = (h || this._ease)(i / f)),
                  this._from && (this.ratio = l = 1 - l),
                  i &&
                    !d &&
                    !t &&
                    !s &&
                    (jM(this, "onStart"), this._tTime !== g))
                )
                  return this;
                for (r = this._pt; r; ) r.r(l, r.d), (r = r._next);
                (u &&
                  u.render(
                    e < 0 ? e : u._dur * u._ease(i / this._dur),
                    t,
                    n
                  )) ||
                  (this._startAt && (this._zTime = e)),
                  this._onUpdate &&
                    !t &&
                    (A && uM(this, e, 0, n), jM(this, "onUpdate")),
                  this._repeat &&
                    s !== o &&
                    this.vars.onRepeat &&
                    !t &&
                    this.parent &&
                    jM(this, "onRepeat"),
                  (g !== this._tDur && g) ||
                    this._tTime !== g ||
                    (A && !this._onUpdate && uM(this, e, 0, !0),
                    (e || !f) &&
                      ((g === this._tDur && this._ts > 0) ||
                        (!g && this._ts < 0)) &&
                      cM(this, 1),
                    t ||
                      (A && !d) ||
                      !(g || d || c) ||
                      (jM(
                        this,
                        g === p ? "onComplete" : "onReverseComplete",
                        !0
                      ),
                      this._prom &&
                        !(g < p && this.timeScale() > 0) &&
                        this._prom()));
              }
            } else
              !(function (e, t, n, i) {
                var r,
                  s,
                  a,
                  o = e.ratio,
                  c =
                    t < 0 ||
                    (!t &&
                      ((!e._start && _M(e) && (e._initted || !xM(e))) ||
                        ((e._ts < 0 || e._dp._ts < 0) && !xM(e))))
                      ? 0
                      : 1,
                  l = e._rDelay,
                  u = 0;
                if (
                  (l &&
                    e._repeat &&
                    ((u = TM(0, e._tDur, t)),
                    (s = pM(u, l)),
                    e._yoyo && 1 & s && (c = 1 - c),
                    s !== pM(e._tTime, l) &&
                      ((o = 1 - c),
                      e.vars.repeatRefresh && e._initted && e.invalidate())),
                  c !== o || HS || i || e._zTime === tI || (!t && e._zTime))
                ) {
                  if (!e._initted && bM(e, t, i, n, u)) return;
                  for (
                    a = e._zTime,
                      e._zTime = t || (n ? tI : 0),
                      n || (n = t && !a),
                      e.ratio = c,
                      e._from && (c = 1 - c),
                      e._time = 0,
                      e._tTime = u,
                      r = e._pt;
                    r;

                  )
                    r.r(c, r.d), (r = r._next);
                  t < 0 && uM(e, t, 0, !0),
                    e._onUpdate && !n && jM(e, "onUpdate"),
                    u && e._repeat && !n && e.parent && jM(e, "onRepeat"),
                    (t >= e._tDur || t < 0) &&
                      e.ratio === c &&
                      (c && cM(e, 1),
                      n ||
                        HS ||
                        (jM(e, c ? "onComplete" : "onReverseComplete", !0),
                        e._prom && e._prom()));
                } else e._zTime || (e._zTime = t);
              })(this, e, t, n);
            return this;
          }),
          (n.targets = function () {
            return this._targets;
          }),
          (n.invalidate = function (t) {
            return (
              (!t || !this.vars.runBackwards) && (this._startAt = 0),
              (this._pt =
                this._op =
                this._onUpdate =
                this._lazy =
                this.ratio =
                  0),
              (this._ptLookup = []),
              this.timeline && this.timeline.invalidate(t),
              e.prototype.invalidate.call(this, t)
            );
          }),
          (n.resetTo = function (e, t, n, i, r) {
            JS || rT.wake(), this._ts || this.play();
            var s = Math.min(
              this._dur,
              (this._dp._time - this._start) * this._ts
            );
            return (
              this._initted || CT(this, s),
              (function (e, t, n, i, r, s, a, o) {
                var c,
                  l,
                  u,
                  h,
                  d = ((e._pt && e._ptCache) || (e._ptCache = {}))[t];
                if (!d)
                  for (
                    d = e._ptCache[t] = [],
                      u = e._ptLookup,
                      h = e._targets.length;
                    h--;

                  ) {
                    if ((c = u[h][t]) && c.d && c.d._pt)
                      for (c = c.d._pt; c && c.p !== t && c.fp !== t; )
                        c = c._next;
                    if (!c)
                      return (
                        (_T = 1),
                        (e.vars[t] = "+=0"),
                        CT(e, a),
                        (_T = 0),
                        o ? TI(t + " not eligible for reset") : 1
                      );
                    d.push(c);
                  }
                for (h = d.length; h--; )
                  ((c = (l = d[h])._pt || l).s =
                    (!i && 0 !== i) || r ? c.s + (i || 0) + s * c.c : i),
                    (c.c = n - c.s),
                    l.e && (l.e = XI(n) + BM(l.e)),
                    l.b && (l.b = c.s + BM(l.b));
              })(this, e, t, n, i, this._ease(s / this._dur), s, r)
                ? this.resetTo(e, t, n, i, 1)
                : (gM(this, 0),
                  this.parent ||
                    aM(
                      this._dp,
                      this,
                      "_first",
                      "_last",
                      this._dp._sort ? "_start" : 0
                    ),
                  this.render(0))
            );
          }),
          (n.kill = function (e, t) {
            if ((void 0 === t && (t = "all"), !(e || (t && "all" !== t))))
              return (this._lazy = this._pt = 0), this.parent ? WM(this) : this;
            if (this.timeline) {
              var n = this.timeline.totalDuration();
              return (
                this.timeline.killTweensOf(e, t, bT && !0 !== bT.vars.overwrite)
                  ._first || WM(this),
                this.parent &&
                  n !== this.timeline.totalDuration() &&
                  EM(this, (this._dur * this.timeline._tDur) / n, 0, 1),
                this
              );
            }
            var i,
              r,
              s,
              a,
              o,
              c,
              l,
              u = this._targets,
              h = e ? LM(e) : u,
              d = this._ptLookup,
              p = this._pt;
            if (
              (!t || "all" === t) &&
              (function (e, t) {
                for (
                  var n = e.length, i = n === t.length;
                  i && n-- && e[n] === t[n];

                );
                return n < 0;
              })(u, h)
            )
              return "all" === t && (this._pt = 0), WM(this);
            for (
              i = this._op = this._op || [],
                "all" !== t &&
                  (cI(t) &&
                    ((o = {}),
                    WI(t, function (e) {
                      return (o[e] = 1);
                    }),
                    (t = o)),
                  (t = (function (e, t) {
                    var n,
                      i,
                      r,
                      s,
                      a = e[0] ? VI(e[0]).harness : 0,
                      o = a && a.aliases;
                    if (!o) return t;
                    for (i in ((n = nM({}, t)), o))
                      if ((i in n))
                        for (r = (s = o[i].split(",")).length; r--; )
                          n[s[r]] = n[i];
                    return n;
                  })(u, t))),
                l = u.length;
              l--;

            )
              if (~h.indexOf(u[l]))
                for (o in ((r = d[l]),
                "all" === t
                  ? ((i[l] = t), (a = r), (s = {}))
                  : ((s = i[l] = i[l] || {}), (a = t)),
                a))
                  (c = r && r[o]) &&
                    (("kill" in c.d && !0 !== c.d.kill(o)) ||
                      oM(this, c, "_pt"),
                    delete r[o]),
                    "all" !== s && (s[o] = 1);
            return this._initted && !this._pt && p && WM(this), this;
          }),
          (t.to = function (e, n) {
            return new t(e, n, arguments[2]);
          }),
          (t.from = function (e, t) {
            return IM(1, arguments);
          }),
          (t.delayedCall = function (e, n, i, r) {
            return new t(n, 0, {
              immediateRender: !1,
              lazy: !1,
              overwrite: !1,
              delay: e,
              onComplete: n,
              onReverseComplete: n,
              onCompleteParams: i,
              onReverseCompleteParams: i,
              callbackScope: r,
            });
          }),
          (t.fromTo = function (e, t, n) {
            return IM(2, arguments);
          }),
          (t.set = function (e, n) {
            return (
              (n.duration = 0), n.repeatDelay || (n.repeat = 0), new t(e, n)
            );
          }),
          (t.killTweensOf = function (e, t, n) {
            return VS.killTweensOf(e, t, n);
          }),
          t
        );
      })(vT);
      tM(BT.prototype, {
        _targets: [],
        _lazy: 0,
        _startAt: 0,
        _op: 0,
        _onInit: 0,
      }),
        WI("staggerTo,staggerFrom,staggerFromTo", function (e) {
          BT[e] = function () {
            var t = new yT(),
              n = RM.call(arguments, 0);
            return (
              n.splice("staggerFromTo" === e ? 5 : 4, 0, 0), t[e].apply(t, n)
            );
          };
        });
      var RT = function (e, t, n) {
          return (e[t] = n);
        },
        DT = function (e, t, n) {
          return e[t](n);
        },
        PT = function (e, t, n, i) {
          return e[t](i.fp, n);
        },
        LT = function (e, t, n) {
          return e.setAttribute(t, n);
        },
        UT = function (e, t) {
          return lI(e[t]) ? DT : hI(e[t]) && e.setAttribute ? LT : RT;
        },
        FT = function (e, t) {
          return t.set(t.t, t.p, Math.round(1e6 * (t.s + t.c * e)) / 1e6, t);
        },
        OT = function (e, t) {
          return t.set(t.t, t.p, !!(t.s + t.c * e), t);
        },
        NT = function (e, t) {
          var n = t._pt,
            i = "";
          if (!e && t.b) i = t.b;
          else if (1 === e && t.e) i = t.e;
          else {
            for (; n; )
              (i =
                n.p +
                (n.m
                  ? n.m(n.s + n.c * e)
                  : Math.round(1e4 * (n.s + n.c * e)) / 1e4) +
                i),
                (n = n._next);
            i += t.c;
          }
          t.set(t.t, t.p, i, t);
        },
        kT = function (e, t) {
          for (var n = t._pt; n; ) n.r(e, n.d), (n = n._next);
        },
        QT = function (e, t, n, i) {
          for (var r, s = this._pt; s; )
            (r = s._next), s.p === i && s.modifier(e, t, n), (s = r);
        },
        GT = function (e) {
          for (var t, n, i = this._pt; i; )
            (n = i._next),
              (i.p === e && !i.op) || i.op === e
                ? oM(this, i, "_pt")
                : i.dep || (t = 1),
              (i = n);
          return !t;
        },
        HT = function (e, t, n, i) {
          i.mSet(e, t, i.m.call(i.tween, n, i.mt), i);
        },
        zT = function (e) {
          for (var t, n, i, r, s = e._pt; s; ) {
            for (t = s._next, n = i; n && n.pr > s.pr; ) n = n._next;
            (s._prev = n ? n._prev : r) ? (s._prev._next = s) : (i = s),
              (s._next = n) ? (n._prev = s) : (r = s),
              (s = t);
          }
          e._pt = i;
        },
        VT = (function () {
          function e(e, t, n, i, r, s, a, o, c) {
            (this.t = t),
              (this.s = i),
              (this.c = r),
              (this.p = n),
              (this.r = s || FT),
              (this.d = a || this),
              (this.set = o || RT),
              (this.pr = c || 0),
              (this._next = e),
              e && (e._prev = this);
          }
          return (
            (e.prototype.modifier = function (e, t, n) {
              (this.mSet = this.mSet || this.set),
                (this.set = HT),
                (this.m = e),
                (this.mt = n),
                (this.tween = t);
            }),
            e
          );
        })();
      WI(
        HI +
          "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger",
        function (e) {
          return (UI[e] = 1);
        }
      ),
        (CI.TweenMax = CI.TweenLite = BT),
        (CI.TimelineLite = CI.TimelineMax = yT),
        (VS = new yT({
          sortChildren: !1,
          defaults: $S,
          autoRemoveChildren: !0,
          id: "root",
          smoothChildTiming: !0,
        })),
        (ZS.stringFilter = iT);
      var jT = [],
        WT = {},
        XT = [],
        qT = 0,
        YT = 0,
        KT = function (e) {
          return (WT[e] || XT).map(function (e) {
            return e();
          });
        },
        JT = function () {
          var e = Date.now(),
            t = [];
          e - qT > 2 &&
            (KT("matchMediaInit"),
            jT.forEach(function (e) {
              var n,
                i,
                r,
                s,
                a = e.queries,
                o = e.conditions;
              for (i in a)
                (n = jS.matchMedia(a[i]).matches) && (r = 1),
                  n !== o[i] && ((o[i] = n), (s = 1));
              s && (e.revert(), r && t.push(e));
            }),
            KT("matchMediaRevert"),
            t.forEach(function (e) {
              return e.onMatch(e, function (t) {
                return e.add(null, t);
              });
            }),
            (qT = e),
            KT("matchMedia"));
        },
        ZT = (function () {
          function e(e, t) {
            (this.selector = t && UM(t)),
              (this.data = []),
              (this._r = []),
              (this.isReverted = !1),
              (this.id = YT++),
              e && this.add(e);
          }
          var t = e.prototype;
          return (
            (t.add = function (e, t, n) {
              lI(e) && ((n = t), (t = e), (e = lI));
              var i = this,
                r = function () {
                  var e,
                    r = zS,
                    s = i.selector;
                  return (
                    r && r !== i && r.data.push(i),
                    n && (i.selector = UM(n)),
                    (zS = i),
                    (e = t.apply(i, arguments)),
                    lI(e) && i._r.push(e),
                    (zS = r),
                    (i.selector = s),
                    (i.isReverted = !1),
                    e
                  );
                };
              return (
                (i.last = r),
                e === lI
                  ? r(i, function (e) {
                      return i.add(null, e);
                    })
                  : e
                  ? (i[e] = r)
                  : r
              );
            }),
            (t.ignore = function (e) {
              var t = zS;
              (zS = null), e(this), (zS = t);
            }),
            (t.getTweens = function () {
              var t = [];
              return (
                this.data.forEach(function (n) {
                  return n instanceof e
                    ? t.push.apply(t, n.getTweens())
                    : n instanceof BT &&
                        !(n.parent && "nested" === n.parent.data) &&
                        t.push(n);
                }),
                t
              );
            }),
            (t.clear = function () {
              this._r.length = this.data.length = 0;
            }),
            (t.kill = function (e, t) {
              var n = this;
              if (
                (e
                  ? (function () {
                      for (var t, i = n.getTweens(), r = n.data.length; r--; )
                        "isFlip" === (t = n.data[r]).data &&
                          (t.revert(),
                          t.getChildren(!0, !0, !1).forEach(function (e) {
                            return i.splice(i.indexOf(e), 1);
                          }));
                      for (
                        i
                          .map(function (e) {
                            return {
                              g:
                                e._dur ||
                                e._delay ||
                                (e._sat && !e._sat.vars.immediateRender)
                                  ? e.globalTime(0)
                                  : -1 / 0,
                              t: e,
                            };
                          })
                          .sort(function (e, t) {
                            return t.g - e.g || -1 / 0;
                          })
                          .forEach(function (t) {
                            return t.t.revert(e);
                          }),
                          r = n.data.length;
                        r--;

                      )
                        (t = n.data[r]) instanceof yT
                          ? "nested" !== t.data &&
                            (t.scrollTrigger && t.scrollTrigger.revert(),
                            t.kill())
                          : !(t instanceof BT) && t.revert && t.revert(e);
                      n._r.forEach(function (t) {
                        return t(e, n);
                      }),
                        (n.isReverted = !0);
                    })()
                  : this.data.forEach(function (e) {
                      return e.kill && e.kill();
                    }),
                this.clear(),
                t)
              )
                for (var i = jT.length; i--; )
                  jT[i].id === this.id && jT.splice(i, 1);
            }),
            (t.revert = function (e) {
              this.kill(e || {});
            }),
            e
          );
        })(),
        $T = (function () {
          function e(e) {
            (this.contexts = []), (this.scope = e), zS && zS.data.push(this);
          }
          var t = e.prototype;
          return (
            (t.add = function (e, t, n) {
              dI(e) || (e = { matches: e });
              var i,
                r,
                s,
                a = new ZT(0, n || this.scope),
                o = (a.conditions = {});
              for (r in (zS && !a.selector && (a.selector = zS.selector),
              this.contexts.push(a),
              (t = a.add("onMatch", t)),
              (a.queries = e),
              e))
                "all" === r
                  ? (s = 1)
                  : (i = jS.matchMedia(e[r])) &&
                    (jT.indexOf(a) < 0 && jT.push(a),
                    (o[r] = i.matches) && (s = 1),
                    i.addListener
                      ? i.addListener(JT)
                      : i.addEventListener("change", JT));
              return (
                s &&
                  t(a, function (e) {
                    return a.add(null, e);
                  }),
                this
              );
            }),
            (t.revert = function (e) {
              this.kill(e || {});
            }),
            (t.kill = function (e) {
              this.contexts.forEach(function (t) {
                return t.kill(e, !0);
              });
            }),
            e
          );
        })(),
        eB = {
          registerPlugin: function () {
            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
              t[n] = arguments[n];
            t.forEach(function (e) {
              return qM(e);
            });
          },
          timeline: function (e) {
            return new yT(e);
          },
          getTweensOf: function (e, t) {
            return VS.getTweensOf(e, t);
          },
          getProperty: function (e, t, n, i) {
            cI(e) && (e = LM(e)[0]);
            var r = VI(e || {}).get,
              s = n ? eM : $I;
            return (
              "native" === n && (n = ""),
              e
                ? t
                  ? s(((NI[t] && NI[t].get) || r)(e, t, n, i))
                  : function (t, n, i) {
                      return s(((NI[t] && NI[t].get) || r)(e, t, n, i));
                    }
                : e
            );
          },
          quickSetter: function (e, t, n) {
            if ((e = LM(e)).length > 1) {
              var i = e.map(function (e) {
                  return iB.quickSetter(e, t, n);
                }),
                r = i.length;
              return function (e) {
                for (var t = r; t--; ) i[t](e);
              };
            }
            e = e[0] || {};
            var s = NI[t],
              a = VI(e),
              o = (a.harness && (a.harness.aliases || {})[t]) || t,
              c = s
                ? function (t) {
                    var i = new s();
                    (KS._pt = 0),
                      i.init(e, n ? t + n : t, KS, 0, [e]),
                      i.render(1, i),
                      KS._pt && kT(1, KS);
                  }
                : a.set(e, o);
            return s
              ? c
              : function (t) {
                  return c(e, o, n ? t + n : t, a, 1);
                };
          },
          quickTo: function (e, t, n) {
            var i,
              r = iB.to(
                e,
                nM((((i = {})[t] = "+=0.1"), (i.paused = !0), i), n || {})
              ),
              s = function (e, n, i) {
                return r.resetTo(t, e, n, i);
              };
            return (s.tween = r), s;
          },
          isTweening: function (e) {
            return VS.getTweensOf(e, !0).length > 0;
          },
          defaults: function (e) {
            return (
              e && e.ease && (e.ease = dT(e.ease, $S.ease)), iM($S, e || {})
            );
          },
          config: function (e) {
            return iM(ZS, e || {});
          },
          registerEffect: function (e) {
            var t = e.name,
              n = e.effect,
              i = e.plugins,
              r = e.defaults,
              s = e.extendTimeline;
            (i || "").split(",").forEach(function (e) {
              return (
                e &&
                !NI[e] &&
                !CI[e] &&
                TI(t + " effect requires " + e + " plugin.")
              );
            }),
              (kI[t] = function (e, t, i) {
                return n(LM(e), tM(t || {}, r), i);
              }),
              s &&
                (yT.prototype[t] = function (e, n, i) {
                  return this.add(kI[t](e, dI(n) ? n : (i = n) && {}, this), i);
                });
          },
          registerEase: function (e, t) {
            aT[e] = dT(t);
          },
          parseEase: function (e, t) {
            return arguments.length ? dT(e, t) : aT;
          },
          getById: function (e) {
            return VS.getById(e);
          },
          exportRoot: function (e, t) {
            void 0 === e && (e = {});
            var n,
              i,
              r = new yT(e);
            for (
              r.smoothChildTiming = pI(e.smoothChildTiming),
                VS.remove(r),
                r._dp = 0,
                r._time = r._tTime = VS._time,
                n = VS._first;
              n;

            )
              (i = n._next),
                (!t &&
                  !n._dur &&
                  n instanceof BT &&
                  n.vars.onComplete === n._targets[0]) ||
                  vM(r, n, n._start - n._delay),
                (n = i);
            return vM(VS, r, 0), r;
          },
          context: function (e, t) {
            return e ? new ZT(e, t) : zS;
          },
          matchMedia: function (e) {
            return new $T(e);
          },
          matchMediaRefresh: function () {
            return (
              jT.forEach(function (e) {
                var t,
                  n,
                  i = e.conditions;
                for (n in i) i[n] && ((i[n] = !1), (t = 1));
                t && e.revert();
              }) || JT()
            );
          },
          addEventListener: function (e, t) {
            var n = WT[e] || (WT[e] = []);
            ~n.indexOf(t) || n.push(t);
          },
          removeEventListener: function (e, t) {
            var n = WT[e],
              i = n && n.indexOf(t);
            i >= 0 && n.splice(i, 1);
          },
          utils: {
            wrap: function e(t, n, i) {
              var r = n - t;
              return mI(t)
                ? GM(t, e(0, t.length), n)
                : MM(i, function (e) {
                    return ((r + ((e - t) % r)) % r) + t;
                  });
            },
            wrapYoyo: function e(t, n, i) {
              var r = n - t,
                s = 2 * r;
              return mI(t)
                ? GM(t, e(0, t.length - 1), n)
                : MM(i, function (e) {
                    return (
                      t + ((e = (s + ((e - t) % s)) % s || 0) > r ? s - e : e)
                    );
                  });
            },
            distribute: OM,
            random: QM,
            snap: kM,
            normalize: function (e, t, n) {
              return zM(e, t, 0, 1, n);
            },
            getUnit: BM,
            clamp: function (e, t, n) {
              return MM(n, function (n) {
                return TM(e, t, n);
              });
            },
            splitColor: ZM,
            toArray: LM,
            selector: UM,
            mapRange: zM,
            pipe: function () {
              for (
                var e = arguments.length, t = new Array(e), n = 0;
                n < e;
                n++
              )
                t[n] = arguments[n];
              return function (e) {
                return t.reduce(function (e, t) {
                  return t(e);
                }, e);
              };
            },
            unitize: function (e, t) {
              return function (n) {
                return e(parseFloat(n)) + (t || BM(n));
              };
            },
            interpolate: function e(t, n, i, r) {
              var s = isNaN(t + n)
                ? 0
                : function (e) {
                    return (1 - e) * t + e * n;
                  };
              if (!s) {
                var a,
                  o,
                  c,
                  l,
                  u,
                  h = cI(t),
                  d = {};
                if ((!0 === i && (r = 1) && (i = null), h))
                  (t = { p: t }), (n = { p: n });
                else if (mI(t) && !mI(n)) {
                  for (c = [], l = t.length, u = l - 2, o = 1; o < l; o++)
                    c.push(e(t[o - 1], t[o]));
                  l--,
                    (s = function (e) {
                      e *= l;
                      var t = Math.min(u, ~~e);
                      return c[t](e - t);
                    }),
                    (i = n);
                } else r || (t = nM(mI(t) ? [] : {}, t));
                if (!c) {
                  for (a in n) ET.call(d, t, a, "get", n[a]);
                  s = function (e) {
                    return kT(e, d) || (h ? t.p : t);
                  };
                }
              }
              return MM(i, s);
            },
            shuffle: FM,
          },
          install: II,
          effects: kI,
          ticker: rT,
          updateRoot: yT.updateRoot,
          plugins: NI,
          globalTimeline: VS,
          core: {
            PropTween: VT,
            globals: BI,
            Tween: BT,
            Timeline: yT,
            Animation: vT,
            getCache: VI,
            _removeLinkedListItem: oM,
            reverting: function () {
              return HS;
            },
            context: function (e) {
              return e && zS && (zS.data.push(e), (e._ctx = zS)), zS;
            },
            suppressOverwrites: function (e) {
              return (GS = e);
            },
          },
        };
      WI("to,from,fromTo,delayedCall,set,killTweensOf", function (e) {
        return (eB[e] = BT[e]);
      }),
        rT.add(yT.updateRoot),
        (KS = eB.to({}, { duration: 0 }));
      var tB = function (e, t) {
          for (var n = e._pt; n && n.p !== t && n.op !== t && n.fp !== t; )
            n = n._next;
          return n;
        },
        nB = function (e, t) {
          return {
            name: e,
            rawVars: 1,
            init: function (e, n, i) {
              i._onInit = function (e) {
                var i, r;
                if (
                  (cI(n) &&
                    ((i = {}),
                    WI(n, function (e) {
                      return (i[e] = 1);
                    }),
                    (n = i)),
                  t)
                ) {
                  for (r in ((i = {}), n)) i[r] = t(n[r]);
                  n = i;
                }
                !(function (e, t) {
                  var n,
                    i,
                    r,
                    s = e._targets;
                  for (n in t)
                    for (i = s.length; i--; )
                      (r = e._ptLookup[i][n]) &&
                        (r = r.d) &&
                        (r._pt && (r = tB(r, n)),
                        r && r.modifier && r.modifier(t[n], e, s[i], n));
                })(e, n);
              };
            },
          };
        },
        iB =
          eB.registerPlugin(
            {
              name: "attr",
              init: function (e, t, n, i, r) {
                var s, a, o;
                for (s in ((this.tween = n), t))
                  (o = e.getAttribute(s) || ""),
                    ((a = this.add(
                      e,
                      "setAttribute",
                      (o || 0) + "",
                      t[s],
                      i,
                      r,
                      0,
                      0,
                      s
                    )).op = s),
                    (a.b = o),
                    this._props.push(s);
              },
              render: function (e, t) {
                for (var n = t._pt; n; )
                  HS ? n.set(n.t, n.p, n.b, n) : n.r(e, n.d), (n = n._next);
              },
            },
            {
              name: "endArray",
              init: function (e, t) {
                for (var n = t.length; n--; )
                  this.add(e, n, e[n] || 0, t[n], 0, 0, 0, 0, 0, 1);
              },
            },
            nB("roundProps", NM),
            nB("modifiers"),
            nB("snap", kM)
          ) || eB;
      (BT.version = yT.version = iB.version = "3.12.5"), (qS = 1), fI() && sT();
      aT.Power0,
        aT.Power1,
        aT.Power2,
        aT.Power3,
        aT.Power4,
        aT.Linear,
        aT.Quad,
        aT.Cubic,
        aT.Quart,
        aT.Quint,
        aT.Strong,
        aT.Elastic,
        aT.Back,
        aT.SteppedEase,
        aT.Bounce,
        aT.Sine,
        aT.Expo,
        aT.Circ;
      var rB,
        sB,
        aB,
        oB,
        cB,
        lB,
        uB,
        hB,
        dB = {},
        pB = 180 / Math.PI,
        fB = Math.PI / 180,
        AB = Math.atan2,
        gB = /([A-Z])/g,
        mB = /(left|right|width|margin|padding|x)/i,
        vB = /[\s,\(]\S/,
        yB = {
          autoAlpha: "opacity,visibility",
          scale: "scaleX,scaleY",
          alpha: "opacity",
        },
        bB = function (e, t) {
          return t.set(
            t.t,
            t.p,
            Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u,
            t
          );
        },
        _B = function (e, t) {
          return t.set(
            t.t,
            t.p,
            1 === e ? t.e : Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u,
            t
          );
        },
        xB = function (e, t) {
          return t.set(
            t.t,
            t.p,
            e ? Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u : t.b,
            t
          );
        },
        EB = function (e, t) {
          var n = t.s + t.c * e;
          t.set(t.t, t.p, ~~(n + (n < 0 ? -0.5 : 0.5)) + t.u, t);
        },
        wB = function (e, t) {
          return t.set(t.t, t.p, e ? t.e : t.b, t);
        },
        CB = function (e, t) {
          return t.set(t.t, t.p, 1 !== e ? t.b : t.e, t);
        },
        SB = function (e, t, n) {
          return (e.style[t] = n);
        },
        IB = function (e, t, n) {
          return e.style.setProperty(t, n);
        },
        MB = function (e, t, n) {
          return (e._gsap[t] = n);
        },
        TB = function (e, t, n) {
          return (e._gsap.scaleX = e._gsap.scaleY = n);
        },
        BB = function (e, t, n, i, r) {
          var s = e._gsap;
          (s.scaleX = s.scaleY = n), s.renderTransform(r, s);
        },
        RB = function (e, t, n, i, r) {
          var s = e._gsap;
          (s[t] = n), s.renderTransform(r, s);
        },
        DB = "transform",
        PB = DB + "Origin",
        LB = function e(t, n) {
          var i = this,
            r = this.target,
            s = r.style,
            a = r._gsap;
          if (t in dB && s) {
            if (((this.tfm = this.tfm || {}), "transform" === t))
              return yB.transform.split(",").forEach(function (t) {
                return e.call(i, t, n);
              });
            if (
              (~(t = yB[t] || t).indexOf(",")
                ? t.split(",").forEach(function (e) {
                    return (i.tfm[e] = ZB(r, e));
                  })
                : (this.tfm[t] = a.x ? a[t] : ZB(r, t)),
              t === PB && (this.tfm.zOrigin = a.zOrigin),
              this.props.indexOf(DB) >= 0)
            )
              return;
            a.svg &&
              ((this.svgo = r.getAttribute("data-svg-origin")),
              this.props.push(PB, n, "")),
              (t = DB);
          }
          (s || n) && this.props.push(t, n, s[t]);
        },
        UB = function (e) {
          e.translate &&
            (e.removeProperty("translate"),
            e.removeProperty("scale"),
            e.removeProperty("rotate"));
        },
        FB = function () {
          var e,
            t,
            n = this.props,
            i = this.target,
            r = i.style,
            s = i._gsap;
          for (e = 0; e < n.length; e += 3)
            n[e + 1]
              ? (i[n[e]] = n[e + 2])
              : n[e + 2]
              ? (r[n[e]] = n[e + 2])
              : r.removeProperty(
                  "--" === n[e].substr(0, 2)
                    ? n[e]
                    : n[e].replace(gB, "-$1").toLowerCase()
                );
          if (this.tfm) {
            for (t in this.tfm) s[t] = this.tfm[t];
            s.svg &&
              (s.renderTransform(),
              i.setAttribute("data-svg-origin", this.svgo || "")),
              ((e = uB()) && e.isStart) ||
                r[DB] ||
                (UB(r),
                s.zOrigin &&
                  r[PB] &&
                  ((r[PB] += " " + s.zOrigin + "px"),
                  (s.zOrigin = 0),
                  s.renderTransform()),
                (s.uncache = 1));
          }
        },
        OB = function (e, t) {
          var n = { target: e, props: [], revert: FB, save: LB };
          return (
            e._gsap || iB.core.getCache(e),
            t &&
              t.split(",").forEach(function (e) {
                return n.save(e);
              }),
            n
          );
        },
        NB = function (e, t) {
          var n = sB.createElementNS
            ? sB.createElementNS(
                (t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"),
                e
              )
            : sB.createElement(e);
          return n && n.style ? n : sB.createElement(e);
        },
        kB = function e(t, n, i) {
          var r = getComputedStyle(t);
          return (
            r[n] ||
            r.getPropertyValue(n.replace(gB, "-$1").toLowerCase()) ||
            r.getPropertyValue(n) ||
            (!i && e(t, GB(n) || n, 1)) ||
            ""
          );
        },
        QB = "O,Moz,ms,Ms,Webkit".split(","),
        GB = function (e, t, n) {
          var i = (t || cB).style,
            r = 5;
          if (e in i && !n) return e;
          for (
            e = e.charAt(0).toUpperCase() + e.substr(1);
            r-- && !(QB[r] + e in i);

          );
          return r < 0 ? null : (3 === r ? "ms" : r >= 0 ? QB[r] : "") + e;
        },
        HB = function () {
          "undefined" != typeof window &&
            window.document &&
            ((rB = window),
            (sB = rB.document),
            (aB = sB.documentElement),
            (cB = NB("div") || { style: {} }),
            NB("div"),
            (DB = GB(DB)),
            (PB = DB + "Origin"),
            (cB.style.cssText =
              "border-width:0;line-height:0;position:absolute;padding:0"),
            (hB = !!GB("perspective")),
            (uB = iB.core.reverting),
            (oB = 1));
        },
        zB = function e(t) {
          var n,
            i = NB(
              "svg",
              (this.ownerSVGElement &&
                this.ownerSVGElement.getAttribute("xmlns")) ||
                "http://www.w3.org/2000/svg"
            ),
            r = this.parentNode,
            s = this.nextSibling,
            a = this.style.cssText;
          if (
            (aB.appendChild(i),
            i.appendChild(this),
            (this.style.display = "block"),
            t)
          )
            try {
              (n = this.getBBox()),
                (this._gsapBBox = this.getBBox),
                (this.getBBox = e);
            } catch (e) {}
          else this._gsapBBox && (n = this._gsapBBox());
          return (
            r && (s ? r.insertBefore(this, s) : r.appendChild(this)),
            aB.removeChild(i),
            (this.style.cssText = a),
            n
          );
        },
        VB = function (e, t) {
          for (var n = t.length; n--; )
            if (e.hasAttribute(t[n])) return e.getAttribute(t[n]);
        },
        jB = function (e) {
          var t;
          try {
            t = e.getBBox();
          } catch (n) {
            t = zB.call(e, !0);
          }
          return (
            (t && (t.width || t.height)) ||
              e.getBBox === zB ||
              (t = zB.call(e, !0)),
            !t || t.width || t.x || t.y
              ? t
              : {
                  x: +VB(e, ["x", "cx", "x1"]) || 0,
                  y: +VB(e, ["y", "cy", "y1"]) || 0,
                  width: 0,
                  height: 0,
                }
          );
        },
        WB = function (e) {
          return !(!e.getCTM || (e.parentNode && !e.ownerSVGElement) || !jB(e));
        },
        XB = function (e, t) {
          if (t) {
            var n,
              i = e.style;
            t in dB && t !== PB && (t = DB),
              i.removeProperty
                ? (("ms" !== (n = t.substr(0, 2)) &&
                    "webkit" !== t.substr(0, 6)) ||
                    (t = "-" + t),
                  i.removeProperty(
                    "--" === n ? t : t.replace(gB, "-$1").toLowerCase()
                  ))
                : i.removeAttribute(t);
          }
        },
        qB = function (e, t, n, i, r, s) {
          var a = new VT(e._pt, t, n, 0, 1, s ? CB : wB);
          return (e._pt = a), (a.b = i), (a.e = r), e._props.push(n), a;
        },
        YB = { deg: 1, rad: 1, turn: 1 },
        KB = { grid: 1, flex: 1 },
        JB = function e(t, n, i, r) {
          var s,
            a,
            o,
            c,
            l = parseFloat(i) || 0,
            u = (i + "").trim().substr((l + "").length) || "px",
            h = cB.style,
            d = mB.test(n),
            p = "svg" === t.tagName.toLowerCase(),
            f = (p ? "client" : "offset") + (d ? "Width" : "Height"),
            A = 100,
            g = "px" === r,
            m = "%" === r;
          if (r === u || !l || YB[r] || YB[u]) return l;
          if (
            ("px" !== u && !g && (l = e(t, n, i, "px")),
            (c = t.getCTM && WB(t)),
            (m || "%" === u) && (dB[n] || ~n.indexOf("adius")))
          )
            return (
              (s = c ? t.getBBox()[d ? "width" : "height"] : t[f]),
              XI(m ? (l / s) * A : (l / 100) * s)
            );
          if (
            ((h[d ? "width" : "height"] = A + (g ? u : r)),
            (a =
              ~n.indexOf("adius") || ("em" === r && t.appendChild && !p)
                ? t
                : t.parentNode),
            c && (a = (t.ownerSVGElement || {}).parentNode),
            (a && a !== sB && a.appendChild) || (a = sB.body),
            (o = a._gsap) &&
              m &&
              o.width &&
              d &&
              o.time === rT.time &&
              !o.uncache)
          )
            return XI((l / o.width) * A);
          if (!m || ("height" !== n && "width" !== n))
            (m || "%" === u) &&
              !KB[kB(a, "display")] &&
              (h.position = kB(t, "position")),
              a === t && (h.position = "static"),
              a.appendChild(cB),
              (s = cB[f]),
              a.removeChild(cB),
              (h.position = "absolute");
          else {
            var v = t.style[n];
            (t.style[n] = A + r), (s = t[f]), v ? (t.style[n] = v) : XB(t, n);
          }
          return (
            d && m && (((o = VI(a)).time = rT.time), (o.width = a[f])),
            XI(g ? (s * l) / A : s && l ? (A / s) * l : 0)
          );
        },
        ZB = function (e, t, n, i) {
          var r;
          return (
            oB || HB(),
            t in yB &&
              "transform" !== t &&
              ~(t = yB[t]).indexOf(",") &&
              (t = t.split(",")[0]),
            dB[t] && "transform" !== t
              ? ((r = uR(e, i)),
                (r =
                  "transformOrigin" !== t
                    ? r[t]
                    : r.svg
                    ? r.origin
                    : hR(kB(e, PB)) + " " + r.zOrigin + "px"))
              : (!(r = e.style[t]) ||
                  "auto" === r ||
                  i ||
                  ~(r + "").indexOf("calc(")) &&
                (r =
                  (iR[t] && iR[t](e, t, n)) ||
                  kB(e, t) ||
                  jI(e, t) ||
                  ("opacity" === t ? 1 : 0)),
            n && !~(r + "").trim().indexOf(" ") ? JB(e, t, r, n) + n : r
          );
        },
        $B = function (e, t, n, i) {
          if (!n || "none" === n) {
            var r = GB(t, e, 1),
              s = r && kB(e, r, 1);
            s && s !== n
              ? ((t = r), (n = s))
              : "borderColor" === t && (n = kB(e, "borderTopColor"));
          }
          var a,
            o,
            c,
            l,
            u,
            h,
            d,
            p,
            f,
            A,
            g,
            m = new VT(this._pt, e.style, t, 0, 1, NT),
            v = 0,
            y = 0;
          if (
            ((m.b = n),
            (m.e = i),
            (n += ""),
            "auto" === (i += "") &&
              ((h = e.style[t]),
              (e.style[t] = i),
              (i = kB(e, t) || i),
              h ? (e.style[t] = h) : XB(e, t)),
            iT((a = [n, i])),
            (i = a[1]),
            (c = (n = a[0]).match(bI) || []),
            (i.match(bI) || []).length)
          ) {
            for (; (o = bI.exec(i)); )
              (d = o[0]),
                (f = i.substring(v, o.index)),
                u
                  ? (u = (u + 1) % 5)
                  : ("rgba(" !== f.substr(-5) && "hsla(" !== f.substr(-5)) ||
                    (u = 1),
                d !== (h = c[y++] || "") &&
                  ((l = parseFloat(h) || 0),
                  (g = h.substr((l + "").length)),
                  "=" === d.charAt(1) && (d = YI(l, d) + g),
                  (p = parseFloat(d)),
                  (A = d.substr((p + "").length)),
                  (v = bI.lastIndex - A.length),
                  A ||
                    ((A = A || ZS.units[t] || g),
                    v === i.length && ((i += A), (m.e += A))),
                  g !== A && (l = JB(e, t, h, A) || 0),
                  (m._pt = {
                    _next: m._pt,
                    p: f || 1 === y ? f : ",",
                    s: l,
                    c: p - l,
                    m: (u && u < 4) || "zIndex" === t ? Math.round : 0,
                  }));
            m.c = v < i.length ? i.substring(v, i.length) : "";
          } else m.r = "display" === t && "none" === i ? CB : wB;
          return xI.test(i) && (m.e = 0), (this._pt = m), m;
        },
        eR = {
          top: "0%",
          bottom: "100%",
          left: "0%",
          right: "100%",
          center: "50%",
        },
        tR = function (e) {
          var t = e.split(" "),
            n = t[0],
            i = t[1] || "50%";
          return (
            ("top" !== n && "bottom" !== n && "left" !== i && "right" !== i) ||
              ((e = n), (n = i), (i = e)),
            (t[0] = eR[n] || n),
            (t[1] = eR[i] || i),
            t.join(" ")
          );
        },
        nR = function (e, t) {
          if (t.tween && t.tween._time === t.tween._dur) {
            var n,
              i,
              r,
              s = t.t,
              a = s.style,
              o = t.u,
              c = s._gsap;
            if ("all" === o || !0 === o) (a.cssText = ""), (i = 1);
            else
              for (r = (o = o.split(",")).length; --r > -1; )
                (n = o[r]),
                  dB[n] && ((i = 1), (n = "transformOrigin" === n ? PB : DB)),
                  XB(s, n);
            i &&
              (XB(s, DB),
              c &&
                (c.svg && s.removeAttribute("transform"),
                uR(s, 1),
                (c.uncache = 1),
                UB(a)));
          }
        },
        iR = {
          clearProps: function (e, t, n, i, r) {
            if ("isFromStart" !== r.data) {
              var s = (e._pt = new VT(e._pt, t, n, 0, 0, nR));
              return (
                (s.u = i), (s.pr = -10), (s.tween = r), e._props.push(n), 1
              );
            }
          },
        },
        rR = [1, 0, 0, 1, 0, 0],
        sR = {},
        aR = function (e) {
          return "matrix(1, 0, 0, 1, 0, 0)" === e || "none" === e || !e;
        },
        oR = function (e) {
          var t = kB(e, DB);
          return aR(t) ? rR : t.substr(7).match(yI).map(XI);
        },
        cR = function (e, t) {
          var n,
            i,
            r,
            s,
            a = e._gsap || VI(e),
            o = e.style,
            c = oR(e);
          return a.svg && e.getAttribute("transform")
            ? "1,0,0,1,0,0" ===
              (c = [
                (r = e.transform.baseVal.consolidate().matrix).a,
                r.b,
                r.c,
                r.d,
                r.e,
                r.f,
              ]).join(",")
              ? rR
              : c
            : (c !== rR ||
                e.offsetParent ||
                e === aB ||
                a.svg ||
                ((r = o.display),
                (o.display = "block"),
                ((n = e.parentNode) && e.offsetParent) ||
                  ((s = 1), (i = e.nextElementSibling), aB.appendChild(e)),
                (c = oR(e)),
                r ? (o.display = r) : XB(e, "display"),
                s &&
                  (i
                    ? n.insertBefore(e, i)
                    : n
                    ? n.appendChild(e)
                    : aB.removeChild(e))),
              t && c.length > 6 ? [c[0], c[1], c[4], c[5], c[12], c[13]] : c);
        },
        lR = function (e, t, n, i, r, s) {
          var a,
            o,
            c,
            l = e._gsap,
            u = r || cR(e, !0),
            h = l.xOrigin || 0,
            d = l.yOrigin || 0,
            p = l.xOffset || 0,
            f = l.yOffset || 0,
            A = u[0],
            g = u[1],
            m = u[2],
            v = u[3],
            y = u[4],
            b = u[5],
            _ = t.split(" "),
            x = parseFloat(_[0]) || 0,
            E = parseFloat(_[1]) || 0;
          n
            ? u !== rR &&
              (o = A * v - g * m) &&
              ((c = x * (-g / o) + E * (A / o) - (A * b - g * y) / o),
              (x = x * (v / o) + E * (-m / o) + (m * b - v * y) / o),
              (E = c))
            : ((x =
                (a = jB(e)).x + (~_[0].indexOf("%") ? (x / 100) * a.width : x)),
              (E =
                a.y +
                (~(_[1] || _[0]).indexOf("%") ? (E / 100) * a.height : E))),
            i || (!1 !== i && l.smooth)
              ? ((y = x - h),
                (b = E - d),
                (l.xOffset = p + (y * A + b * m) - y),
                (l.yOffset = f + (y * g + b * v) - b))
              : (l.xOffset = l.yOffset = 0),
            (l.xOrigin = x),
            (l.yOrigin = E),
            (l.smooth = !!i),
            (l.origin = t),
            (l.originIsAbsolute = !!n),
            (e.style[PB] = "0px 0px"),
            s &&
              (qB(s, l, "xOrigin", h, x),
              qB(s, l, "yOrigin", d, E),
              qB(s, l, "xOffset", p, l.xOffset),
              qB(s, l, "yOffset", f, l.yOffset)),
            e.setAttribute("data-svg-origin", x + " " + E);
        },
        uR = function (e, t) {
          var n = e._gsap || new mT(e);
          if ("x" in n && !t && !n.uncache) return n;
          var i,
            r,
            s,
            a,
            o,
            c,
            l,
            u,
            h,
            d,
            p,
            f,
            A,
            g,
            m,
            v,
            y,
            b,
            _,
            x,
            E,
            w,
            C,
            S,
            I,
            M,
            T,
            B,
            R,
            D,
            P,
            L,
            U = e.style,
            F = n.scaleX < 0,
            O = "px",
            N = "deg",
            k = getComputedStyle(e),
            Q = kB(e, PB) || "0";
          return (
            (i = r = s = c = l = u = h = d = p = 0),
            (a = o = 1),
            (n.svg = !(!e.getCTM || !WB(e))),
            k.translate &&
              (("none" === k.translate &&
                "none" === k.scale &&
                "none" === k.rotate) ||
                (U[DB] =
                  ("none" !== k.translate
                    ? "translate3d(" +
                      (k.translate + " 0 0").split(" ").slice(0, 3).join(", ") +
                      ") "
                    : "") +
                  ("none" !== k.rotate ? "rotate(" + k.rotate + ") " : "") +
                  ("none" !== k.scale
                    ? "scale(" + k.scale.split(" ").join(",") + ") "
                    : "") +
                  ("none" !== k[DB] ? k[DB] : "")),
              (U.scale = U.rotate = U.translate = "none")),
            (g = cR(e, n.svg)),
            n.svg &&
              (n.uncache
                ? ((I = e.getBBox()),
                  (Q = n.xOrigin - I.x + "px " + (n.yOrigin - I.y) + "px"),
                  (S = ""))
                : (S = !t && e.getAttribute("data-svg-origin")),
              lR(e, S || Q, !!S || n.originIsAbsolute, !1 !== n.smooth, g)),
            (f = n.xOrigin || 0),
            (A = n.yOrigin || 0),
            g !== rR &&
              ((b = g[0]),
              (_ = g[1]),
              (x = g[2]),
              (E = g[3]),
              (i = w = g[4]),
              (r = C = g[5]),
              6 === g.length
                ? ((a = Math.sqrt(b * b + _ * _)),
                  (o = Math.sqrt(E * E + x * x)),
                  (c = b || _ ? AB(_, b) * pB : 0),
                  (h = x || E ? AB(x, E) * pB + c : 0) &&
                    (o *= Math.abs(Math.cos(h * fB))),
                  n.svg &&
                    ((i -= f - (f * b + A * x)), (r -= A - (f * _ + A * E))))
                : ((L = g[6]),
                  (D = g[7]),
                  (T = g[8]),
                  (B = g[9]),
                  (R = g[10]),
                  (P = g[11]),
                  (i = g[12]),
                  (r = g[13]),
                  (s = g[14]),
                  (l = (m = AB(L, R)) * pB),
                  m &&
                    ((S = w * (v = Math.cos(-m)) + T * (y = Math.sin(-m))),
                    (I = C * v + B * y),
                    (M = L * v + R * y),
                    (T = w * -y + T * v),
                    (B = C * -y + B * v),
                    (R = L * -y + R * v),
                    (P = D * -y + P * v),
                    (w = S),
                    (C = I),
                    (L = M)),
                  (u = (m = AB(-x, R)) * pB),
                  m &&
                    ((v = Math.cos(-m)),
                    (P = E * (y = Math.sin(-m)) + P * v),
                    (b = S = b * v - T * y),
                    (_ = I = _ * v - B * y),
                    (x = M = x * v - R * y)),
                  (c = (m = AB(_, b)) * pB),
                  m &&
                    ((S = b * (v = Math.cos(m)) + _ * (y = Math.sin(m))),
                    (I = w * v + C * y),
                    (_ = _ * v - b * y),
                    (C = C * v - w * y),
                    (b = S),
                    (w = I)),
                  l &&
                    Math.abs(l) + Math.abs(c) > 359.9 &&
                    ((l = c = 0), (u = 180 - u)),
                  (a = XI(Math.sqrt(b * b + _ * _ + x * x))),
                  (o = XI(Math.sqrt(C * C + L * L))),
                  (m = AB(w, C)),
                  (h = Math.abs(m) > 2e-4 ? m * pB : 0),
                  (p = P ? 1 / (P < 0 ? -P : P) : 0)),
              n.svg &&
                ((S = e.getAttribute("transform")),
                (n.forceCSS =
                  e.setAttribute("transform", "") || !aR(kB(e, DB))),
                S && e.setAttribute("transform", S))),
            Math.abs(h) > 90 &&
              Math.abs(h) < 270 &&
              (F
                ? ((a *= -1),
                  (h += c <= 0 ? 180 : -180),
                  (c += c <= 0 ? 180 : -180))
                : ((o *= -1), (h += h <= 0 ? 180 : -180))),
            (t = t || n.uncache),
            (n.x =
              i -
              ((n.xPercent =
                i &&
                ((!t && n.xPercent) ||
                  (Math.round(e.offsetWidth / 2) === Math.round(-i) ? -50 : 0)))
                ? (e.offsetWidth * n.xPercent) / 100
                : 0) +
              O),
            (n.y =
              r -
              ((n.yPercent =
                r &&
                ((!t && n.yPercent) ||
                  (Math.round(e.offsetHeight / 2) === Math.round(-r)
                    ? -50
                    : 0)))
                ? (e.offsetHeight * n.yPercent) / 100
                : 0) +
              O),
            (n.z = s + O),
            (n.scaleX = XI(a)),
            (n.scaleY = XI(o)),
            (n.rotation = XI(c) + N),
            (n.rotationX = XI(l) + N),
            (n.rotationY = XI(u) + N),
            (n.skewX = h + N),
            (n.skewY = d + N),
            (n.transformPerspective = p + O),
            (n.zOrigin =
              parseFloat(Q.split(" ")[2]) || (!t && n.zOrigin) || 0) &&
              (U[PB] = hR(Q)),
            (n.xOffset = n.yOffset = 0),
            (n.force3D = ZS.force3D),
            (n.renderTransform = n.svg ? vR : hB ? mR : pR),
            (n.uncache = 0),
            n
          );
        },
        hR = function (e) {
          return (e = e.split(" "))[0] + " " + e[1];
        },
        dR = function (e, t, n) {
          var i = BM(t);
          return XI(parseFloat(t) + parseFloat(JB(e, "x", n + "px", i))) + i;
        },
        pR = function (e, t) {
          (t.z = "0px"),
            (t.rotationY = t.rotationX = "0deg"),
            (t.force3D = 0),
            mR(e, t);
        },
        fR = "0deg",
        AR = "0px",
        gR = ") ",
        mR = function (e, t) {
          var n = t || this,
            i = n.xPercent,
            r = n.yPercent,
            s = n.x,
            a = n.y,
            o = n.z,
            c = n.rotation,
            l = n.rotationY,
            u = n.rotationX,
            h = n.skewX,
            d = n.skewY,
            p = n.scaleX,
            f = n.scaleY,
            A = n.transformPerspective,
            g = n.force3D,
            m = n.target,
            v = n.zOrigin,
            y = "",
            b = ("auto" === g && e && 1 !== e) || !0 === g;
          if (v && (u !== fR || l !== fR)) {
            var _,
              x = parseFloat(l) * fB,
              E = Math.sin(x),
              w = Math.cos(x);
            (x = parseFloat(u) * fB),
              (_ = Math.cos(x)),
              (s = dR(m, s, E * _ * -v)),
              (a = dR(m, a, -Math.sin(x) * -v)),
              (o = dR(m, o, w * _ * -v + v));
          }
          A !== AR && (y += "perspective(" + A + gR),
            (i || r) && (y += "translate(" + i + "%, " + r + "%) "),
            (b || s !== AR || a !== AR || o !== AR) &&
              (y +=
                o !== AR || b
                  ? "translate3d(" + s + ", " + a + ", " + o + ") "
                  : "translate(" + s + ", " + a + gR),
            c !== fR && (y += "rotate(" + c + gR),
            l !== fR && (y += "rotateY(" + l + gR),
            u !== fR && (y += "rotateX(" + u + gR),
            (h === fR && d === fR) || (y += "skew(" + h + ", " + d + gR),
            (1 === p && 1 === f) || (y += "scale(" + p + ", " + f + gR),
            (m.style[DB] = y || "translate(0, 0)");
        },
        vR = function (e, t) {
          var n,
            i,
            r,
            s,
            a,
            o = t || this,
            c = o.xPercent,
            l = o.yPercent,
            u = o.x,
            h = o.y,
            d = o.rotation,
            p = o.skewX,
            f = o.skewY,
            A = o.scaleX,
            g = o.scaleY,
            m = o.target,
            v = o.xOrigin,
            y = o.yOrigin,
            b = o.xOffset,
            _ = o.yOffset,
            x = o.forceCSS,
            E = parseFloat(u),
            w = parseFloat(h);
          (d = parseFloat(d)),
            (p = parseFloat(p)),
            (f = parseFloat(f)) && ((p += f = parseFloat(f)), (d += f)),
            d || p
              ? ((d *= fB),
                (p *= fB),
                (n = Math.cos(d) * A),
                (i = Math.sin(d) * A),
                (r = Math.sin(d - p) * -g),
                (s = Math.cos(d - p) * g),
                p &&
                  ((f *= fB),
                  (a = Math.tan(p - f)),
                  (r *= a = Math.sqrt(1 + a * a)),
                  (s *= a),
                  f &&
                    ((a = Math.tan(f)),
                    (n *= a = Math.sqrt(1 + a * a)),
                    (i *= a))),
                (n = XI(n)),
                (i = XI(i)),
                (r = XI(r)),
                (s = XI(s)))
              : ((n = A), (s = g), (i = r = 0)),
            ((E && !~(u + "").indexOf("px")) ||
              (w && !~(h + "").indexOf("px"))) &&
              ((E = JB(m, "x", u, "px")), (w = JB(m, "y", h, "px"))),
            (v || y || b || _) &&
              ((E = XI(E + v - (v * n + y * r) + b)),
              (w = XI(w + y - (v * i + y * s) + _))),
            (c || l) &&
              ((a = m.getBBox()),
              (E = XI(E + (c / 100) * a.width)),
              (w = XI(w + (l / 100) * a.height))),
            (a =
              "matrix(" +
              n +
              "," +
              i +
              "," +
              r +
              "," +
              s +
              "," +
              E +
              "," +
              w +
              ")"),
            m.setAttribute("transform", a),
            x && (m.style[DB] = a);
        },
        yR = function (e, t, n, i, r) {
          var s,
            a,
            o = 360,
            c = cI(r),
            l = parseFloat(r) * (c && ~r.indexOf("rad") ? pB : 1) - i,
            u = i + l + "deg";
          return (
            c &&
              ("short" === (s = r.split("_")[1]) &&
                (l %= o) !== l % 180 &&
                (l += l < 0 ? o : -360),
              "cw" === s && l < 0
                ? (l = ((l + 36e9) % o) - ~~(l / o) * o)
                : "ccw" === s &&
                  l > 0 &&
                  (l = ((l - 36e9) % o) - ~~(l / o) * o)),
            (e._pt = a = new VT(e._pt, t, n, i, l, _B)),
            (a.e = u),
            (a.u = "deg"),
            e._props.push(n),
            a
          );
        },
        bR = function (e, t) {
          for (var n in t) e[n] = t[n];
          return e;
        },
        _R = function (e, t, n) {
          var i,
            r,
            s,
            a,
            o,
            c,
            l,
            u = bR({}, n._gsap),
            h = n.style;
          for (r in (u.svg
            ? ((s = n.getAttribute("transform")),
              n.setAttribute("transform", ""),
              (h[DB] = t),
              (i = uR(n, 1)),
              XB(n, DB),
              n.setAttribute("transform", s))
            : ((s = getComputedStyle(n)[DB]),
              (h[DB] = t),
              (i = uR(n, 1)),
              (h[DB] = s)),
          dB))
            (s = u[r]) !== (a = i[r]) &&
              "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 &&
              ((o = BM(s) !== (l = BM(a)) ? JB(n, r, s, l) : parseFloat(s)),
              (c = parseFloat(a)),
              (e._pt = new VT(e._pt, i, r, o, c - o, bB)),
              (e._pt.u = l || 0),
              e._props.push(r));
          bR(i, u);
        };
      WI("padding,margin,Width,Radius", function (e, t) {
        var n = "Top",
          i = "Right",
          r = "Bottom",
          s = "Left",
          a = (t < 3 ? [n, i, r, s] : [n + s, n + i, r + i, r + s]).map(
            function (n) {
              return t < 2 ? e + n : "border" + n + e;
            }
          );
        iR[t > 1 ? "border" + e : e] = function (e, t, n, i, r) {
          var s, o;
          if (arguments.length < 4)
            return (
              (s = a.map(function (t) {
                return ZB(e, t, n);
              })),
              5 === (o = s.join(" ")).split(s[0]).length ? s[0] : o
            );
          (s = (i + "").split(" ")),
            (o = {}),
            a.forEach(function (e, t) {
              return (o[e] = s[t] = s[t] || s[((t - 1) / 2) | 0]);
            }),
            e.init(t, o, r);
        };
      });
      var xR,
        ER,
        wR,
        CR = {
          name: "css",
          register: HB,
          targetTest: function (e) {
            return e.style && e.nodeType;
          },
          init: function (e, t, n, i, r) {
            var s,
              a,
              o,
              c,
              l,
              u,
              h,
              d,
              p,
              f,
              A,
              g,
              m,
              v,
              y,
              b,
              _ = this._props,
              x = e.style,
              E = n.vars.startAt;
            for (h in (oB || HB(),
            (this.styles = this.styles || OB(e)),
            (b = this.styles.props),
            (this.tween = n),
            t))
              if (
                "autoRound" !== h &&
                ((a = t[h]), !NI[h] || !wT(h, t, n, i, e, r))
              )
                if (
                  ((l = typeof a),
                  (u = iR[h]),
                  "function" === l && (l = typeof (a = a.call(n, i, e, r))),
                  "string" === l && ~a.indexOf("random(") && (a = HM(a)),
                  u)
                )
                  u(this, e, h, a, n) && (y = 1);
                else if ("--" === h.substr(0, 2))
                  (s = (getComputedStyle(e).getPropertyValue(h) + "").trim()),
                    (a += ""),
                    (tT.lastIndex = 0),
                    tT.test(s) || ((d = BM(s)), (p = BM(a))),
                    p ? d !== p && (s = JB(e, h, s, p) + p) : d && (a += d),
                    this.add(x, "setProperty", s, a, i, r, 0, 0, h),
                    _.push(h),
                    b.push(h, 0, x[h]);
                else if ("undefined" !== l) {
                  if (
                    (E && h in E
                      ? ((s =
                          "function" == typeof E[h]
                            ? E[h].call(n, i, e, r)
                            : E[h]),
                        cI(s) && ~s.indexOf("random(") && (s = HM(s)),
                        BM(s + "") ||
                          "auto" === s ||
                          (s += ZS.units[h] || BM(ZB(e, h)) || ""),
                        "=" === (s + "").charAt(1) && (s = ZB(e, h)))
                      : (s = ZB(e, h)),
                    (c = parseFloat(s)),
                    (f =
                      "string" === l &&
                      "=" === a.charAt(1) &&
                      a.substr(0, 2)) && (a = a.substr(2)),
                    (o = parseFloat(a)),
                    h in yB &&
                      ("autoAlpha" === h &&
                        (1 === c &&
                          "hidden" === ZB(e, "visibility") &&
                          o &&
                          (c = 0),
                        b.push("visibility", 0, x.visibility),
                        qB(
                          this,
                          x,
                          "visibility",
                          c ? "inherit" : "hidden",
                          o ? "inherit" : "hidden",
                          !o
                        )),
                      "scale" !== h &&
                        "transform" !== h &&
                        ~(h = yB[h]).indexOf(",") &&
                        (h = h.split(",")[0])),
                    (A = h in dB))
                  )
                    if (
                      (this.styles.save(h),
                      g ||
                        (((m = e._gsap).renderTransform && !t.parseTransform) ||
                          uR(e, t.parseTransform),
                        (v = !1 !== t.smoothOrigin && m.smooth),
                        ((g = this._pt =
                          new VT(
                            this._pt,
                            x,
                            DB,
                            0,
                            1,
                            m.renderTransform,
                            m,
                            0,
                            -1
                          )).dep = 1)),
                      "scale" === h)
                    )
                      (this._pt = new VT(
                        this._pt,
                        m,
                        "scaleY",
                        m.scaleY,
                        (f ? YI(m.scaleY, f + o) : o) - m.scaleY || 0,
                        bB
                      )),
                        (this._pt.u = 0),
                        _.push("scaleY", h),
                        (h += "X");
                    else {
                      if ("transformOrigin" === h) {
                        b.push(PB, 0, x[PB]),
                          (a = tR(a)),
                          m.svg
                            ? lR(e, a, 0, v, 0, this)
                            : ((p = parseFloat(a.split(" ")[2]) || 0) !==
                                m.zOrigin &&
                                qB(this, m, "zOrigin", m.zOrigin, p),
                              qB(this, x, h, hR(s), hR(a)));
                        continue;
                      }
                      if ("svgOrigin" === h) {
                        lR(e, a, 1, v, 0, this);
                        continue;
                      }
                      if (h in sR) {
                        yR(this, m, h, c, f ? YI(c, f + a) : a);
                        continue;
                      }
                      if ("smoothOrigin" === h) {
                        qB(this, m, "smooth", m.smooth, a);
                        continue;
                      }
                      if ("force3D" === h) {
                        m[h] = a;
                        continue;
                      }
                      if ("transform" === h) {
                        _R(this, a, e);
                        continue;
                      }
                    }
                  else h in x || (h = GB(h) || h);
                  if (
                    A ||
                    ((o || 0 === o) && (c || 0 === c) && !vB.test(a) && h in x)
                  )
                    o || (o = 0),
                      (d = (s + "").substr((c + "").length)) !==
                        (p = BM(a) || (h in ZS.units ? ZS.units[h] : d)) &&
                        (c = JB(e, h, s, p)),
                      (this._pt = new VT(
                        this._pt,
                        A ? m : x,
                        h,
                        c,
                        (f ? YI(c, f + o) : o) - c,
                        A ||
                        ("px" !== p && "zIndex" !== h) ||
                        !1 === t.autoRound
                          ? bB
                          : EB
                      )),
                      (this._pt.u = p || 0),
                      d !== p &&
                        "%" !== p &&
                        ((this._pt.b = s), (this._pt.r = xB));
                  else if (h in x) $B.call(this, e, h, s, f ? f + a : a);
                  else if (h in e)
                    this.add(e, h, s || e[h], f ? f + a : a, i, r);
                  else if ("parseTransform" !== h) {
                    MI(h, a);
                    continue;
                  }
                  A || (h in x ? b.push(h, 0, x[h]) : b.push(h, 1, s || e[h])),
                    _.push(h);
                }
            y && zT(this);
          },
          render: function (e, t) {
            if (t.tween._time || !uB())
              for (var n = t._pt; n; ) n.r(e, n.d), (n = n._next);
            else t.styles.revert();
          },
          get: ZB,
          aliases: yB,
          getSetter: function (e, t, n) {
            var i = yB[t];
            return (
              i && i.indexOf(",") < 0 && (t = i),
              t in dB && t !== PB && (e._gsap.x || ZB(e, "x"))
                ? n && lB === n
                  ? "scale" === t
                    ? TB
                    : MB
                  : (lB = n || {}) && ("scale" === t ? BB : RB)
                : e.style && !hI(e.style[t])
                ? SB
                : ~t.indexOf("-")
                ? IB
                : UT(e, t)
            );
          },
          core: { _removeProperty: XB, _getMatrix: cR },
        };
      (iB.utils.checkPrefix = GB),
        (iB.core.getStyleSaver = OB),
        (wR = WI(
          (xR = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent") +
            "," +
            (ER = "rotation,rotationX,rotationY,skewX,skewY") +
            ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective",
          function (e) {
            dB[e] = 1;
          }
        )),
        WI(ER, function (e) {
          (ZS.units[e] = "deg"), (sR[e] = 1);
        }),
        (yB[wR[13]] = xR + "," + ER),
        WI(
          "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY",
          function (e) {
            var t = e.split(":");
            yB[t[1]] = wR[t[0]];
          }
        ),
        WI(
          "x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective",
          function (e) {
            ZS.units[e] = "px";
          }
        ),
        iB.registerPlugin(CR);
      var SR = iB.registerPlugin(CR) || iB;
      SR.core.Tween;
      Math.PI, Math.PI;
      function IR(e, t, n) {
        return Math.max(t, Math.min(n, e));
      }
      function MR(e, t, n) {
        const i = new br(),
          { easingDuration: r } = n,
          s = SR.quickTo(i, "x", { ease: "power2.out", duration: r });
        window.addEventListener("mousemove", o);
        const a = SR.quickTo(i, "y", {
          ease: "power2.out",
          duration: r,
          onUpdate: () => {
            if (n.type === je.Pan) {
              const { maxDistance: e } = n;
              t.position.set(i.x * e.x, i.y * e.y, 0);
            }
            if (
              (function (e) {
                return e.type === je.Tilt;
              })(n)
            ) {
              const { maxRotation: e } = n;
              (t.rotation.order = "YXZ"),
                t.rotation.set(i.y * e.x, -i.x * e.y, 0);
            }
          },
        });
        function o(t) {
          const n = e.getBoundingClientRect(),
            i = IR((t.clientX - n.x) / n.width, 0, 1),
            r = IR((t.clientY - n.y) / n.height, 0, 1);
          s(2 * i - 1), a(2 * -r + 1);
        }
        return {
          dispose: function () {
            s.tween.kill(),
              a.tween.kill(),
              (t.rotation.order = "XYZ"),
              window.removeEventListener("mousemove", o);
          },
        };
      }
      function TR(e) {
        let t,
          n = !1;
        const i = new br(e.clientWidth, e.clientHeight),
          r = (function (e) {
            const t = new Au({
              canvas: e,
              powerPreference: "high-performance",
              antialias: !0,
              depth: !0,
              alpha: !0,
            });
            return (
              t.setSize(e.clientWidth, e.clientHeight, !1),
              (t.shadowMap.enabled = !0),
              (t.shadowMap.type = an),
              t
            );
          })(e),
          s = new Map(),
          a = new Map();
        let o,
          c,
          l = !1;
        const u = new cr();
        let h, d;
        const {
          effects: p,
          render: f,
          setMainCamera: A,
          setMainScene: g,
          createEffect: m,
          updateEffect: v,
          deleteEffect: y,
          setUsePostProcessing: b,
          setMultiSampling: _,
          updateCameraProjectionMatrix: x,
        } = FS(r, i, L, P, function () {
          return h;
        });
        const E = (function (e) {
            const t = new Id(),
              n = new $x(),
              i = new DE(),
              r = new jw(),
              s =
                GL || "srcdoc" === window.location.pathname
                  ? "/_next/static/"
                  : "",
              a = new Z_().setDecoderPath(`${s}/draco/`),
              o = new kw().setTranscoderPath(`${s}/basis/`);
            o.detectSupport(e);
            const c = new tx()
                .setCrossOrigin("anonymous")
                .setDRACOLoader(a)
                .setKTX2Loader(o)
                .setMeshoptDecoder(Vw),
              l = new jE(),
              u = new ew(),
              h = {
                [Ge.Gltf]: c,
                [Ge.Texture]: t,
                [Ge.HDRTexture]: n,
                [Ge.EXRTexture]: i,
                [Ge.Obj]: l,
                [Ge.FBX]: u,
                [Ge.VideoTexture]: r,
              };
            return {
              load: function (e, t, n = () => {}) {
                const i = h[e];
                if (!i) throw new Error(`No loader for this asset type ${e}`);
                return i.load(t, n);
              },
              loadAsync: (e, t) => {
                const n = h[e];
                if (!n) throw new Error(`No loader for this asset type ${e}`);
                return n.loadAsync(t);
              },
              dispose: function () {
                a.dispose(), o.dispose();
              },
            };
          })(r),
          { load: w, loadAsync: C } = E,
          S = K_(E, u),
          I = new Set(),
          M = new Set(),
          T = new jd();
        function B() {
          if (!o || !c || !r)
            return void console.error(
              "Trying to render with uninitalized objects",
              { activeScene: o, activeCamera: c, renderer: r }
            );
          n && (null == t || t.update());
          const e = T.getDelta(),
            i = T.getElapsedTime();
          I.forEach((t) => t(o, c, e, i)),
            f(e),
            M.forEach((t) => t(o, c, e, i));
        }
        function R() {
          if (!r) throw Error("Renderer is undefined");
          r.setAnimationLoop(null);
        }
        function D(e) {
          I.delete(e);
        }
        function P() {
          return o;
        }
        function L() {
          return c;
        }
        const U = [
          "SpotLightHelper",
          "PointLightHelper",
          "DirectionalLightHelper",
          "CameraHelper",
        ];
        function F(e) {
          e.traverse((e) => {
            if (!U.includes(e.type) && e instanceof Za) {
              const t = e;
              (t.material.wireframe = l),
                (t.material.transparent =
                  !l && t.material.userData.isTransparent);
            }
          });
        }
        return {
          objects: s,
          materials: a,
          renderer: r,
          canvas: e,
          canvasSize: i,
          effects: p,
          eventDispatcher: u,
          load: w,
          loadAsync: C,
          getActiveScene: P,
          setActiveScene: function (e) {
            (o = e), g(e);
          },
          getActiveCamera: L,
          setActiveCamera: function (t) {
            if (((c = t), A(t), c && c instanceof uo && x(), !GL)) {
              null == d || d.dispose();
              const n = t.userData.controls;
              n && (d = MR(e, t, n));
            }
          },
          setCameraPreview: function (e) {
            (h = e), h && h.camera instanceof uo && x();
          },
          resourceManager: S,
          getResource: S.getResource,
          addOnRenderCallback: function (e) {
            return I.add(e), () => D(e);
          },
          removeOnRenderCallback: D,
          addAfterRenderCallback: function (e) {
            return (
              M.add(e),
              () =>
                (function (e) {
                  M.delete(e);
                })(e)
            );
          },
          createEffect: m,
          deleteEffect: y,
          updateEffect: v,
          start: function () {
            if (!r) throw Error("Renderer is undefined");
            u.dispatchEvent({ type: P_.Loaded }), r.setAnimationLoop(B);
          },
          stop: R,
          render: B,
          dispose: function () {
            E.dispose(),
              S.dispose(),
              s.forEach((e) => {
                e.isMesh && e.geometry.dispose();
              }),
              R();
          },
          setWireframe: function (e) {
            (l = e),
              s.forEach((e) => {
                F(e);
              });
          },
          setUsePostProcessing: b,
          setWireframeOnObject: F,
          showStatsPanel: function (e) {
            (n = !0),
              t || ((t = new (NS())()), (t.dom.style.position = "fixed")),
              t.begin(),
              t.showPanel(0),
              e.appendChild(t.dom);
          },
          hideStatsPanel: function () {
            var e;
            (n = !1),
              t &&
                (t.end(),
                null === (e = t.dom.parentElement) ||
                  void 0 === e ||
                  e.removeChild(t.dom));
          },
          setMultiSampling: _,
          attachToDOM: function (e) {
            e.appendChild(r.domElement), i.set(0, 0);
          },
        };
      }
      function BR(e, t, n) {
        return null === e
          ? null
          : (e.point.applyMatrix4(t.matrixWorld),
            (e.distance = e.point.distanceTo(n.ray.origin)),
            (e.object = t),
            e.distance < n.near || e.distance > n.far ? null : e);
      }
      const RR = 0,
        DR = 1,
        PR = 2,
        LR = 2,
        UR = 1.25,
        FR = 1,
        OR = 32,
        NR = 65535,
        kR = Math.pow(2, -24),
        QR = Symbol("SKIP_GENERATION");
      function GR(e) {
        return (
          (function (e) {
            return e.index ? e.index.count : e.attributes.position.count;
          })(e) / 3
        );
      }
      function HR(e, t) {
        if (!e.index) {
          const n = e.attributes.position.count,
            i = (function (e, t = ArrayBuffer) {
              return e > 65535
                ? new Uint32Array(new t(4 * e))
                : new Uint16Array(new t(2 * e));
            })(n, t.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer);
          e.setIndex(new Ta(i, 1));
          for (let e = 0; e < n; e++) i[e] = e;
        }
      }
      function zR(e) {
        const t = GR(e),
          n = e.drawRange,
          i = n.start / 3,
          r = (n.start + n.count) / 3,
          s = Math.max(0, i),
          a = Math.min(t, r) - s;
        return [{ offset: Math.floor(s), count: Math.floor(a) }];
      }
      function VR(e) {
        if (!e.groups || !e.groups.length) return zR(e);
        const t = [],
          n = new Set(),
          i = e.drawRange,
          r = i.start / 3,
          s = (i.start + i.count) / 3;
        for (const t of e.groups) {
          const e = t.start / 3,
            i = (t.start + t.count) / 3;
          n.add(Math.max(r, e)), n.add(Math.min(s, i));
        }
        const a = Array.from(n.values()).sort((e, t) => e - t);
        for (let e = 0; e < a.length - 1; e++) {
          const n = a[e],
            i = a[e + 1];
          t.push({ offset: Math.floor(n), count: Math.floor(i - n) });
        }
        return t;
      }
      function jR(e, t, n, i, r) {
        let s = 1 / 0,
          a = 1 / 0,
          o = 1 / 0,
          c = -1 / 0,
          l = -1 / 0,
          u = -1 / 0,
          h = 1 / 0,
          d = 1 / 0,
          p = 1 / 0,
          f = -1 / 0,
          A = -1 / 0,
          g = -1 / 0;
        for (let i = 6 * t, r = 6 * (t + n); i < r; i += 6) {
          const t = e[i + 0],
            n = e[i + 1],
            r = t - n,
            m = t + n;
          r < s && (s = r),
            m > c && (c = m),
            t < h && (h = t),
            t > f && (f = t);
          const v = e[i + 2],
            y = e[i + 3],
            b = v - y,
            _ = v + y;
          b < a && (a = b),
            _ > l && (l = _),
            v < d && (d = v),
            v > A && (A = v);
          const x = e[i + 4],
            E = e[i + 5],
            w = x - E,
            C = x + E;
          w < o && (o = w),
            C > u && (u = C),
            x < p && (p = x),
            x > g && (g = x);
        }
        (i[0] = s),
          (i[1] = a),
          (i[2] = o),
          (i[3] = c),
          (i[4] = l),
          (i[5] = u),
          (r[0] = h),
          (r[1] = d),
          (r[2] = p),
          (r[3] = f),
          (r[4] = A),
          (r[5] = g);
      }
      function WR(e, t, n) {
        return (
          (n.min.x = t[e]),
          (n.min.y = t[e + 1]),
          (n.min.z = t[e + 2]),
          (n.max.x = t[e + 3]),
          (n.max.y = t[e + 4]),
          (n.max.z = t[e + 5]),
          n
        );
      }
      function XR(e) {
        let t = -1,
          n = -1 / 0;
        for (let i = 0; i < 3; i++) {
          const r = e[i + 3] - e[i];
          r > n && ((n = r), (t = i));
        }
        return t;
      }
      function qR(e, t) {
        t.set(e);
      }
      function YR(e, t, n) {
        let i, r;
        for (let s = 0; s < 3; s++) {
          const a = s + 3;
          (i = e[s]),
            (r = t[s]),
            (n[s] = i < r ? i : r),
            (i = e[a]),
            (r = t[a]),
            (n[a] = i > r ? i : r);
        }
      }
      function KR(e, t, n) {
        for (let i = 0; i < 3; i++) {
          const r = t[e + 2 * i],
            s = t[e + 2 * i + 1],
            a = r - s,
            o = r + s;
          a < n[i] && (n[i] = a), o > n[i + 3] && (n[i + 3] = o);
        }
      }
      function JR(e) {
        const t = e[3] - e[0],
          n = e[4] - e[1],
          i = e[5] - e[2];
        return 2 * (t * n + n * i + i * t);
      }
      const ZR = 32,
        $R = (e, t) => e.candidate - t.candidate,
        eD = new Array(ZR)
          .fill()
          .map(() => ({
            count: 0,
            bounds: new Float32Array(6),
            rightCacheBounds: new Float32Array(6),
            leftCacheBounds: new Float32Array(6),
            candidate: 0,
          })),
        tD = new Float32Array(6);
      class nD {
        constructor() {
          this.boundingData = new Float32Array(6);
        }
      }
      function iD(e, t, n, i, r, s) {
        let a = i,
          o = i + r - 1;
        const c = s.pos,
          l = 2 * s.axis;
        for (;;) {
          for (; a <= o && n[6 * a + l] < c; ) a++;
          for (; a <= o && n[6 * o + l] >= c; ) o--;
          if (!(a < o)) return a;
          for (let e = 0; e < 3; e++) {
            let n = t[3 * a + e];
            (t[3 * a + e] = t[3 * o + e]), (t[3 * o + e] = n);
          }
          for (let e = 0; e < 6; e++) {
            let t = n[6 * a + e];
            (n[6 * a + e] = n[6 * o + e]), (n[6 * o + e] = t);
          }
          a++, o--;
        }
      }
      function rD(e, t, n, i, r, s) {
        let a = i,
          o = i + r - 1;
        const c = s.pos,
          l = 2 * s.axis;
        for (;;) {
          for (; a <= o && n[6 * a + l] < c; ) a++;
          for (; a <= o && n[6 * o + l] >= c; ) o--;
          if (!(a < o)) return a;
          {
            let t = e[a];
            (e[a] = e[o]), (e[o] = t);
            for (let e = 0; e < 6; e++) {
              let t = n[6 * a + e];
              (n[6 * a + e] = n[6 * o + e]), (n[6 * o + e] = t);
            }
            a++, o--;
          }
        }
      }
      function sD(e, t) {
        return 65535 === t[e + 15];
      }
      function aD(e, t) {
        return t[e + 6];
      }
      function oD(e, t) {
        return t[e + 14];
      }
      function cD(e) {
        return e + 8;
      }
      function lD(e, t) {
        return t[e + 6];
      }
      function uD(e, t) {
        return t[e + 7];
      }
      let hD, dD, pD, fD;
      const AD = Math.pow(2, 32);
      function gD(e) {
        return "count" in e ? 1 : 1 + gD(e.left) + gD(e.right);
      }
      function mD(e, t, n) {
        return (
          (hD = new Float32Array(n)),
          (dD = new Uint32Array(n)),
          (pD = new Uint16Array(n)),
          (fD = new Uint8Array(n)),
          vD(e, t)
        );
      }
      function vD(e, t) {
        const n = e / 4,
          i = e / 2,
          r = "count" in t,
          s = t.boundingData;
        for (let e = 0; e < 6; e++) hD[n + e] = s[e];
        if (r) {
          if (t.buffer) {
            const i = t.buffer;
            fD.set(new Uint8Array(i), e);
            for (let t = e, r = e + i.byteLength; t < r; t += OR) {
              sD(t / 2, pD) || (dD[t / 4 + 6] += n);
            }
            return e + i.byteLength;
          }
          {
            const r = t.offset,
              s = t.count;
            return (dD[n + 6] = r), (pD[i + 14] = s), (pD[i + 15] = NR), e + OR;
          }
        }
        {
          const i = t.left,
            r = t.right,
            s = t.splitAxis;
          let a;
          if (((a = vD(e + OR, i)), a / 4 > AD))
            throw new Error(
              "MeshBVH: Cannot store child pointer greater than 32 bits."
            );
          return (dD[n + 6] = a / 4), (a = vD(a, r)), (dD[n + 7] = s), a;
        }
      }
      function yD(e, t, n, i, r) {
        const {
            maxDepth: s,
            verbose: a,
            maxLeafTris: o,
            strategy: c,
            onProgress: l,
            indirect: u,
          } = r,
          h = e._indirectBuffer,
          d = e.geometry,
          p = d.index ? d.index.array : null,
          f = u ? rD : iD,
          A = GR(d),
          g = new Float32Array(6);
        let m = !1;
        const v = new nD();
        return (
          jR(t, n, i, v.boundingData, g),
          (function e(n, i, r, l = null, u = 0) {
            !m &&
              u >= s &&
              ((m = !0),
              a &&
                (console.warn(
                  `MeshBVH: Max depth of ${s} reached when generating BVH. Consider increasing maxDepth.`
                ),
                console.warn(d)));
            if (r <= o || u >= s)
              return y(i + r), (n.offset = i), (n.count = r), n;
            const A = (function (e, t, n, i, r, s) {
              let a = -1,
                o = 0;
              if (s === RR)
                (a = XR(t)), -1 !== a && (o = (t[a] + t[a + 3]) / 2);
              else if (s === DR)
                (a = XR(e)),
                  -1 !== a &&
                    (o = (function (e, t, n, i) {
                      let r = 0;
                      for (let s = t, a = t + n; s < a; s++)
                        r += e[6 * s + 2 * i];
                      return r / n;
                    })(n, i, r, a));
              else if (s === PR) {
                const s = JR(e);
                let c = UR * r;
                const l = 6 * i,
                  u = 6 * (i + r);
                for (let e = 0; e < 3; e++) {
                  const i = t[e],
                    h = (t[e + 3] - i) / ZR;
                  if (r < ZR / 4) {
                    const t = [...eD];
                    t.length = r;
                    let i = 0;
                    for (let r = l; r < u; r += 6, i++) {
                      const s = t[i];
                      (s.candidate = n[r + 2 * e]), (s.count = 0);
                      const {
                        bounds: a,
                        leftCacheBounds: o,
                        rightCacheBounds: c,
                      } = s;
                      for (let e = 0; e < 3; e++)
                        (c[e] = 1 / 0),
                          (c[e + 3] = -1 / 0),
                          (o[e] = 1 / 0),
                          (o[e + 3] = -1 / 0),
                          (a[e] = 1 / 0),
                          (a[e + 3] = -1 / 0);
                      KR(r, n, a);
                    }
                    t.sort($R);
                    let h = r;
                    for (let e = 0; e < h; e++) {
                      const n = t[e];
                      for (; e + 1 < h && t[e + 1].candidate === n.candidate; )
                        t.splice(e + 1, 1), h--;
                    }
                    for (let i = l; i < u; i += 6) {
                      const r = n[i + 2 * e];
                      for (let e = 0; e < h; e++) {
                        const s = t[e];
                        r >= s.candidate
                          ? KR(i, n, s.rightCacheBounds)
                          : (KR(i, n, s.leftCacheBounds), s.count++);
                      }
                    }
                    for (let n = 0; n < h; n++) {
                      const i = t[n],
                        l = i.count,
                        u = r - i.count,
                        h = i.leftCacheBounds,
                        d = i.rightCacheBounds;
                      let p = 0;
                      0 !== l && (p = JR(h) / s);
                      let f = 0;
                      0 !== u && (f = JR(d) / s);
                      const A = FR + UR * (p * l + f * u);
                      A < c && ((a = e), (c = A), (o = i.candidate));
                    }
                  } else {
                    for (let e = 0; e < ZR; e++) {
                      const t = eD[e];
                      (t.count = 0), (t.candidate = i + h + e * h);
                      const n = t.bounds;
                      for (let e = 0; e < 3; e++)
                        (n[e] = 1 / 0), (n[e + 3] = -1 / 0);
                    }
                    for (let t = l; t < u; t += 6) {
                      let r = ~~((n[t + 2 * e] - i) / h);
                      r >= ZR && (r = ZR - 1);
                      const s = eD[r];
                      s.count++, KR(t, n, s.bounds);
                    }
                    const t = eD[ZR - 1];
                    qR(t.bounds, t.rightCacheBounds);
                    for (let e = ZR - 2; e >= 0; e--) {
                      const t = eD[e],
                        n = eD[e + 1];
                      YR(t.bounds, n.rightCacheBounds, t.rightCacheBounds);
                    }
                    let d = 0;
                    for (let t = 0; t < ZR - 1; t++) {
                      const n = eD[t],
                        i = n.count,
                        l = n.bounds,
                        u = eD[t + 1].rightCacheBounds;
                      0 !== i && (0 === d ? qR(l, tD) : YR(l, tD, tD)),
                        (d += i);
                      let h = 0,
                        p = 0;
                      0 !== d && (h = JR(tD) / s);
                      const f = r - d;
                      0 !== f && (p = JR(u) / s);
                      const A = FR + UR * (h * d + p * f);
                      A < c && ((a = e), (c = A), (o = n.candidate));
                    }
                  }
                }
              } else
                console.warn(
                  `MeshBVH: Invalid build strategy value ${s} used.`
                );
              return { axis: a, pos: o };
            })(n.boundingData, l, t, i, r, c);
            if (-1 === A.axis)
              return y(i + r), (n.offset = i), (n.count = r), n;
            const v = f(h, p, t, i, r, A);
            if (v === i || v === i + r) y(i + r), (n.offset = i), (n.count = r);
            else {
              n.splitAxis = A.axis;
              const s = new nD(),
                a = i,
                o = v - i;
              (n.left = s),
                jR(t, a, o, s.boundingData, g),
                e(s, a, o, g, u + 1);
              const c = new nD(),
                l = v,
                h = r - o;
              (n.right = c),
                jR(t, l, h, c.boundingData, g),
                e(c, l, h, g, u + 1);
            }
            return n;
          })(v, n, i, g),
          v
        );
        function y(e) {
          l && l(e / A);
        }
      }
      function bD(e, t) {
        const n = e.geometry;
        t.indirect &&
          ((e._indirectBuffer = (function (e, t) {
            const n =
                (e.index ? e.index.count : e.attributes.position.count) / 3,
              i = n > 65536,
              r = i ? 4 : 2,
              s = t ? new SharedArrayBuffer(n * r) : new ArrayBuffer(n * r),
              a = i ? new Uint32Array(s) : new Uint16Array(s);
            for (let e = 0, t = a.length; e < t; e++) a[e] = e;
            return a;
          })(n, t.useSharedArrayBuffer)),
          (function (e) {
            if (0 === e.groups.length) return !1;
            const t = GR(e),
              n = VR(e).sort((e, t) => e.offset - t.offset),
              i = n[n.length - 1];
            i.count = Math.min(t - i.offset, i.count);
            let r = 0;
            return n.forEach(({ count: e }) => (r += e)), t !== r;
          })(n) &&
            !t.verbose &&
            console.warn(
              'MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.'
            )),
          e._indirectBuffer || HR(n, t);
        const i = t.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer,
          r = (function (e, t = null, n = null, i = null) {
            const r = e.attributes.position,
              s = e.index ? e.index.array : null,
              a = GR(e),
              o = r.normalized;
            let c;
            null === t
              ? ((c = new Float32Array(6 * a * 4)), (n = 0), (i = a))
              : ((c = t), (n = n || 0), (i = i || a));
            const l = r.array,
              u = r.offset || 0;
            let h = 3;
            r.isInterleavedBufferAttribute && (h = r.data.stride);
            const d = ["getX", "getY", "getZ"];
            for (let e = n; e < n + i; e++) {
              const t = 3 * e,
                n = 6 * e;
              let i = t + 0,
                a = t + 1,
                p = t + 2;
              s && ((i = s[i]), (a = s[a]), (p = s[p])),
                o || ((i = i * h + u), (a = a * h + u), (p = p * h + u));
              for (let e = 0; e < 3; e++) {
                let t, s, u;
                o
                  ? ((t = r[d[e]](i)), (s = r[d[e]](a)), (u = r[d[e]](p)))
                  : ((t = l[i + e]), (s = l[a + e]), (u = l[p + e]));
                let h = t;
                s < h && (h = s), u < h && (h = u);
                let f = t;
                s > f && (f = s), u > f && (f = u);
                const A = (f - h) / 2,
                  g = 2 * e;
                (c[n + g + 0] = h + A),
                  (c[n + g + 1] = A + (Math.abs(h) + A) * kR);
              }
            }
            return c;
          })(n),
          s = t.indirect ? zR(n) : VR(n);
        e._roots = s.map((n) => {
          const s = yD(e, r, n.offset, n.count, t),
            a = gD(s),
            o = new i(OR * a);
          return mD(0, s, o), o;
        });
      }
      class _D {
        constructor() {
          (this.min = 1 / 0), (this.max = -1 / 0);
        }
        setFromPointsField(e, t) {
          let n = 1 / 0,
            i = -1 / 0;
          for (let r = 0, s = e.length; r < s; r++) {
            const s = e[r][t];
            (n = s < n ? s : n), (i = s > i ? s : i);
          }
          (this.min = n), (this.max = i);
        }
        setFromPoints(e, t) {
          let n = 1 / 0,
            i = -1 / 0;
          for (let r = 0, s = t.length; r < s; r++) {
            const s = t[r],
              a = e.dot(s);
            (n = a < n ? a : n), (i = a > i ? a : i);
          }
          (this.min = n), (this.max = i);
        }
        isSeparated(e) {
          return this.min > e.max || e.min > this.max;
        }
      }
      _D.prototype.setFromBox = (function () {
        const e = new Yr();
        return function (t, n) {
          const i = n.min,
            r = n.max;
          let s = 1 / 0,
            a = -1 / 0;
          for (let n = 0; n <= 1; n++)
            for (let o = 0; o <= 1; o++)
              for (let c = 0; c <= 1; c++) {
                (e.x = i.x * n + r.x * (1 - n)),
                  (e.y = i.y * o + r.y * (1 - o)),
                  (e.z = i.z * c + r.z * (1 - c));
                const l = t.dot(e);
                (s = Math.min(l, s)), (a = Math.max(l, a));
              }
          (this.min = s), (this.max = a);
        };
      })();
      !(function () {
        const e = new _D();
      })();
      const xD = (function () {
          const e = new Yr(),
            t = new Yr(),
            n = new Yr();
          return function (i, r, s) {
            const a = i.start,
              o = e,
              c = r.start,
              l = t;
            n.subVectors(a, c),
              e.subVectors(i.end, i.start),
              t.subVectors(r.end, r.start);
            const u = n.dot(l),
              h = l.dot(o),
              d = l.dot(l),
              p = n.dot(o),
              f = o.dot(o) * d - h * h;
            let A, g;
            (A = 0 !== f ? (u * h - p * d) / f : 0),
              (g = (u + A * h) / d),
              (s.x = A),
              (s.y = g);
          };
        })(),
        ED = (function () {
          const e = new br(),
            t = new Yr(),
            n = new Yr();
          return function (i, r, s, a) {
            xD(i, r, e);
            let o = e.x,
              c = e.y;
            if (o >= 0 && o <= 1 && c >= 0 && c <= 1)
              return i.at(o, s), void r.at(c, a);
            if (o >= 0 && o <= 1)
              return (
                c < 0 ? r.at(0, a) : r.at(1, a),
                void i.closestPointToPoint(a, !0, s)
              );
            if (c >= 0 && c <= 1)
              return (
                o < 0 ? i.at(0, s) : i.at(1, s),
                void r.closestPointToPoint(s, !0, a)
              );
            {
              let e, l;
              (e = o < 0 ? i.start : i.end), (l = c < 0 ? r.start : r.end);
              const u = t,
                h = n;
              return (
                i.closestPointToPoint(l, !0, t),
                r.closestPointToPoint(e, !0, n),
                u.distanceToSquared(l) <= h.distanceToSquared(e)
                  ? (s.copy(u), void a.copy(l))
                  : (s.copy(e), void a.copy(h))
              );
            }
          };
        })(),
        wD = (function () {
          const e = new Yr(),
            t = new Yr(),
            n = new yo(),
            i = new hp();
          return function (r, s) {
            const { radius: a, center: o } = r,
              { a: c, b: l, c: u } = s;
            (i.start = c), (i.end = l);
            if (i.closestPointToPoint(o, !0, e).distanceTo(o) <= a) return !0;
            (i.start = c), (i.end = u);
            if (i.closestPointToPoint(o, !0, e).distanceTo(o) <= a) return !0;
            (i.start = l), (i.end = u);
            if (i.closestPointToPoint(o, !0, e).distanceTo(o) <= a) return !0;
            const h = s.getPlane(n);
            if (Math.abs(h.distanceToPoint(o)) <= a) {
              const e = h.projectPoint(o, t);
              if (s.containsPoint(e)) return !0;
            }
            return !1;
          };
        })();
      function CD(e) {
        return Math.abs(e) < 1e-15;
      }
      class SD extends da {
        constructor(...e) {
          super(...e),
            (this.isExtendedTriangle = !0),
            (this.satAxes = new Array(4).fill().map(() => new Yr())),
            (this.satBounds = new Array(4).fill().map(() => new _D())),
            (this.points = [this.a, this.b, this.c]),
            (this.sphere = new gs()),
            (this.plane = new yo()),
            (this.needsUpdate = !0);
        }
        intersectsSphere(e) {
          return wD(e, this);
        }
        update() {
          const e = this.a,
            t = this.b,
            n = this.c,
            i = this.points,
            r = this.satAxes,
            s = this.satBounds,
            a = r[0],
            o = s[0];
          this.getNormal(a), o.setFromPoints(a, i);
          const c = r[1],
            l = s[1];
          c.subVectors(e, t), l.setFromPoints(c, i);
          const u = r[2],
            h = s[2];
          u.subVectors(t, n), h.setFromPoints(u, i);
          const d = r[3],
            p = s[3];
          d.subVectors(n, e),
            p.setFromPoints(d, i),
            this.sphere.setFromPoints(this.points),
            this.plane.setFromNormalAndCoplanarPoint(a, e),
            (this.needsUpdate = !1);
        }
      }
      (SD.prototype.closestPointToSegment = (function () {
        const e = new Yr(),
          t = new Yr(),
          n = new hp();
        return function (i, r = null, s = null) {
          const { start: a, end: o } = i,
            c = this.points;
          let l,
            u = 1 / 0;
          for (let a = 0; a < 3; a++) {
            const o = (a + 1) % 3;
            n.start.copy(c[a]),
              n.end.copy(c[o]),
              ED(n, i, e, t),
              (l = e.distanceToSquared(t)),
              l < u && ((u = l), r && r.copy(e), s && s.copy(t));
          }
          return (
            this.closestPointToPoint(a, e),
            (l = a.distanceToSquared(e)),
            l < u && ((u = l), r && r.copy(e), s && s.copy(a)),
            this.closestPointToPoint(o, e),
            (l = o.distanceToSquared(e)),
            l < u && ((u = l), r && r.copy(e), s && s.copy(o)),
            Math.sqrt(u)
          );
        };
      })()),
        (SD.prototype.intersectsTriangle = (function () {
          const e = new SD(),
            t = new Array(3),
            n = new Array(3),
            i = new _D(),
            r = new _D(),
            s = new Yr(),
            a = new Yr(),
            o = new Yr(),
            c = new Yr(),
            l = new Yr(),
            u = new hp(),
            h = new hp(),
            d = new hp(),
            p = new Yr();
          function f(e, t, n) {
            const i = e.points;
            let r = 0,
              s = -1;
            for (let e = 0; e < 3; e++) {
              const { start: o, end: c } = u;
              o.copy(i[e]), c.copy(i[(e + 1) % 3]), u.delta(a);
              const l = CD(t.distanceToPoint(o));
              if (CD(t.normal.dot(a)) && l) {
                n.copy(u), (r = 2);
                break;
              }
              const h = t.intersectLine(u, p);
              if ((!h && l && p.copy(o), (h || l) && !CD(p.distanceTo(c)))) {
                if (r <= 1) {
                  (1 === r ? n.start : n.end).copy(p), l && (s = r);
                } else if (r >= 2) {
                  (1 === s ? n.start : n.end).copy(p), (r = 2);
                  break;
                }
                if ((r++, 2 === r && -1 === s)) break;
              }
            }
            return r;
          }
          return function (a, u = null, p = !1) {
            this.needsUpdate && this.update(),
              a.isExtendedTriangle
                ? a.needsUpdate && a.update()
                : (e.copy(a), e.update(), (a = e));
            const A = this.plane,
              g = a.plane;
            if (Math.abs(A.normal.dot(g.normal)) > 1 - 1e-10) {
              const e = this.satBounds,
                o = this.satAxes;
              (n[0] = a.a), (n[1] = a.b), (n[2] = a.c);
              for (let t = 0; t < 4; t++) {
                const r = e[t],
                  s = o[t];
                if ((i.setFromPoints(s, n), r.isSeparated(i))) return !1;
              }
              const c = a.satBounds,
                l = a.satAxes;
              (t[0] = this.a), (t[1] = this.b), (t[2] = this.c);
              for (let e = 0; e < 4; e++) {
                const n = c[e],
                  r = l[e];
                if ((i.setFromPoints(r, t), n.isSeparated(i))) return !1;
              }
              for (let e = 0; e < 4; e++) {
                const a = o[e];
                for (let e = 0; e < 4; e++) {
                  const o = l[e];
                  if (
                    (s.crossVectors(a, o),
                    i.setFromPoints(s, t),
                    r.setFromPoints(s, n),
                    i.isSeparated(r))
                  )
                    return !1;
                }
              }
              return (
                u &&
                  (p ||
                    console.warn(
                      "ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."
                    ),
                  u.start.set(0, 0, 0),
                  u.end.set(0, 0, 0)),
                !0
              );
            }
            {
              const e = f(this, g, h);
              if (1 === e && a.containsPoint(h.end))
                return u && (u.start.copy(h.end), u.end.copy(h.end)), !0;
              if (2 !== e) return !1;
              const t = f(a, A, d);
              if (1 === t && this.containsPoint(d.end))
                return u && (u.start.copy(d.end), u.end.copy(d.end)), !0;
              if (2 !== t) return !1;
              if ((h.delta(o), d.delta(c), o.dot(c) < 0)) {
                let e = d.start;
                (d.start = d.end), (d.end = e);
              }
              const n = h.start.dot(o),
                i = h.end.dot(o),
                r = d.start.dot(o),
                s = d.end.dot(o);
              return (
                (n === s || r === i || i < r !== n < s) &&
                (u &&
                  (l.subVectors(h.start, d.start),
                  l.dot(o) > 0 ? u.start.copy(h.start) : u.start.copy(d.start),
                  l.subVectors(h.end, d.end),
                  l.dot(o) < 0 ? u.end.copy(h.end) : u.end.copy(d.end)),
                !0)
              );
            }
          };
        })()),
        (SD.prototype.distanceToPoint = (function () {
          const e = new Yr();
          return function (t) {
            return this.closestPointToPoint(t, e), t.distanceTo(e);
          };
        })()),
        (SD.prototype.distanceToTriangle = (function () {
          const e = new Yr(),
            t = new Yr(),
            n = ["a", "b", "c"],
            i = new hp(),
            r = new hp();
          return function (s, a = null, o = null) {
            const c = a || o ? i : null;
            if (this.intersectsTriangle(s, c))
              return (a || o) && (a && c.getCenter(a), o && c.getCenter(o)), 0;
            let l = 1 / 0;
            for (let t = 0; t < 3; t++) {
              let i;
              const r = n[t],
                c = s[r];
              this.closestPointToPoint(c, e),
                (i = c.distanceToSquared(e)),
                i < l && ((l = i), a && a.copy(e), o && o.copy(c));
              const u = this[r];
              s.closestPointToPoint(u, e),
                (i = u.distanceToSquared(e)),
                i < l && ((l = i), a && a.copy(u), o && o.copy(e));
            }
            for (let c = 0; c < 3; c++) {
              const u = n[c],
                h = n[(c + 1) % 3];
              i.set(this[u], this[h]);
              for (let c = 0; c < 3; c++) {
                const u = n[c],
                  h = n[(c + 1) % 3];
                r.set(s[u], s[h]), ED(i, r, e, t);
                const d = e.distanceToSquared(t);
                d < l && ((l = d), a && a.copy(e), o && o.copy(t));
              }
            }
            return Math.sqrt(l);
          };
        })());
      class ID {
        constructor(e, t, n) {
          (this.isOrientedBox = !0),
            (this.min = new Yr()),
            (this.max = new Yr()),
            (this.matrix = new Cs()),
            (this.invMatrix = new Cs()),
            (this.points = new Array(8).fill().map(() => new Yr())),
            (this.satAxes = new Array(3).fill().map(() => new Yr())),
            (this.satBounds = new Array(3).fill().map(() => new _D())),
            (this.alignedSatBounds = new Array(3).fill().map(() => new _D())),
            (this.needsUpdate = !1),
            e && this.min.copy(e),
            t && this.max.copy(t),
            n && this.matrix.copy(n);
        }
        set(e, t, n) {
          this.min.copy(e),
            this.max.copy(t),
            this.matrix.copy(n),
            (this.needsUpdate = !0);
        }
        copy(e) {
          this.min.copy(e.min),
            this.max.copy(e.max),
            this.matrix.copy(e.matrix),
            (this.needsUpdate = !0);
        }
      }
      (ID.prototype.update = function () {
        const e = this.matrix,
          t = this.min,
          n = this.max,
          i = this.points;
        for (let r = 0; r <= 1; r++)
          for (let s = 0; s <= 1; s++)
            for (let a = 0; a <= 1; a++) {
              const o = i[(1 * r) | (2 * s) | (4 * a)];
              (o.x = r ? n.x : t.x),
                (o.y = s ? n.y : t.y),
                (o.z = a ? n.z : t.z),
                o.applyMatrix4(e);
            }
        const r = this.satBounds,
          s = this.satAxes,
          a = i[0];
        for (let e = 0; e < 3; e++) {
          const t = s[e],
            n = r[e],
            o = i[1 << e];
          t.subVectors(a, o), n.setFromPoints(t, i);
        }
        const o = this.alignedSatBounds;
        o[0].setFromPointsField(i, "x"),
          o[1].setFromPointsField(i, "y"),
          o[2].setFromPointsField(i, "z"),
          this.invMatrix.copy(this.matrix).invert(),
          (this.needsUpdate = !1);
      }),
        (ID.prototype.intersectsBox = (function () {
          const e = new _D();
          return function (t) {
            this.needsUpdate && this.update();
            const n = t.min,
              i = t.max,
              r = this.satBounds,
              s = this.satAxes,
              a = this.alignedSatBounds;
            if (((e.min = n.x), (e.max = i.x), a[0].isSeparated(e))) return !1;
            if (((e.min = n.y), (e.max = i.y), a[1].isSeparated(e))) return !1;
            if (((e.min = n.z), (e.max = i.z), a[2].isSeparated(e))) return !1;
            for (let n = 0; n < 3; n++) {
              const i = s[n],
                a = r[n];
              if ((e.setFromBox(i, t), a.isSeparated(e))) return !1;
            }
            return !0;
          };
        })()),
        (ID.prototype.intersectsTriangle = (function () {
          const e = new SD(),
            t = new Array(3),
            n = new _D(),
            i = new _D(),
            r = new Yr();
          return function (s) {
            this.needsUpdate && this.update(),
              s.isExtendedTriangle
                ? s.needsUpdate && s.update()
                : (e.copy(s), e.update(), (s = e));
            const a = this.satBounds,
              o = this.satAxes;
            (t[0] = s.a), (t[1] = s.b), (t[2] = s.c);
            for (let e = 0; e < 3; e++) {
              const i = a[e],
                r = o[e];
              if ((n.setFromPoints(r, t), i.isSeparated(n))) return !1;
            }
            const c = s.satBounds,
              l = s.satAxes,
              u = this.points;
            for (let e = 0; e < 3; e++) {
              const t = c[e],
                i = l[e];
              if ((n.setFromPoints(i, u), t.isSeparated(n))) return !1;
            }
            for (let e = 0; e < 3; e++) {
              const s = o[e];
              for (let e = 0; e < 4; e++) {
                const a = l[e];
                if (
                  (r.crossVectors(s, a),
                  n.setFromPoints(r, t),
                  i.setFromPoints(r, u),
                  n.isSeparated(i))
                )
                  return !1;
              }
            }
            return !0;
          };
        })()),
        (ID.prototype.closestPointToPoint = function (e, t) {
          return (
            this.needsUpdate && this.update(),
            t
              .copy(e)
              .applyMatrix4(this.invMatrix)
              .clamp(this.min, this.max)
              .applyMatrix4(this.matrix),
            t
          );
        }),
        (ID.prototype.distanceToPoint = (function () {
          const e = new Yr();
          return function (t) {
            return this.closestPointToPoint(t, e), t.distanceTo(e);
          };
        })()),
        (ID.prototype.distanceToBox = (function () {
          const e = ["x", "y", "z"],
            t = new Array(12).fill().map(() => new hp()),
            n = new Array(12).fill().map(() => new hp()),
            i = new Yr(),
            r = new Yr();
          return function (s, a = 0, o = null, c = null) {
            if ((this.needsUpdate && this.update(), this.intersectsBox(s)))
              return (
                (o || c) &&
                  (s.getCenter(r),
                  this.closestPointToPoint(r, i),
                  s.closestPointToPoint(i, r),
                  o && o.copy(i),
                  c && c.copy(r)),
                0
              );
            const l = a * a,
              u = s.min,
              h = s.max,
              d = this.points;
            let p = 1 / 0;
            for (let e = 0; e < 8; e++) {
              const t = d[e];
              r.copy(t).clamp(u, h);
              const n = t.distanceToSquared(r);
              if (n < p && ((p = n), o && o.copy(t), c && c.copy(r), n < l))
                return Math.sqrt(n);
            }
            let f = 0;
            for (let i = 0; i < 3; i++)
              for (let r = 0; r <= 1; r++)
                for (let s = 0; s <= 1; s++) {
                  const a = (i + 1) % 3,
                    o = (i + 2) % 3,
                    c = (1 << i) | (r << a) | (s << o),
                    l = d[(r << a) | (s << o)],
                    p = d[c];
                  t[f].set(l, p);
                  const A = e[i],
                    g = e[a],
                    m = e[o],
                    v = n[f],
                    y = v.start,
                    b = v.end;
                  (y[A] = u[A]),
                    (y[g] = r ? u[g] : h[g]),
                    (y[m] = s ? u[m] : h[g]),
                    (b[A] = h[A]),
                    (b[g] = r ? u[g] : h[g]),
                    (b[m] = s ? u[m] : h[g]),
                    f++;
                }
            for (let e = 0; e <= 1; e++)
              for (let t = 0; t <= 1; t++)
                for (let n = 0; n <= 1; n++) {
                  (r.x = e ? h.x : u.x),
                    (r.y = t ? h.y : u.y),
                    (r.z = n ? h.z : u.z),
                    this.closestPointToPoint(r, i);
                  const s = r.distanceToSquared(i);
                  if (s < p && ((p = s), o && o.copy(i), c && c.copy(r), s < l))
                    return Math.sqrt(s);
                }
            for (let e = 0; e < 12; e++) {
              const s = t[e];
              for (let e = 0; e < 12; e++) {
                const t = n[e];
                ED(s, t, i, r);
                const a = i.distanceToSquared(r);
                if (a < p && ((p = a), o && o.copy(i), c && c.copy(r), a < l))
                  return Math.sqrt(a);
              }
            }
            return Math.sqrt(p);
          };
        })());
      class MD {
        constructor(e) {
          (this._getNewPrimitive = e), (this._primitives = []);
        }
        getPrimitive() {
          const e = this._primitives;
          return 0 === e.length ? this._getNewPrimitive() : e.pop();
        }
        releasePrimitive(e) {
          this._primitives.push(e);
        }
      }
      class TD extends MD {
        constructor() {
          super(() => new SD());
        }
      }
      const BD = new TD();
      const RD = new (class {
        constructor() {
          (this.float32Array = null),
            (this.uint16Array = null),
            (this.uint32Array = null);
          const e = [];
          let t = null;
          (this.setBuffer = (n) => {
            t && e.push(t),
              (t = n),
              (this.float32Array = new Float32Array(n)),
              (this.uint16Array = new Uint16Array(n)),
              (this.uint32Array = new Uint32Array(n));
          }),
            (this.clearBuffer = () => {
              (t = null),
                (this.float32Array = null),
                (this.uint16Array = null),
                (this.uint32Array = null),
                0 !== e.length && this.setBuffer(e.pop());
            });
        }
      })();
      let DD, PD;
      const LD = [],
        UD = new MD(() => new Zr());
      function FD(e, t, n, i, r, s) {
        (DD = UD.getPrimitive()),
          (PD = UD.getPrimitive()),
          LD.push(DD, PD),
          RD.setBuffer(e._roots[t]);
        const a = OD(0, e.geometry, n, i, r, s);
        RD.clearBuffer(),
          UD.releasePrimitive(DD),
          UD.releasePrimitive(PD),
          LD.pop(),
          LD.pop();
        const o = LD.length;
        return o > 0 && ((PD = LD[o - 1]), (DD = LD[o - 2])), a;
      }
      function OD(e, t, n, i, r = null, s = 0, a = 0) {
        const { float32Array: o, uint16Array: c, uint32Array: l } = RD;
        let u = 2 * e;
        if (sD(u, c)) {
          const h = aD(e, l),
            d = oD(u, c);
          return WR(e, o, DD), i(h, d, !1, a, s + e, DD);
        }
        {
          const p = cD(e),
            f = lD(e, l);
          let A,
            g,
            m,
            v,
            y = p,
            b = f;
          if (
            r &&
            ((m = DD),
            (v = PD),
            WR(y, o, m),
            WR(b, o, v),
            (A = r(m)),
            (g = r(v)),
            g < A)
          ) {
            (y = f), (b = p);
            const I = A;
            (A = g), (g = I), (m = v);
          }
          m || ((m = DD), WR(y, o, m));
          const _ = n(m, sD(2 * y, c), A, a + 1, s + y);
          let x;
          if (_ === LR) {
            const M = C(y);
            x = i(M, S(y) - M, !0, a + 1, s + y, m);
          } else x = _ && OD(y, t, n, i, r, s, a + 1);
          if (x) return !0;
          (v = PD), WR(b, o, v);
          const E = n(v, sD(2 * b, c), g, a + 1, s + b);
          let w;
          if (E === LR) {
            const T = C(b);
            w = i(T, S(b) - T, !0, a + 1, s + b, v);
          } else w = E && OD(b, t, n, i, r, s, a + 1);
          return !!w;
          function C(e) {
            const { uint16Array: t, uint32Array: n } = RD;
            let i = 2 * e;
            for (; !sD(i, t); ) i = 2 * (e = cD(e));
            return aD(e, n);
          }
          function S(e) {
            const { uint16Array: t, uint32Array: n } = RD;
            let i = 2 * e;
            for (; !sD(i, t); ) i = 2 * (e = lD(e, n));
            return aD(e, n) + oD(i, t);
          }
        }
      }
      const ND = new Yr(),
        kD = new Yr();
      const QD = new Yr(),
        GD = new Yr(),
        HD = new Yr(),
        zD = new br(),
        VD = new br(),
        jD = new br(),
        WD = new Yr(),
        XD = new Yr(),
        qD = new Yr(),
        YD = new Yr();
      function KD(e, t, n, i, r, s, a, o, c) {
        QD.fromBufferAttribute(t, s),
          GD.fromBufferAttribute(t, a),
          HD.fromBufferAttribute(t, o);
        const l = (function (e, t, n, i, r, s) {
          let a;
          return (
            (a =
              s === ln
                ? e.intersectTriangle(i, n, t, !0, r)
                : e.intersectTriangle(t, n, i, s !== un, r)),
            null === a
              ? null
              : { distance: e.origin.distanceTo(r), point: r.clone() }
          );
        })(e, QD, GD, HD, YD, c);
        if (l) {
          i &&
            (zD.fromBufferAttribute(i, s),
            VD.fromBufferAttribute(i, a),
            jD.fromBufferAttribute(i, o),
            (l.uv = da.getInterpolation(YD, QD, GD, HD, zD, VD, jD, new br()))),
            r &&
              (zD.fromBufferAttribute(r, s),
              VD.fromBufferAttribute(r, a),
              jD.fromBufferAttribute(r, o),
              (l.uv1 = da.getInterpolation(
                YD,
                QD,
                GD,
                HD,
                zD,
                VD,
                jD,
                new br()
              ))),
            n &&
              (WD.fromBufferAttribute(n, s),
              XD.fromBufferAttribute(n, a),
              qD.fromBufferAttribute(n, o),
              (l.normal = da.getInterpolation(
                YD,
                QD,
                GD,
                HD,
                WD,
                XD,
                qD,
                new Yr()
              )),
              l.normal.dot(e.direction) > 0 && l.normal.multiplyScalar(-1));
          const t = { a: s, b: a, c: o, normal: new Yr(), materialIndex: 0 };
          da.getNormal(QD, GD, HD, t.normal), (l.face = t), (l.faceIndex = s);
        }
        return l;
      }
      function JD(e, t, n, i, r) {
        const s = 3 * i;
        let a = s + 0,
          o = s + 1,
          c = s + 2;
        const l = e.index;
        e.index && ((a = l.getX(a)), (o = l.getX(o)), (c = l.getX(c)));
        const { position: u, normal: h, uv: d, uv1: p } = e.attributes,
          f = KD(n, u, h, d, p, a, o, c, t);
        return f ? ((f.faceIndex = i), r && r.push(f), f) : null;
      }
      function ZD(e, t, n, i) {
        const r = e.a,
          s = e.b,
          a = e.c;
        let o = t,
          c = t + 1,
          l = t + 2;
        n && ((o = n.getX(o)), (c = n.getX(c)), (l = n.getX(l))),
          (r.x = i.getX(o)),
          (r.y = i.getY(o)),
          (r.z = i.getZ(o)),
          (s.x = i.getX(c)),
          (s.y = i.getY(c)),
          (s.z = i.getZ(c)),
          (a.x = i.getX(l)),
          (a.y = i.getY(l)),
          (a.z = i.getZ(l));
      }
      function $D(e, t, n, i, r, s, a) {
        const { geometry: o } = n,
          { index: c } = o,
          l = o.attributes.position;
        for (let n = e, o = t + e; n < o; n++) {
          let e;
          if (
            ((e = n), ZD(a, 3 * e, c, l), (a.needsUpdate = !0), i(a, e, r, s))
          )
            return !0;
        }
        return !1;
      }
      function eP(e, t = null) {
        t && Array.isArray(t) && (t = new Set(t));
        const n = e.geometry,
          i = n.index ? n.index.array : null,
          r = n.attributes.position;
        let s,
          a,
          o,
          c,
          l = 0;
        const u = e._roots;
        for (let e = 0, t = u.length; e < t; e++)
          (s = u[e]),
            (a = new Uint32Array(s)),
            (o = new Uint16Array(s)),
            (c = new Float32Array(s)),
            h(0, l),
            (l += s.byteLength);
        function h(e, n, s = !1) {
          const l = 2 * e;
          if (o[l + 15] === NR) {
            const t = a[e + 6];
            let n = 1 / 0,
              s = 1 / 0,
              u = 1 / 0,
              h = -1 / 0,
              d = -1 / 0,
              p = -1 / 0;
            for (let e = 3 * t, a = 3 * (t + o[l + 14]); e < a; e++) {
              let t = i[e];
              const a = r.getX(t),
                o = r.getY(t),
                c = r.getZ(t);
              a < n && (n = a),
                a > h && (h = a),
                o < s && (s = o),
                o > d && (d = o),
                c < u && (u = c),
                c > p && (p = c);
            }
            return (
              (c[e + 0] !== n ||
                c[e + 1] !== s ||
                c[e + 2] !== u ||
                c[e + 3] !== h ||
                c[e + 4] !== d ||
                c[e + 5] !== p) &&
              ((c[e + 0] = n),
              (c[e + 1] = s),
              (c[e + 2] = u),
              (c[e + 3] = h),
              (c[e + 4] = d),
              (c[e + 5] = p),
              !0)
            );
          }
          {
            const i = e + 8,
              r = a[e + 6],
              o = i + n,
              l = r + n;
            let u = s,
              d = !1,
              p = !1;
            t
              ? u || ((d = t.has(o)), (p = t.has(l)), (u = !d && !p))
              : ((d = !0), (p = !0));
            const f = u || p;
            let A = !1;
            (u || d) && (A = h(i, n, u));
            let g = !1;
            f && (g = h(r, n, u));
            const m = A || g;
            if (m)
              for (let t = 0; t < 3; t++) {
                const n = i + t,
                  s = r + t,
                  a = c[n],
                  o = c[n + 3],
                  l = c[s],
                  u = c[s + 3];
                (c[e + t] = a < l ? a : l), (c[e + t + 3] = o > u ? o : u);
              }
            return m;
          }
        }
      }
      const tP = new Zr();
      function nP(e, t, n, i) {
        return WR(e, t, tP), n.intersectBox(tP, i);
      }
      const iP = new Yr();
      function rP(e, t, n, i, r) {
        RD.setBuffer(e._roots[t]), sP(0, e, n, i, r), RD.clearBuffer();
      }
      function sP(e, t, n, i, r) {
        const { float32Array: s, uint16Array: a, uint32Array: o } = RD,
          c = 2 * e;
        if (sD(c, a)) {
          !(function (e, t, n, i, r, s) {
            const { geometry: a, _indirectBuffer: o } = e;
            for (let e = i, o = i + r; e < o; e++) JD(a, t, n, e, s);
          })(t, n, i, aD(e, o), oD(c, a), r);
        } else {
          const a = cD(e);
          nP(a, s, i, iP) && sP(a, t, n, i, r);
          const c = lD(e, o);
          nP(c, s, i, iP) && sP(c, t, n, i, r);
        }
      }
      const aP = new Yr(),
        oP = ["x", "y", "z"];
      function cP(e, t, n, i) {
        RD.setBuffer(e._roots[t]);
        const r = lP(0, e, n, i);
        return RD.clearBuffer(), r;
      }
      function lP(e, t, n, i) {
        const { float32Array: r, uint16Array: s, uint32Array: a } = RD;
        let o = 2 * e;
        if (sD(o, s)) {
          return (function (e, t, n, i, r) {
            const { geometry: s, _indirectBuffer: a } = e;
            let o = 1 / 0,
              c = null;
            for (let e = i, a = i + r; e < a; e++) {
              let i;
              (i = JD(s, t, n, e)),
                i && i.distance < o && ((c = i), (o = i.distance));
            }
            return c;
          })(t, n, i, aD(e, a), oD(o, s));
        }
        {
          const s = uD(e, a),
            o = oP[s],
            c = i.direction[o] >= 0;
          let l, u;
          c ? ((l = cD(e)), (u = lD(e, a))) : ((l = lD(e, a)), (u = cD(e)));
          const h = nP(l, r, i, aP) ? lP(l, t, n, i) : null;
          if (h) {
            const e = h.point[o];
            if (c ? e <= r[u + s] : e >= r[u + s + 3]) return h;
          }
          const d = nP(u, r, i, aP) ? lP(u, t, n, i) : null;
          return h && d ? (h.distance <= d.distance ? h : d) : h || d || null;
        }
      }
      const uP = new Zr(),
        hP = new SD(),
        dP = new SD(),
        pP = new Cs(),
        fP = new ID(),
        AP = new ID();
      function gP(e, t, n, i) {
        RD.setBuffer(e._roots[t]);
        const r = mP(0, e, n, i);
        return RD.clearBuffer(), r;
      }
      function mP(e, t, n, i, r = null) {
        const { float32Array: s, uint16Array: a, uint32Array: o } = RD;
        let c = 2 * e;
        null === r &&
          (n.boundingBox || n.computeBoundingBox(),
          fP.set(n.boundingBox.min, n.boundingBox.max, i),
          (r = fP));
        if (!sD(c, a)) {
          const a = e + 8,
            c = o[e + 6];
          WR(a, s, uP);
          if (r.intersectsBox(uP) && mP(a, t, n, i, r)) return !0;
          WR(c, s, uP);
          return !!(r.intersectsBox(uP) && mP(c, t, n, i, r));
        }
        {
          const r = t.geometry,
            l = r.index,
            u = r.attributes.position,
            h = n.index,
            d = n.attributes.position,
            p = aD(e, o),
            f = oD(c, a);
          if ((pP.copy(i).invert(), n.boundsTree)) {
            WR(e, s, AP), AP.matrix.copy(pP), (AP.needsUpdate = !0);
            const t = n.boundsTree.shapecast({
              intersectsBounds: (e) => AP.intersectsBox(e),
              intersectsTriangle: (e) => {
                e.a.applyMatrix4(i),
                  e.b.applyMatrix4(i),
                  e.c.applyMatrix4(i),
                  (e.needsUpdate = !0);
                for (let t = 3 * p, n = 3 * (f + p); t < n; t += 3)
                  if (
                    (ZD(dP, t, l, u),
                    (dP.needsUpdate = !0),
                    e.intersectsTriangle(dP))
                  )
                    return !0;
                return !1;
              },
            });
            return t;
          }
          for (let e = 3 * p, t = 3 * (f + p); e < t; e += 3) {
            ZD(hP, e, l, u),
              hP.a.applyMatrix4(pP),
              hP.b.applyMatrix4(pP),
              hP.c.applyMatrix4(pP),
              (hP.needsUpdate = !0);
            for (let e = 0, t = h.count; e < t; e += 3)
              if (
                (ZD(dP, e, h, d),
                (dP.needsUpdate = !0),
                hP.intersectsTriangle(dP))
              )
                return !0;
          }
        }
      }
      const vP = new Cs(),
        yP = new ID(),
        bP = new ID(),
        _P = new Yr(),
        xP = new Yr(),
        EP = new Yr(),
        wP = new Yr();
      function CP(e, t, n, i = {}, r = {}, s = 0, a = 1 / 0) {
        t.boundingBox || t.computeBoundingBox(),
          yP.set(t.boundingBox.min, t.boundingBox.max, n),
          (yP.needsUpdate = !0);
        const o = e.geometry,
          c = o.attributes.position,
          l = o.index,
          u = t.attributes.position,
          h = t.index,
          d = BD.getPrimitive(),
          p = BD.getPrimitive();
        let f = _P,
          A = xP,
          g = null,
          m = null;
        r && ((g = EP), (m = wP));
        let v = 1 / 0,
          y = null,
          b = null;
        return (
          vP.copy(n).invert(),
          bP.matrix.copy(vP),
          e.shapecast({
            boundsTraverseOrder: (e) => yP.distanceToBox(e),
            intersectsBounds: (e, t, n) =>
              n < v &&
              n < a &&
              (t &&
                (bP.min.copy(e.min), bP.max.copy(e.max), (bP.needsUpdate = !0)),
              !0),
            intersectsRange: (e, i) => {
              if (t.boundsTree) {
                return t.boundsTree.shapecast({
                  boundsTraverseOrder: (e) => bP.distanceToBox(e),
                  intersectsBounds: (e, t, n) => n < v && n < a,
                  intersectsRange: (t, r) => {
                    for (let a = t, o = t + r; a < o; a++) {
                      ZD(p, 3 * a, h, u),
                        p.a.applyMatrix4(n),
                        p.b.applyMatrix4(n),
                        p.c.applyMatrix4(n),
                        (p.needsUpdate = !0);
                      for (let t = e, n = e + i; t < n; t++) {
                        ZD(d, 3 * t, l, c), (d.needsUpdate = !0);
                        const e = d.distanceToTriangle(p, f, g);
                        if (
                          (e < v &&
                            (A.copy(f),
                            m && m.copy(g),
                            (v = e),
                            (y = t),
                            (b = a)),
                          e < s)
                        )
                          return !0;
                      }
                    }
                  },
                });
              }
              for (let r = 0, a = GR(t); r < a; r++) {
                ZD(p, 3 * r, h, u),
                  p.a.applyMatrix4(n),
                  p.b.applyMatrix4(n),
                  p.c.applyMatrix4(n),
                  (p.needsUpdate = !0);
                for (let t = e, n = e + i; t < n; t++) {
                  ZD(d, 3 * t, l, c), (d.needsUpdate = !0);
                  const e = d.distanceToTriangle(p, f, g);
                  if (
                    (e < v &&
                      (A.copy(f), m && m.copy(g), (v = e), (y = t), (b = r)),
                    e < s)
                  )
                    return !0;
                }
              }
            },
          }),
          BD.releasePrimitive(d),
          BD.releasePrimitive(p),
          v === 1 / 0
            ? null
            : (i.point ? i.point.copy(A) : (i.point = A.clone()),
              (i.distance = v),
              (i.faceIndex = y),
              r &&
                (r.point ? r.point.copy(m) : (r.point = m.clone()),
                r.point.applyMatrix4(vP),
                A.applyMatrix4(vP),
                (r.distance = A.sub(r.point).length()),
                (r.faceIndex = b)),
              i)
        );
      }
      function SP(e, t, n, i, r, s, a) {
        const { geometry: o } = n,
          { index: c } = o,
          l = o.attributes.position;
        for (let o = e, u = t + e; o < u; o++) {
          let e;
          if (
            ((e = n.resolveTriangleIndex(o)),
            ZD(a, 3 * e, c, l),
            (a.needsUpdate = !0),
            i(a, e, r, s))
          )
            return !0;
        }
        return !1;
      }
      function IP(e, t = null) {
        t && Array.isArray(t) && (t = new Set(t));
        const n = e.geometry,
          i = n.index ? n.index.array : null,
          r = n.attributes.position;
        let s,
          a,
          o,
          c,
          l = 0;
        const u = e._roots;
        for (let e = 0, t = u.length; e < t; e++)
          (s = u[e]),
            (a = new Uint32Array(s)),
            (o = new Uint16Array(s)),
            (c = new Float32Array(s)),
            h(0, l),
            (l += s.byteLength);
        function h(n, s, l = !1) {
          const u = 2 * n;
          if (o[u + 15] === NR) {
            const t = a[n + 6];
            let s = 1 / 0,
              l = 1 / 0,
              h = 1 / 0,
              d = -1 / 0,
              p = -1 / 0,
              f = -1 / 0;
            for (let n = t, a = t + o[u + 14]; n < a; n++) {
              const t = 3 * e.resolveTriangleIndex(n);
              for (let e = 0; e < 3; e++) {
                let n = t + e;
                n = i ? i[n] : n;
                const a = r.getX(n),
                  o = r.getY(n),
                  c = r.getZ(n);
                a < s && (s = a),
                  a > d && (d = a),
                  o < l && (l = o),
                  o > p && (p = o),
                  c < h && (h = c),
                  c > f && (f = c);
              }
            }
            return (
              (c[n + 0] !== s ||
                c[n + 1] !== l ||
                c[n + 2] !== h ||
                c[n + 3] !== d ||
                c[n + 4] !== p ||
                c[n + 5] !== f) &&
              ((c[n + 0] = s),
              (c[n + 1] = l),
              (c[n + 2] = h),
              (c[n + 3] = d),
              (c[n + 4] = p),
              (c[n + 5] = f),
              !0)
            );
          }
          {
            const e = n + 8,
              i = a[n + 6],
              r = e + s,
              o = i + s;
            let u = l,
              d = !1,
              p = !1;
            t
              ? u || ((d = t.has(r)), (p = t.has(o)), (u = !d && !p))
              : ((d = !0), (p = !0));
            const f = u || p;
            let A = !1;
            (u || d) && (A = h(e, s, u));
            let g = !1;
            f && (g = h(i, s, u));
            const m = A || g;
            if (m)
              for (let t = 0; t < 3; t++) {
                const r = e + t,
                  s = i + t,
                  a = c[r],
                  o = c[r + 3],
                  l = c[s],
                  u = c[s + 3];
                (c[n + t] = a < l ? a : l), (c[n + t + 3] = o > u ? o : u);
              }
            return m;
          }
        }
      }
      const MP = new Yr();
      function TP(e, t, n, i, r) {
        RD.setBuffer(e._roots[t]), BP(0, e, n, i, r), RD.clearBuffer();
      }
      function BP(e, t, n, i, r) {
        const { float32Array: s, uint16Array: a, uint32Array: o } = RD,
          c = 2 * e;
        if (sD(c, a)) {
          !(function (e, t, n, i, r, s) {
            const { geometry: a, _indirectBuffer: o } = e;
            for (let e = i, c = i + r; e < c; e++) JD(a, t, n, o ? o[e] : e, s);
          })(t, n, i, aD(e, o), oD(c, a), r);
        } else {
          const a = cD(e);
          nP(a, s, i, MP) && BP(a, t, n, i, r);
          const c = lD(e, o);
          nP(c, s, i, MP) && BP(c, t, n, i, r);
        }
      }
      const RP = new Yr(),
        DP = ["x", "y", "z"];
      function PP(e, t, n, i) {
        RD.setBuffer(e._roots[t]);
        const r = LP(0, e, n, i);
        return RD.clearBuffer(), r;
      }
      function LP(e, t, n, i) {
        const { float32Array: r, uint16Array: s, uint32Array: a } = RD;
        let o = 2 * e;
        if (sD(o, s)) {
          return (function (e, t, n, i, r) {
            const { geometry: s, _indirectBuffer: a } = e;
            let o = 1 / 0,
              c = null;
            for (let e = i, l = i + r; e < l; e++) {
              let i;
              (i = JD(s, t, n, a ? a[e] : e)),
                i && i.distance < o && ((c = i), (o = i.distance));
            }
            return c;
          })(t, n, i, aD(e, a), oD(o, s));
        }
        {
          const s = uD(e, a),
            o = DP[s],
            c = i.direction[o] >= 0;
          let l, u;
          c ? ((l = cD(e)), (u = lD(e, a))) : ((l = lD(e, a)), (u = cD(e)));
          const h = nP(l, r, i, RP) ? LP(l, t, n, i) : null;
          if (h) {
            const e = h.point[o];
            if (c ? e <= r[u + s] : e >= r[u + s + 3]) return h;
          }
          const d = nP(u, r, i, RP) ? LP(u, t, n, i) : null;
          return h && d ? (h.distance <= d.distance ? h : d) : h || d || null;
        }
      }
      const UP = new Zr(),
        FP = new SD(),
        OP = new SD(),
        NP = new Cs(),
        kP = new ID(),
        QP = new ID();
      function GP(e, t, n, i) {
        RD.setBuffer(e._roots[t]);
        const r = HP(0, e, n, i);
        return RD.clearBuffer(), r;
      }
      function HP(e, t, n, i, r = null) {
        const { float32Array: s, uint16Array: a, uint32Array: o } = RD;
        let c = 2 * e;
        null === r &&
          (n.boundingBox || n.computeBoundingBox(),
          kP.set(n.boundingBox.min, n.boundingBox.max, i),
          (r = kP));
        if (!sD(c, a)) {
          const a = e + 8,
            c = o[e + 6];
          WR(a, s, UP);
          if (r.intersectsBox(UP) && HP(a, t, n, i, r)) return !0;
          WR(c, s, UP);
          return !!(r.intersectsBox(UP) && HP(c, t, n, i, r));
        }
        {
          const r = t.geometry,
            l = r.index,
            u = r.attributes.position,
            h = n.index,
            d = n.attributes.position,
            p = aD(e, o),
            f = oD(c, a);
          if ((NP.copy(i).invert(), n.boundsTree)) {
            WR(e, s, QP), QP.matrix.copy(NP), (QP.needsUpdate = !0);
            const r = n.boundsTree.shapecast({
              intersectsBounds: (e) => QP.intersectsBox(e),
              intersectsTriangle: (e) => {
                e.a.applyMatrix4(i),
                  e.b.applyMatrix4(i),
                  e.c.applyMatrix4(i),
                  (e.needsUpdate = !0);
                for (let n = p, i = f + p; n < i; n++)
                  if (
                    (ZD(OP, 3 * t.resolveTriangleIndex(n), l, u),
                    (OP.needsUpdate = !0),
                    e.intersectsTriangle(OP))
                  )
                    return !0;
                return !1;
              },
            });
            return r;
          }
          for (let e = p, n = f + p; e < n; e++) {
            const n = t.resolveTriangleIndex(e);
            ZD(FP, 3 * n, l, u),
              FP.a.applyMatrix4(NP),
              FP.b.applyMatrix4(NP),
              FP.c.applyMatrix4(NP),
              (FP.needsUpdate = !0);
            for (let e = 0, t = h.count; e < t; e += 3)
              if (
                (ZD(OP, e, h, d),
                (OP.needsUpdate = !0),
                FP.intersectsTriangle(OP))
              )
                return !0;
          }
        }
      }
      const zP = new Cs(),
        VP = new ID(),
        jP = new ID(),
        WP = new Yr(),
        XP = new Yr(),
        qP = new Yr(),
        YP = new Yr();
      function KP(e, t, n, i = {}, r = {}, s = 0, a = 1 / 0) {
        t.boundingBox || t.computeBoundingBox(),
          VP.set(t.boundingBox.min, t.boundingBox.max, n),
          (VP.needsUpdate = !0);
        const o = e.geometry,
          c = o.attributes.position,
          l = o.index,
          u = t.attributes.position,
          h = t.index,
          d = BD.getPrimitive(),
          p = BD.getPrimitive();
        let f = WP,
          A = XP,
          g = null,
          m = null;
        r && ((g = qP), (m = YP));
        let v = 1 / 0,
          y = null,
          b = null;
        return (
          zP.copy(n).invert(),
          jP.matrix.copy(zP),
          e.shapecast({
            boundsTraverseOrder: (e) => VP.distanceToBox(e),
            intersectsBounds: (e, t, n) =>
              n < v &&
              n < a &&
              (t &&
                (jP.min.copy(e.min), jP.max.copy(e.max), (jP.needsUpdate = !0)),
              !0),
            intersectsRange: (i, r) => {
              if (t.boundsTree) {
                const o = t.boundsTree;
                return o.shapecast({
                  boundsTraverseOrder: (e) => jP.distanceToBox(e),
                  intersectsBounds: (e, t, n) => n < v && n < a,
                  intersectsRange: (t, a) => {
                    for (let _ = t, x = t + a; _ < x; _++) {
                      const t = o.resolveTriangleIndex(_);
                      ZD(p, 3 * t, h, u),
                        p.a.applyMatrix4(n),
                        p.b.applyMatrix4(n),
                        p.c.applyMatrix4(n),
                        (p.needsUpdate = !0);
                      for (let t = i, n = i + r; t < n; t++) {
                        const n = e.resolveTriangleIndex(t);
                        ZD(d, 3 * n, l, c), (d.needsUpdate = !0);
                        const i = d.distanceToTriangle(p, f, g);
                        if (
                          (i < v &&
                            (A.copy(f),
                            m && m.copy(g),
                            (v = i),
                            (y = t),
                            (b = _)),
                          i < s)
                        )
                          return !0;
                      }
                    }
                  },
                });
              }
              for (let a = 0, o = GR(t); a < o; a++) {
                ZD(p, 3 * a, h, u),
                  p.a.applyMatrix4(n),
                  p.b.applyMatrix4(n),
                  p.c.applyMatrix4(n),
                  (p.needsUpdate = !0);
                for (let t = i, n = i + r; t < n; t++) {
                  const n = e.resolveTriangleIndex(t);
                  ZD(d, 3 * n, l, c), (d.needsUpdate = !0);
                  const i = d.distanceToTriangle(p, f, g);
                  if (
                    (i < v &&
                      (A.copy(f), m && m.copy(g), (v = i), (y = t), (b = a)),
                    i < s)
                  )
                    return !0;
                }
              }
            },
          }),
          BD.releasePrimitive(d),
          BD.releasePrimitive(p),
          v === 1 / 0
            ? null
            : (i.point ? i.point.copy(A) : (i.point = A.clone()),
              (i.distance = v),
              (i.faceIndex = y),
              r &&
                (r.point ? r.point.copy(m) : (r.point = m.clone()),
                r.point.applyMatrix4(zP),
                A.applyMatrix4(zP),
                (r.distance = A.sub(r.point).length()),
                (r.faceIndex = b)),
              i)
        );
      }
      const JP = new RD.constructor(),
        ZP = new RD.constructor(),
        $P = new MD(() => new Zr()),
        eL = new Zr(),
        tL = new Zr(),
        nL = new Zr(),
        iL = new Zr();
      let rL = !1;
      function sL(e, t, n, i, r, s = 0, a = 0, o = 0, c = 0, l = null, u = !1) {
        let h, d;
        u ? ((h = ZP), (d = JP)) : ((h = JP), (d = ZP));
        const p = h.float32Array,
          f = h.uint32Array,
          A = h.uint16Array,
          g = d.float32Array,
          m = d.uint32Array,
          v = d.uint16Array,
          y = 2 * t,
          b = sD(2 * e, A),
          _ = sD(y, v);
        let x = !1;
        if (_ && b)
          x = u
            ? r(
                aD(t, m),
                oD(2 * t, v),
                aD(e, f),
                oD(2 * e, A),
                c,
                a + t,
                o,
                s + e
              )
            : r(
                aD(e, f),
                oD(2 * e, A),
                aD(t, m),
                oD(2 * t, v),
                o,
                s + e,
                c,
                a + t
              );
        else if (_) {
          const l = $P.getPrimitive();
          WR(t, g, l), l.applyMatrix4(n);
          const h = cD(e),
            d = lD(e, f);
          WR(h, p, eL), WR(d, p, tL);
          const A = l.intersectsBox(eL),
            m = l.intersectsBox(tL);
          (x =
            (A && sL(t, h, i, n, r, a, s, c, o + 1, l, !u)) ||
            (m && sL(t, d, i, n, r, a, s, c, o + 1, l, !u))),
            $P.releasePrimitive(l);
        } else {
          const h = cD(t),
            d = lD(t, m);
          WR(h, g, nL), WR(d, g, iL);
          const A = l.intersectsBox(nL),
            v = l.intersectsBox(iL);
          if (A && v)
            x =
              sL(e, h, n, i, r, s, a, o, c + 1, l, u) ||
              sL(e, d, n, i, r, s, a, o, c + 1, l, u);
          else if (A)
            if (b) x = sL(e, h, n, i, r, s, a, o, c + 1, l, u);
            else {
              const t = $P.getPrimitive();
              t.copy(nL).applyMatrix4(n);
              const l = cD(e),
                d = lD(e, f);
              WR(l, p, eL), WR(d, p, tL);
              const A = t.intersectsBox(eL),
                g = t.intersectsBox(tL);
              (x =
                (A && sL(h, l, i, n, r, a, s, c, o + 1, t, !u)) ||
                (g && sL(h, d, i, n, r, a, s, c, o + 1, t, !u))),
                $P.releasePrimitive(t);
            }
          else if (v)
            if (b) x = sL(e, d, n, i, r, s, a, o, c + 1, l, u);
            else {
              const t = $P.getPrimitive();
              t.copy(iL).applyMatrix4(n);
              const l = cD(e),
                h = lD(e, f);
              WR(l, p, eL), WR(h, p, tL);
              const A = t.intersectsBox(eL),
                g = t.intersectsBox(tL);
              (x =
                (A && sL(d, l, i, n, r, a, s, c, o + 1, t, !u)) ||
                (g && sL(d, h, i, n, r, a, s, c, o + 1, t, !u))),
                $P.releasePrimitive(t);
            }
        }
        return x;
      }
      const aL = new ID(),
        oL = new Zr(),
        cL = {
          strategy: RR,
          maxDepth: 40,
          maxLeafTris: 10,
          useSharedArrayBuffer: !1,
          setBoundingBox: !0,
          onProgress: null,
          indirect: !1,
          verbose: !0,
        };
      class lL {
        static serialize(e, t = {}) {
          t = { cloneBuffers: !0, ...t };
          const n = e.geometry,
            i = e._roots,
            r = e._indirectBuffer,
            s = n.getIndex();
          let a;
          return (
            (a = t.cloneBuffers
              ? {
                  roots: i.map((e) => e.slice()),
                  index: s.array.slice(),
                  indirectBuffer: r ? r.slice() : null,
                }
              : { roots: i, index: s.array, indirectBuffer: r }),
            a
          );
        }
        static deserialize(e, t, n = {}) {
          n = { setIndex: !0, indirect: Boolean(e.indirectBuffer), ...n };
          const { index: i, roots: r, indirectBuffer: s } = e,
            a = new lL(t, { ...n, [QR]: !0 });
          if (((a._roots = r), (a._indirectBuffer = s || null), n.setIndex)) {
            const n = t.getIndex();
            if (null === n) {
              const n = new Ta(e.index, 1, !1);
              t.setIndex(n);
            } else n.array !== i && (n.array.set(i), (n.needsUpdate = !0));
          }
          return a;
        }
        get indirect() {
          return !!this._indirectBuffer;
        }
        constructor(e, t = {}) {
          if (!e.isBufferGeometry)
            throw new Error("MeshBVH: Only BufferGeometries are supported.");
          if (e.index && e.index.isInterleavedBufferAttribute)
            throw new Error(
              "MeshBVH: InterleavedBufferAttribute is not supported for the index attribute."
            );
          if (
            (t = Object.assign({ ...cL, [QR]: !1 }, t)).useSharedArrayBuffer &&
            "undefined" == typeof SharedArrayBuffer
          )
            throw new Error("MeshBVH: SharedArrayBuffer is not available.");
          (this.geometry = e),
            (this._roots = null),
            (this._indirectBuffer = null),
            t[QR] ||
              (bD(this, t),
              !e.boundingBox &&
                t.setBoundingBox &&
                (e.boundingBox = this.getBoundingBox(new Zr())));
          const { _indirectBuffer: n } = this;
          this.resolveTriangleIndex = t.indirect ? (e) => n[e] : (e) => e;
        }
        refit(e = null) {
          return (this.indirect ? IP : eP)(this, e);
        }
        traverse(e, t = 0) {
          const n = this._roots[t],
            i = new Uint32Array(n),
            r = new Uint16Array(n);
          !(function t(s, a = 0) {
            const o = 2 * s,
              c = r[o + 15] === NR;
            if (c) {
              const t = i[s + 6],
                l = r[o + 14];
              e(a, c, new Float32Array(n, 4 * s, 6), t, l);
            } else {
              const r = s + OR / 4,
                o = i[s + 6],
                l = i[s + 7];
              e(a, c, new Float32Array(n, 4 * s, 6), l) ||
                (t(r, a + 1), t(o, a + 1));
            }
          })(0);
        }
        raycast(e, t = cn) {
          const n = this._roots,
            i = this.geometry,
            r = [],
            s = t.isMaterial,
            a = Array.isArray(t),
            o = i.groups,
            c = s ? t.side : t,
            l = this.indirect ? TP : rP;
          for (let i = 0, s = n.length; i < s; i++) {
            const n = a ? t[o[i].materialIndex].side : c,
              s = r.length;
            if ((l(this, i, n, e, r), a)) {
              const e = o[i].materialIndex;
              for (let t = s, n = r.length; t < n; t++)
                r[t].face.materialIndex = e;
            }
          }
          return r;
        }
        raycastFirst(e, t = cn) {
          const n = this._roots,
            i = this.geometry,
            r = t.isMaterial,
            s = Array.isArray(t);
          let a = null;
          const o = i.groups,
            c = r ? t.side : t,
            l = this.indirect ? PP : cP;
          for (let i = 0, r = n.length; i < r; i++) {
            const n = l(this, i, s ? t[o[i].materialIndex].side : c, e);
            null != n &&
              (null == a || n.distance < a.distance) &&
              ((a = n), s && (n.face.materialIndex = o[i].materialIndex));
          }
          return a;
        }
        intersectsGeometry(e, t) {
          let n = !1;
          const i = this._roots,
            r = this.indirect ? GP : gP;
          for (
            let s = 0, a = i.length;
            s < a && ((n = r(this, s, e, t)), !n);
            s++
          );
          return n;
        }
        shapecast(e) {
          const t = BD.getPrimitive(),
            n = this.indirect ? SP : $D;
          let {
            boundsTraverseOrder: i,
            intersectsBounds: r,
            intersectsRange: s,
            intersectsTriangle: a,
          } = e;
          if (s && a) {
            const e = s;
            s = (i, r, s, o, c) =>
              !!e(i, r, s, o, c) || n(i, r, this, a, s, o, t);
          } else
            s ||
              (s = a
                ? (e, i, r, s) => n(e, i, this, a, r, s, t)
                : (e, t, n) => n);
          let o = !1,
            c = 0;
          const l = this._roots;
          for (let e = 0, t = l.length; e < t; e++) {
            const t = l[e];
            if (((o = FD(this, e, r, s, i, c)), o)) break;
            c += t.byteLength;
          }
          return BD.releasePrimitive(t), o;
        }
        bvhcast(e, t, n) {
          let { intersectsRanges: i, intersectsTriangles: r } = n;
          const s = BD.getPrimitive(),
            a = this.geometry.index,
            o = this.geometry.attributes.position,
            c = this.indirect
              ? (e) => {
                  const t = this.resolveTriangleIndex(e);
                  ZD(s, 3 * t, a, o);
                }
              : (e) => {
                  ZD(s, 3 * e, a, o);
                },
            l = BD.getPrimitive(),
            u = e.geometry.index,
            h = e.geometry.attributes.position,
            d = e.indirect
              ? (t) => {
                  const n = e.resolveTriangleIndex(t);
                  ZD(l, 3 * n, u, h);
                }
              : (e) => {
                  ZD(l, 3 * e, u, h);
                };
          if (r) {
            const e = (e, n, i, a, o, u, h, p) => {
              for (let f = i, A = i + a; f < A; f++) {
                d(f),
                  l.a.applyMatrix4(t),
                  l.b.applyMatrix4(t),
                  l.c.applyMatrix4(t),
                  (l.needsUpdate = !0);
                for (let t = e, i = e + n; t < i; t++)
                  if ((c(t), (s.needsUpdate = !0), r(s, l, t, f, o, u, h, p)))
                    return !0;
              }
              return !1;
            };
            if (i) {
              const t = i;
              i = function (n, i, r, s, a, o, c, l) {
                return !!t(n, i, r, s, a, o, c, l) || e(n, i, r, s, a, o, c, l);
              };
            } else i = e;
          }
          return (function (e, t, n, i) {
            if (rL)
              throw new Error(
                "MeshBVH: Recursive calls to bvhcast not supported."
              );
            rL = !0;
            const r = e._roots,
              s = t._roots;
            let a,
              o = 0,
              c = 0;
            const l = new Cs().copy(n).invert();
            for (let e = 0, t = r.length; e < t; e++) {
              JP.setBuffer(r[e]), (c = 0);
              const t = $P.getPrimitive();
              WR(0, JP.float32Array, t), t.applyMatrix4(l);
              for (
                let r = 0, u = s.length;
                r < u &&
                (ZP.setBuffer(s[e]),
                (a = sL(0, 0, n, l, i, o, c, 0, 0, t)),
                ZP.clearBuffer(),
                (c += s[r].length),
                !a);
                r++
              );
              if (
                ($P.releasePrimitive(t),
                JP.clearBuffer(),
                (o += r[e].length),
                a)
              )
                break;
            }
            return (rL = !1), a;
          })(this, e, t, i);
        }
        intersectsBox(e, t) {
          return (
            aL.set(e.min, e.max, t),
            (aL.needsUpdate = !0),
            this.shapecast({
              intersectsBounds: (e) => aL.intersectsBox(e),
              intersectsTriangle: (e) => aL.intersectsTriangle(e),
            })
          );
        }
        intersectsSphere(e) {
          return this.shapecast({
            intersectsBounds: (t) => e.intersectsBox(t),
            intersectsTriangle: (t) => t.intersectsSphere(e),
          });
        }
        closestPointToGeometry(e, t, n = {}, i = {}, r = 0, s = 1 / 0) {
          return (this.indirect ? KP : CP)(this, e, t, n, i, r, s);
        }
        closestPointToPoint(e, t = {}, n = 0, i = 1 / 0) {
          return (function (e, t, n = {}, i = 0, r = 1 / 0) {
            const s = i * i,
              a = r * r;
            let o = 1 / 0,
              c = null;
            if (
              (e.shapecast({
                boundsTraverseOrder: (e) => (
                  ND.copy(t).clamp(e.min, e.max), ND.distanceToSquared(t)
                ),
                intersectsBounds: (e, t, n) => n < o && n < a,
                intersectsTriangle: (e, n) => {
                  e.closestPointToPoint(t, ND);
                  const i = t.distanceToSquared(ND);
                  return i < o && (kD.copy(ND), (o = i), (c = n)), i < s;
                },
              }),
              o === 1 / 0)
            )
              return null;
            const l = Math.sqrt(o);
            return (
              n.point ? n.point.copy(kD) : (n.point = kD.clone()),
              (n.distance = l),
              (n.faceIndex = c),
              n
            );
          })(this, e, t, n, i);
        }
        getBoundingBox(e) {
          e.makeEmpty();
          return (
            this._roots.forEach((t) => {
              WR(0, new Float32Array(t), oL), e.union(oL);
            }),
            e
          );
        }
      }
      const uL = new ws(),
        hL = new Cs(),
        dL = Za.prototype.raycast;
      function pL(e, t) {
        if (this.geometry.boundsTree) {
          if (void 0 === this.material) return;
          hL.copy(this.matrixWorld).invert(), uL.copy(e.ray).applyMatrix4(hL);
          const n = this.geometry.boundsTree;
          if (!0 === e.firstHitOnly) {
            const i = BR(n.raycastFirst(uL, this.material), this, e);
            i && t.push(i);
          } else {
            const i = n.raycast(uL, this.material);
            for (let n = 0, r = i.length; n < r; n++) {
              const r = BR(i[n], this, e);
              r && t.push(r);
            }
          }
        } else dL.call(this, e, t);
      }
      const fL = 30;
      function AL(e) {
        const {
            canvas: t,
            eventDispatcher: n,
            getActiveCamera: i,
            getActiveScene: r,
          } = e,
          s = t.parentElement,
          a = new ap();
        a.layers.set(De.Raycast), (a.firstHitOnly = !0);
        const o = hv(
          function (e) {
            const t = { type: P_.MouseMove, data: u(e), mouseEvent: e };
            n.dispatchEvent(t);
          },
          fL,
          { maxWait: fL, leading: !0 }
        );
        function c(e) {
          if (4 === (void 0 !== e.buttons ? e.buttons : e.which)) return;
          const t = { type: P_.MouseDown, data: u(e), mouseEvent: e };
          n.dispatchEvent(t);
        }
        t.addEventListener("mousedown", c),
          t.addEventListener("mouseup", function (e) {
            const t = { type: P_.MouseUp, data: u(e), mouseEvent: e };
            n.dispatchEvent(t);
          }),
          t.addEventListener("mousemove", o);
        const l = new br();
        function u(e) {
          const n = i(),
            o = r();
          if (!o || !n)
            return {
              distance: 0,
              object: null,
              x: 0,
              y: 0,
              point: null,
              ray: a.ray,
            };
          const c = s.getBoundingClientRect();
          (l.x = ((e.clientX - c.left) / t.clientWidth) * 2 - 1),
            (l.y = (-(e.clientY - c.top) / t.clientHeight) * 2 + 1),
            a.setFromCamera(l, n);
          let u = [];
          if (
            (GL
              ? (a.layers.set(De.HelpersRaycast),
                (u = a.intersectObject(o)),
                u.length ||
                  (a.layers.set(De.Raycast), (u = a.intersectObject(o))))
              : (a.layers.set(De.Raycast), (u = a.intersectObject(o))),
            !u.length)
          )
            return {
              distance: 0,
              object: null,
              x: l.x,
              y: l.y,
              point: null,
              ray: a.ray,
            };
          const h = u[0];
          return {
            distance: h.distance,
            object: h.object,
            point: h.point,
            ray: a.ray,
            x: l.x,
            y: l.y,
          };
        }
        const h = new Cs(),
          d = new xo(),
          p = new Set(),
          f = new Zr();
        return {
          dispose: function () {
            t.removeEventListener("mousedown", c),
              t.removeEventListener("mousemove", o);
          },
          getObjectPositionOnScreen: function (e) {
            const t = i(),
              n = new Yr();
            return e.getWorldPosition(n), n.project(t);
          },
          getObjectIntersectionAtPointer: function (e, t, n, r) {
            r ? a.layers.set(r) : a.layers.enableAll();
            const s = i();
            if ((a.setFromCamera(t, s), a.intersectObject(e, n).length > 0))
              return a.intersectObject(e)[0];
          },
          getObjectsInScreenView: function (e, t) {
            const n = i(),
              s = r();
            return (
              n instanceof uo &&
                (function (n) {
                  const { near: i, far: r, fov: s, aspect: a, zoom: o } = n;
                  let c = (i * Math.tan(0.5 * yr.DEG2RAD * s)) / o,
                    l = 2 * c,
                    u = a * l,
                    d = -0.5 * u;
                  (c = -(e.y - 0.5) * l),
                    (l *= t.y - e.y),
                    (d = (e.x - 0.5) * u),
                    (u *= t.x - e.x),
                    h.makePerspective(d, d + u, c, c - l, i, r);
                })(n),
              n instanceof No &&
                (function (n) {
                  const {
                      near: i,
                      far: r,
                      left: s,
                      right: a,
                      top: o,
                      bottom: c,
                      zoom: l,
                    } = n,
                    u = (a - s) / (2 * l),
                    d = (o - c) / (2 * l),
                    p = (a + s) / 2,
                    f = (o + c) / 2;
                  let A = p - u,
                    g = p + u,
                    m = f + d,
                    v = f - d;
                  const y = m - v,
                    b = g - A;
                  (m -= e.y * y),
                    (v += (1 - t.y) * y),
                    (A += e.x * b),
                    (g -= (1 - t.x) * b),
                    h.makeOrthographic(A, g, m, v, i, r);
                })(n),
              h.multiply(n.matrixWorldInverse),
              d.setFromProjectionMatrix(h),
              p.clear(),
              s.traverseVisible((e) => {
                if (!e.userData.isCollider) return;
                if (!e.layers.isEnabled(De.Raycast)) return;
                const t = e;
                if (
                  (null === t.geometry.boundingBox &&
                    t.geometry.computeBoundingBox(),
                  f.copy(t.geometry.boundingBox).applyMatrix4(t.matrixWorld),
                  d.intersectsBox(f))
                ) {
                  const t = k_(e);
                  if (!t) return;
                  p.has(t.uuid) || p.add(t.uuid);
                }
              }),
              [...p]
            );
          },
        };
      }
      (Za.prototype.raycast = pL),
        (Bu.prototype.raycast = pL),
        (Vu.prototype.raycast = pL),
        (Qa.prototype.computeBoundsTree = function (e) {
          return (this.boundsTree = new lL(this, e)), this.boundsTree;
        }),
        (Qa.prototype.disposeBoundsTree = function () {
          this.boundsTree = null;
        });
      const gL = function (e, t) {
          return Db(e, t);
        },
        mL = { [Qe.Front]: cn, [Qe.Back]: ln, [Qe.Double]: un },
        vL = {
          [ke.Lit]: Yh,
          [ke.Unlit]: _a,
          [ke.Phong]: Jh,
          [ke.Physical]: Kh,
        };
      function yL(e) {
        const {
          resourceManager: t,
          materials: n,
          objects: i,
          getActiveScene: r,
        } = e;
        function s(e) {
          return n.get(e);
        }
        function a(e) {
          const t = vL[e.type];
          if (!t) throw Error("Material type not supported");
          const i = (function (e, t) {
            const n = e,
              i = new Proxy(
                e,
                F_(Array.from(fp[t]), (e) =>
                  n.dispatchEvent({ type: U_.Update, property: e, target: n })
                )
              );
            return i;
          })(new t(), e.type);
          return (i.uuid = e.uuid), n.set(e.uuid, i), o(e);
        }
        function o(t, i, s = !1) {
          var a, o, l, u, h, d, p, f;
          const {
              name: A,
              side: g,
              color: m,
              opacity: v,
              transparent: y,
              alphaTest: b,
            } = t,
            _ = n.get(t.uuid);
          if (!_) throw Error(`Material with ${t.uuid} does not exist`);
          s || (_.color.set(m), (_.opacity = v)),
            (_.name = A || ""),
            (_.side = mL[g]),
            (_.transparent = y),
            (_.userData.isTransparent = y),
            (_.alphaTest = b);
          const x = [
            c(t, "map", null == i ? void 0 : i.map),
            c(t, "alphaMap", null == i ? void 0 : i.alphaMap),
          ];
          if (t.type === ke.Unlit) {
            if (!(_ instanceof _a)) throw Error("Material type mismatch");
            s || (_.reflectivity = t.reflectivity),
              x.push(c(t, "specularMap", null == i ? void 0 : i.specularMap));
            const n =
              null ===
                (l =
                  null ===
                    (o =
                      null === (a = r()) || void 0 === a
                        ? void 0
                        : a.environment) || void 0 === o
                    ? void 0
                    : o.userData) || void 0 === l
                ? void 0
                : l.originalTextureUuid;
            n &&
              (null === (u = e.resourceManager.getResource(n)) ||
                void 0 === u ||
                u.assetInstance.then((e) => {
                  const t = e.reflection;
                  _.envMap = t;
                }));
          }
          if (
            (function (e) {
              return e.type === ke.Lit;
            })(t) ||
            qt(t)
          ) {
            if (
              !(function (e) {
                return "MeshStandardMaterial" === e.type;
              })(_) &&
              !nn(_)
            )
              throw Error("Material type mismatch");
            const {
              flatShading: e,
              roughness: n,
              displacementScale: r,
              emissive: a,
              emissiveIntensity: o,
              metalness: l,
            } = t;
            if (
              (s ||
                ((_.metalness = l),
                (_.roughness = n),
                (_.emissiveIntensity = o),
                (_.displacementScale = r),
                _.emissive.set(a)),
              (_.flatShading = e),
              x.push(
                c(t, "metalnessMap", null == i ? void 0 : i.metalnessMap),
                c(t, "emissiveMap", null == i ? void 0 : i.emissiveMap),
                c(t, "normalMap", null == i ? void 0 : i.normalMap),
                c(t, "roughnessMap", null == i ? void 0 : i.roughnessMap),
                c(t, "displacementMap", null == i ? void 0 : i.displacementMap)
              ),
              qt(t) && nn(_))
            ) {
              const {
                ior: e,
                reflectivity: n,
                iridescence: r,
                iridescenceIOR: a,
                sheen: o,
                sheenColor: l,
                sheenRoughness: u,
                clearcoat: h,
                clearcoatRoughness: d,
                transmission: p,
                dispersion: f,
                thickness: A,
                attenuationColor: g,
                attenuationDistance: m,
                specularIntensity: v,
                specularColor: y,
              } = t;
              s ||
                ((_.ior = e),
                (_.reflectivity = n),
                (_.iridescence = r),
                (_.iridescenceIOR = a),
                (_.sheen = o),
                (_.sheenRoughness = u),
                _.sheenColor.set(l),
                (_.clearcoat = h),
                (_.clearcoatRoughness = d),
                (_.transmission = p),
                (_.dispersion = f),
                (_.thickness = A),
                _.attenuationColor.set(g),
                (_.attenuationDistance = 0 === m ? 1 / 0 : m),
                _.specularColor.set(y),
                (_.specularIntensity = v)),
                x.push(
                  c(t, "iridescenceMap", null == i ? void 0 : i.iridescenceMap)
                );
            }
          }
          if (
            (function (e) {
              return e.type === ke.Phong;
            })(t)
          ) {
            if (!(_ instanceof Jh)) throw Error("Material type mismatch");
            const {
              flatShading: n,
              bumpScale: a,
              displacementScale: o,
              emissive: l,
              emissiveIntensity: u,
              refractionRatio: A,
              useRefraction: g,
              shininess: m,
              reflectivity: v,
              specular: y,
            } = t;
            s ||
              ((_.bumpScale = a),
              (_.reflectivity = v),
              (_.emissiveIntensity = u),
              (_.displacementScale = o),
              _.emissive.set(l),
              _.specular.set(y),
              (_.refractionRatio = A),
              (_.shininess = m)),
              (_.userData.useRefraction = g),
              (_.flatShading = n),
              x.push(
                c(t, "specularMap", null == i ? void 0 : i.specularMap),
                c(t, "emissiveMap", null == i ? void 0 : i.emissiveMap),
                c(t, "normalMap", null == i ? void 0 : i.normalMap),
                c(t, "bumpMap", null == i ? void 0 : i.bumpMap),
                c(t, "displacementMap", null == i ? void 0 : i.displacementMap)
              );
            const b =
              null ===
                (p =
                  null ===
                    (d =
                      null === (h = r()) || void 0 === h
                        ? void 0
                        : h.environment) || void 0 === d
                    ? void 0
                    : d.userData) || void 0 === p
                ? void 0
                : p.originalTextureUuid;
            b &&
              (null === (f = e.resourceManager.getResource(b)) ||
                void 0 === f ||
                f.assetInstance.then((e) => {
                  const t = e;
                  _.envMap = g ? t.refraction : t.reflection;
                }));
          }
          return (_.needsUpdate = !0), Promise.all(x);
        }
        const c = (e, r, s) => {
          var a, o;
          const c = e[r],
            l = n.get(e.uuid);
          if (!l) throw new Error(`Material with ${e.uuid} does not exist`);
          if (
            (s &&
              s.uuid !== (null == c ? void 0 : c.uuid) &&
              t.deleteResource(s.uuid),
            gL(c, s))
          )
            return;
          if (!c) return void (l[r] = null);
          const u = (e) => {
            e
              ? ((l[r] = e),
                (e.wrapS = bL[c.wrapS]),
                (e.wrapT = bL[c.wrapT]),
                e.repeat.set(c.repeat.x, c.repeat.y),
                e.offset.set(c.offset.x, c.offset.y),
                e.center.set(c.center.x, c.center.y),
                e.image && (e.needsUpdate = !0),
                (l.needsUpdate = !0),
                Xt(c) &&
                  ((s && Xt(s) && s.loop === c.loop) || e.source.data.play(),
                  (e.source.data.loop = c.loop)))
              : (l[r] = null);
          };
          if (c) {
            if (c.assetUrl !== pp)
              return null ===
                (o = t.getResource(c.uuid) || t.createResource(c)) ||
                void 0 === o
                ? void 0
                : o.assetInstance.then((e) => {
                    u(e);
                  });
            {
              const t =
                null === (a = i.get(e.overrideObjectId)) || void 0 === a
                  ? void 0
                  : a.userData;
              if (!t) return;
              u(t.originalMaps[e.overrideMaterialIndex][r]);
            }
          }
        };
        return {
          dispose: function () {
            n.forEach((e) => N_(e));
          },
          createMaterial: a,
          updateMaterial: o,
          getMaterial: s,
          deleteMaterial: function (e) {
            const t = n.get(e);
            if (!t)
              throw new Error(
                `Cannot delete material that does not exist! ${e}`
              );
            t.dispose(), n.delete(e);
          },
          replaceMaterial: function (e, t) {
            const i = n.get(t.uuid);
            if (!i) return;
            i.uuid = vp();
            const o = r();
            a(e);
            const c = s(e.uuid);
            o.traverse((e) => {
              ("Mesh" === e.type ||
                (function (e) {
                  return "SkinnedMesh" === e.type;
                })(e)) &&
                e.material.uuid === i.uuid &&
                (e.material = c);
            }),
              i.dispose();
          },
        };
      }
      const bL = { [ze.Clamp]: Bn, [ze.Repeat]: Tn, [ze.MirroredRepeat]: Rn };
      function _L(e) {
        let t = null;
        if (
          (function (e) {
            return e.type === Fe.Plane;
          })(e)
        ) {
          const {
            width: n,
            height: i,
            widthSegments: r,
            heightSegments: s,
          } = e;
          t = new Co(n, i, r, s);
        }
        if (
          (function (e) {
            return e.type === Fe.Box;
          })(e)
        ) {
          const {
            width: n,
            height: i,
            depth: r,
            widthSegments: s,
            heightSegments: a,
            depthSegments: o,
          } = e;
          t = new eo(n, i, r, s, a, o);
        }
        if (
          (function (e) {
            return e.type === Fe.Sphere;
          })(e)
        ) {
          const {
            radius: n,
            widthSegments: i,
            heightSegments: r,
            phiStart: s,
            phiLength: a,
            thetaStart: o,
            thetaLength: c,
          } = e;
          t = new Xh(n, i, r, s, a, o, c);
        }
        if (
          (function (e) {
            return e.type === Fe.Cylinder;
          })(e)
        ) {
          const {
            radiusTop: n,
            radiusBottom: i,
            height: r,
            radialSegments: s,
            heightSegments: a,
            openEnded: o,
            thetaStart: c,
            thetaLength: l,
          } = e;
          t = new mh(n, i, r, s, a, o, c, l);
        }
        if (
          (function (e) {
            return e.type === Fe.Torus;
          })(e)
        ) {
          const {
            radius: n,
            tube: i,
            radialSegments: r,
            tubularSegments: s,
            arc: a,
          } = e;
          t = new qh(n, i, r, s, a);
        }
        if (
          (function (e) {
            return e.type === Fe.Cone;
          })(e)
        ) {
          const {
            radius: n,
            height: i,
            radialSegments: r,
            heightSegments: s,
            openEnded: a,
            thetaStart: o,
            thetaLength: c,
          } = e;
          t = new vh(n, i, r, s, a, o, c);
        }
        if (!t) throw new Error("Unknown geometry type!");
        return (
          t.computeBoundsTree({ maxLeafTris: 5, maxDepth: 18, strategy: RR }),
          (t.uuid = e.uuid),
          t
        );
      }
      const xL = 10;
      function EL(e, t) {
        const n = (function (e) {
          const t = new Ko(e);
          t.compileCubemapShader();
          const n = new mu(),
            i = new Hd(),
            r = new Za(
              new Xh(1).scale(1, 1, -1),
              new Zh({ transparent: !0, depthTest: !1 })
            ),
            s = new Za(new Xh(1).scale(1, 1, -1), new Zh({ depthTest: !1 }));
          return (
            n.add(s),
            n.add(r),
            n.add(i),
            {
              generateEnvironment: function (e, a, o, c, l) {
                return (
                  s.material.color.set(o),
                  (i.intensity = l),
                  (r.material.map = e),
                  (r.material.opacity = c),
                  (r.rotation.y = a),
                  t.fromScene(n).texture
                );
              },
            }
          );
        })(e.renderer);
        function i(e, t) {
          var n;
          const { intensity: i, color: r, castShadow: s, shadowQuality: a } = t;
          if (
            ((e.intensity = i),
            e.color.set(r),
            s &&
              (e.shadow &&
                ((e.shadow.mapSize.width = Number(a)),
                (e.shadow.mapSize.height = Number(a)),
                null === (n = e.shadow.map) || void 0 === n || n.dispose(),
                (e.shadow.map = null),
                (e.shadow.normalBias = 0.03),
                e.shadow.isDirectionalLightShadow &&
                  ((e.shadow.camera.top = xL),
                  (e.shadow.camera.right = xL),
                  (e.shadow.camera.left = -xL),
                  (e.shadow.camera.bottom = -xL)),
                (e.shadow.needsUpdate = !0)),
              en(t) && (e.castShadow = !1)),
            Zt(t))
          ) {
            const n = e,
              { decay: i, distance: r } = t;
            void 0 !== i && (n.decay = i), void 0 !== r && (n.distance = r);
          }
          if (tn(t)) {
            const n = e,
              { decay: i, distance: r, penumbra: s, angle: a } = t;
            void 0 !== i && (n.decay = i),
              void 0 !== r && (n.distance = r),
              void 0 !== s && (n.penumbra = s),
              void 0 !== a && (n.angle = a);
          }
          if ($t(t)) {
            const n = e,
              { target: i } = t;
            i && Q_(n.target.position, i);
          }
        }
        function r(e, t) {
          var n, i;
          Q_(e.position, t.position),
            Q_(e.scale, t.scale),
            (n = e.rotation),
            (i = t.rotation),
            n.setFromVector3(Q_(G_, i));
        }
        return {
          updateObject: function (s, a, o = !1) {
            const c = e.objects.get(s.uuid);
            if (!c)
              throw new Error(
                "Objects that you are trying to update doesn't exist!"
              );
            (c.name = s.name),
              (c.visible = s.visible),
              (c.castShadow = s.castShadow),
              (c.receiveShadow = s.receiveShadow),
              o || r(c, s),
              jt(s) &&
                (function (n, i, r) {
                  var s;
                  const {
                    uuid: a,
                    object: o,
                    animation: c,
                    castShadow: l,
                    receiveShadow: u,
                  } = i;
                  if (
                    ((r && r.castShadow === l && r.receiveShadow === u) ||
                      n.traverse((e) => {
                        (e.castShadow = i.castShadow),
                          (e.receiveShadow = i.receiveShadow);
                      }),
                    gL(null == r ? void 0 : r.animation, c))
                  )
                    return;
                  const { clipName: h } = c;
                  h
                    ? null === (s = e.getResource(o.uuid)) ||
                      void 0 === s ||
                      s.assetInstance.then((e) => {
                        var i;
                        if (o.assetType !== Ge.Gltf) return;
                        const s = e.animations;
                        (null == r ? void 0 : r.animation.clipName) &&
                          r.animation.clipName !== h &&
                          t.removeAnimation(r.uuid, r.animation.clipName);
                        const l = t.getAnimation(a, h);
                        if (l) t.updateAnimation(a, c), l.play();
                        else {
                          const e = s.find((e) => e.name === h),
                            r =
                              null ===
                                (i = n.children.find(
                                  (e) => !!e.userData.isGLTF
                                )) || void 0 === i
                                ? void 0
                                : i.children[0];
                          if (!e || !r)
                            throw Error(
                              `No animation clip with this name ${h} or root ${n}`
                            );
                          t.createAnimation(r, a, e, c).play();
                        }
                      })
                    : (null == r ? void 0 : r.animation.clipName) &&
                      t.removeAnimation(r.uuid, r.animation.clipName);
                })(c, s, a),
              Ht(s) && i(c, s),
              Wt(s) &&
                (function (e, t, n) {
                  const {
                    flowDirectionX: i,
                    flowDirectionY: r,
                    flowSpeed: s,
                    color: a,
                    quality: o,
                    useRefraction: c,
                    waveScale: l,
                    reflectivity: u,
                  } = t;
                  n && c !== n.useRefraction && e.setUseRefraction(c),
                    n && o !== n.quality && e.setResolution(t.quality),
                    n &&
                      a !== n.color &&
                      e.material.uniforms.color.value.set(a),
                    (e.material.uniforms.flowDirection.value.x = i),
                    (e.material.uniforms.flowDirection.value.y = r),
                    e.material.uniforms.flowDirection.value.normalize(),
                    (e.material.uniforms.reflectivity.value = u),
                    (e.material.uniforms.config.value.w = l),
                    (e.flowSpeed = s),
                    (e.material.needsUpdate = !0);
                })(c, s, a),
              Vt(s) &&
                (function (t, r, s) {
                  var a;
                  const {
                    background: o,
                    environment: c,
                    ambientLight: l,
                    fog: u,
                    useEnvironmentAsBackground: h,
                    backgroundBlurriness: d,
                    multisampling: p,
                  } = r;
                  if (
                    ((t.backgroundBlurriness = d),
                    (null == s ? void 0 : s.environment) &&
                      s.environment.uuid !== (null == c ? void 0 : c.uuid) &&
                      e.resourceManager.deleteResource(s.environment.uuid),
                    c
                      ? (
                          e.resourceManager.getResource(c.uuid) ||
                          e.resourceManager.createResource(c)
                        ).assetInstance.then((i) => {
                          var r;
                          const s = i,
                            { intensity: a, rotation: l, opacity: u } = c;
                          null === (r = t.environment) ||
                            void 0 === r ||
                            r.dispose();
                          const d = n.generateEnvironment(
                            s.reflection,
                            l,
                            "string" == typeof o ? o : "white",
                            u,
                            a
                          );
                          (t.environment = d),
                            (d.userData.originalTextureUuid = c.uuid),
                            h && (t.background = d),
                            e.materials.forEach((e) => {
                              (function (e) {
                                return "MeshBasicMaterial" === e.type;
                              })(e) && (e.envMap = s.reflection),
                                (function (e) {
                                  return "MeshPhongMaterial" === e.type;
                                })(e) &&
                                  (e.envMap =
                                    (e.userData.useRefraction, s.reflection));
                            });
                        })
                      : (t.environment = null),
                    (null == s ? void 0 : s.background) &&
                      "string" != typeof s.background &&
                      s.background.uuid !== o.uuid &&
                      e.resourceManager.deleteResource(s.background.uuid),
                    !h || !c)
                  )
                    if (o)
                      if ("string" == typeof o) {
                        const e = t.background;
                        (null == e ? void 0 : e.isColor)
                          ? e.set(o)
                          : (t.background = new ma(o));
                      } else
                        null ===
                          (a =
                            e.resourceManager.getResource(o.uuid) ||
                            e.resourceManager.createResource(o)) ||
                          void 0 === a ||
                          a.assetInstance.then((e) => {
                            t.background = e.reflection;
                          });
                    else t.background = null;
                  const f = e.objects.get(l.uuid);
                  f && ((f.visible = l.visible), i(f, l)),
                    (null == p ? void 0 : p.enabled)
                      ? e.setMultiSampling(p.samples)
                      : e.setMultiSampling(0),
                    (null == u ? void 0 : u.enabled)
                      ? (t.fog = new gu(
                          u.useBackgroundColor
                            ? "string" == typeof r.background
                              ? r.background
                              : "#FFFFFF"
                            : u.color,
                          u.near,
                          u.far
                        ))
                      : (null == u ? void 0 : u.enabled) || (t.fog = null);
                })(c, s, a),
              zt(s) &&
                (function (t, n, i) {
                  const { geometry: r } = n;
                  if (
                    ((null == i ? void 0 : i.geometry) &&
                      r !== (null == i ? void 0 : i.geometry) &&
                      (t.geometry = _L(r)),
                    n.materialId !== (null == i ? void 0 : i.materialId))
                  ) {
                    const i = e.materials.get(n.materialId);
                    if (!i)
                      throw Error(
                        `Material with ${n.materialId} does not exist!`
                      );
                    t.material = i;
                  }
                })(c, s, a),
              Yt(s) &&
                (function (t, n) {
                  if (Kt(n)) {
                    const { zoom: e, near: i, far: r, fov: s } = n,
                      a = t;
                    (a.zoom = e),
                      (a.near = i),
                      (a.far = r),
                      (a.fov = s),
                      a.updateProjectionMatrix();
                  }
                  if (Jt(n)) {
                    const { zoom: i, near: r, far: s } = n,
                      a = t;
                    (a.zoom = i), (a.near = r), (a.far = s);
                    const o = e.canvasSize.x / e.canvasSize.y;
                    (a.left = -o), (a.right = o), a.updateProjectionMatrix();
                  }
                })(c.camera, s);
          },
        };
      }
      class wL extends Za {
        constructor(e, t = {}) {
          super(e),
            (this.isRefractor = !0),
            (this.type = "Refractor"),
            (this.camera = new uo());
          const n = this,
            i = void 0 !== t.color ? new ma(t.color) : new ma(8355711),
            r = t.textureWidth || 512,
            s = t.textureHeight || 512,
            a = t.clipBias || 0,
            o = t.shader || wL.RefractorShader,
            c = void 0 !== t.multisample ? t.multisample : 4,
            l = this.camera;
          (l.matrixAutoUpdate = !1), (l.userData.refractor = !0);
          const u = new yo(),
            h = new Cs(),
            d = new jr(r, s, { samples: c, type: jn });
          (this.material = new so({
            name: void 0 !== o.name ? o.name : "unspecified",
            uniforms: ro.clone(o.uniforms),
            vertexShader: o.vertexShader,
            fragmentShader: o.fragmentShader,
            transparent: !0,
          })),
            (this.material.uniforms.color.value = i),
            (this.material.uniforms.tDiffuse.value = d.texture),
            (this.material.uniforms.textureMatrix.value = h);
          const p = (function () {
              const e = new Yr(),
                t = new Yr(),
                i = new Cs(),
                r = new Yr(),
                s = new Yr();
              return function (a) {
                return (
                  e.setFromMatrixPosition(n.matrixWorld),
                  t.setFromMatrixPosition(a.matrixWorld),
                  r.subVectors(e, t),
                  i.extractRotation(n.matrixWorld),
                  s.set(0, 0, 1),
                  s.applyMatrix4(i),
                  r.dot(s) < 0
                );
              };
            })(),
            f = (function () {
              const e = new Yr(),
                t = new Yr(),
                i = new qr(),
                r = new Yr();
              return function () {
                n.matrixWorld.decompose(t, i, r),
                  e.set(0, 0, 1).applyQuaternion(i).normalize(),
                  e.negate(),
                  u.setFromNormalAndCoplanarPoint(e, t);
              };
            })(),
            A = (function () {
              const e = new yo(),
                t = new zr(),
                n = new zr();
              return function (i) {
                l.matrixWorld.copy(i.matrixWorld),
                  l.matrixWorldInverse.copy(l.matrixWorld).invert(),
                  l.projectionMatrix.copy(i.projectionMatrix),
                  (l.far = i.far),
                  e.copy(u),
                  e.applyMatrix4(l.matrixWorldInverse),
                  t.set(e.normal.x, e.normal.y, e.normal.z, e.constant);
                const r = l.projectionMatrix;
                (n.x = (Math.sign(t.x) + r.elements[8]) / r.elements[0]),
                  (n.y = (Math.sign(t.y) + r.elements[9]) / r.elements[5]),
                  (n.z = -1),
                  (n.w = (1 + r.elements[10]) / r.elements[14]),
                  t.multiplyScalar(2 / t.dot(n)),
                  (r.elements[2] = t.x),
                  (r.elements[6] = t.y),
                  (r.elements[10] = t.z + 1 - a),
                  (r.elements[14] = t.w);
              };
            })();
          (this.onBeforeRender = function (e, t, i) {
            !0 !== i.userData.refractor &&
              !0 != !p(i) &&
              (f(),
              (function (e) {
                h.set(
                  0.5,
                  0,
                  0,
                  0.5,
                  0,
                  0.5,
                  0,
                  0.5,
                  0,
                  0,
                  0.5,
                  0.5,
                  0,
                  0,
                  0,
                  1
                ),
                  h.multiply(e.projectionMatrix),
                  h.multiply(e.matrixWorldInverse),
                  h.multiply(n.matrixWorld);
              })(i),
              A(i),
              (function (e, t, i) {
                n.visible = !1;
                const r = e.getRenderTarget(),
                  s = e.xr.enabled,
                  a = e.shadowMap.autoUpdate;
                (e.xr.enabled = !1),
                  (e.shadowMap.autoUpdate = !1),
                  e.setRenderTarget(d),
                  !1 === e.autoClear && e.clear(),
                  e.render(t, l),
                  (e.xr.enabled = s),
                  (e.shadowMap.autoUpdate = a),
                  e.setRenderTarget(r);
                const o = i.viewport;
                void 0 !== o && e.state.viewport(o), (n.visible = !0);
              })(e, t, i));
          }),
            (this.getRenderTarget = function () {
              return d;
            }),
            (this.dispose = function () {
              d.dispose(), n.material.dispose();
            });
        }
      }
      wL.RefractorShader = {
        name: "RefractorShader",
        uniforms: {
          color: { value: null },
          tDiffuse: { value: null },
          textureMatrix: { value: null },
        },
        vertexShader:
          "\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
        fragmentShader:
          "\n\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec4 vUv;\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\n\t\t}",
      };
      class CL extends Za {
        constructor(e, t = {}) {
          super(e),
            (this.isReflector = !0),
            (this.type = "Reflector"),
            (this.camera = new uo());
          const n = this,
            i = void 0 !== t.color ? new ma(t.color) : new ma(8355711),
            r = t.textureWidth || 512,
            s = t.textureHeight || 512,
            a = t.clipBias || 0,
            o = t.shader || CL.ReflectorShader,
            c = void 0 !== t.multisample ? t.multisample : 4,
            l = new yo(),
            u = new Yr(),
            h = new Yr(),
            d = new Yr(),
            p = new Cs(),
            f = new Yr(0, 0, -1),
            A = new zr(),
            g = new Yr(),
            m = new Yr(),
            v = new zr(),
            y = new Cs(),
            b = this.camera,
            _ = new jr(r, s, { samples: c, type: jn }),
            x = new so({
              name: void 0 !== o.name ? o.name : "unspecified",
              uniforms: ro.clone(o.uniforms),
              fragmentShader: o.fragmentShader,
              vertexShader: o.vertexShader,
            });
          (x.uniforms.tDiffuse.value = _.texture),
            (x.uniforms.color.value = i),
            (x.uniforms.textureMatrix.value = y),
            (this.material = x),
            (this.onBeforeRender = function (e, t, i) {
              if (
                (h.setFromMatrixPosition(n.matrixWorld),
                d.setFromMatrixPosition(i.matrixWorld),
                p.extractRotation(n.matrixWorld),
                u.set(0, 0, 1),
                u.applyMatrix4(p),
                g.subVectors(h, d),
                g.dot(u) > 0)
              )
                return;
              g.reflect(u).negate(),
                g.add(h),
                p.extractRotation(i.matrixWorld),
                f.set(0, 0, -1),
                f.applyMatrix4(p),
                f.add(d),
                m.subVectors(h, f),
                m.reflect(u).negate(),
                m.add(h),
                b.position.copy(g),
                b.up.set(0, 1, 0),
                b.up.applyMatrix4(p),
                b.up.reflect(u),
                b.lookAt(m),
                (b.far = i.far),
                b.updateMatrixWorld(),
                b.projectionMatrix.copy(i.projectionMatrix),
                y.set(
                  0.5,
                  0,
                  0,
                  0.5,
                  0,
                  0.5,
                  0,
                  0.5,
                  0,
                  0,
                  0.5,
                  0.5,
                  0,
                  0,
                  0,
                  1
                ),
                y.multiply(b.projectionMatrix),
                y.multiply(b.matrixWorldInverse),
                y.multiply(n.matrixWorld),
                l.setFromNormalAndCoplanarPoint(u, h),
                l.applyMatrix4(b.matrixWorldInverse),
                A.set(l.normal.x, l.normal.y, l.normal.z, l.constant);
              const r = b.projectionMatrix;
              (v.x = (Math.sign(A.x) + r.elements[8]) / r.elements[0]),
                (v.y = (Math.sign(A.y) + r.elements[9]) / r.elements[5]),
                (v.z = -1),
                (v.w = (1 + r.elements[10]) / r.elements[14]),
                A.multiplyScalar(2 / A.dot(v)),
                (r.elements[2] = A.x),
                (r.elements[6] = A.y),
                (r.elements[10] = A.z + 1 - a),
                (r.elements[14] = A.w),
                (n.visible = !1);
              const s = e.getRenderTarget(),
                o = e.xr.enabled,
                c = e.shadowMap.autoUpdate;
              (e.xr.enabled = !1),
                (e.shadowMap.autoUpdate = !1),
                e.setRenderTarget(_),
                e.state.buffers.depth.setMask(!0),
                !1 === e.autoClear && e.clear(),
                e.render(t, b),
                (e.xr.enabled = o),
                (e.shadowMap.autoUpdate = c),
                e.setRenderTarget(s);
              const x = i.viewport;
              void 0 !== x && e.state.viewport(x), (n.visible = !0);
            }),
            (this.getRenderTarget = function () {
              return _;
            }),
            (this.dispose = function () {
              _.dispose(), n.material.dispose();
            });
        }
      }
      CL.ReflectorShader = {
        name: "ReflectorShader",
        uniforms: {
          color: { value: null },
          tDiffuse: { value: null },
          textureMatrix: { value: null },
        },
        vertexShader:
          "\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\t#include <common>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t#include <logdepthbuf_vertex>\n\n\t\t}",
        fragmentShader:
          "\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\n\t\t}",
      };
      const SL = 0.15,
        IL = 0.075;
      class ML extends Za {
        constructor(e, t) {
          var n;
          super(e),
            (this.isWater = !0),
            (this.textureMatrix = new Cs()),
            (this.clock = new jd()),
            (this.useRefraction = !1),
            (this.clipBias = 0),
            (this.textureHeight = 512),
            (this.textureWidth = 512),
            (this.isWater = !0);
          const {
            flowSpeed: i = 0.03,
            textureHeight: r = 512,
            textureWidth: s = 512,
            clipBias: a = 0,
            flowDirection: o = new br(1, 0),
            reflectivity: c = 0.02,
            scale: l = 1,
            flowMap: u,
            normalMap0: h,
            normalMap1: d,
            useRefraction: p = !1,
          } = t;
          (this.flowSpeed = i), (this.useRefraction = p);
          const f = new ma(t.color),
            A = TL;
          (this.clipBias = a),
            (this.textureWidth = s),
            (this.textureHeight = r),
            (this.reflector = new CL(e, {
              textureWidth: s,
              textureHeight: r,
              clipBias: a,
            })),
            (this.reflector.matrixAutoUpdate = !1),
            this.useRefraction &&
              ((this.refractor = new wL(e, {
                textureWidth: s,
                textureHeight: r,
                clipBias: a,
              })),
              (this.refractor.matrixAutoUpdate = !1)),
            (this.material = new so({
              uniforms: ro.merge([Io.fog, A.uniforms]),
              vertexShader: A.vertexShader,
              fragmentShader: A.fragmentShader,
              transparent: !0,
              fog: !0,
            })),
            void 0 !== u
              ? ((this.material.defines.USE_FLOWMAP = ""),
                (this.material.uniforms.tFlowMap = new rp(u)))
              : (this.material.uniforms.flowDirection = new rp(o)),
            this.useRefraction &&
              ((this.material.defines.USE_REFRACTION = ""),
              (this.material.uniforms.tRefractionMap.value =
                null === (n = this.refractor) || void 0 === n
                  ? void 0
                  : n.getRenderTarget().texture)),
            (h.wrapS = h.wrapT = Tn),
            (d.wrapS = d.wrapT = Tn),
            (this.material.uniforms.tReflectionMap.value =
              this.reflector.getRenderTarget().texture),
            (this.material.uniforms.tNormalMap0.value = h),
            (this.material.uniforms.tNormalMap1.value = d),
            (this.material.uniforms.color.value = f),
            (this.material.uniforms.reflectivity.value = c),
            (this.material.uniforms.textureMatrix.value = this.textureMatrix),
            (this.material.uniforms.config.value.x = 0),
            (this.material.uniforms.config.value.y = IL),
            (this.material.uniforms.config.value.z = IL),
            (this.material.uniforms.config.value.w = l),
            (this.onBeforeRender = function (e, t, n, i, r, s) {
              var a, o;
              this.updateTextureMatrix(n),
                this.updateFlow(),
                (this.visible = !1),
                this.reflector.matrixWorld.copy(this.matrixWorld),
                this.reflector.onBeforeRender(e, t, n, i, r, s),
                this.useRefraction &&
                  (null === (a = this.refractor) ||
                    void 0 === a ||
                    a.onBeforeRender(e, t, n, i, r, s),
                  null === (o = this.refractor) ||
                    void 0 === o ||
                    o.matrixWorld.copy(this.matrixWorld)),
                (this.visible = !0);
            });
        }
        updateTextureMatrix(e) {
          this.textureMatrix.set(
            0.5,
            0,
            0,
            0.5,
            0,
            0.5,
            0,
            0.5,
            0,
            0,
            0.5,
            0.5,
            0,
            0,
            0,
            1
          ),
            this.textureMatrix.multiply(e.projectionMatrix),
            this.textureMatrix.multiply(e.matrixWorldInverse),
            this.textureMatrix.multiply(this.matrixWorld);
        }
        setUseRefraction(e) {
          var t, n;
          this.useRefraction !== e &&
            (this.useRefraction
              ? ((this.material.defines.USE_REFRACTION = !1),
                null === (t = this.refractor) || void 0 === t || t.dispose())
              : ((this.refractor = new wL(this.geometry, {
                  textureWidth: this.textureWidth,
                  textureHeight: this.textureHeight,
                  clipBias: this.clipBias,
                })),
                (this.refractor.matrixAutoUpdate = !1),
                (this.material.defines.USE_REFRACTION = ""),
                (this.material.uniforms.tRefractionMap.value =
                  null === (n = this.refractor) || void 0 === n
                    ? void 0
                    : n.getRenderTarget().texture)),
            (this.useRefraction = e));
        }
        updateFlow() {
          const e = this.clock.getDelta(),
            t = this.material.uniforms.config;
          (t.value.x += this.flowSpeed * e),
            (t.value.y = t.value.x + IL),
            t.value.x >= SL
              ? ((t.value.x = 0), (t.value.y = IL))
              : t.value.y >= SL && (t.value.y = t.value.y - SL);
        }
        setResolution(e) {
          var t;
          this.reflector.getRenderTarget().setSize(e, e),
            null === (t = this.refractor) ||
              void 0 === t ||
              t.getRenderTarget().setSize(e, e);
        }
        dispose() {
          var e, t, n, i, r, s, a;
          this.reflector.dispose(),
            null === (e = this.refractor) || void 0 === e || e.dispose(),
            null ===
              (n =
                null === (t = this.material.uniforms.tNormalMap0) ||
                void 0 === t
                  ? void 0
                  : t.value) ||
              void 0 === n ||
              n.dispose(),
            null ===
              (r =
                null === (i = this.material.uniforms.tNormalMap1) ||
                void 0 === i
                  ? void 0
                  : i.value) ||
              void 0 === r ||
              r.dispose(),
            this.material.dispose(),
            null === (a = (s = this.geometry).disposeBoundsTree) ||
              void 0 === a ||
              a.call(s),
            this.geometry.dispose();
        }
      }
      const TL = {
        uniforms: {
          color: { type: "c", value: null },
          reflectivity: { type: "f", value: 0 },
          tReflectionMap: { type: "t", value: null },
          tRefractionMap: { type: "t", value: null },
          tNormalMap0: { type: "t", value: null },
          tNormalMap1: { type: "t", value: null },
          textureMatrix: { type: "m4", value: null },
          config: { type: "v4", value: new zr() },
        },
        vertexShader:
          "#define GLSLIFY 1\n#include <common>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n\nuniform mat4 textureMatrix;\n\nvarying vec4 vCoord;\nvarying vec2 vUv;\nvarying vec3 vToEye;\n\nvoid main() {\n    vUv = uv;\n    vCoord = textureMatrix * vec4(position, 1.0);\n\n    vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n    vToEye = cameraPosition - worldPosition.xyz;\n\n    vec4 mvPosition = viewMatrix * worldPosition; // used in fog_vertex\n    gl_Position = projectionMatrix * mvPosition;\n\n    #include <logdepthbuf_vertex>\n    #include <fog_vertex>\n\n}",
        fragmentShader:
          "#define GLSLIFY 1\n#include <common>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n\nuniform sampler2D tReflectionMap;\n    #ifdef USE_REFRACTION\nuniform sampler2D tRefractionMap;\n    #endif\nuniform sampler2D tNormalMap0;\nuniform sampler2D tNormalMap1;\n\n\t\t#ifdef USE_FLOWMAP\nuniform sampler2D tFlowMap;\n\t\t#else\nuniform vec2 flowDirection;\n\t\t#endif\n\nuniform vec3 color;\nuniform float reflectivity;\nuniform vec4 config;\n\nvarying vec4 vCoord;\nvarying vec2 vUv;\nvarying vec3 vToEye;\n\nvoid main() {\n\n  #include <logdepthbuf_fragment>\n\n  float flowMapOffset0 = config.x;\n  float flowMapOffset1 = config.y;\n  float halfCycle = config.z;\n  float scale = config.w;\n\n  vec3 toEye = normalize(vToEye);\n\n\t\t\t// determine flow direction\n  vec2 flow;\n\t\t\t#ifdef USE_FLOWMAP\n  flow = texture2D(tFlowMap, vUv).rg * 2.0 - 1.0;\n\t\t\t#else\n  flow = flowDirection;\n\t\t\t#endif\n  flow.x *= -1.0;\n\n\t\t\t// sample normal maps (distort uvs with flowdata)\n  vec4 normalColor0 = texture2D(tNormalMap0, (vUv * scale) + flow * flowMapOffset0);\n  vec4 normalColor1 = texture2D(tNormalMap1, (vUv * scale) + flow * flowMapOffset1);\n\n\t\t\t// linear interpolate to get the final normal color\n  float flowLerp = abs(halfCycle - flowMapOffset0) / halfCycle;\n  vec4 normalColor = mix(normalColor0, normalColor1, flowLerp);\n\n\t\t\t// calculate normal vector\n  vec3 normal = normalize(vec3(normalColor.r * 2.0 - 1.0, normalColor.b, normalColor.g * 2.0 - 1.0));\n\n\t\t\t// calculate the fresnel term to blend reflection and refraction maps\n  float theta = max(dot(toEye, normal), 0.0);\n  float reflectance = reflectivity + (1.0 - reflectivity) * pow((1.0 - theta), 5.0);     \n\n\t\t\t// calculate final uv coords\n  vec3 coord = vCoord.xyz / vCoord.w;\n  vec2 uv = coord.xy + coord.z * normal.xz * 0.05;\n\n  vec4 reflectColor = texture2D(tReflectionMap, vec2(1.0 - uv.x, uv.y));\n      #ifdef USE_REFRACTION\n  vec4 refractColor = texture2D(tRefractionMap, uv);\n      #endif\n\n\t\t\t// multiply water color with the mix of both textures\n      #ifdef USE_REFRACTION\n  gl_FragColor = vec4(color, 1.0) * mix(refractColor, reflectColor, reflectance);\n      #else\n  gl_FragColor = vec4(color, reflectance) * reflectColor;\n      #endif\n\n  #include <tonemapping_fragment>\n  #include <tonemapping_fragment>\n  #include <fog_fragment>\n}\n",
      };
      class BL extends au {
        constructor(e) {
          return (
            super(),
            (this.isCameraWrapper = !0),
            (this.camera = e),
            this.add(this.camera),
            this
          );
        }
      }
      const RL = "https://files.staging.peachworlds.com",
        DL = `${RL}/static/textures/WaterNormalData1.jpg`,
        PL = `${RL}/static/textures/WaterNormalData2.jpg`;
      function LL(e, t) {
        const { updateObject: n } = EL(e, t),
          { materials: i, objects: r } = e;
        function s(e, t) {
          var n;
          const i = r.get(e),
            s = r.get(t);
          if (!i) throw new Error("Cannot set parent relationship!");
          s ? s.add(i) : null === (n = i.parent) || void 0 === n || n.remove(i);
        }
        return {
          updateObject: n,
          createObject: function t(a, o) {
            let c = null;
            if (!a.uuid) throw new Error("Object must have a uuid!");
            if (r.has(a.uuid)) throw new Error("Object already exists!");
            if (
              ((function (e) {
                return e.type === Ue.Group;
              })(a) && (c = new au()),
              Wt(a) &&
                (c = (function (t) {
                  const {
                      flowDirectionX: n,
                      flowDirectionY: i,
                      flowSpeed: r,
                      color: s,
                      waveScale: a,
                      quality: o,
                    } = t,
                    c = new Co(1, 1),
                    l = new ML(c, {
                      normalMap0: e.load(Ge.Texture, DL),
                      normalMap1: e.load(Ge.Texture, PL),
                      scale: a,
                      flowDirection: new br(n, i),
                      flowSpeed: r,
                      textureHeight: o,
                      textureWidth: o,
                      color: s,
                    });
                  return (
                    (l.userData = { isCollider: !0 }),
                    l.layers.enable(De.Raycast),
                    l
                  );
                })(a)),
              Ht(a) &&
                (c = (function (e) {
                  if (Zt(e)) return new kd();
                  if ($t(e)) return new Gd();
                  if (en(e)) return new Hd();
                  if (tn(e)) {
                    const e = new Zs(),
                      t = new Ld();
                    return (
                      t.add(e), e.position.set(0, -1, 0), (t.target = e), t
                    );
                  }
                  throw new Error("Light type is not supported!");
                })(a)),
              zt(a) &&
                (c = (function (e) {
                  const { geometry: t, materialId: n } = e,
                    r = _L(t),
                    s = new Za();
                  if (!i.has(n))
                    throw new Error(`Material with uuid ${n} doesn't exist`);
                  return (
                    (s.material = i.get(n)),
                    (s.geometry = r),
                    (s.userData = { isCollider: !0 }),
                    s.layers.enable(De.Raycast),
                    s
                  );
                })(a)),
              jt(a) &&
                (c = (function (t) {
                  const { object: i } = t,
                    r = e.resourceManager.createResource(i);
                  switch (i.assetType) {
                    case Ge.Gltf:
                    case Ge.Obj:
                    case Ge.FBX: {
                      const e = new au();
                      return (
                        r.assetInstance.then((i) => {
                          const { model: r, materials: s } = i;
                          (e.userData.originalMaps = s.map((e) => {
                            const t = e;
                            return {
                              alphaMap: t.alphaMap,
                              metalnessMap: t.metalnessMap,
                              map: t.map,
                              emissiveMap: t.emissiveMap,
                              normalMap: t.normalMap,
                              roughnessMap: t.roughnessMap,
                              displacementMap: t.displacementMap,
                            };
                          })),
                            r.traverse((e) => {
                              if (e instanceof Za) {
                                e.updateMatrixWorld(!0),
                                  e.geometry.computeBoundsTree({
                                    maxLeafTris: 5,
                                    strategy: RR,
                                  }),
                                  e.layers.enable(De.Raycast);
                                const t = { isCollider: !0 };
                                e.userData = Object.assign(
                                  Object.assign({}, e.userData),
                                  t
                                );
                              }
                            }),
                            e.add(r),
                            r
                              .getObjectsByProperty("isLight", !0)
                              .forEach((e) => {
                                e.removeFromParent();
                              }),
                            n(t);
                        }),
                        e
                      );
                    }
                    default:
                      throw Error(
                        `No imported object of this type ${i.assetType}`
                      );
                  }
                })(a)),
              Vt(a) && (c = new mu()),
              Yt(a) &&
                (c = (function (t) {
                  let n;
                  if (
                    (Kt(t) &&
                      ((n = new uo()),
                      (n.aspect = e.canvasSize.x / e.canvasSize.y)),
                    Jt(t) && (n = new No()),
                    !n)
                  )
                    throw new Error("Camera type is not supported!");
                  const i = new BL(n);
                  return (
                    n.updateProjectionMatrix(),
                    (n.userData.controls = t.controls),
                    i
                  );
                })(a)),
              !c)
            )
              throw new Error(`Object type <${a.type}> is not supported!`);
            const { name: l, uuid: u, visible: h = !0 } = a;
            (c.uuid = u),
              (c.visible = h),
              (c.userData = Object.assign(Object.assign({}, c.userData), {
                name: l,
                isPwObject: !0,
              }));
            const d = O_(c);
            r.set(a.uuid, d),
              n(a),
              o && s(a.uuid, o),
              Vt(a) && t(a.ambientLight, a.uuid),
              e.setWireframeOnObject(c);
          },
          setParentRelationship: s,
          deleteObject: function (e) {
            var n, i;
            const s = r.get(e);
            if (!s)
              throw new Error(`Cannot delete object that does not exist! ${e}`);
            null === (n = s.parent) || void 0 === n || n.remove(s),
              s.dispose && s.dispose(),
              s instanceof mu &&
                (null === (i = s.environment) || void 0 === i || i.dispose()),
              t.removeObjectAnimations(s.uuid),
              r.delete(e);
          },
          getObject: function (e) {
            return r.get(e);
          },
        };
      }
      function UL(e, t, n, i) {
        var r;
        const s = (function (e, t) {
            var n, i;
            const r = {};
            if (!e || !t) return r;
            const s = Object.values(gt);
            for (const a of s) {
              const s =
                null ===
                  (i =
                    null === (n = e.devices[a]) || void 0 === n
                      ? void 0
                      : n.canvases) || void 0 === i
                  ? void 0
                  : i[t];
              s && (r[a] = s.cameraId);
            }
            return r;
          })(e, null === (r = t.parentElement) || void 0 === r ? void 0 : r.id),
          a = n.find((e) => e === s.desktop) || i,
          o = n.find((e) => e === s.tablet) || a;
        return {
          desktop: a,
          tablet: o,
          mobile: n.find((e) => e === s.mobile) || o,
        };
      }
      function FL() {
        const e =
          window.innerWidth ||
          document.documentElement.clientWidth ||
          document.body.clientWidth;
        return e < gp ? gt.Mobile : e < mp ? gt.Tablet : gt.Desktop;
      }
      function OL(e, t, n, i, r) {
        var s, a, o;
        const { pwObjects: c, defaultCameraId: l } = t,
          u = UL(
            n,
            e,
            (function (e) {
              return e.filter((e) => Yt(e)).map((e) => e.uuid);
            })(Array.from(c.values())),
            l
          );
        let h,
          d = i(l);
        d ||
          c.forEach((e) => {
            d || e.type !== Ue.Camera || (d = i(e.uuid));
          });
        const p = {
            desktop:
              null === (s = i(u.desktop) || d) || void 0 === s
                ? void 0
                : s.camera,
            tablet:
              null === (a = i(u.tablet) || d) || void 0 === a
                ? void 0
                : a.camera,
            mobile:
              null === (o = i(u.mobile) || d) || void 0 === o
                ? void 0
                : o.camera,
          },
          f = () => {
            const e = FL();
            if (h === e) return;
            h = e;
            const t = p[e];
            r.getActiveCamera() !== t && r.setActiveCamera(t);
          };
        f(), window.addEventListener("resize", f);
        return {
          dispose: () => {
            window.removeEventListener("resize", f);
          },
          updateResponsiveCanvasCamera: f,
        };
      }
      const NL = "RESOLUTION_FACTOR",
        kL = [60, 75, 90, 120, 144, 165, 240];
      function QL(
        e,
        {
          iterations: t = 15,
          ms: n = 1e3,
          threshold: i = 0.75,
          flipflops: r = 1 / 0,
          bounds: s = (e) => (e > 100 ? [60, 100] : [40, 60]),
          minResolutionFactor: a = 0.2,
          memoizeResolutionFactor: o = !0,
        }
      ) {
        const c = {
          fps: 0,
          index: 0,
          flipped: 0,
          refreshrate: kL[0],
          fallback: !1,
          frames: [],
          averages: [],
          subscriptions: new Map(),
          subscribe: (e) => {
            const t = Symbol();
            return (
              c.subscriptions.set(t, e.current),
              () => {
                c.subscriptions.delete(t);
              }
            );
          },
        };
        if ((e.addOnRenderCallback(l), o)) {
          const t = Number(window.localStorage.getItem(NL));
          !Number.isNaN(t) && t > a && e.renderer.setPixelRatio(t);
        }
        function l() {
          const { frames: o, averages: l } = c;
          if (c.fallback) return;
          if (l.length >= t)
            return void (
              dp &&
              console.error(
                "PerformanceMonitorModule: averages.length >= iterations"
              )
            );
          o.push(performance.now());
          const d = o[o.length - 1] - o[0];
          if (d < n) return;
          if (
            ((c.fps = Math.round(1e3 / (d / o.length))),
            (c.frames = []),
            (l[c.index++ % t] = c.fps),
            l.length < t)
          )
            return;
          const [p, f] = s(c.refreshrate),
            A = l.filter((e) => e >= f),
            g = l.filter((e) => e < p),
            m = Ip(p, f),
            v = Ip(l);
          v > c.refreshrate &&
            (c.refreshrate = (function (e) {
              const t = kL.findIndex((t) => t >= e);
              if (-1 === t) return kL[kL.length - 1];
              if (0 === t) return kL[0];
              const n = kL[t],
                i = kL[t - 1];
              return Math.abs(i - e) >= Math.abs(n - e) || 1.1 * i <= e ? n : i;
            })(v));
          const y = Math.sqrt(v / m);
          A.length > t * i &&
            v > m &&
            (c.flipped++,
            (function (t) {
              if (t < 1)
                throw new Error(
                  "fpsDeltaFromTargetNorm should be greater than 1 when onIncline is called"
                );
              if (h() >= window.devicePixelRatio) return;
              const n = Math.min(
                window.devicePixelRatio,
                e.renderer.getPixelRatio() * t
              );
              u(n);
            })(y),
            c.subscriptions.forEach((e) => e.onIncline && e.onIncline(c))),
            g.length > t * i &&
              (c.flipped++,
              (function (t) {
                if (Math.sign(t) < 1)
                  throw new Error(
                    "fpsDeltaFromTargetNorm should less than 1 when onDecline is called"
                  );
                if (h() <= a) return;
                const n = Math.max(a, e.renderer.getPixelRatio() * t);
                u(n);
              })(y),
              c.subscriptions.forEach((e) => e.onDecline && e.onDecline(c))),
            c.flipped > r &&
              !c.fallback &&
              ((c.fallback = !0),
              c.subscriptions.forEach((e) => e.onFallback && e.onFallback(c)),
              dp &&
                console.warn(
                  "Auto-resolution system disabled: max flipflops reached"
                )),
            (c.averages = []);
        }
        function u(t) {
          e.renderer.setPixelRatio(t),
            o && window.localStorage.setItem(NL, t.toString());
        }
        function h() {
          return e.renderer.getPixelRatio();
        }
        return {
          api: c,
          dispose: function () {
            e.removeOnRenderCallback(l);
          },
        };
      }
      let GL = !1;
      function HL(e, t, n = !1) {
        GL = n;
        const i = TR(e),
          r = AL(i),
          s = (function (e) {
            const { getActiveScene: t } = e,
              n = new ip(t()),
              i = new Map();
            function r(e, t) {
              var n;
              const { clipName: r, loop: s, speed: a } = t;
              if (!r) return;
              const o =
                null === (n = i.get(e)) || void 0 === n ? void 0 : n.get(r);
              if (!o)
                throw Error(
                  `Animation with name ${r} and object id ${e} does not exist`
                );
              o.setLoop(s ? Gi : Qi, 1 / 0), o.reset(), (o.timeScale = a);
            }
            function s(e, t) {
              var r, s;
              const a =
                null === (r = i.get(e)) || void 0 === r ? void 0 : r.get(t);
              a &&
                ((a.enabled = !1),
                a.stop(),
                a.reset(),
                n.uncacheRoot(a.getRoot()),
                n.uncacheClip(a.getClip()),
                null === (s = i.get(e)) || void 0 === s || s.delete(t));
            }
            return {
              createAnimation: function (e, t, s, a) {
                const o = n.clipAction(s, e);
                return (
                  (o.clampWhenFinished = !0),
                  (o.blendMode = qi),
                  i.has(t) || i.set(t, new Map()),
                  i.get(t).set(s.name, o),
                  r(t, a),
                  o
                );
              },
              removeAnimation: s,
              removeObjectAnimations: function (e) {
                var t;
                null === (t = i.get(e)) ||
                  void 0 === t ||
                  t.forEach((t, n) => s(e, n));
              },
              updateAnimation: r,
              getAnimation: function (e, t) {
                var n;
                return null === (n = i.get(e)) || void 0 === n
                  ? void 0
                  : n.get(t);
              },
              update: function (e) {
                n.update(e);
              },
              dispose: function () {
                n.stopAllAction(), n.getRoot() && n.uncacheRoot(n.getRoot());
              },
            };
          })(i),
          a = yL(i);
        let o;
        if (!n && (null == t ? void 0 : t.isReductionEnabled)) {
          const {
              fpsThresholdAbsolute: e = 60,
              minResolution: n = 0.1,
              fpsThresholdMode: r,
            } = t || {},
            s = window.location !== window.parent.location,
            a = r === Ve.Absolute ? e : 60;
          o = QL(i, {
            memoizeResolutionFactor: !s,
            minResolutionFactor: 0.01 * (n || 100),
            flipflops: 8,
            threshold: 0.85,
            iterations: 5,
            ms: 1e3,
            bounds: (e) => {
              const t = Math.min(a, e);
              return [0.9 * t, 1.2 * t];
            },
          });
        }
        const {
            start: c,
            stop: l,
            eventDispatcher: u,
            addOnRenderCallback: h,
            removeOnRenderCallback: d,
            renderer: p,
            effects: f,
            setActiveCamera: A,
            setActiveScene: g,
            setCameraPreview: m,
            setWireframe: v,
            setUsePostProcessing: y,
            createEffect: b,
            updateEffect: _,
            deleteEffect: x,
            getResource: E,
            resourceManager: w,
            showStatsPanel: C,
            hideStatsPanel: S,
            addAfterRenderCallback: I,
            attachToDOM: M,
          } = i,
          {
            getMaterial: T,
            updateMaterial: B,
            createMaterial: R,
            deleteMaterial: D,
            replaceMaterial: P,
          } = a;
        h((e, t, n) => s.update(n));
        const {
            updateObject: L,
            createObject: U,
            getObject: F,
            deleteObject: O,
            setParentRelationship: N,
          } = LL(i, s),
          {
            getObjectIntersectionAtPointer: k,
            getObjectPositionOnScreen: Q,
            getObjectsInScreenView: G,
          } = r,
          { getAnimation: H } = s;
        function z(e, t, n) {
          const i = F(e);
          n.forEach((e) => B(e, void 0, !0));
          const r = (i) => {
            if (!i.userData.isPwObject || i.uuid === e) {
              if (i instanceof Za || i instanceof Vu) {
                const e = t.findIndex((e) => i.material.uuid === e);
                -1 !== e && (i.material = T(n[e].uuid));
              }
              i.children.forEach(r);
            }
          };
          i && r(i);
        }
        const V = (e, t) => (
          u.addEventListener(e, t), () => u.removeEventListener(e, t)
        );
        return {
          renderer: p,
          effects: f,
          core: i,
          setActiveCamera: A,
          setActiveScene: g,
          setCameraPreview: m,
          initializeClient: function (t, n) {
            const {
              pwObjects: r,
              pwMaterials: s,
              parents: a,
              usePostProcessing: o,
              effects: c,
            } = t;
            s.forEach((e) => R(e)),
              r.forEach((e) => U(e)),
              Array.from(a.entries()).forEach(([e, t]) => {
                N(e, t);
              }),
              OL(e, t, n, F, i),
              r.forEach((e) => {
                i.getActiveScene() ||
                  e.type !== Ue.Scene ||
                  i.setActiveScene(F(e.uuid));
              }),
              r.forEach((e) => {
                jt(e) &&
                  e.materials &&
                  E(e.object.uuid).assetInstance.then((t) => {
                    var n;
                    e.materials &&
                      z(
                        e.uuid,
                        t.materials.map((e) => e.uuid),
                        null === (n = e.materials) || void 0 === n
                          ? void 0
                          : n.map((e) => s.get(e))
                      );
                  });
              });
            let l = !1;
            c.forEach((e) => {
              e.enabled && ((l = l || e.enabled), b(e));
            }),
              y(l && o),
              V(P_.ResourcesLoaded, () => {
                const e = Number.MAX_VALUE / 2,
                  t = new No(-e, e, e, -e, 0, Number.MAX_VALUE);
                t.position.set(0, 0, -e);
                const n = i.getActiveCamera();
                i.setActiveCamera(t),
                  i.start(),
                  document.location.search.includes("debug") &&
                    C(document.body),
                  p.compileAsync(i.getActiveScene(), t).then(() => {
                    i.setActiveCamera(n),
                      u.dispatchEvent({ type: P_.SceneReady });
                  });
              }),
              w.checkIfResourceLoadingFinished();
          },
          listenTo: V,
          start: c,
          stop: l,
          dispose: function () {
            i.dispose(),
              r.dispose(),
              s.dispose(),
              a.dispose(),
              null == o || o.dispose();
          },
          updateObject: L,
          getObject: F,
          getResource: E,
          createEffect: b,
          updateEffect: _,
          deleteEffect: x,
          createObject: U,
          deleteObject: O,
          createMaterial: R,
          updateMaterial: B,
          deleteMaterial: D,
          replaceMaterial: P,
          replaceImportedMaterials: z,
          getImportedAnimation: H,
          setParentRelationship: N,
          addOnRenderCallback: h,
          removeOnRenderCallback: d,
          getObjectIntersectionAtPointer: k,
          getObjectPositionOnScreen: Q,
          setWireframe: v,
          setUsePostProcessing: y,
          getMaterial: T,
          showStatsPanel: C,
          hideStatsPanel: S,
          addAfterRenderCallback: I,
          getObjectsInScreenView: G,
          attachToDOM: M,
        };
      }
      const zL = { disposePageCallbacks: [] };
      function VL(e) {
        zL.disposePageCallbacks.push(e);
      }
      function jL() {
        const e = zL.disposePageCallbacks;
        for (zL.disposePageCallbacks = []; e.length > 0; ) {
          const t = e.pop();
          if (t)
            try {
              t();
            } catch (e) {
              console.error("Router page dispose callback error:", e);
            }
        }
      }
      function WL(e, t, n) {
        return Math.max(e, Math.min(t, n));
      }
      var XL = class {
        isRunning = !1;
        value = 0;
        from = 0;
        to = 0;
        currentTime = 0;
        lerp;
        duration;
        easing;
        onUpdate;
        advance(e) {
          if (!this.isRunning) return;
          let t = !1;
          if (this.duration && this.easing) {
            this.currentTime += e;
            const n = WL(0, this.currentTime / this.duration, 1);
            t = n >= 1;
            const i = t ? 1 : this.easing(n);
            this.value = this.from + (this.to - this.from) * i;
          } else
            this.lerp
              ? ((this.value = (function (e, t, n, i) {
                  return (function (e, t, n) {
                    return (1 - n) * e + n * t;
                  })(e, t, 1 - Math.exp(-n * i));
                })(this.value, this.to, 60 * this.lerp, e)),
                Math.round(this.value) === this.to &&
                  ((this.value = this.to), (t = !0)))
              : ((this.value = this.to), (t = !0));
          t && this.stop(), this.onUpdate?.(this.value, t);
        }
        stop() {
          this.isRunning = !1;
        }
        fromTo(
          e,
          t,
          { lerp: n, duration: i, easing: r, onStart: s, onUpdate: a }
        ) {
          (this.from = this.value = e),
            (this.to = t),
            (this.lerp = n),
            (this.duration = i),
            (this.easing = r),
            (this.currentTime = 0),
            (this.isRunning = !0),
            s?.(),
            (this.onUpdate = a);
        }
      };
      var qL = class {
          constructor(e, t, { autoResize: n = !0, debounce: i = 250 } = {}) {
            (this.wrapper = e),
              (this.content = t),
              n &&
                ((this.debouncedResize = (function (e, t) {
                  let n;
                  return function (...i) {
                    let r = this;
                    clearTimeout(n),
                      (n = setTimeout(() => {
                        (n = void 0), e.apply(r, i);
                      }, t));
                  };
                })(this.resize, i)),
                this.wrapper instanceof Window
                  ? window.addEventListener("resize", this.debouncedResize, !1)
                  : ((this.wrapperResizeObserver = new ResizeObserver(
                      this.debouncedResize
                    )),
                    this.wrapperResizeObserver.observe(this.wrapper)),
                (this.contentResizeObserver = new ResizeObserver(
                  this.debouncedResize
                )),
                this.contentResizeObserver.observe(this.content)),
              this.resize();
          }
          width = 0;
          height = 0;
          scrollHeight = 0;
          scrollWidth = 0;
          debouncedResize;
          wrapperResizeObserver;
          contentResizeObserver;
          destroy() {
            this.wrapperResizeObserver?.disconnect(),
              this.contentResizeObserver?.disconnect(),
              this.wrapper === window &&
                this.debouncedResize &&
                window.removeEventListener("resize", this.debouncedResize, !1);
          }
          resize = () => {
            this.onWrapperResize(), this.onContentResize();
          };
          onWrapperResize = () => {
            this.wrapper instanceof Window
              ? ((this.width = window.innerWidth),
                (this.height = window.innerHeight))
              : ((this.width = this.wrapper.clientWidth),
                (this.height = this.wrapper.clientHeight));
          };
          onContentResize = () => {
            this.wrapper instanceof Window
              ? ((this.scrollHeight = this.content.scrollHeight),
                (this.scrollWidth = this.content.scrollWidth))
              : ((this.scrollHeight = this.wrapper.scrollHeight),
                (this.scrollWidth = this.wrapper.scrollWidth));
          };
          get limit() {
            return {
              x: this.scrollWidth - this.width,
              y: this.scrollHeight - this.height,
            };
          }
        },
        YL = class {
          events = {};
          emit(e, ...t) {
            let n = this.events[e] || [];
            for (let e = 0, i = n.length; e < i; e++) n[e]?.(...t);
          }
          on(e, t) {
            return (
              this.events[e]?.push(t) || (this.events[e] = [t]),
              () => {
                this.events[e] = this.events[e]?.filter((e) => t !== e);
              }
            );
          }
          off(e, t) {
            this.events[e] = this.events[e]?.filter((e) => t !== e);
          }
          destroy() {
            this.events = {};
          }
        },
        KL = 100 / 6,
        JL = { passive: !1 },
        ZL = class {
          constructor(e, t = { wheelMultiplier: 1, touchMultiplier: 1 }) {
            (this.element = e),
              (this.options = t),
              window.addEventListener("resize", this.onWindowResize, !1),
              this.onWindowResize(),
              this.element.addEventListener("wheel", this.onWheel, JL),
              this.element.addEventListener(
                "touchstart",
                this.onTouchStart,
                JL
              ),
              this.element.addEventListener("touchmove", this.onTouchMove, JL),
              this.element.addEventListener("touchend", this.onTouchEnd, JL);
          }
          touchStart = { x: 0, y: 0 };
          lastDelta = { x: 0, y: 0 };
          window = { width: 0, height: 0 };
          emitter = new YL();
          on(e, t) {
            return this.emitter.on(e, t);
          }
          destroy() {
            this.emitter.destroy(),
              window.removeEventListener("resize", this.onWindowResize, !1),
              this.element.removeEventListener("wheel", this.onWheel, JL),
              this.element.removeEventListener(
                "touchstart",
                this.onTouchStart,
                JL
              ),
              this.element.removeEventListener(
                "touchmove",
                this.onTouchMove,
                JL
              ),
              this.element.removeEventListener("touchend", this.onTouchEnd, JL);
          }
          onTouchStart = (e) => {
            const { clientX: t, clientY: n } = e.targetTouches
              ? e.targetTouches[0]
              : e;
            (this.touchStart.x = t),
              (this.touchStart.y = n),
              (this.lastDelta = { x: 0, y: 0 }),
              this.emitter.emit("scroll", { deltaX: 0, deltaY: 0, event: e });
          };
          onTouchMove = (e) => {
            const { clientX: t, clientY: n } = e.targetTouches
                ? e.targetTouches[0]
                : e,
              i = -(t - this.touchStart.x) * this.options.touchMultiplier,
              r = -(n - this.touchStart.y) * this.options.touchMultiplier;
            (this.touchStart.x = t),
              (this.touchStart.y = n),
              (this.lastDelta = { x: i, y: r }),
              this.emitter.emit("scroll", { deltaX: i, deltaY: r, event: e });
          };
          onTouchEnd = (e) => {
            this.emitter.emit("scroll", {
              deltaX: this.lastDelta.x,
              deltaY: this.lastDelta.y,
              event: e,
            });
          };
          onWheel = (e) => {
            let { deltaX: t, deltaY: n, deltaMode: i } = e;
            (t *= 1 === i ? KL : 2 === i ? this.window.width : 1),
              (n *= 1 === i ? KL : 2 === i ? this.window.height : 1),
              (t *= this.options.wheelMultiplier),
              (n *= this.options.wheelMultiplier),
              this.emitter.emit("scroll", { deltaX: t, deltaY: n, event: e });
          };
          onWindowResize = () => {
            this.window = {
              width: window.innerWidth,
              height: window.innerHeight,
            };
          };
        },
        $L = class {
          _isScrolling = !1;
          _isStopped = !1;
          _isLocked = !1;
          _preventNextNativeScrollEvent = !1;
          _resetVelocityTimeout = null;
          __rafID = null;
          isTouching;
          time = 0;
          userData = {};
          lastVelocity = 0;
          velocity = 0;
          direction = 0;
          options;
          targetScroll;
          animatedScroll;
          animate = new XL();
          emitter = new YL();
          dimensions;
          virtualScroll;
          constructor({
            wrapper: e = window,
            content: t = document.documentElement,
            eventsTarget: n = e,
            smoothWheel: i = !0,
            syncTouch: r = !1,
            syncTouchLerp: s = 0.075,
            touchInertiaMultiplier: a = 35,
            duration: o,
            easing: c = (e) => Math.min(1, 1.001 - Math.pow(2, -10 * e)),
            lerp: l = 0.1,
            infinite: u = !1,
            orientation: h = "vertical",
            gestureOrientation: d = "vertical",
            touchMultiplier: p = 1,
            wheelMultiplier: f = 1,
            autoResize: A = !0,
            prevent: g,
            virtualScroll: m,
            overscroll: v = !0,
            autoRaf: y = !1,
            __experimental__naiveDimensions: b = !1,
          } = {}) {
            (window.lenisVersion = "1.1.16"),
              (e && e !== document.documentElement && e !== document.body) ||
                (e = window),
              (this.options = {
                wrapper: e,
                content: t,
                eventsTarget: n,
                smoothWheel: i,
                syncTouch: r,
                syncTouchLerp: s,
                touchInertiaMultiplier: a,
                duration: o,
                easing: c,
                lerp: l,
                infinite: u,
                gestureOrientation: d,
                orientation: h,
                touchMultiplier: p,
                wheelMultiplier: f,
                autoResize: A,
                prevent: g,
                virtualScroll: m,
                overscroll: v,
                autoRaf: y,
                __experimental__naiveDimensions: b,
              }),
              (this.dimensions = new qL(e, t, { autoResize: A })),
              this.updateClassName(),
              (this.targetScroll = this.animatedScroll = this.actualScroll),
              this.options.wrapper.addEventListener(
                "scroll",
                this.onNativeScroll,
                !1
              ),
              this.options.wrapper.addEventListener(
                "pointerdown",
                this.onPointerDown,
                !1
              ),
              (this.virtualScroll = new ZL(n, {
                touchMultiplier: p,
                wheelMultiplier: f,
              })),
              this.virtualScroll.on("scroll", this.onVirtualScroll),
              this.options.autoRaf &&
                (this.__rafID = requestAnimationFrame(this.raf));
          }
          destroy() {
            this.emitter.destroy(),
              this.options.wrapper.removeEventListener(
                "scroll",
                this.onNativeScroll,
                !1
              ),
              this.options.wrapper.removeEventListener(
                "pointerdown",
                this.onPointerDown,
                !1
              ),
              this.virtualScroll.destroy(),
              this.dimensions.destroy(),
              this.cleanUpClassName(),
              this.__rafID && cancelAnimationFrame(this.__rafID);
          }
          on(e, t) {
            return this.emitter.on(e, t);
          }
          off(e, t) {
            return this.emitter.off(e, t);
          }
          setScroll(e) {
            this.isHorizontal
              ? (this.rootElement.scrollLeft = e)
              : (this.rootElement.scrollTop = e);
          }
          onPointerDown = (e) => {
            1 === e.button && this.reset();
          };
          onVirtualScroll = (e) => {
            if (
              "function" == typeof this.options.virtualScroll &&
              !1 === this.options.virtualScroll(e)
            )
              return;
            const { deltaX: t, deltaY: n, event: i } = e;
            if (
              (this.emitter.emit("virtual-scroll", {
                deltaX: t,
                deltaY: n,
                event: i,
              }),
              i.ctrlKey)
            )
              return;
            if (i.lenisStopPropagation) return;
            const r = i.type.includes("touch"),
              s = i.type.includes("wheel");
            this.isTouching = "touchstart" === i.type || "touchmove" === i.type;
            if (
              this.options.syncTouch &&
              r &&
              "touchstart" === i.type &&
              !this.isStopped &&
              !this.isLocked
            )
              return void this.reset();
            const a = 0 === t && 0 === n,
              o =
                ("vertical" === this.options.gestureOrientation && 0 === n) ||
                ("horizontal" === this.options.gestureOrientation && 0 === t);
            if (a || o) return;
            let c = i.composedPath();
            c = c.slice(0, c.indexOf(this.rootElement));
            const l = this.options.prevent;
            if (
              c.find(
                (e) =>
                  e instanceof HTMLElement &&
                  (("function" == typeof l && l?.(e)) ||
                    e.hasAttribute?.("data-lenis-prevent") ||
                    (r && e.hasAttribute?.("data-lenis-prevent-touch")) ||
                    (s && e.hasAttribute?.("data-lenis-prevent-wheel")))
              )
            )
              return;
            if (this.isStopped || this.isLocked) return void i.preventDefault();
            if (
              !(
                (this.options.syncTouch && r) ||
                (this.options.smoothWheel && s)
              )
            )
              return (
                (this.isScrolling = "native"),
                this.animate.stop(),
                void (i.lenisStopPropagation = !0)
              );
            let u = n;
            "both" === this.options.gestureOrientation
              ? (u = Math.abs(n) > Math.abs(t) ? n : t)
              : "horizontal" === this.options.gestureOrientation && (u = t),
              (!this.options.overscroll ||
                this.options.infinite ||
                (this.options.wrapper !== window &&
                  ((this.animatedScroll > 0 &&
                    this.animatedScroll < this.limit) ||
                    (0 === this.animatedScroll && n > 0) ||
                    (this.animatedScroll === this.limit && n < 0)))) &&
                (i.lenisStopPropagation = !0),
              i.preventDefault();
            const h = r && this.options.syncTouch,
              d = r && "touchend" === i.type && Math.abs(u) > 5;
            d && (u = this.velocity * this.options.touchInertiaMultiplier),
              this.scrollTo(this.targetScroll + u, {
                programmatic: !1,
                ...(h
                  ? { lerp: d ? this.options.syncTouchLerp : 1 }
                  : {
                      lerp: this.options.lerp,
                      duration: this.options.duration,
                      easing: this.options.easing,
                    }),
              });
          };
          resize() {
            this.dimensions.resize(),
              (this.animatedScroll = this.targetScroll = this.actualScroll),
              this.emit();
          }
          emit() {
            this.emitter.emit("scroll", this);
          }
          onNativeScroll = () => {
            if (
              (null !== this._resetVelocityTimeout &&
                (clearTimeout(this._resetVelocityTimeout),
                (this._resetVelocityTimeout = null)),
              this._preventNextNativeScrollEvent)
            )
              this._preventNextNativeScrollEvent = !1;
            else if (!1 === this.isScrolling || "native" === this.isScrolling) {
              const e = this.animatedScroll;
              (this.animatedScroll = this.targetScroll = this.actualScroll),
                (this.lastVelocity = this.velocity),
                (this.velocity = this.animatedScroll - e),
                (this.direction = Math.sign(this.animatedScroll - e)),
                (this.isScrolling = "native"),
                this.emit(),
                0 !== this.velocity &&
                  (this._resetVelocityTimeout = setTimeout(() => {
                    (this.lastVelocity = this.velocity),
                      (this.velocity = 0),
                      (this.isScrolling = !1),
                      this.emit();
                  }, 400));
            }
          };
          reset() {
            (this.isLocked = !1),
              (this.isScrolling = !1),
              (this.animatedScroll = this.targetScroll = this.actualScroll),
              (this.lastVelocity = this.velocity = 0),
              this.animate.stop();
          }
          start() {
            this.isStopped && ((this.isStopped = !1), this.reset());
          }
          stop() {
            this.isStopped ||
              ((this.isStopped = !0), this.animate.stop(), this.reset());
          }
          raf = (e) => {
            const t = e - (this.time || e);
            (this.time = e),
              this.animate.advance(0.001 * t),
              this.options.autoRaf &&
                (this.__rafID = requestAnimationFrame(this.raf));
          };
          scrollTo(
            e,
            {
              offset: t = 0,
              immediate: n = !1,
              lock: i = !1,
              duration: r = this.options.duration,
              easing: s = this.options.easing,
              lerp: a = this.options.lerp,
              onStart: o,
              onComplete: c,
              force: l = !1,
              programmatic: u = !0,
              userData: h,
            } = {}
          ) {
            if ((!this.isStopped && !this.isLocked) || l) {
              if ("string" == typeof e && ["top", "left", "start"].includes(e))
                e = 0;
              else if (
                "string" == typeof e &&
                ["bottom", "right", "end"].includes(e)
              )
                e = this.limit;
              else {
                let n;
                if (
                  ("string" == typeof e
                    ? (n = document.querySelector(e))
                    : e instanceof HTMLElement && e?.nodeType && (n = e),
                  n)
                ) {
                  if (this.options.wrapper !== window) {
                    const e = this.rootElement.getBoundingClientRect();
                    t -= this.isHorizontal ? e.left : e.top;
                  }
                  const i = n.getBoundingClientRect();
                  e =
                    (this.isHorizontal ? i.left : i.top) + this.animatedScroll;
                }
              }
              if ("number" == typeof e) {
                if (
                  ((e += t),
                  (e = Math.round(e)),
                  this.options.infinite
                    ? u &&
                      (this.targetScroll = this.animatedScroll = this.scroll)
                    : (e = WL(0, e, this.limit)),
                  e === this.targetScroll)
                )
                  return o?.(this), void c?.(this);
                if (((this.userData = h ?? {}), n))
                  return (
                    (this.animatedScroll = this.targetScroll = e),
                    this.setScroll(this.scroll),
                    this.reset(),
                    this.preventNextNativeScrollEvent(),
                    this.emit(),
                    c?.(this),
                    void (this.userData = {})
                  );
                u || (this.targetScroll = e),
                  this.animate.fromTo(this.animatedScroll, e, {
                    duration: r,
                    easing: s,
                    lerp: a,
                    onStart: () => {
                      i && (this.isLocked = !0),
                        (this.isScrolling = "smooth"),
                        o?.(this);
                    },
                    onUpdate: (e, t) => {
                      (this.isScrolling = "smooth"),
                        (this.lastVelocity = this.velocity),
                        (this.velocity = e - this.animatedScroll),
                        (this.direction = Math.sign(this.velocity)),
                        (this.animatedScroll = e),
                        this.setScroll(this.scroll),
                        u && (this.targetScroll = e),
                        t || this.emit(),
                        t &&
                          (this.reset(),
                          this.emit(),
                          c?.(this),
                          (this.userData = {}),
                          this.preventNextNativeScrollEvent());
                    },
                  });
              }
            }
          }
          preventNextNativeScrollEvent() {
            (this._preventNextNativeScrollEvent = !0),
              requestAnimationFrame(() => {
                this._preventNextNativeScrollEvent = !1;
              });
          }
          get rootElement() {
            return this.options.wrapper === window
              ? document.documentElement
              : this.options.wrapper;
          }
          get limit() {
            return this.options.__experimental__naiveDimensions
              ? this.isHorizontal
                ? this.rootElement.scrollWidth - this.rootElement.clientWidth
                : this.rootElement.scrollHeight - this.rootElement.clientHeight
              : this.dimensions.limit[this.isHorizontal ? "x" : "y"];
          }
          get isHorizontal() {
            return "horizontal" === this.options.orientation;
          }
          get actualScroll() {
            return this.isHorizontal
              ? this.rootElement.scrollLeft
              : this.rootElement.scrollTop;
          }
          get scroll() {
            return this.options.infinite
              ? (function (e, t) {
                  return ((e % t) + t) % t;
                })(this.animatedScroll, this.limit)
              : this.animatedScroll;
          }
          get progress() {
            return 0 === this.limit ? 1 : this.scroll / this.limit;
          }
          get isScrolling() {
            return this._isScrolling;
          }
          set isScrolling(e) {
            this._isScrolling !== e &&
              ((this._isScrolling = e), this.updateClassName());
          }
          get isStopped() {
            return this._isStopped;
          }
          set isStopped(e) {
            this._isStopped !== e &&
              ((this._isStopped = e), this.updateClassName());
          }
          get isLocked() {
            return this._isLocked;
          }
          set isLocked(e) {
            this._isLocked !== e &&
              ((this._isLocked = e), this.updateClassName());
          }
          get isSmooth() {
            return "smooth" === this.isScrolling;
          }
          get className() {
            let e = "lenis";
            return (
              this.isStopped && (e += " lenis-stopped"),
              this.isLocked && (e += " lenis-locked"),
              this.isScrolling && (e += " lenis-scrolling"),
              "smooth" === this.isScrolling && (e += " lenis-smooth"),
              e
            );
          }
          updateClassName() {
            this.cleanUpClassName(),
              (this.rootElement.className =
                `${this.rootElement.className} ${this.className}`.trim());
          }
          cleanUpClassName() {
            this.rootElement.className = this.rootElement.className
              .replace(/lenis(-\w+)?/g, "")
              .trim();
          }
        };
      const eU = { listeners: new Set() };
      function tU() {
        return { syncTouch: !vf, duration: 1.2, easing: rf.lenisDefault };
      }
      function nU() {
        if ("smooth" !== document.body.getAttribute("data-scroll-type"))
          return { isSmooth: !1, config: { syncTouch: !vf, duration: 0.2 } };
        const e = document.body,
          t = tU(),
          n = e.getAttribute("data-scroll-easing");
        n in rf && (t.easing = rf[n]);
        const i = e.getAttribute("data-scroll-duration"),
          r = Cp(parseInt(i) / 1e3, 3);
        !isNaN(r) && r >= 0 && (t.duration = r);
        const s = e.getAttribute("data-scroll-speed"),
          a = Cp(parseInt(s) / 100, 2);
        !isNaN(a) &&
          a > 0 &&
          ((t.wheelMultiplier = a), (t.touchMultiplier = a));
        return (
          "yes" === e.getAttribute("data-scroll-infinite") && (t.infinite = !0),
          { isSmooth: !0, config: t }
        );
      }
      function iU() {
        var e;
        eU.val && eU.val.destroy(),
          window.scrollTo(0, 0),
          (eU.config = nU()),
          (eU.val = new $L(eU.config.config)),
          ((e = eU.val).setScroll = (t) => {
            const n = e.velocity,
              i = e.rootElement,
              r = n > 0 ? Math.ceil(t) : n < 0 ? Math.floor(t) : Math.round(t);
            e.isHorizontal
              ? (i.scrollLeft = Math.round(r))
              : (i.scrollTop = Math.round(r));
          }),
          eU.val.on("scroll", (e) => {
            const t = eU.listeners;
            for (const n of t)
              try {
                n(e);
              } catch (e) {
                console.error("Smooth scroll listener callback error:", e);
              }
          });
      }
      var rU = function (e, t, n, i) {
        return new (n || (n = Promise))(function (r, s) {
          function a(e) {
            try {
              c(i.next(e));
            } catch (e) {
              s(e);
            }
          }
          function o(e) {
            try {
              c(i.throw(e));
            } catch (e) {
              s(e);
            }
          }
          function c(e) {
            var t;
            e.done
              ? r(e.value)
              : ((t = e.value),
                t instanceof n
                  ? t
                  : new n(function (e) {
                      e(t);
                    })).then(a, o);
          }
          c((i = i.apply(e, t || [])).next());
        });
      };
      const sU = {};
      function aU(e, t) {
        return rU(this, void 0, void 0, function* () {
          if (!e) return;
          const n = document.getElementsByClassName("pwb-scene")[0];
          if (!n) return;
          const i = document.createElement("canvas");
          n.appendChild(i);
          const r = HL(i, e.autoResolutionSettings);
          sU.builder = r;
          const {
              pwObjects: s,
              pwMaterials: a,
              parents: o,
              children: c,
              effects: l,
              pwObjectsUsingPwMaterial: u,
              sharedMaterials: h,
            } = e,
            d = Object.assign(Object.assign({}, e), {
              pwObjects: new Map(Object.entries(s)),
              pwMaterials: new Map(Object.entries(a)),
              parents: new Map(Object.entries(o)),
              children: new Map(Object.entries(c)),
              effects: new Map(Object.entries(l || {})),
              pwObjectsUsingPwMaterial: new Map(Object.entries(u || {})),
              sharedMaterials: new Set(h),
            });
          let p;
          const f = new Promise((e) => {
            p = e;
          });
          r.listenTo(P_.SceneReady, () => {
            null == p || p(void 0);
          }),
            r.initializeClient(d, t),
            yield f,
            mf && r.showStatsPanel(document.body),
            VL(() => {
              var e;
              null === (e = sU.builder) || void 0 === e || e.dispose(),
                (sU.builder = void 0);
            });
        });
      }
      function oU(e) {
        return rU(this, void 0, void 0, function* () {
          if (!e) return;
          const { builder: t } = sU;
          if (!t) return;
          window.scrollTo(0, 0);
          const n = D_("default project");
          n.setState(e.sheetsById);
          const i = n.getAnimation(I_),
            r = e.sheetsById[I_].sequence;
          if (!r) return void console.error("No animation sheet state found!");
          const { tracksByObject: s = {}, unitType: a, lengthInUnits: o } = r;
          Object.keys(s).forEach((e) => {
            const n = t.getMaterial(e);
            if (n) return void i.animateMaterial(n);
            const r = t.getObject(e);
            r && i.animateObject3D(r);
          });
          const c = (e) => {
            const t = (function (e) {
              const { height: t, scrollHeight: n } = e.dimensions,
                i = e.scroll;
              return "percentage" === a
                ? (i / (n - t)) * 100
                : "dynamicViewPort" === a
                ? (i / t) * 100
                : (console.error(`Animation unit type: <${a}> not supported.`),
                  0);
            })(e);
            i.setPosition(t / o);
          };
          var l;
          (l = c),
            eU.listeners.add(l),
            VL(() => {
              !(function (e) {
                eU.listeners.delete(e);
              })(c);
            });
        });
      }
      const cU = {
        listeners: { [lt.UIOverlay]: new Set(), [lt.UIAudio]: new Set() },
      };
      function lU(e, t) {
        cU.listeners[e].add(t);
      }
      function uU(e, t) {
        cU.listeners[e].delete(t);
      }
      function hU(e, t) {
        !(function (e, t, n) {
          const i = cU.listeners[e];
          for (const e of i)
            try {
              e(((r = t), JSON.parse(JSON.stringify(r))), n);
            } catch (e) {
              console.error("Interaction error:", e);
            }
          var r;
        })(e.type, e, t);
      }
      function dU(e) {
        return [lt.UIAudio, lt.UIOverlay].includes(e.type) && !!e.id;
      }
      function pU(e) {
        return `pwb-ignore-click-ui-overlay-interaction-${e}`;
      }
      const fU = {
        [dt.MouseClick]: function (e) {
          const { el: t } = e,
            { actions: n, mouseCursor: i } = e.interaction;
          !(function (e) {
            const { el: t } = e,
              { actions: n } = e.interaction,
              i = new Set();
            for (const e of n) {
              if (e.type !== lt.UIOverlay) return;
              if (!e.id) return;
              i.add(pU(e.id));
            }
            for (const e of i) t.classList.add(e);
          })(e),
            i === Te.Pointer && (t.style.cursor = "pointer"),
            t.addEventListener("click", (e) => {
              Dp(e), Pp(e);
              for (const e of n) hU(e, dt.MouseClick);
            });
        },
        [dt.MouseEnter]: function (e) {
          const { el: t } = e,
            { actions: n } = e.interaction;
          t.addEventListener("mouseenter", () => {
            for (const e of n) hU(e, dt.MouseEnter);
          });
        },
        [dt.MouseLeave]: function (e) {
          const { el: t } = e,
            { actions: n } = e.interaction;
          t.addEventListener("mouseleave", () => {
            for (const e of n) hU(e, dt.MouseLeave);
          });
        },
      };
      function AU(e) {
        const t = (function (e) {
          const t = [];
          if (!e) return t;
          const n = e[At.Interactions] || {};
          return (
            Object.entries(n).forEach(([e, n]) => {
              if (!n) return;
              const i = document.getElementById(e);
              if (i)
                for (const e of n) {
                  const n = e.actions.filter((e) => dU(e));
                  n.length <= 0 ||
                    t.push({
                      el: i,
                      interaction: {
                        triggerType: e.triggerType,
                        mouseCursor: e.mouseCursor,
                        actions: n,
                      },
                    });
                }
            }),
            t
          );
        })(e);
        for (const e of t) fU[e.interaction.triggerType](e);
      }
      const gU = {};
      function mU() {
        if (gU.scrollSections) return gU.scrollSections;
        throw new Error(
          "ScrollSectionsModule needs to be initialized before the findAllScrollSections function can be called."
        );
      }
      function vU(e) {
        gU.scrollSections = (function (e) {
          const t = new Map();
          if (!e) return t;
          const n = e.sections || {};
          return (
            Object.entries(n).forEach(([e, n]) => {
              if (!(null == n ? void 0 : n.hash)) return;
              const i = document.getElementById(e);
              if (!i) return;
              const { hash: r, offsetY: s } = n;
              t.set(e, { id: e, hash: r, offsetY: s || 0, el: i });
            }),
            t
          );
        })(e);
      }
      function yU(e, t) {
        const n = new Map();
        if (!e) return n;
        const i = e.links || {};
        return (
          Object.entries(i).forEach(([e, i]) => {
            if (!i) return;
            const r = (function (e, t) {
              if (e.type === pt.External) {
                if ("string" != typeof e.url) return;
                const t = e.url.trim();
                if (!t) return;
                return { type: pt.External, url: xp(t), newTab: !!e.newTab };
              }
              if (e.type === pt.Internal) {
                if (!e.pageId) return;
                if (!e.pagePath) return;
                const n = !!e.newTab,
                  i = e.sectionId ? t.get(e.sectionId) : void 0;
                return {
                  type: pt.Internal,
                  pageId: e.pageId,
                  pagePath: e.pagePath,
                  sectionId: e.sectionId,
                  sectionHash: e.sectionHash,
                  sectionEl: null == i ? void 0 : i.el,
                  sectionOffsetY: (null == i ? void 0 : i.offsetY) || 0,
                  newTab: n,
                  smoothScroll: !n && !!e.smoothScroll,
                };
              }
            })(i, t);
            r && n.set(e, r);
          }),
          n
        );
      }
      function bU(e) {
        const t = window;
        return (n) => {
          Dp(n), Pp(n);
          const i = e.url;
          n.ctrlKey || n.metaKey || e.newTab || gf
            ? t.open(i, "_blank")
            : n.shiftKey
            ? t.open(i)
            : (t.location.href = i);
        };
      }
      function _U(e) {
        const t = window;
        return (n) => {
          Dp(n), Pp(n);
          const i = e.newTab && gf;
          if (e.newTab && !i) {
            const n = (function (e, t, n) {
              const i = t || "/",
                r = n ? `#${n}` : "";
              try {
                const t = new URL(xp(e));
                return (t.hash = r), (t.pathname = i), t.toString();
              } catch (e) {
                return `${i}${r}`;
              }
            })(window.location.href, e.pagePath, e.sectionHash);
            return void t.open(n, "_blank");
          }
          if (
            (function () {
              const { isInitialized: e, isNavigating: t } = xG;
              return !e || t ? void 0 : xG.currentPath;
            })() !== e.pagePath
          )
            return void CG(e.pagePath, e.sectionHash);
          if (!eU.val) return;
          const r = e.sectionEl ? e.sectionEl : "top",
            s = { offset: e.sectionOffsetY, immediate: !e.smoothScroll && !i };
          if (!(s.immediate || (eU.config && eU.config.isSmooth))) {
            const e = tU();
            (s.duration = e.duration), (s.easing = e.easing);
          }
          eU.val.scrollTo(r, s);
        };
      }
      function xU(e) {
        if (!eU.val) return;
        const t = xG.currentSectionHash;
        if (!t) return;
        const n = Array.from(e.values()).find((e) => e.hash === t);
        n && eU.val.scrollTo(n.el, { offset: n.offsetY, immediate: !0 });
      }
      const EU = (e) => e;
      let wU = EU,
        CU = EU;
      function SU(e, t, n) {
        var i;
        if ("string" == typeof e) {
          let r = document;
          t &&
            (CU(Boolean(t.current), "Scope provided, but no element detected."),
            (r = t.current)),
            n
              ? ((null !== (i = n[e]) && void 0 !== i) ||
                  (n[e] = r.querySelectorAll(e)),
                (e = n[e]))
              : (e = r.querySelectorAll(e));
        } else e instanceof Element && (e = [e]);
        return Array.from(e || []);
      }
      const IU = new WeakMap(),
        MU = !1,
        TU = !1;
      class BU {
        constructor() {
          (this.order = []), (this.scheduled = new Set());
        }
        add(e) {
          if (!this.scheduled.has(e))
            return this.scheduled.add(e), this.order.push(e), !0;
        }
        remove(e) {
          const t = this.order.indexOf(e);
          -1 !== t && (this.order.splice(t, 1), this.scheduled.delete(e));
        }
        clear() {
          (this.order.length = 0), this.scheduled.clear();
        }
      }
      const RU = [
        "read",
        "resolveKeyframes",
        "update",
        "preRender",
        "render",
        "postRender",
      ];
      const {
        schedule: DU,
        cancel: PU,
        state: LU,
        steps: UU,
      } = (function (e, t) {
        let n = !1,
          i = !0;
        const r = { delta: 0, timestamp: 0, isProcessing: !1 },
          s = RU.reduce(
            (e, t) => (
              (e[t] = (function (e) {
                let t = new BU(),
                  n = new BU(),
                  i = 0,
                  r = !1,
                  s = !1;
                const a = new WeakSet(),
                  o = {
                    schedule: (e, s = !1, o = !1) => {
                      const c = o && r,
                        l = c ? t : n;
                      return (
                        s && a.add(e),
                        l.add(e) && c && r && (i = t.order.length),
                        e
                      );
                    },
                    cancel: (e) => {
                      n.remove(e), a.delete(e);
                    },
                    process: (c) => {
                      if (r) s = !0;
                      else {
                        if (
                          ((r = !0),
                          ([t, n] = [n, t]),
                          n.clear(),
                          (i = t.order.length),
                          i)
                        )
                          for (let n = 0; n < i; n++) {
                            const i = t.order[n];
                            a.has(i) && (o.schedule(i), e()), i(c);
                          }
                        (r = !1), s && ((s = !1), o.process(c));
                      }
                    },
                  };
                return o;
              })(() => (n = !0))),
              e
            ),
            {}
          ),
          a = (e) => {
            s[e].process(r);
          },
          o = () => {
            const s = TU ? r.timestamp : performance.now();
            (n = !1),
              (r.delta = i
                ? 1e3 / 60
                : Math.max(Math.min(s - r.timestamp, 40), 1)),
              (r.timestamp = s),
              (r.isProcessing = !0),
              RU.forEach(a),
              (r.isProcessing = !1),
              n && t && ((i = !1), e(o));
          };
        return {
          schedule: RU.reduce((t, a) => {
            const c = s[a];
            return (
              (t[a] = (t, s = !1, a = !1) => (
                n || ((n = !0), (i = !0), r.isProcessing || e(o)),
                c.schedule(t, s, a)
              )),
              t
            );
          }, {}),
          cancel: (e) => RU.forEach((t) => s[t].cancel(e)),
          state: r,
          steps: s,
        };
      })(
        "undefined" != typeof requestAnimationFrame
          ? requestAnimationFrame
          : EU,
        !0
      );
      function FU(e, t) {
        let n;
        const i = () => {
          const { currentTime: i } = t,
            r = (null === i ? 0 : i.value) / 100;
          n !== r && e(r), (n = r);
        };
        return DU.update(i, !0), () => PU(i);
      }
      function OU(e) {
        let t;
        return () => (void 0 === t && (t = e()), t);
      }
      const NU = OU(() => void 0 !== window.ScrollTimeline);
      class kU {
        constructor(e) {
          this.animations = e.filter(Boolean);
        }
        then(e, t) {
          return Promise.all(this.animations).then(e).catch(t);
        }
        getAll(e) {
          return this.animations[0][e];
        }
        setAll(e, t) {
          for (let n = 0; n < this.animations.length; n++)
            this.animations[n][e] = t;
        }
        attachTimeline(e) {
          const t = this.animations.map((t) => {
            if (!NU() || !t.attachTimeline)
              return (
                t.pause(),
                FU((e) => {
                  t.time = t.duration * e;
                }, e)
              );
            t.attachTimeline(e);
          });
          return () => {
            t.forEach((e, t) => {
              e && e(), this.animations[t].stop();
            });
          };
        }
        get time() {
          return this.getAll("time");
        }
        set time(e) {
          this.setAll("time", e);
        }
        get speed() {
          return this.getAll("speed");
        }
        set speed(e) {
          this.setAll("speed", e);
        }
        get duration() {
          let e = 0;
          for (let t = 0; t < this.animations.length; t++)
            e = Math.max(e, this.animations[t].duration);
          return e;
        }
        runAll(e) {
          this.animations.forEach((t) => t[e]());
        }
        play() {
          this.runAll("play");
        }
        pause() {
          this.runAll("pause");
        }
        stop() {
          this.runAll("stop");
        }
        cancel() {
          this.runAll("cancel");
        }
        complete() {
          this.runAll("complete");
        }
      }
      const QU = [
          "transformPerspective",
          "x",
          "y",
          "z",
          "translateX",
          "translateY",
          "translateZ",
          "scale",
          "scaleX",
          "scaleY",
          "rotate",
          "rotateX",
          "rotateY",
          "rotateZ",
          "skew",
          "skewX",
          "skewY",
        ],
        GU = new Set(QU),
        HU = (e) => e.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(),
        zU = "data-" + HU("framerAppearId"),
        VU = (e) => 1e3 * e,
        jU = (e) => e / 1e3,
        WU = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 },
        XU = { type: "keyframes", duration: 0.8 },
        qU = { type: "keyframes", ease: [0.25, 0.1, 0.35, 1], duration: 0.3 },
        YU = (e, { keyframes: t }) =>
          t.length > 2
            ? XU
            : GU.has(e)
            ? e.startsWith("scale")
              ? {
                  type: "spring",
                  stiffness: 550,
                  damping: 0 === t[1] ? 2 * Math.sqrt(550) : 30,
                  restSpeed: 10,
                }
              : WU
            : qU;
      function KU(e, t) {
        return e[t] || e.default || e;
      }
      const JU = !1,
        ZU = (e) => null !== e;
      function $U(e, { repeat: t, repeatType: n = "loop" }) {
        const i = e.filter(ZU);
        return i[t && "loop" !== n && t % 2 == 1 ? 0 : i.length - 1];
      }
      let eF;
      function tF() {
        eF = void 0;
      }
      const nF = {
          now: () => (
            void 0 === eF &&
              nF.set(LU.isProcessing || TU ? LU.timestamp : performance.now()),
            eF
          ),
          set: (e) => {
            (eF = e), queueMicrotask(tF);
          },
        },
        iF = (e) => /^0[^.\s]+$/u.test(e);
      const rF = (e) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e),
        sF = (e) => (t) => "string" == typeof t && t.startsWith(e),
        aF = sF("--"),
        oF = sF("var(--"),
        cF = (e) => !!oF(e) && lF.test(e.split("/*")[0].trim()),
        lF =
          /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,
        uF = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;
      function hF(e, t, n = 1) {
        CU(
          n <= 4,
          `Max CSS variable fallback depth detected in property "${e}". This may indicate a circular fallback dependency.`
        );
        const [i, r] = (function (e) {
          const t = uF.exec(e);
          if (!t) return [,];
          const [, n, i, r] = t;
          return [`--${null != n ? n : i}`, r];
        })(e);
        if (!i) return;
        const s = window.getComputedStyle(t).getPropertyValue(i);
        if (s) {
          const e = s.trim();
          return rF(e) ? parseFloat(e) : e;
        }
        return cF(r) ? hF(r, t, n + 1) : r;
      }
      const dF = (e, t, n) => (n > t ? t : n < e ? e : n),
        pF = {
          test: (e) => "number" == typeof e,
          parse: parseFloat,
          transform: (e) => e,
        },
        fF = { ...pF, transform: (e) => dF(0, 1, e) },
        AF = { ...pF, default: 1 },
        gF = (e) => Math.round(1e5 * e) / 1e5,
        mF = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu,
        vF =
          /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu,
        yF =
          /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu;
      function bF(e) {
        return "string" == typeof e;
      }
      const _F = (e) => ({
          test: (t) => bF(t) && t.endsWith(e) && 1 === t.split(" ").length,
          parse: parseFloat,
          transform: (t) => `${t}${e}`,
        }),
        xF = _F("deg"),
        EF = _F("%"),
        wF = _F("px"),
        CF = _F("vh"),
        SF = _F("vw"),
        IF = {
          ...EF,
          parse: (e) => EF.parse(e) / 100,
          transform: (e) => EF.transform(100 * e),
        },
        MF = new Set([
          "width",
          "height",
          "top",
          "left",
          "right",
          "bottom",
          "x",
          "y",
          "translateX",
          "translateY",
        ]),
        TF = (e) => e === pF || e === wF,
        BF = (e, t) => parseFloat(e.split(", ")[t]),
        RF =
          (e, t) =>
          (n, { transform: i }) => {
            if ("none" === i || !i) return 0;
            const r = i.match(/^matrix3d\((.+)\)$/u);
            if (r) return BF(r[1], t);
            {
              const t = i.match(/^matrix\((.+)\)$/u);
              return t ? BF(t[1], e) : 0;
            }
          },
        DF = new Set(["x", "y", "z"]),
        PF = QU.filter((e) => !DF.has(e));
      const LF = {
        width: ({ x: e }, { paddingLeft: t = "0", paddingRight: n = "0" }) =>
          e.max - e.min - parseFloat(t) - parseFloat(n),
        height: ({ y: e }, { paddingTop: t = "0", paddingBottom: n = "0" }) =>
          e.max - e.min - parseFloat(t) - parseFloat(n),
        top: (e, { top: t }) => parseFloat(t),
        left: (e, { left: t }) => parseFloat(t),
        bottom: ({ y: e }, { top: t }) => parseFloat(t) + (e.max - e.min),
        right: ({ x: e }, { left: t }) => parseFloat(t) + (e.max - e.min),
        x: RF(4, 13),
        y: RF(5, 14),
      };
      (LF.translateX = LF.x), (LF.translateY = LF.y);
      const UF = (e) => (t) => t.test(e),
        FF = [
          pF,
          wF,
          EF,
          xF,
          SF,
          CF,
          { test: (e) => "auto" === e, parse: (e) => e },
        ],
        OF = (e) => FF.find(UF(e)),
        NF = new Set();
      let kF = !1,
        QF = !1;
      function GF() {
        QF &&
          (NF.forEach((e) => {
            e.needsMeasurement && e.unsetTransforms();
          }),
          NF.forEach((e) => {
            e.needsMeasurement && e.measureInitialState();
          }),
          NF.forEach((e) => {
            e.needsMeasurement && e.renderEndStyles();
          }),
          NF.forEach((e) => {
            e.needsMeasurement && e.measureEndState();
          })),
          (QF = !1),
          (kF = !1),
          NF.forEach((e) => e.complete()),
          NF.clear();
      }
      function HF() {
        NF.forEach((e) => {
          e.readKeyframes(), e.needsMeasurement && (QF = !0);
        }),
          DU.resolveKeyframes(GF);
      }
      class zF {
        constructor(e, t, n, i, r, s = !1) {
          (this.isComplete = !1),
            (this.isAsync = !1),
            (this.needsMeasurement = !1),
            (this.isScheduled = !1),
            (this.unresolvedKeyframes = [...e]),
            (this.onComplete = t),
            (this.name = n),
            (this.motionValue = i),
            (this.element = r),
            (this.isAsync = s);
        }
        scheduleResolve() {
          (this.isScheduled = !0),
            this.isAsync
              ? (NF.add(this), kF || ((kF = !0), DU.read(HF)))
              : (this.readKeyframes(), this.complete());
        }
        readKeyframes() {
          const {
            unresolvedKeyframes: e,
            name: t,
            element: n,
            motionValue: i,
          } = this;
          for (let r = 0; r < e.length; r++)
            if (null === e[r])
              if (0 === r) {
                const r = null == i ? void 0 : i.get(),
                  s = e[e.length - 1];
                if (void 0 !== r) e[0] = r;
                else if (n && t) {
                  const i = n.readValue(t, s);
                  null != i && (e[0] = i);
                }
                void 0 === e[0] && (e[0] = s), i && void 0 === r && i.set(e[0]);
              } else e[r] = e[r - 1];
        }
        unsetTransforms() {}
        measureInitialState() {}
        renderEndStyles() {}
        measureEndState() {}
        complete() {
          (this.isComplete = !0),
            this.onComplete(this.unresolvedKeyframes),
            NF.delete(this);
        }
        cancel() {
          this.isComplete || ((this.isScheduled = !1), NF.delete(this));
        }
        resume() {
          this.isComplete || this.scheduleResolve();
        }
      }
      const VF = (e, t) => (n) =>
          Boolean(
            (bF(n) && yF.test(n) && n.startsWith(e)) ||
              (t && Object.prototype.hasOwnProperty.call(n, t))
          ),
        jF = (e, t, n) => (i) => {
          if (!bF(i)) return i;
          const [r, s, a, o] = i.match(mF);
          return {
            [e]: parseFloat(r),
            [t]: parseFloat(s),
            [n]: parseFloat(a),
            alpha: void 0 !== o ? parseFloat(o) : 1,
          };
        },
        WF = { ...pF, transform: (e) => Math.round(((e) => dF(0, 255, e))(e)) },
        XF = {
          test: VF("rgb", "red"),
          parse: jF("red", "green", "blue"),
          transform: ({ red: e, green: t, blue: n, alpha: i = 1 }) =>
            "rgba(" +
            WF.transform(e) +
            ", " +
            WF.transform(t) +
            ", " +
            WF.transform(n) +
            ", " +
            gF(fF.transform(i)) +
            ")",
        };
      const qF = {
          test: VF("#"),
          parse: function (e) {
            let t = "",
              n = "",
              i = "",
              r = "";
            return (
              e.length > 5
                ? ((t = e.substring(1, 3)),
                  (n = e.substring(3, 5)),
                  (i = e.substring(5, 7)),
                  (r = e.substring(7, 9)))
                : ((t = e.substring(1, 2)),
                  (n = e.substring(2, 3)),
                  (i = e.substring(3, 4)),
                  (r = e.substring(4, 5)),
                  (t += t),
                  (n += n),
                  (i += i),
                  (r += r)),
              {
                red: parseInt(t, 16),
                green: parseInt(n, 16),
                blue: parseInt(i, 16),
                alpha: r ? parseInt(r, 16) / 255 : 1,
              }
            );
          },
          transform: XF.transform,
        },
        YF = {
          test: VF("hsl", "hue"),
          parse: jF("hue", "saturation", "lightness"),
          transform: ({ hue: e, saturation: t, lightness: n, alpha: i = 1 }) =>
            "hsla(" +
            Math.round(e) +
            ", " +
            EF.transform(gF(t)) +
            ", " +
            EF.transform(gF(n)) +
            ", " +
            gF(fF.transform(i)) +
            ")",
        },
        KF = {
          test: (e) => XF.test(e) || qF.test(e) || YF.test(e),
          parse: (e) =>
            XF.test(e) ? XF.parse(e) : YF.test(e) ? YF.parse(e) : qF.parse(e),
          transform: (e) =>
            bF(e)
              ? e
              : e.hasOwnProperty("red")
              ? XF.transform(e)
              : YF.transform(e),
        };
      const JF = "number",
        ZF = "color",
        $F = "var",
        eO = "var(",
        tO = "${}",
        nO =
          /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
      function iO(e) {
        const t = e.toString(),
          n = [],
          i = { color: [], number: [], var: [] },
          r = [];
        let s = 0;
        const a = t
          .replace(
            nO,
            (e) => (
              KF.test(e)
                ? (i.color.push(s), r.push(ZF), n.push(KF.parse(e)))
                : e.startsWith(eO)
                ? (i.var.push(s), r.push($F), n.push(e))
                : (i.number.push(s), r.push(JF), n.push(parseFloat(e))),
              ++s,
              tO
            )
          )
          .split(tO);
        return { values: n, split: a, indexes: i, types: r };
      }
      function rO(e) {
        return iO(e).values;
      }
      function sO(e) {
        const { split: t, types: n } = iO(e),
          i = t.length;
        return (e) => {
          let r = "";
          for (let s = 0; s < i; s++)
            if (((r += t[s]), void 0 !== e[s])) {
              const t = n[s];
              r += t === JF ? gF(e[s]) : t === ZF ? KF.transform(e[s]) : e[s];
            }
          return r;
        };
      }
      const aO = (e) => ("number" == typeof e ? 0 : e);
      const oO = {
          test: function (e) {
            var t, n;
            return (
              isNaN(e) &&
              bF(e) &&
              ((null === (t = e.match(mF)) || void 0 === t
                ? void 0
                : t.length) || 0) +
                ((null === (n = e.match(vF)) || void 0 === n
                  ? void 0
                  : n.length) || 0) >
                0
            );
          },
          parse: rO,
          createTransformer: sO,
          getAnimatableNone: function (e) {
            const t = rO(e);
            return sO(e)(t.map(aO));
          },
        },
        cO = new Set(["brightness", "contrast", "saturate", "opacity"]);
      function lO(e) {
        const [t, n] = e.slice(0, -1).split("(");
        if ("drop-shadow" === t) return e;
        const [i] = n.match(mF) || [];
        if (!i) return e;
        const r = n.replace(i, "");
        let s = cO.has(t) ? 1 : 0;
        return i !== n && (s *= 100), t + "(" + s + r + ")";
      }
      const uO = /\b([a-z-]*)\(.*?\)/gu,
        hO = {
          ...oO,
          getAnimatableNone: (e) => {
            const t = e.match(uO);
            return t ? t.map(lO).join(" ") : e;
          },
        },
        dO = { ...pF, transform: Math.round },
        pO = {
          borderWidth: wF,
          borderTopWidth: wF,
          borderRightWidth: wF,
          borderBottomWidth: wF,
          borderLeftWidth: wF,
          borderRadius: wF,
          radius: wF,
          borderTopLeftRadius: wF,
          borderTopRightRadius: wF,
          borderBottomRightRadius: wF,
          borderBottomLeftRadius: wF,
          width: wF,
          maxWidth: wF,
          height: wF,
          maxHeight: wF,
          size: wF,
          top: wF,
          right: wF,
          bottom: wF,
          left: wF,
          padding: wF,
          paddingTop: wF,
          paddingRight: wF,
          paddingBottom: wF,
          paddingLeft: wF,
          margin: wF,
          marginTop: wF,
          marginRight: wF,
          marginBottom: wF,
          marginLeft: wF,
          rotate: xF,
          rotateX: xF,
          rotateY: xF,
          rotateZ: xF,
          scale: AF,
          scaleX: AF,
          scaleY: AF,
          scaleZ: AF,
          skew: xF,
          skewX: xF,
          skewY: xF,
          distance: wF,
          translateX: wF,
          translateY: wF,
          translateZ: wF,
          x: wF,
          y: wF,
          z: wF,
          perspective: wF,
          transformPerspective: wF,
          opacity: fF,
          originX: IF,
          originY: IF,
          originZ: wF,
          zIndex: dO,
          fillOpacity: fF,
          strokeOpacity: fF,
          numOctaves: dO,
        },
        fO = {
          ...pO,
          color: KF,
          backgroundColor: KF,
          outlineColor: KF,
          fill: KF,
          stroke: KF,
          borderColor: KF,
          borderTopColor: KF,
          borderRightColor: KF,
          borderBottomColor: KF,
          borderLeftColor: KF,
          filter: hO,
          WebkitFilter: hO,
        },
        AO = (e) => fO[e];
      function gO(e, t) {
        let n = AO(e);
        return (
          n !== hO && (n = oO),
          n.getAnimatableNone ? n.getAnimatableNone(t) : void 0
        );
      }
      class mO extends zF {
        constructor(e, t, n, i) {
          super(e, t, n, i, null == i ? void 0 : i.owner, !0);
        }
        readKeyframes() {
          const { unresolvedKeyframes: e, element: t, name: n } = this;
          if (!t.current) return;
          const i = [];
          super.readKeyframes();
          for (let n = 0; n < e.length; n++) {
            const s = e[n];
            if ("string" == typeof s && cF(s)) {
              const i = hF(s, t.current);
              void 0 !== i && (e[n] = i);
            }
            ("number" == typeof (r = e[n])
              ? 0 === r
              : null === r || "none" === r || "0" === r || iF(r)) && i.push(n);
          }
          var r;
          if (
            (i.length &&
              (function (e, t, n) {
                let i,
                  r = 0;
                for (; r < e.length && !i; )
                  "string" == typeof e[r] &&
                    "none" !== e[r] &&
                    "0" !== e[r] &&
                    (i = e[r]),
                    r++;
                if (i && n) for (const r of t) e[r] = gO(n, i);
              })(e, i, n),
            !MF.has(n) || 2 !== e.length)
          )
            return;
          const [s, a] = e,
            o = OF(s),
            c = OF(a);
          if (o && c && o !== c)
            if (TF(o) && TF(c))
              for (let t = 0; t < e.length; t++) {
                const n = e[t];
                "string" == typeof n && (e[t] = parseFloat(n));
              }
            else this.needsMeasurement = !0;
        }
        unsetTransforms() {
          const { element: e, name: t, unresolvedKeyframes: n } = this;
          if (!e.current) return;
          this.removedTransforms = (function (e) {
            const t = [];
            return (
              PF.forEach((n) => {
                const i = e.getValue(n);
                void 0 !== i &&
                  (t.push([n, i.get()]), i.set(n.startsWith("scale") ? 1 : 0));
              }),
              t.length && e.render(),
              t
            );
          })(e);
          const i = n[n.length - 1];
          e.getValue(t, i).jump(i, !1);
        }
        measureInitialState() {
          const { element: e, unresolvedKeyframes: t, name: n } = this;
          e.current &&
            ("height" === n && (this.suspendedScrollY = window.pageYOffset),
            (this.measuredOrigin = LF[n](
              e.measureViewportBox(),
              window.getComputedStyle(e.current)
            )),
            (t[0] = this.measuredOrigin));
        }
        renderEndStyles() {
          this.element.render();
        }
        measureEndState() {
          var e;
          const { element: t, name: n, unresolvedKeyframes: i } = this;
          if (!t.current) return;
          const r = t.getValue(n);
          r && r.jump(this.measuredOrigin, !1),
            (i[i.length - 1] = LF[n](
              t.measureViewportBox(),
              window.getComputedStyle(t.current)
            )),
            "height" === n &&
              void 0 !== this.suspendedScrollY &&
              window.scrollTo(0, this.suspendedScrollY),
            (null === (e = this.removedTransforms) || void 0 === e
              ? void 0
              : e.length) &&
              this.removedTransforms.forEach(([e, n]) => {
                t.getValue(e).set(n);
              });
        }
      }
      const vO = (e, t) =>
        "zIndex" !== t &&
        (!("number" != typeof e && !Array.isArray(e)) ||
          !(
            "string" != typeof e ||
            (!oO.test(e) && "0" !== e) ||
            e.startsWith("url(")
          ));
      class yO {
        constructor({
          autoplay: e = !0,
          delay: t = 0,
          type: n = "keyframes",
          repeat: i = 0,
          repeatDelay: r = 0,
          repeatType: s = "loop",
          ...a
        }) {
          (this.isStopped = !1),
            (this.options = {
              autoplay: e,
              delay: t,
              type: n,
              repeat: i,
              repeatDelay: r,
              repeatType: s,
              ...a,
            }),
            this.updateFinishedPromise();
        }
        get resolved() {
          return this._resolved || (HF(), GF(), PU(HF), PU(GF)), this._resolved;
        }
        onKeyframesResolved(e) {
          const {
            name: t,
            type: n,
            velocity: i,
            delay: r,
            onComplete: s,
            onUpdate: a,
          } = this.options;
          if (
            !(function (e, t, n, i) {
              const r = e[0];
              if (null === r) return !1;
              const s = e[e.length - 1],
                a = vO(r, t),
                o = vO(s, t);
              return (
                wU(
                  a === o,
                  `You are trying to animate ${t} from "${r}" to "${s}". ${r} is not an animatable value - to enable this animation set ${r} to a value animatable to ${s} via the \`style\` property.`
                ),
                !(!a || !o) &&
                  ((function (e) {
                    const t = e[0];
                    if (1 === e.length) return !0;
                    for (let n = 0; n < e.length; n++)
                      if (e[n] !== t) return !0;
                  })(e) ||
                    ("spring" === n && i))
              );
            })(e, t, n, i)
          ) {
            if (JU || !r) {
              const t = $U(e, this.options);
              return (
                null == a || a(t),
                null == s || s(),
                this.resolveFinishedPromise(),
                void this.updateFinishedPromise()
              );
            }
            this.options.duration = 0;
          }
          (this._resolved = { keyframes: e, ...this.initPlayback(e) }),
            this.onPostResolved();
        }
        onPostResolved() {}
        then(e, t) {
          return this.currentFinishedPromise.then(e, t);
        }
        updateFinishedPromise() {
          this.currentFinishedPromise = new Promise((e) => {
            this.resolveFinishedPromise = () => {
              e(), this.updateFinishedPromise();
            };
          });
        }
      }
      function bO(e, t) {
        return t ? e * (1e3 / t) : 0;
      }
      const _O = 5;
      function xO(e, t, n) {
        const i = Math.max(t - _O, 0);
        return bO(n - e(i), t - i);
      }
      const EO = 0.001,
        wO = 0.01,
        CO = 10,
        SO = 0.05,
        IO = 1;
      function MO({
        duration: e = 800,
        bounce: t = 0.25,
        velocity: n = 0,
        mass: i = 1,
      }) {
        let r, s;
        wU(e <= VU(CO), "Spring duration must be 10 seconds or less");
        let a = 1 - t;
        (a = dF(SO, IO, a)),
          (e = dF(wO, CO, jU(e))),
          a < 1
            ? ((r = (t) => {
                const i = t * a,
                  r = i * e,
                  s = i - n,
                  o = BO(t, a),
                  c = Math.exp(-r);
                return EO - (s / o) * c;
              }),
              (s = (t) => {
                const i = t * a * e,
                  s = i * n + n,
                  o = Math.pow(a, 2) * Math.pow(t, 2) * e,
                  c = Math.exp(-i),
                  l = BO(Math.pow(t, 2), a);
                return ((-r(t) + EO > 0 ? -1 : 1) * ((s - o) * c)) / l;
              }))
            : ((r = (t) => Math.exp(-t * e) * ((t - n) * e + 1) - EO),
              (s = (t) => Math.exp(-t * e) * (e * e * (n - t))));
        const o = (function (e, t, n) {
          let i = n;
          for (let n = 1; n < TO; n++) i -= e(i) / t(i);
          return i;
        })(r, s, 5 / e);
        if (((e = VU(e)), isNaN(o)))
          return { stiffness: 100, damping: 10, duration: e };
        {
          const t = Math.pow(o, 2) * i;
          return {
            stiffness: t,
            damping: 2 * a * Math.sqrt(i * t),
            duration: e,
          };
        }
      }
      const TO = 12;
      function BO(e, t) {
        return e * Math.sqrt(1 - t * t);
      }
      const RO = ["duration", "bounce"],
        DO = ["stiffness", "damping", "mass"];
      function PO(e, t) {
        return t.some((t) => void 0 !== e[t]);
      }
      function LO({ keyframes: e, restDelta: t, restSpeed: n, ...i }) {
        const r = e[0],
          s = e[e.length - 1],
          a = { done: !1, value: r },
          {
            stiffness: o,
            damping: c,
            mass: l,
            duration: u,
            velocity: h,
            isResolvedFromDuration: d,
          } = (function (e) {
            let t = {
              velocity: 0,
              stiffness: 100,
              damping: 10,
              mass: 1,
              isResolvedFromDuration: !1,
              ...e,
            };
            if (!PO(e, DO) && PO(e, RO)) {
              const n = MO(e);
              (t = { ...t, ...n, mass: 1 }), (t.isResolvedFromDuration = !0);
            }
            return t;
          })({ ...i, velocity: -jU(i.velocity || 0) }),
          p = h || 0,
          f = c / (2 * Math.sqrt(o * l)),
          A = s - r,
          g = jU(Math.sqrt(o / l)),
          m = Math.abs(A) < 5;
        let v;
        if ((n || (n = m ? 0.01 : 2), t || (t = m ? 0.005 : 0.5), f < 1)) {
          const e = BO(g, f);
          v = (t) => {
            const n = Math.exp(-f * g * t);
            return (
              s -
              n *
                (((p + f * g * A) / e) * Math.sin(e * t) + A * Math.cos(e * t))
            );
          };
        } else if (1 === f)
          v = (e) => s - Math.exp(-g * e) * (A + (p + g * A) * e);
        else {
          const e = g * Math.sqrt(f * f - 1);
          v = (t) => {
            const n = Math.exp(-f * g * t),
              i = Math.min(e * t, 300);
            return (
              s -
              (n * ((p + f * g * A) * Math.sinh(i) + e * A * Math.cosh(i))) / e
            );
          };
        }
        return {
          calculatedDuration: (d && u) || null,
          next: (e) => {
            const i = v(e);
            if (d) a.done = e >= u;
            else {
              let r = p;
              0 !== e && (r = f < 1 ? xO(v, e, i) : 0);
              const o = Math.abs(r) <= n,
                c = Math.abs(s - i) <= t;
              a.done = o && c;
            }
            return (a.value = a.done ? s : i), a;
          },
        };
      }
      function UO({
        keyframes: e,
        velocity: t = 0,
        power: n = 0.8,
        timeConstant: i = 325,
        bounceDamping: r = 10,
        bounceStiffness: s = 500,
        modifyTarget: a,
        min: o,
        max: c,
        restDelta: l = 0.5,
        restSpeed: u,
      }) {
        const h = e[0],
          d = { done: !1, value: h },
          p = (e) =>
            void 0 === o
              ? c
              : void 0 === c || Math.abs(o - e) < Math.abs(c - e)
              ? o
              : c;
        let f = n * t;
        const A = h + f,
          g = void 0 === a ? A : a(A);
        g !== A && (f = g - h);
        const m = (e) => -f * Math.exp(-e / i),
          v = (e) => g + m(e),
          y = (e) => {
            const t = m(e),
              n = v(e);
            (d.done = Math.abs(t) <= l), (d.value = d.done ? g : n);
          };
        let b, _;
        const x = (e) => {
          ((e) => (void 0 !== o && e < o) || (void 0 !== c && e > c))(
            d.value
          ) &&
            ((b = e),
            (_ = LO({
              keyframes: [d.value, p(d.value)],
              velocity: xO(v, e, d.value),
              damping: r,
              stiffness: s,
              restDelta: l,
              restSpeed: u,
            })));
        };
        return (
          x(0),
          {
            calculatedDuration: null,
            next: (e) => {
              let t = !1;
              return (
                _ || void 0 !== b || ((t = !0), y(e), x(e)),
                void 0 !== b && e >= b ? _.next(e - b) : (!t && y(e), d)
              );
            },
          }
        );
      }
      const FO = (e, t, n) =>
          (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e,
        OO = 1e-7,
        NO = 12;
      function kO(e, t, n, i) {
        if (e === t && n === i) return EU;
        const r = (t) =>
          (function (e, t, n, i, r) {
            let s,
              a,
              o = 0;
            do {
              (a = t + (n - t) / 2),
                (s = FO(a, i, r) - e),
                s > 0 ? (n = a) : (t = a);
            } while (Math.abs(s) > OO && ++o < NO);
            return a;
          })(t, 0, 1, e, n);
        return (e) => (0 === e || 1 === e ? e : FO(r(e), t, i));
      }
      const QO = kO(0.42, 0, 1, 1),
        GO = kO(0, 0, 0.58, 1),
        HO = kO(0.42, 0, 0.58, 1),
        zO = (e) => Array.isArray(e) && "number" != typeof e[0],
        VO = (e) => (t) => t <= 0.5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2,
        jO = (e) => (t) => 1 - e(1 - t),
        WO = (e) => 1 - Math.sin(Math.acos(e)),
        XO = jO(WO),
        qO = VO(WO),
        YO = kO(0.33, 1.53, 0.69, 0.99),
        KO = jO(YO),
        JO = VO(KO),
        ZO = {
          linear: EU,
          easeIn: QO,
          easeInOut: HO,
          easeOut: GO,
          circIn: WO,
          circInOut: qO,
          circOut: XO,
          backIn: KO,
          backInOut: JO,
          backOut: YO,
          anticipate: (e) =>
            (e *= 2) < 1 ? 0.5 * KO(e) : 0.5 * (2 - Math.pow(2, -10 * (e - 1))),
        },
        $O = (e) => {
          if (Array.isArray(e)) {
            CU(
              4 === e.length,
              "Cubic bezier arrays must contain four numerical values."
            );
            const [t, n, i, r] = e;
            return kO(t, n, i, r);
          }
          return "string" == typeof e
            ? (CU(void 0 !== ZO[e], `Invalid easing type '${e}'`), ZO[e])
            : e;
        },
        eN = (e, t) => (n) => t(e(n)),
        tN = (...e) => e.reduce(eN),
        nN = (e, t, n) => {
          const i = t - e;
          return 0 === i ? 1 : (n - e) / i;
        },
        iN = (e, t, n) => e + (t - e) * n;
      function rN(e, t, n) {
        return (
          n < 0 && (n += 1),
          n > 1 && (n -= 1),
          n < 1 / 6
            ? e + 6 * (t - e) * n
            : n < 0.5
            ? t
            : n < 2 / 3
            ? e + (t - e) * (2 / 3 - n) * 6
            : e
        );
      }
      const sN = (e, t, n) => {
          const i = e * e,
            r = n * (t * t - i) + i;
          return r < 0 ? 0 : Math.sqrt(r);
        },
        aN = [qF, XF, YF];
      function oN(e) {
        const t = ((e) => aN.find((t) => t.test(e)))(e);
        CU(
          Boolean(t),
          `'${e}' is not an animatable color. Use the equivalent color code instead.`
        );
        let n = t.parse(e);
        return (
          t === YF &&
            (n = (function ({ hue: e, saturation: t, lightness: n, alpha: i }) {
              (e /= 360), (n /= 100);
              let r = 0,
                s = 0,
                a = 0;
              if ((t /= 100)) {
                const i = n < 0.5 ? n * (1 + t) : n + t - n * t,
                  o = 2 * n - i;
                (r = rN(o, i, e + 1 / 3)),
                  (s = rN(o, i, e)),
                  (a = rN(o, i, e - 1 / 3));
              } else r = s = a = n;
              return {
                red: Math.round(255 * r),
                green: Math.round(255 * s),
                blue: Math.round(255 * a),
                alpha: i,
              };
            })(n)),
          n
        );
      }
      const cN = (e, t) => {
        const n = oN(e),
          i = oN(t),
          r = { ...n };
        return (e) => (
          (r.red = sN(n.red, i.red, e)),
          (r.green = sN(n.green, i.green, e)),
          (r.blue = sN(n.blue, i.blue, e)),
          (r.alpha = iN(n.alpha, i.alpha, e)),
          XF.transform(r)
        );
      };
      function lN(e, t) {
        return (n) => (n > 0 ? t : e);
      }
      function uN(e, t) {
        return (n) => iN(e, t, n);
      }
      function hN(e) {
        return "number" == typeof e
          ? uN
          : "string" == typeof e
          ? cF(e)
            ? lN
            : KF.test(e)
            ? cN
            : fN
          : Array.isArray(e)
          ? dN
          : "object" == typeof e
          ? KF.test(e)
            ? cN
            : pN
          : lN;
      }
      function dN(e, t) {
        const n = [...e],
          i = n.length,
          r = e.map((e, n) => hN(e)(e, t[n]));
        return (e) => {
          for (let t = 0; t < i; t++) n[t] = r[t](e);
          return n;
        };
      }
      function pN(e, t) {
        const n = { ...e, ...t },
          i = {};
        for (const r in n)
          void 0 !== e[r] && void 0 !== t[r] && (i[r] = hN(e[r])(e[r], t[r]));
        return (e) => {
          for (const t in i) n[t] = i[t](e);
          return n;
        };
      }
      const fN = (e, t) => {
        const n = oO.createTransformer(t),
          i = iO(e),
          r = iO(t);
        return i.indexes.var.length === r.indexes.var.length &&
          i.indexes.color.length === r.indexes.color.length &&
          i.indexes.number.length >= r.indexes.number.length
          ? tN(
              dN(
                (function (e, t) {
                  var n;
                  const i = [],
                    r = { color: 0, var: 0, number: 0 };
                  for (let s = 0; s < t.values.length; s++) {
                    const a = t.types[s],
                      o = e.indexes[a][r[a]],
                      c = null !== (n = e.values[o]) && void 0 !== n ? n : 0;
                    (i[s] = c), r[a]++;
                  }
                  return i;
                })(i, r),
                r.values
              ),
              n
            )
          : (wU(
              !0,
              `Complex values '${e}' and '${t}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`
            ),
            lN(e, t));
      };
      function AN(e, t, n) {
        if (
          "number" == typeof e &&
          "number" == typeof t &&
          "number" == typeof n
        )
          return iN(e, t, n);
        return hN(e)(e, t);
      }
      function gN(e, t, { clamp: n = !0, ease: i, mixer: r } = {}) {
        const s = e.length;
        if (
          (CU(
            s === t.length,
            "Both input and output ranges must be the same length"
          ),
          1 === s)
        )
          return () => t[0];
        if (2 === s && e[0] === e[1]) return () => t[1];
        e[0] > e[s - 1] && ((e = [...e].reverse()), (t = [...t].reverse()));
        const a = (function (e, t, n) {
            const i = [],
              r = n || AN,
              s = e.length - 1;
            for (let n = 0; n < s; n++) {
              let s = r(e[n], e[n + 1]);
              if (t) {
                const e = Array.isArray(t) ? t[n] || EU : t;
                s = tN(e, s);
              }
              i.push(s);
            }
            return i;
          })(t, i, r),
          o = a.length,
          c = (t) => {
            let n = 0;
            if (o > 1) for (; n < e.length - 2 && !(t < e[n + 1]); n++);
            const i = nN(e[n], e[n + 1], t);
            return a[n](i);
          };
        return n ? (t) => c(dF(e[0], e[s - 1], t)) : c;
      }
      function mN(e, t) {
        const n = e[e.length - 1];
        for (let i = 1; i <= t; i++) {
          const r = nN(0, t, i);
          e.push(iN(n, 1, r));
        }
      }
      function vN(e) {
        const t = [0];
        return mN(t, e.length - 1), t;
      }
      function yN({
        duration: e = 300,
        keyframes: t,
        times: n,
        ease: i = "easeInOut",
      }) {
        const r = zO(i) ? i.map($O) : $O(i),
          s = { done: !1, value: t[0] },
          a = (function (e, t) {
            return e.map((e) => e * t);
          })(n && n.length === t.length ? n : vN(t), e),
          o = gN(a, t, {
            ease: Array.isArray(r)
              ? r
              : ((c = t),
                (l = r),
                c.map(() => l || HO).splice(0, c.length - 1)),
          });
        var c, l;
        return {
          calculatedDuration: e,
          next: (t) => ((s.value = o(t)), (s.done = t >= e), s),
        };
      }
      const bN = 2e4;
      function _N(e) {
        let t = 0;
        let n = e.next(t);
        for (; !n.done && t < bN; ) (t += 50), (n = e.next(t));
        return t >= bN ? 1 / 0 : t;
      }
      const xN = (e) => {
          const t = ({ timestamp: t }) => e(t);
          return {
            start: () => DU.update(t, !0),
            stop: () => PU(t),
            now: () => (LU.isProcessing ? LU.timestamp : nF.now()),
          };
        },
        EN = { decay: UO, inertia: UO, tween: yN, keyframes: yN, spring: LO },
        wN = (e) => e / 100;
      class CN extends yO {
        constructor({ KeyframeResolver: e = zF, ...t }) {
          super(t),
            (this.holdTime = null),
            (this.startTime = null),
            (this.cancelTime = null),
            (this.currentTime = 0),
            (this.playbackSpeed = 1),
            (this.pendingPlayState = "running"),
            (this.state = "idle");
          const { name: n, motionValue: i, keyframes: r } = this.options,
            s = (e) => this.onKeyframesResolved(e);
          n && i && i.owner
            ? (this.resolver = i.owner.resolveKeyframes(r, s, n, i))
            : (this.resolver = new e(r, s, n, i)),
            this.resolver.scheduleResolve();
        }
        initPlayback(e) {
          const {
              type: t = "keyframes",
              repeat: n = 0,
              repeatDelay: i = 0,
              repeatType: r,
              velocity: s = 0,
            } = this.options,
            a = EN[t] || yN;
          let o, c;
          a !== yN &&
            "number" != typeof e[0] &&
            ((o = tN(wN, AN(e[0], e[1]))), (e = [0, 100]));
          const l = a({ ...this.options, keyframes: e });
          "mirror" === r &&
            (c = a({
              ...this.options,
              keyframes: [...e].reverse(),
              velocity: -s,
            })),
            null === l.calculatedDuration && (l.calculatedDuration = _N(l));
          const { calculatedDuration: u } = l,
            h = u + i;
          return {
            generator: l,
            mirroredGenerator: c,
            mapPercentToKeyframes: o,
            calculatedDuration: u,
            resolvedDuration: h,
            totalDuration: h * (n + 1) - i,
          };
        }
        onPostResolved() {
          const { autoplay: e = !0 } = this.options;
          this.play(),
            "paused" !== this.pendingPlayState && e
              ? (this.state = this.pendingPlayState)
              : this.pause();
        }
        tick(e, t = !1) {
          const {
            generator: n,
            mirroredGenerator: i,
            mapPercentToKeyframes: r,
            keyframes: s,
            calculatedDuration: a,
            totalDuration: o,
            resolvedDuration: c,
          } = this.resolved;
          if (null === this.startTime) return n.next(0);
          const {
            delay: l,
            repeat: u,
            repeatType: h,
            repeatDelay: d,
            onUpdate: p,
          } = this.options;
          this.speed > 0
            ? (this.startTime = Math.min(this.startTime, e))
            : this.speed < 0 &&
              (this.startTime = Math.min(e - o / this.speed, this.startTime)),
            t
              ? (this.currentTime = e)
              : null !== this.holdTime
              ? (this.currentTime = this.holdTime)
              : (this.currentTime =
                  Math.round(e - this.startTime) * this.speed);
          const f = this.currentTime - l * (this.speed >= 0 ? 1 : -1),
            A = this.speed >= 0 ? f < 0 : f > o;
          (this.currentTime = Math.max(f, 0)),
            "finished" === this.state &&
              null === this.holdTime &&
              (this.currentTime = o);
          let g = this.currentTime,
            m = n;
          if (u) {
            const e = Math.min(this.currentTime, o) / c;
            let t = Math.floor(e),
              n = e % 1;
            !n && e >= 1 && (n = 1), 1 === n && t--, (t = Math.min(t, u + 1));
            Boolean(t % 2) &&
              ("reverse" === h
                ? ((n = 1 - n), d && (n -= d / c))
                : "mirror" === h && (m = i)),
              (g = dF(0, 1, n) * c);
          }
          const v = A ? { done: !1, value: s[0] } : m.next(g);
          r && (v.value = r(v.value));
          let { done: y } = v;
          A ||
            null === a ||
            (y =
              this.speed >= 0 ? this.currentTime >= o : this.currentTime <= 0);
          const b =
            null === this.holdTime &&
            ("finished" === this.state || ("running" === this.state && y));
          return p && p(v.value), b && this.finish(), v;
        }
        get duration() {
          return jU(this.resolved.calculatedDuration);
        }
        get time() {
          return jU(this.currentTime);
        }
        set time(e) {
          (e = VU(e)),
            (this.currentTime = e),
            null !== this.holdTime || 0 === this.speed
              ? (this.holdTime = e)
              : this.driver &&
                (this.startTime = this.driver.now() - e / this.speed);
        }
        get speed() {
          return this.playbackSpeed;
        }
        set speed(e) {
          const t = this.playbackSpeed !== e;
          (this.playbackSpeed = e), t && (this.time = jU(this.currentTime));
        }
        play() {
          if (
            (this.resolver.isScheduled || this.resolver.resume(),
            !this._resolved)
          )
            return void (this.pendingPlayState = "running");
          if (this.isStopped) return;
          const { driver: e = xN, onPlay: t } = this.options;
          this.driver || (this.driver = e((e) => this.tick(e))), t && t();
          const n = this.driver.now();
          null !== this.holdTime
            ? (this.startTime = n - this.holdTime)
            : (this.startTime && "finished" !== this.state) ||
              (this.startTime = n),
            "finished" === this.state && this.updateFinishedPromise(),
            (this.cancelTime = this.startTime),
            (this.holdTime = null),
            (this.state = "running"),
            this.driver.start();
        }
        pause() {
          var e;
          this._resolved
            ? ((this.state = "paused"),
              (this.holdTime =
                null !== (e = this.currentTime) && void 0 !== e ? e : 0))
            : (this.pendingPlayState = "paused");
        }
        stop() {
          if (((this.isStopped = !0), "idle" === this.state)) return;
          this.state = "idle";
          const { onStop: e } = this.options;
          e && e(), this.teardown();
        }
        complete() {
          "running" !== this.state && this.play(),
            (this.pendingPlayState = this.state = "finished"),
            (this.holdTime = null);
        }
        finish() {
          this.teardown(), (this.state = "finished");
          const { onComplete: e } = this.options;
          e && e();
        }
        cancel() {
          null !== this.cancelTime && this.tick(this.cancelTime),
            this.teardown();
        }
        teardown() {
          (this.state = "idle"),
            this.stopDriver(),
            this.resolveFinishedPromise(),
            this.updateFinishedPromise(),
            (this.startTime = this.cancelTime = null),
            this.resolver.cancel();
        }
        stopDriver() {
          this.driver && (this.driver.stop(), (this.driver = void 0));
        }
        sample(e) {
          return (this.startTime = 0), this.tick(e, !0);
        }
      }
      const SN = (e) => Array.isArray(e) && "number" == typeof e[0];
      function IN(e) {
        return Boolean(
          !e ||
            ("string" == typeof e && TN[e]) ||
            SN(e) ||
            (Array.isArray(e) && e.every(IN))
        );
      }
      const MN = ([e, t, n, i]) => `cubic-bezier(${e}, ${t}, ${n}, ${i})`,
        TN = {
          linear: "linear",
          ease: "ease",
          easeIn: "ease-in",
          easeOut: "ease-out",
          easeInOut: "ease-in-out",
          circIn: MN([0, 0.65, 0.55, 1]),
          circOut: MN([0.55, 0, 1, 0.45]),
          backIn: MN([0.31, 0.01, 0.66, -0.59]),
          backOut: MN([0.33, 1.53, 0.69, 0.99]),
        };
      function BN(e) {
        if (e) return SN(e) ? MN(e) : Array.isArray(e) ? e.map(BN) : TN[e];
      }
      const RN = OU(() =>
          Object.hasOwnProperty.call(Element.prototype, "animate")
        ),
        DN = new Set(["opacity", "clipPath", "filter", "transform"]);
      class PN extends yO {
        constructor(e) {
          super(e);
          const { name: t, motionValue: n, keyframes: i } = this.options;
          (this.resolver = new mO(i, (e) => this.onKeyframesResolved(e), t, n)),
            this.resolver.scheduleResolve();
        }
        initPlayback(e) {
          let t = this.options.duration || 300;
          if (
            "spring" === (n = this.options).type ||
            "backgroundColor" === n.name ||
            !IN(n.ease)
          ) {
            const {
                onComplete: n,
                onUpdate: i,
                motionValue: r,
                ...s
              } = this.options,
              a = (function (e, t) {
                const n = new CN({ ...t, keyframes: e, repeat: 0, delay: 0 });
                let i = { done: !1, value: e[0] };
                const r = [];
                let s = 0;
                for (; !i.done && s < 2e4; )
                  (i = n.sample(s)), r.push(i.value), (s += 10);
                return {
                  times: void 0,
                  keyframes: r,
                  duration: s - 10,
                  ease: "linear",
                };
              })(e, s);
            (e = a.keyframes),
              (t = a.duration),
              (this.options.times = a.times),
              (this.options.ease = a.ease);
          }
          var n;
          const { motionValue: i, name: r } = this.options,
            s = (function (
              e,
              t,
              n,
              {
                delay: i = 0,
                duration: r = 300,
                repeat: s = 0,
                repeatType: a = "loop",
                ease: o,
                times: c,
              } = {}
            ) {
              const l = { [t]: n };
              c && (l.offset = c);
              const u = BN(o);
              return (
                Array.isArray(u) && (l.easing = u),
                e.animate(l, {
                  delay: i,
                  duration: r,
                  easing: Array.isArray(u) ? "linear" : u,
                  fill: "both",
                  iterations: s + 1,
                  direction: "reverse" === a ? "alternate" : "normal",
                })
              );
            })(i.owner.current, r, e, { ...this.options, duration: t });
          return (
            (s.startTime = nF.now()),
            this.pendingTimeline
              ? ((s.timeline = this.pendingTimeline),
                (this.pendingTimeline = void 0))
              : (s.onfinish = () => {
                  const { onComplete: t } = this.options;
                  i.set($U(e, this.options)),
                    t && t(),
                    this.cancel(),
                    this.resolveFinishedPromise(),
                    this.updateFinishedPromise();
                }),
            { animation: s, duration: t, keyframes: e }
          );
        }
        get duration() {
          const { duration: e } = this.resolved;
          return jU(e);
        }
        get time() {
          const { animation: e } = this.resolved;
          return jU(e.currentTime || 0);
        }
        set time(e) {
          const { animation: t } = this.resolved;
          t.currentTime = VU(e);
        }
        get speed() {
          const { animation: e } = this.resolved;
          return e.playbackRate;
        }
        set speed(e) {
          const { animation: t } = this.resolved;
          t.playbackRate = e;
        }
        get state() {
          const { animation: e } = this.resolved;
          return e.playState;
        }
        attachTimeline(e) {
          if (this._resolved) {
            const { animation: t } = this.resolved;
            (t.timeline = e), (t.onfinish = null);
          } else this.pendingTimeline = e;
          return EU;
        }
        play() {
          if (this.isStopped) return;
          const { animation: e } = this.resolved;
          e.play();
        }
        pause() {
          const { animation: e } = this.resolved;
          e.pause();
        }
        stop() {
          this.isStopped = !0;
          const { animation: e, keyframes: t } = this.resolved;
          if ("idle" !== e.playState && "finished" !== e.playState) {
            if (this.time) {
              const {
                  motionValue: e,
                  onUpdate: n,
                  onComplete: i,
                  ...r
                } = this.options,
                s = new CN({ ...r, keyframes: t });
              e.setWithVelocity(
                s.sample(this.time - 10).value,
                s.sample(this.time).value,
                10
              );
            }
            this.cancel();
          }
        }
        complete() {
          this.resolved.animation.finish();
        }
        cancel() {
          this.resolved.animation.cancel();
        }
        static supports(e) {
          const {
            motionValue: t,
            name: n,
            repeatDelay: i,
            repeatType: r,
            damping: s,
            type: a,
          } = e;
          return (
            RN() &&
            n &&
            DN.has(n) &&
            t &&
            t.owner &&
            t.owner.current instanceof HTMLElement &&
            !t.owner.getProps().onUpdate &&
            !i &&
            "mirror" !== r &&
            0 !== s &&
            "inertia" !== a
          );
        }
      }
      const LN =
          (e, t, n, i = {}, r, s) =>
          (a) => {
            const o = KU(i, e) || {},
              c = o.delay || i.delay || 0;
            let { elapsed: l = 0 } = i;
            l -= VU(c);
            let u = {
              keyframes: Array.isArray(n) ? n : [null, n],
              ease: "easeOut",
              velocity: t.getVelocity(),
              ...o,
              delay: -l,
              onUpdate: (e) => {
                t.set(e), o.onUpdate && o.onUpdate(e);
              },
              onComplete: () => {
                a(), o.onComplete && o.onComplete();
              },
              name: e,
              motionValue: t,
              element: s ? void 0 : r,
            };
            (function ({
              when: e,
              delay: t,
              delayChildren: n,
              staggerChildren: i,
              staggerDirection: r,
              repeat: s,
              repeatType: a,
              repeatDelay: o,
              from: c,
              elapsed: l,
              ...u
            }) {
              return !!Object.keys(u).length;
            })(o) || (u = { ...u, ...YU(e, u) }),
              u.duration && (u.duration = VU(u.duration)),
              u.repeatDelay && (u.repeatDelay = VU(u.repeatDelay)),
              void 0 !== u.from && (u.keyframes[0] = u.from);
            let h = !1;
            if (
              (!1 === u.type && ((u.duration = 0), 0 === u.delay && (h = !0)),
              (JU || MU) && ((h = !0), (u.duration = 0), (u.delay = 0)),
              h && !s && void 0 !== t.get())
            ) {
              const e = $U(u.keyframes, o);
              if (void 0 !== e)
                return void DU.update(() => {
                  u.onUpdate(e), u.onComplete();
                });
            }
            return !s && PN.supports(u) ? new PN(u) : new CN(u);
          },
        UN = (e) => Boolean(e && e.getVelocity);
      function FN(e) {
        return Boolean(UN(e) && e.add);
      }
      const ON = (e) =>
        ((e) => Array.isArray(e))(e) ? e[e.length - 1] || 0 : e;
      function NN(e, t) {
        const n = e.indexOf(t);
        n > -1 && e.splice(n, 1);
      }
      class kN {
        constructor() {
          this.subscriptions = [];
        }
        add(e) {
          var t, n;
          return (
            (t = this.subscriptions),
            (n = e),
            -1 === t.indexOf(n) && t.push(n),
            () => NN(this.subscriptions, e)
          );
        }
        notify(e, t, n) {
          const i = this.subscriptions.length;
          if (i)
            if (1 === i) this.subscriptions[0](e, t, n);
            else
              for (let r = 0; r < i; r++) {
                const i = this.subscriptions[r];
                i && i(e, t, n);
              }
        }
        getSize() {
          return this.subscriptions.length;
        }
        clear() {
          this.subscriptions.length = 0;
        }
      }
      const QN = { current: void 0 };
      class GN {
        constructor(e, t = {}) {
          var n;
          (this.version = "11.0.12"),
            (this.canTrackVelocity = !1),
            (this.events = {}),
            (this.updateAndNotify = (e, t = !0) => {
              const n = nF.now();
              this.updatedAt !== n && this.setPrevFrameValue(),
                (this.prev = this.current),
                this.setCurrent(e),
                this.current !== this.prev &&
                  this.events.change &&
                  this.events.change.notify(this.current),
                t &&
                  this.events.renderRequest &&
                  this.events.renderRequest.notify(this.current);
            }),
            (this.hasAnimated = !1),
            this.setCurrent(e),
            (this.canTrackVelocity =
              ((n = this.current), !isNaN(parseFloat(n)))),
            (this.owner = t.owner);
        }
        setCurrent(e) {
          (this.current = e), (this.updatedAt = nF.now());
        }
        setPrevFrameValue(e = this.current) {
          (this.prevFrameValue = e), (this.prevUpdatedAt = this.updatedAt);
        }
        onChange(e) {
          return this.on("change", e);
        }
        on(e, t) {
          this.events[e] || (this.events[e] = new kN());
          const n = this.events[e].add(t);
          return "change" === e
            ? () => {
                n(),
                  DU.read(() => {
                    this.events.change.getSize() || this.stop();
                  });
              }
            : n;
        }
        clearListeners() {
          for (const e in this.events) this.events[e].clear();
        }
        attach(e, t) {
          (this.passiveEffect = e), (this.stopPassiveEffect = t);
        }
        set(e, t = !0) {
          t && this.passiveEffect
            ? this.passiveEffect(e, this.updateAndNotify)
            : this.updateAndNotify(e, t);
        }
        setWithVelocity(e, t, n) {
          this.set(t),
            (this.prev = void 0),
            (this.prevFrameValue = e),
            (this.prevUpdatedAt = this.updatedAt - n);
        }
        jump(e, t = !0) {
          this.updateAndNotify(e),
            (this.prev = e),
            (this.prevUpdatedAt = this.prevFrameValue = void 0),
            t && this.stop(),
            this.stopPassiveEffect && this.stopPassiveEffect();
        }
        get() {
          return QN.current && QN.current.push(this), this.current;
        }
        getPrevious() {
          return this.prev;
        }
        getVelocity() {
          const e = nF.now();
          if (
            !this.canTrackVelocity ||
            void 0 === this.prevFrameValue ||
            e - this.updatedAt > 30
          )
            return 0;
          const t = Math.min(this.updatedAt - this.prevUpdatedAt, 30);
          return bO(
            parseFloat(this.current) - parseFloat(this.prevFrameValue),
            t
          );
        }
        start(e) {
          return (
            this.stop(),
            new Promise((t) => {
              (this.hasAnimated = !0),
                (this.animation = e(t)),
                this.events.animationStart &&
                  this.events.animationStart.notify();
            }).then(() => {
              this.events.animationComplete &&
                this.events.animationComplete.notify(),
                this.clearAnimation();
            })
          );
        }
        stop() {
          this.animation &&
            (this.animation.stop(),
            this.events.animationCancel &&
              this.events.animationCancel.notify()),
            this.clearAnimation();
        }
        isAnimating() {
          return !!this.animation;
        }
        clearAnimation() {
          delete this.animation;
        }
        destroy() {
          this.clearListeners(),
            this.stop(),
            this.stopPassiveEffect && this.stopPassiveEffect();
        }
      }
      function HN(e, t) {
        return new GN(e, t);
      }
      function zN(e, t, n, i = {}, r = {}) {
        return (
          "function" == typeof t && (t = t(void 0 !== n ? n : e.custom, i, r)),
          "string" == typeof t && (t = e.variants && e.variants[t]),
          "function" == typeof t && (t = t(void 0 !== n ? n : e.custom, i, r)),
          t
        );
      }
      function VN(e, t, n) {
        e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, HN(n));
      }
      function jN(e, t) {
        const n = (function (e, t, n) {
          const i = e.getProps();
          return zN(
            i,
            t,
            void 0 !== n ? n : i.custom,
            (function (e) {
              const t = {};
              return e.values.forEach((e, n) => (t[n] = e.get())), t;
            })(e),
            (function (e) {
              const t = {};
              return e.values.forEach((e, n) => (t[n] = e.getVelocity())), t;
            })(e)
          );
        })(e, t);
        let { transitionEnd: i = {}, transition: r = {}, ...s } = n || {};
        s = { ...s, ...i };
        for (const t in s) {
          VN(e, t, ON(s[t]));
        }
      }
      function WN({ protectedKeys: e, needsAnimating: t }, n) {
        const i = e.hasOwnProperty(n) && !0 !== t[n];
        return (t[n] = !1), i;
      }
      function XN(e, t, { delay: n = 0, transitionOverride: i, type: r } = {}) {
        var s;
        let {
          transition: a = e.getDefaultTransition(),
          transitionEnd: o,
          ...c
        } = t;
        const l = e.getValue("willChange");
        i && (a = i);
        const u = [],
          h = r && e.animationState && e.animationState.getState()[r];
        for (const t in c) {
          const i = e.getValue(
              t,
              null !== (s = e.latestValues[t]) && void 0 !== s ? s : null
            ),
            r = c[t];
          if (void 0 === r || (h && WN(h, t))) continue;
          const o = { delay: n, elapsed: 0, ...KU(a || {}, t) };
          let d = !1;
          if (window.HandoffAppearAnimations) {
            const n = e.getProps()[zU];
            if (n) {
              const e = window.HandoffAppearAnimations(n, t);
              null !== e && ((o.elapsed = e), (d = !0));
            }
          }
          i.start(
            LN(
              t,
              i,
              r,
              e.shouldReduceMotion && GU.has(t) ? { type: !1 } : o,
              e,
              d
            )
          );
          const p = i.animation;
          p && (FN(l) && (l.add(t), p.then(() => l.remove(t))), u.push(p));
        }
        return (
          o &&
            Promise.all(u).then(() => {
              DU.update(() => {
                o && jN(e, o);
              });
            }),
          u
        );
      }
      const qN = {};
      function YN(e, { layout: t, layoutId: n }) {
        return (
          GU.has(e) ||
          e.startsWith("origin") ||
          ((t || void 0 !== n) && (!!qN[e] || "opacity" === e))
        );
      }
      function KN(e, t) {
        const { style: n } = e,
          i = {};
        for (const r in n)
          (UN(n[r]) || (t.style && UN(t.style[r])) || YN(r, e)) &&
            (i[r] = n[r]);
        return i;
      }
      function JN(e) {
        return (
          e &&
          "object" == typeof e &&
          Object.prototype.hasOwnProperty.call(e, "current")
        );
      }
      const ZN = "undefined" != typeof document,
        $N = { current: null },
        ek = { current: !1 };
      function tk(e) {
        return "string" == typeof e || Array.isArray(e);
      }
      const nk = [
        "initial",
        "animate",
        "whileInView",
        "whileFocus",
        "whileHover",
        "whileTap",
        "whileDrag",
        "exit",
      ];
      function ik(e) {
        return (
          (function (e) {
            return (
              null !== e && "object" == typeof e && "function" == typeof e.start
            );
          })(e.animate) || nk.some((t) => tk(e[t]))
        );
      }
      const rk = {
          animation: [
            "animate",
            "variants",
            "whileHover",
            "whileTap",
            "exit",
            "whileInView",
            "whileFocus",
            "whileDrag",
          ],
          exit: ["exit"],
          drag: ["drag", "dragControls"],
          focus: ["whileFocus"],
          hover: ["whileHover", "onHoverStart", "onHoverEnd"],
          tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
          pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
          inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
          layout: ["layout", "layoutId"],
        },
        sk = {};
      for (const e in rk)
        sk[e] = { isEnabled: (t) => rk[e].some((e) => !!t[e]) };
      const ak = [...FF, KF, oO],
        ok = Object.keys(sk),
        ck = ok.length,
        lk = [
          "AnimationStart",
          "AnimationComplete",
          "Update",
          "BeforeLayoutMeasure",
          "LayoutMeasure",
          "LayoutAnimationStart",
          "LayoutAnimationComplete",
        ],
        uk = nk.length;
      class hk {
        constructor(
          {
            parent: e,
            props: t,
            presenceContext: n,
            reducedMotionConfig: i,
            blockInitialAnimation: r,
            visualState: s,
          },
          a = {}
        ) {
          (this.resolveKeyframes = (e, t, n, i) =>
            new this.KeyframeResolver(e, t, n, i, this)),
            (this.current = null),
            (this.children = new Set()),
            (this.isVariantNode = !1),
            (this.isControllingVariants = !1),
            (this.shouldReduceMotion = null),
            (this.values = new Map()),
            (this.KeyframeResolver = zF),
            (this.features = {}),
            (this.valueSubscriptions = new Map()),
            (this.prevMotionValues = {}),
            (this.events = {}),
            (this.propEventSubscriptions = {}),
            (this.notifyUpdate = () =>
              this.notify("Update", this.latestValues)),
            (this.render = () => {
              this.current &&
                (this.triggerBuild(),
                this.renderInstance(
                  this.current,
                  this.renderState,
                  this.props.style,
                  this.projection
                ));
            }),
            (this.scheduleRender = () => DU.render(this.render, !1, !0));
          const { latestValues: o, renderState: c } = s;
          (this.latestValues = o),
            (this.baseTarget = { ...o }),
            (this.initialValues = t.initial ? { ...o } : {}),
            (this.renderState = c),
            (this.parent = e),
            (this.props = t),
            (this.presenceContext = n),
            (this.depth = e ? e.depth + 1 : 0),
            (this.reducedMotionConfig = i),
            (this.options = a),
            (this.blockInitialAnimation = Boolean(r)),
            (this.isControllingVariants = ik(t)),
            (this.isVariantNode = (function (e) {
              return Boolean(ik(e) || e.variants);
            })(t)),
            this.isVariantNode && (this.variantChildren = new Set()),
            (this.manuallyAnimateOnMount = Boolean(e && e.current));
          const { willChange: l, ...u } = this.scrapeMotionValuesFromProps(
            t,
            {}
          );
          for (const e in u) {
            const t = u[e];
            void 0 !== o[e] && UN(t) && (t.set(o[e], !1), FN(l) && l.add(e));
          }
        }
        scrapeMotionValuesFromProps(e, t) {
          return {};
        }
        mount(e) {
          (this.current = e),
            IU.set(e, this),
            this.projection &&
              !this.projection.instance &&
              this.projection.mount(e),
            this.parent &&
              this.isVariantNode &&
              !this.isControllingVariants &&
              (this.removeFromVariantTree = this.parent.addVariantChild(this)),
            this.values.forEach((e, t) => this.bindToMotionValue(t, e)),
            ek.current ||
              (function () {
                if (((ek.current = !0), ZN))
                  if (window.matchMedia) {
                    const e = window.matchMedia("(prefers-reduced-motion)"),
                      t = () => ($N.current = e.matches);
                    e.addListener(t), t();
                  } else $N.current = !1;
              })(),
            (this.shouldReduceMotion =
              "never" !== this.reducedMotionConfig &&
              ("always" === this.reducedMotionConfig || $N.current)),
            this.parent && this.parent.children.add(this),
            this.update(this.props, this.presenceContext);
        }
        unmount() {
          IU.delete(this.current),
            this.projection && this.projection.unmount(),
            PU(this.notifyUpdate),
            PU(this.render),
            this.valueSubscriptions.forEach((e) => e()),
            this.removeFromVariantTree && this.removeFromVariantTree(),
            this.parent && this.parent.children.delete(this);
          for (const e in this.events) this.events[e].clear();
          for (const e in this.features) this.features[e].unmount();
          this.current = null;
        }
        bindToMotionValue(e, t) {
          const n = GU.has(e),
            i = t.on("change", (t) => {
              (this.latestValues[e] = t),
                this.props.onUpdate && DU.preRender(this.notifyUpdate),
                n && this.projection && (this.projection.isTransformDirty = !0);
            }),
            r = t.on("renderRequest", this.scheduleRender);
          this.valueSubscriptions.set(e, () => {
            i(), r();
          });
        }
        sortNodePosition(e) {
          return this.current &&
            this.sortInstanceNodePosition &&
            this.type === e.type
            ? this.sortInstanceNodePosition(this.current, e.current)
            : 0;
        }
        loadFeatures({ children: e, ...t }, n, i, r) {
          let s, a;
          for (let e = 0; e < ck; e++) {
            const n = ok[e],
              {
                isEnabled: i,
                Feature: r,
                ProjectionNode: o,
                MeasureLayout: c,
              } = sk[n];
            o && (s = o),
              i(t) &&
                (!this.features[n] && r && (this.features[n] = new r(this)),
                c && (a = c));
          }
          if (
            ("html" === this.type || "svg" === this.type) &&
            !this.projection &&
            s
          ) {
            this.projection = new s(
              this.latestValues,
              this.parent && this.parent.projection
            );
            const {
              layoutId: e,
              layout: n,
              drag: i,
              dragConstraints: a,
              layoutScroll: o,
              layoutRoot: c,
            } = t;
            this.projection.setOptions({
              layoutId: e,
              layout: n,
              alwaysMeasureLayout: Boolean(i) || (a && JN(a)),
              visualElement: this,
              scheduleRender: () => this.scheduleRender(),
              animationType: "string" == typeof n ? n : "both",
              initialPromotionConfig: r,
              layoutScroll: o,
              layoutRoot: c,
            });
          }
          return a;
        }
        updateFeatures() {
          for (const e in this.features) {
            const t = this.features[e];
            t.isMounted ? t.update() : (t.mount(), (t.isMounted = !0));
          }
        }
        triggerBuild() {
          this.build(
            this.renderState,
            this.latestValues,
            this.options,
            this.props
          );
        }
        measureViewportBox() {
          return this.current
            ? this.measureInstanceViewportBox(this.current, this.props)
            : { x: { min: 0, max: 0 }, y: { min: 0, max: 0 } };
        }
        getStaticValue(e) {
          return this.latestValues[e];
        }
        setStaticValue(e, t) {
          this.latestValues[e] = t;
        }
        update(e, t) {
          (e.transformTemplate || this.props.transformTemplate) &&
            this.scheduleRender(),
            (this.prevProps = this.props),
            (this.props = e),
            (this.prevPresenceContext = this.presenceContext),
            (this.presenceContext = t);
          for (let t = 0; t < lk.length; t++) {
            const n = lk[t];
            this.propEventSubscriptions[n] &&
              (this.propEventSubscriptions[n](),
              delete this.propEventSubscriptions[n]);
            const i = e["on" + n];
            i && (this.propEventSubscriptions[n] = this.on(n, i));
          }
          (this.prevMotionValues = (function (e, t, n) {
            const { willChange: i } = t;
            for (const r in t) {
              const s = t[r],
                a = n[r];
              if (UN(s)) e.addValue(r, s), FN(i) && i.add(r);
              else if (UN(a))
                e.addValue(r, HN(s, { owner: e })), FN(i) && i.remove(r);
              else if (a !== s)
                if (e.hasValue(r)) {
                  const t = e.getValue(r);
                  !t.hasAnimated && t.set(s);
                } else {
                  const t = e.getStaticValue(r);
                  e.addValue(r, HN(void 0 !== t ? t : s, { owner: e }));
                }
            }
            for (const i in n) void 0 === t[i] && e.removeValue(i);
            return t;
          })(
            this,
            this.scrapeMotionValuesFromProps(e, this.prevProps),
            this.prevMotionValues
          )),
            this.handleChildMotionValue && this.handleChildMotionValue();
        }
        getProps() {
          return this.props;
        }
        getVariant(e) {
          return this.props.variants ? this.props.variants[e] : void 0;
        }
        getDefaultTransition() {
          return this.props.transition;
        }
        getTransformPagePoint() {
          return this.props.transformPagePoint;
        }
        getClosestVariantNode() {
          return this.isVariantNode
            ? this
            : this.parent
            ? this.parent.getClosestVariantNode()
            : void 0;
        }
        getVariantContext(e = !1) {
          if (e) return this.parent ? this.parent.getVariantContext() : void 0;
          if (!this.isControllingVariants) {
            const e = (this.parent && this.parent.getVariantContext()) || {};
            return (
              void 0 !== this.props.initial && (e.initial = this.props.initial),
              e
            );
          }
          const t = {};
          for (let e = 0; e < uk; e++) {
            const n = nk[e],
              i = this.props[n];
            (tk(i) || !1 === i) && (t[n] = i);
          }
          return t;
        }
        addVariantChild(e) {
          const t = this.getClosestVariantNode();
          if (t)
            return (
              t.variantChildren && t.variantChildren.add(e),
              () => t.variantChildren.delete(e)
            );
        }
        addValue(e, t) {
          t !== this.values.get(e) &&
            (this.removeValue(e), this.bindToMotionValue(e, t)),
            this.values.set(e, t),
            (this.latestValues[e] = t.get());
        }
        removeValue(e) {
          this.values.delete(e);
          const t = this.valueSubscriptions.get(e);
          t && (t(), this.valueSubscriptions.delete(e)),
            delete this.latestValues[e],
            this.removeValueFromRenderState(e, this.renderState);
        }
        hasValue(e) {
          return this.values.has(e);
        }
        getValue(e, t) {
          if (this.props.values && this.props.values[e])
            return this.props.values[e];
          let n = this.values.get(e);
          return (
            void 0 === n &&
              void 0 !== t &&
              ((n = HN(null === t ? void 0 : t, { owner: this })),
              this.addValue(e, n)),
            n
          );
        }
        readValue(e, t) {
          var n;
          let i =
            void 0 === this.latestValues[e] && this.current
              ? null !== (n = this.getBaseTargetFromProps(this.props, e)) &&
                void 0 !== n
                ? n
                : this.readValueFromInstance(this.current, e, this.options)
              : this.latestValues[e];
          return (
            null != i &&
              ("string" == typeof i && (rF(i) || iF(i))
                ? (i = parseFloat(i))
                : !((e) => ak.find(UF(e)))(i) && oO.test(t) && (i = gO(e, t)),
              this.setBaseTarget(e, UN(i) ? i.get() : i)),
            UN(i) ? i.get() : i
          );
        }
        setBaseTarget(e, t) {
          this.baseTarget[e] = t;
        }
        getBaseTarget(e) {
          var t, n;
          const { initial: i } = this.props,
            r =
              "string" == typeof i || "object" == typeof i
                ? null ===
                    (n = zN(
                      this.props,
                      i,
                      null === (t = this.presenceContext) || void 0 === t
                        ? void 0
                        : t.custom
                    )) || void 0 === n
                  ? void 0
                  : n[e]
                : void 0;
          if (i && void 0 !== r) return r;
          const s = this.getBaseTargetFromProps(this.props, e);
          return void 0 === s || UN(s)
            ? void 0 !== this.initialValues[e] && void 0 === r
              ? void 0
              : this.baseTarget[e]
            : s;
        }
        on(e, t) {
          return (
            this.events[e] || (this.events[e] = new kN()), this.events[e].add(t)
          );
        }
        notify(e, ...t) {
          this.events[e] && this.events[e].notify(...t);
        }
      }
      class dk extends hk {
        constructor() {
          super(...arguments), (this.KeyframeResolver = mO);
        }
        sortInstanceNodePosition(e, t) {
          return 2 & e.compareDocumentPosition(t) ? 1 : -1;
        }
        getBaseTargetFromProps(e, t) {
          return e.style ? e.style[t] : void 0;
        }
        removeValueFromRenderState(e, { vars: t, style: n }) {
          delete t[e], delete n[e];
        }
      }
      const pk = {
          x: "translateX",
          y: "translateY",
          z: "translateZ",
          transformPerspective: "perspective",
        },
        fk = QU.length;
      const Ak = (e, t) => (t && "number" == typeof e ? t.transform(e) : e);
      function gk(e, t, n, i) {
        const { style: r, vars: s, transform: a, transformOrigin: o } = e;
        let c = !1,
          l = !1,
          u = !0;
        for (const e in t) {
          const n = t[e];
          if (aF(e)) {
            s[e] = n;
            continue;
          }
          const i = pO[e],
            h = Ak(n, i);
          if (GU.has(e)) {
            if (((c = !0), (a[e] = h), !u)) continue;
            n !== (i.default || 0) && (u = !1);
          } else e.startsWith("origin") ? ((l = !0), (o[e] = h)) : (r[e] = h);
        }
        if (
          (t.transform ||
            (c || i
              ? (r.transform = (function (
                  e,
                  {
                    enableHardwareAcceleration: t = !0,
                    allowTransformNone: n = !0,
                  },
                  i,
                  r
                ) {
                  let s = "";
                  for (let t = 0; t < fk; t++) {
                    const n = QU[t];
                    void 0 !== e[n] && (s += `${pk[n] || n}(${e[n]}) `);
                  }
                  return (
                    t && !e.z && (s += "translateZ(0)"),
                    (s = s.trim()),
                    r ? (s = r(e, i ? "" : s)) : n && i && (s = "none"),
                    s
                  );
                })(e.transform, n, u, i))
              : r.transform && (r.transform = "none")),
          l)
        ) {
          const { originX: e = "50%", originY: t = "50%", originZ: n = 0 } = o;
          r.transformOrigin = `${e} ${t} ${n}`;
        }
      }
      function mk(e, t, n) {
        return "string" == typeof e ? e : wF.transform(t + n * e);
      }
      const vk = { offset: "stroke-dashoffset", array: "stroke-dasharray" },
        yk = { offset: "strokeDashoffset", array: "strokeDasharray" };
      function bk(
        e,
        {
          attrX: t,
          attrY: n,
          attrScale: i,
          originX: r,
          originY: s,
          pathLength: a,
          pathSpacing: o = 1,
          pathOffset: c = 0,
          ...l
        },
        u,
        h,
        d
      ) {
        if ((gk(e, l, u, d), h))
          return void (e.style.viewBox && (e.attrs.viewBox = e.style.viewBox));
        (e.attrs = e.style), (e.style = {});
        const { attrs: p, style: f, dimensions: A } = e;
        p.transform && (A && (f.transform = p.transform), delete p.transform),
          A &&
            (void 0 !== r || void 0 !== s || f.transform) &&
            (f.transformOrigin = (function (e, t, n) {
              return `${mk(t, e.x, e.width)} ${mk(n, e.y, e.height)}`;
            })(A, void 0 !== r ? r : 0.5, void 0 !== s ? s : 0.5)),
          void 0 !== t && (p.x = t),
          void 0 !== n && (p.y = n),
          void 0 !== i && (p.scale = i),
          void 0 !== a &&
            (function (e, t, n = 1, i = 0, r = !0) {
              e.pathLength = 1;
              const s = r ? vk : yk;
              e[s.offset] = wF.transform(-i);
              const a = wF.transform(t),
                o = wF.transform(n);
              e[s.array] = `${a} ${o}`;
            })(p, a, o, c, !1);
      }
      const _k = new Set([
        "baseFrequency",
        "diffuseConstant",
        "kernelMatrix",
        "kernelUnitLength",
        "keySplines",
        "keyTimes",
        "limitingConeAngle",
        "markerHeight",
        "markerWidth",
        "numOctaves",
        "targetX",
        "targetY",
        "surfaceScale",
        "specularConstant",
        "specularExponent",
        "stdDeviation",
        "tableValues",
        "viewBox",
        "gradientTransform",
        "pathLength",
        "startOffset",
        "textLength",
        "lengthAdjust",
      ]);
      function xk(e, { style: t, vars: n }, i, r) {
        Object.assign(e.style, t, r && r.getProjectionStyles(i));
        for (const t in n) e.style.setProperty(t, n[t]);
      }
      class Ek extends dk {
        constructor() {
          super(...arguments), (this.type = "svg"), (this.isSVGTag = !1);
        }
        getBaseTargetFromProps(e, t) {
          return e[t];
        }
        readValueFromInstance(e, t) {
          if (GU.has(t)) {
            const e = AO(t);
            return (e && e.default) || 0;
          }
          return (t = _k.has(t) ? t : HU(t)), e.getAttribute(t);
        }
        measureInstanceViewportBox() {
          return { x: { min: 0, max: 0 }, y: { min: 0, max: 0 } };
        }
        scrapeMotionValuesFromProps(e, t) {
          return (function (e, t) {
            const n = KN(e, t);
            for (const i in e)
              (UN(e[i]) || UN(t[i])) &&
                (n[
                  -1 !== QU.indexOf(i)
                    ? "attr" + i.charAt(0).toUpperCase() + i.substring(1)
                    : i
                ] = e[i]);
            return n;
          })(e, t);
        }
        build(e, t, n, i) {
          bk(e, t, n, this.isSVGTag, i.transformTemplate);
        }
        renderInstance(e, t, n, i) {
          !(function (e, t, n, i) {
            xk(e, t, void 0, i);
            for (const n in t.attrs)
              e.setAttribute(_k.has(n) ? n : HU(n), t.attrs[n]);
          })(e, t, 0, i);
        }
        mount(e) {
          var t;
          (this.isSVGTag =
            "string" == typeof (t = e.tagName) && "svg" === t.toLowerCase()),
            super.mount(e);
        }
      }
      function wk(e, t) {
        return (function ({ top: e, left: t, right: n, bottom: i }) {
          return { x: { min: t, max: n }, y: { min: e, max: i } };
        })(
          (function (e, t) {
            if (!t) return e;
            const n = t({ x: e.left, y: e.top }),
              i = t({ x: e.right, y: e.bottom });
            return { top: n.y, left: n.x, bottom: i.y, right: i.x };
          })(e.getBoundingClientRect(), t)
        );
      }
      class Ck extends dk {
        constructor() {
          super(...arguments), (this.type = "html");
        }
        readValueFromInstance(e, t) {
          if (GU.has(t)) {
            const e = AO(t);
            return (e && e.default) || 0;
          }
          {
            const i = ((n = e), window.getComputedStyle(n)),
              r = (aF(t) ? i.getPropertyValue(t) : i[t]) || 0;
            return "string" == typeof r ? r.trim() : r;
          }
          var n;
        }
        measureInstanceViewportBox(e, { transformPagePoint: t }) {
          return wk(e, t);
        }
        build(e, t, n, i) {
          gk(e, t, n, i.transformTemplate);
        }
        scrapeMotionValuesFromProps(e, t) {
          return KN(e, t);
        }
        handleChildMotionValue() {
          this.childSubscription &&
            (this.childSubscription(), delete this.childSubscription);
          const { children: e } = this.props;
          UN(e) &&
            (this.childSubscription = e.on("change", (e) => {
              this.current && (this.current.textContent = `${e}`);
            }));
        }
        renderInstance(e, t, n, i) {
          xk(e, t, n, i);
        }
      }
      function Sk(e) {
        const t = {
            presenceContext: null,
            props: {},
            visualState: {
              renderState: {
                transform: {},
                transformOrigin: {},
                style: {},
                vars: {},
                attrs: {},
              },
              latestValues: {},
            },
          },
          n = (function (e) {
            return e instanceof SVGElement && "svg" !== e.tagName;
          })(e)
            ? new Ek(t, { enableHardwareAcceleration: !1 })
            : new Ck(t, { enableHardwareAcceleration: !0 });
        n.mount(e), IU.set(e, n);
      }
      function Ik(e, t, n) {
        const i = UN(e) ? e : HN(e);
        return i.start(LN("", i, t, n)), i.animation;
      }
      function Mk(e, t = 100) {
        const n = LO({ keyframes: [0, t], ...e }),
          i = Math.min(_N(n), bN);
        return {
          type: "keyframes",
          ease: (e) => n.next(i * e).value / t,
          duration: jU(i),
        };
      }
      function Tk(e, t, n, i) {
        var r;
        return "number" == typeof t
          ? t
          : t.startsWith("-") || t.startsWith("+")
          ? Math.max(0, e + parseFloat(t))
          : "<" === t
          ? n
          : null !== (r = i.get(t)) && void 0 !== r
          ? r
          : e;
      }
      const Bk = (e, t, n) => {
        const i = t - e;
        return ((((n - e) % i) + i) % i) + e;
      };
      function Rk(e, t) {
        return zO(e) ? e[Bk(0, e.length, t)] : e;
      }
      function Dk(e, t, n, i, r, s) {
        !(function (e, t, n) {
          for (let i = 0; i < e.length; i++) {
            const r = e[i];
            r.at > t && r.at < n && (NN(e, r), i--);
          }
        })(e, r, s);
        for (let a = 0; a < t.length; a++)
          e.push({ value: t[a], at: iN(r, s, i[a]), easing: Rk(n, a) });
      }
      function Pk(e, t) {
        return e.at === t.at
          ? null === e.value
            ? 1
            : null === t.value
            ? -1
            : 0
          : e.at - t.at;
      }
      const Lk = "easeInOut";
      function Uk(e, t) {
        return !t.has(e) && t.set(e, {}), t.get(e);
      }
      function Fk(e, t) {
        return t[e] || (t[e] = []), t[e];
      }
      function Ok(e) {
        return Array.isArray(e) ? e : [e];
      }
      function Nk(e, t) {
        return e[t] ? { ...e, ...e[t] } : { ...e };
      }
      const kk = (e) => "number" == typeof e,
        Qk = (e) => e.every(kk);
      function Gk(e, t, n, i) {
        const r = SU(e, i),
          s = r.length;
        CU(Boolean(s), "No valid element provided.");
        const a = [];
        for (let e = 0; e < s; e++) {
          const i = r[e];
          IU.has(i) || Sk(i);
          const o = IU.get(i),
            c = { ...n };
          "function" == typeof c.delay && (c.delay = c.delay(e, s)),
            a.push(...XN(o, { ...t, transition: c }, {}));
        }
        return new kU(a);
      }
      function Hk(e, t, n) {
        const i = [],
          r = (function (e, { defaultTransition: t = {}, ...n } = {}, i) {
            const r = t.duration || 0.3,
              s = new Map(),
              a = new Map(),
              o = {},
              c = new Map();
            let l = 0,
              u = 0,
              h = 0;
            for (let n = 0; n < e.length; n++) {
              const s = e[n];
              if ("string" == typeof s) {
                c.set(s, u);
                continue;
              }
              if (!Array.isArray(s)) {
                c.set(s.name, Tk(u, s.at, l, c));
                continue;
              }
              let [d, p, f = {}] = s;
              void 0 !== f.at && (u = Tk(u, f.at, l, c));
              let A = 0;
              const g = (e, n, i, s = 0, a = 0) => {
                const o = Ok(e),
                  {
                    delay: c = 0,
                    times: l = vN(o),
                    type: d = "keyframes",
                    ...p
                  } = n;
                let { ease: f = t.ease || "easeOut", duration: g } = n;
                const m = "function" == typeof c ? c(s, a) : c,
                  v = o.length;
                if (v <= 2 && "spring" === d) {
                  let e = 100;
                  if (2 === v && Qk(o)) {
                    const t = o[1] - o[0];
                    e = Math.abs(t);
                  }
                  const t = { ...p };
                  void 0 !== g && (t.duration = VU(g));
                  const n = Mk(t, e);
                  (f = n.ease), (g = n.duration);
                }
                null != g || (g = r);
                const y = u + m,
                  b = y + g;
                1 === l.length && 0 === l[0] && (l[1] = 1);
                const _ = l.length - o.length;
                _ > 0 && mN(l, _),
                  1 === o.length && o.unshift(null),
                  Dk(i, o, f, l, y, b),
                  (A = Math.max(m + g, A)),
                  (h = Math.max(b, h));
              };
              if (UN(d)) g(p, f, Fk("default", Uk(d, a)));
              else {
                const e = SU(d, i, o),
                  t = e.length;
                for (let n = 0; n < t; n++) {
                  const i = Uk(e[n], a);
                  for (const e in p) g(p[e], Nk(f, e), Fk(e, i), n, t);
                }
              }
              (l = u), (u += A);
            }
            return (
              a.forEach((e, i) => {
                for (const r in e) {
                  const a = e[r];
                  a.sort(Pk);
                  const o = [],
                    c = [],
                    l = [];
                  for (let e = 0; e < a.length; e++) {
                    const { at: t, value: n, easing: i } = a[e];
                    o.push(n), c.push(nN(0, h, t)), l.push(i || "easeOut");
                  }
                  0 !== c[0] && (c.unshift(0), o.unshift(o[0]), l.unshift(Lk)),
                    1 !== c[c.length - 1] && (c.push(1), o.push(null)),
                    s.has(i) || s.set(i, { keyframes: {}, transition: {} });
                  const u = s.get(i);
                  (u.keyframes[r] = o),
                    (u.transition[r] = {
                      ...t,
                      duration: h,
                      ease: l,
                      times: c,
                      ...n,
                    });
                }
              }),
              s
            );
          })(e, t, n);
        return (
          r.forEach(({ keyframes: e, transition: t }, n) => {
            let r;
            (r = UN(n) ? Ik(n, e.default, t.default) : Gk(n, e, t)), i.push(r);
          }),
          new kU(i)
        );
      }
      const zk = ((e) =>
          function (t, n, i) {
            let r;
            var s;
            return (
              (s = t),
              (r =
                Array.isArray(s) && Array.isArray(s[0])
                  ? Hk(t, n, e)
                  : (function (e) {
                      return "object" == typeof e && !Array.isArray(e);
                    })(n)
                  ? Gk(t, n, i, e)
                  : Ik(t, n, i)),
              e && e.animations.push(r),
              r
            );
          })(),
        Vk = { some: 0, all: 1 };
      function jk(e, t, { root: n, margin: i, amount: r = "some" } = {}) {
        const s = SU(e),
          a = new WeakMap(),
          o = new IntersectionObserver(
            (e) => {
              e.forEach((e) => {
                const n = a.get(e.target);
                if (e.isIntersecting !== Boolean(n))
                  if (e.isIntersecting) {
                    const n = t(e);
                    "function" == typeof n
                      ? a.set(e.target, n)
                      : o.unobserve(e.target);
                  } else n && (n(e), a.delete(e.target));
              });
            },
            {
              root: n,
              rootMargin: i,
              threshold: "number" == typeof r ? r : Vk[r],
            }
          );
        return s.forEach((e) => o.observe(e)), () => o.disconnect();
      }
      const Wk = new WeakMap();
      let Xk;
      function qk({ target: e, contentRect: t, borderBoxSize: n }) {
        var i;
        null === (i = Wk.get(e)) ||
          void 0 === i ||
          i.forEach((i) => {
            i({
              target: e,
              contentSize: t,
              get size() {
                return (function (e, t) {
                  if (t) {
                    const { inlineSize: e, blockSize: n } = t[0];
                    return { width: e, height: n };
                  }
                  return e instanceof SVGElement && "getBBox" in e
                    ? e.getBBox()
                    : { width: e.offsetWidth, height: e.offsetHeight };
                })(e, n);
              },
            });
          });
      }
      function Yk(e) {
        e.forEach(qk);
      }
      function Kk(e, t) {
        Xk ||
          ("undefined" != typeof ResizeObserver &&
            (Xk = new ResizeObserver(Yk)));
        const n = SU(e);
        return (
          n.forEach((e) => {
            let n = Wk.get(e);
            n || ((n = new Set()), Wk.set(e, n)),
              n.add(t),
              null == Xk || Xk.observe(e);
          }),
          () => {
            n.forEach((e) => {
              const n = Wk.get(e);
              null == n || n.delete(t),
                (null == n ? void 0 : n.size) || null == Xk || Xk.unobserve(e);
            });
          }
        );
      }
      const Jk = new Set();
      let Zk;
      function $k(e) {
        return (
          Jk.add(e),
          Zk ||
            ((Zk = () => {
              const e = {
                  width: window.innerWidth,
                  height: window.innerHeight,
                },
                t = { target: window, size: e, contentSize: e };
              Jk.forEach((e) => e(t));
            }),
            window.addEventListener("resize", Zk)),
          () => {
            Jk.delete(e), !Jk.size && Zk && (Zk = void 0);
          }
        );
      }
      const eQ = 50,
        tQ = () => ({
          time: 0,
          x: {
            current: 0,
            offset: [],
            progress: 0,
            scrollLength: 0,
            targetOffset: 0,
            targetLength: 0,
            containerLength: 0,
            velocity: 0,
          },
          y: {
            current: 0,
            offset: [],
            progress: 0,
            scrollLength: 0,
            targetOffset: 0,
            targetLength: 0,
            containerLength: 0,
            velocity: 0,
          },
        }),
        nQ = {
          x: { length: "Width", position: "Left" },
          y: { length: "Height", position: "Top" },
        };
      function iQ(e, t, n, i) {
        const r = n[t],
          { length: s, position: a } = nQ[t],
          o = r.current,
          c = n.time;
        (r.current = e["scroll" + a]),
          (r.scrollLength = e["scroll" + s] - e["client" + s]),
          (r.offset.length = 0),
          (r.offset[0] = 0),
          (r.offset[1] = r.scrollLength),
          (r.progress = nN(0, r.scrollLength, r.current));
        const l = i - c;
        r.velocity = l > eQ ? 0 : bO(r.current - o, l);
      }
      const rQ = {
          Enter: [
            [0, 1],
            [1, 1],
          ],
          Exit: [
            [0, 0],
            [1, 0],
          ],
          Any: [
            [1, 0],
            [0, 1],
          ],
          All: [
            [0, 0],
            [1, 1],
          ],
        },
        sQ = { start: 0, center: 0.5, end: 1 };
      function aQ(e, t, n = 0) {
        let i = 0;
        if ((void 0 !== sQ[e] && (e = sQ[e]), "string" == typeof e)) {
          const t = parseFloat(e);
          e.endsWith("px")
            ? (i = t)
            : e.endsWith("%")
            ? (e = t / 100)
            : e.endsWith("vw")
            ? (i = (t / 100) * document.documentElement.clientWidth)
            : e.endsWith("vh")
            ? (i = (t / 100) * document.documentElement.clientHeight)
            : (e = t);
        }
        return "number" == typeof e && (i = t * e), n + i;
      }
      const oQ = [0, 0];
      function cQ(e, t, n, i) {
        let r = Array.isArray(e) ? e : oQ,
          s = 0,
          a = 0;
        return (
          "number" == typeof e
            ? (r = [e, e])
            : "string" == typeof e &&
              (r = (e = e.trim()).includes(" ")
                ? e.split(" ")
                : [e, sQ[e] ? e : "0"]),
          (s = aQ(r[0], n, i)),
          (a = aQ(r[1], t)),
          s - a
        );
      }
      const lQ = { x: 0, y: 0 };
      function uQ(e, t, n) {
        const { offset: i = rQ.All } = n,
          { target: r = e, axis: s = "y" } = n,
          a = "y" === s ? "height" : "width",
          o =
            r !== e
              ? (function (e, t) {
                  const n = { x: 0, y: 0 };
                  let i = e;
                  for (; i && i !== t; )
                    if (i instanceof HTMLElement)
                      (n.x += i.offsetLeft),
                        (n.y += i.offsetTop),
                        (i = i.offsetParent);
                    else if ("svg" === i.tagName) {
                      const e = i.getBoundingClientRect();
                      i = i.parentElement;
                      const t = i.getBoundingClientRect();
                      (n.x += e.left - t.left), (n.y += e.top - t.top);
                    } else {
                      if (!(i instanceof SVGGraphicsElement)) break;
                      {
                        const { x: e, y: t } = i.getBBox();
                        (n.x += e), (n.y += t);
                        let r = null,
                          s = i.parentNode;
                        for (; !r; )
                          "svg" === s.tagName && (r = s), (s = i.parentNode);
                        i = r;
                      }
                    }
                  return n;
                })(r, e)
              : lQ,
          c =
            r === e
              ? { width: e.scrollWidth, height: e.scrollHeight }
              : (function (e) {
                  return "getBBox" in e && "svg" !== e.tagName
                    ? e.getBBox()
                    : { width: e.clientWidth, height: e.clientHeight };
                })(r),
          l = { width: e.clientWidth, height: e.clientHeight };
        t[s].offset.length = 0;
        let u = !t[s].interpolate;
        const h = i.length;
        for (let e = 0; e < h; e++) {
          const n = cQ(i[e], l[a], c[a], o[s]);
          u || n === t[s].interpolatorOffsets[e] || (u = !0),
            (t[s].offset[e] = n);
        }
        u &&
          ((t[s].interpolate = gN(t[s].offset, vN(i))),
          (t[s].interpolatorOffsets = [...t[s].offset])),
          (t[s].progress = t[s].interpolate(t[s].current));
      }
      function hQ(e, t, n, i = {}) {
        return {
          measure: () =>
            (function (e, t = e, n) {
              if (((n.x.targetOffset = 0), (n.y.targetOffset = 0), t !== e)) {
                let i = t;
                for (; i && i !== e; )
                  (n.x.targetOffset += i.offsetLeft),
                    (n.y.targetOffset += i.offsetTop),
                    (i = i.offsetParent);
              }
              (n.x.targetLength = t === e ? t.scrollWidth : t.clientWidth),
                (n.y.targetLength = t === e ? t.scrollHeight : t.clientHeight),
                (n.x.containerLength = e.clientWidth),
                (n.y.containerLength = e.clientHeight);
            })(e, i.target, n),
          update: (t) => {
            !(function (e, t, n) {
              iQ(e, "x", t, n), iQ(e, "y", t, n), (t.time = n);
            })(e, n, t),
              (i.offset || i.target) && uQ(e, n, i);
          },
          notify: () => t(n),
        };
      }
      const dQ = new WeakMap(),
        pQ = new WeakMap(),
        fQ = new WeakMap(),
        AQ = (e) => (e === document.documentElement ? window : e);
      function gQ(e, { container: t = document.documentElement, ...n } = {}) {
        let i = fQ.get(t);
        i || ((i = new Set()), fQ.set(t, i));
        const r = tQ(),
          s = hQ(t, e, r, n);
        if ((i.add(s), !dQ.has(t))) {
          const e = () => {
              for (const e of i) e.measure();
            },
            n = () => {
              for (const e of i) e.update(LU.timestamp);
            },
            r = () => {
              for (const e of i) e.notify();
            },
            s = () => {
              DU.read(e, !1, !0), DU.read(n, !1, !0), DU.update(r, !1, !0);
            };
          dQ.set(t, s);
          const a = AQ(t);
          window.addEventListener("resize", s, { passive: !0 }),
            t !== document.documentElement &&
              pQ.set(
                t,
                (function (e, t) {
                  return "function" == typeof e ? $k(e) : Kk(e, t);
                })(t, s)
              ),
            a.addEventListener("scroll", s, { passive: !0 });
        }
        const a = dQ.get(t);
        return (
          DU.read(a, !1, !0),
          () => {
            var e;
            PU(a);
            const n = fQ.get(t);
            if (!n) return;
            if ((n.delete(s), n.size)) return;
            const i = dQ.get(t);
            dQ.delete(t),
              i &&
                (AQ(t).removeEventListener("scroll", i),
                null === (e = pQ.get(t)) || void 0 === e || e(),
                window.removeEventListener("resize", i));
          }
        );
      }
      const mQ = new Map();
      function vQ({
        source: e = document.documentElement,
        axis: t = "y",
      } = {}) {
        mQ.has(e) || mQ.set(e, {});
        const n = mQ.get(e);
        return (
          n[t] ||
            (n[t] = NU()
              ? new ScrollTimeline({ source: e, axis: t })
              : (function ({ source: e, axis: t = "y" }) {
                  const n = { value: 0 },
                    i = gQ(
                      (e) => {
                        n.value = 100 * e[t].progress;
                      },
                      { container: e, axis: t }
                    );
                  return { currentTime: n, cancel: i };
                })({ source: e, axis: t })),
          n[t]
        );
      }
      var yQ;
      !(function (e) {
        (e.Initial = "initial"), (e.Entered = "entered"), (e.Exited = "exited");
      })(yQ || (yQ = {}));
      const bQ = Object.values(nt),
        _Q = { lastScrollDirection: void 0 };
      function xQ(e) {
        return parseFloat((e / 1e3).toFixed(3));
      }
      function EQ(e) {
        if (!e) return;
        const t = bQ.find((t) => t === e) || nt.Custom,
          n = (function (e) {
            return {
              keyframe: Up(e),
              transition: Lp(Ze.Spring, Ye.ScrollAnimation),
            };
          })(t),
          i =
            "object" == typeof e
              ? {
                  keyframe: Object.assign(
                    Object.assign({}, n.keyframe),
                    e.keyframe
                  ),
                  transition: Object.assign(
                    Object.assign({}, n.transition),
                    e.transition
                  ),
                }
              : n;
        return {
          keyframe:
            ((s = i.keyframe),
            {
              opacity: s.opacity,
              scale: s.scale,
              rotateX: s.rotateX,
              rotateY: s.rotateY,
              rotateZ: s.rotateZ,
              x: s.offsetX,
              y: s.offsetY,
            }),
          transition:
            ((r = i.transition),
            r.type === Ze.Spring
              ? {
                  type: "spring",
                  delay: xQ(r.delay),
                  stiffness: r.stiffness,
                  damping: r.damping,
                  mass: r.mass,
                }
              : {
                  type: "tween",
                  ease: r.type,
                  delay: xQ(r.delay),
                  duration: xQ(r.duration),
                }),
        };
        var r, s;
      }
      function wQ(e) {
        if (!e.type) return;
        const t = (function (e) {
            return {
              type: e,
              direction: et.Down,
              start: tt.Top,
              replay: !0,
              clickThrough: !0,
            };
          })(e.type),
          n = Object.assign(Object.assign({}, t), e),
          i = n.type;
        if (i === $e.OnAppear) {
          const e = EQ(n.effectA);
          if (!e) return;
          return {
            type: $e.OnAppear,
            effectA: e,
            clickThrough: n.clickThrough,
          };
        }
        if (i === $e.OnScroll) {
          const e = EQ(n.effectA);
          if (!e) return;
          return {
            type: $e.OnScroll,
            direction: n.direction,
            replay: n.replay,
            effectA: e,
            clickThrough: n.clickThrough,
          };
        }
        if (i === $e.ElementInView) {
          const e = EQ(n.effectA),
            t = EQ(n.effectB);
          if (!e && !t) return;
          return {
            type: $e.ElementInView,
            start: n.start,
            replay: n.replay,
            effectA: e,
            effectB: t,
            clickThrough: n.clickThrough,
          };
        }
        if (i === $e.SectionInView) {
          const e = mU(),
            t = n.sectionId ? e.get(n.sectionId) : void 0;
          if (!t) return;
          const i = EQ(n.effectA),
            r = EQ(n.effectB);
          if (!i && !r) return;
          return {
            type: $e.SectionInView,
            section: t,
            start: n.start,
            replay: n.replay,
            effectA: i,
            effectB: r,
            clickThrough: n.clickThrough,
          };
        }
      }
      function CQ(e) {
        const t = parseFloat(
            window.getComputedStyle(e).getPropertyValue("opacity")
          ),
          n = e.style.transform;
        let i = 1,
          r = 1,
          s = 0,
          a = 0,
          o = 0,
          c = 0,
          l = 0;
        isNaN(t) || (i *= t);
        const u = n.match(
          /(scale|rotateX|rotateY|rotateZ|translateX|translateY)\((.*?)\)/g
        );
        return (
          u &&
            u.forEach((e) => {
              const [t, n] = e.split("("),
                i = parseFloat(n);
              switch (t) {
                case "scale":
                  r *= i;
                  break;
                case "rotateX":
                  s += i;
                  break;
                case "rotateY":
                  a += i;
                  break;
                case "rotateZ":
                  o += i;
                  break;
                case "translateX":
                  c += i;
                  break;
                case "translateY":
                  l += i;
              }
            }),
          {
            opacity: i,
            scale: r,
            rotateX: s,
            rotateY: a,
            rotateZ: o,
            x: c,
            y: l,
          }
        );
      }
      function SQ(e, t) {
        const { animation: n, state: i } = e,
          { currentState: r } = i;
        switch (n.type) {
          case $e.OnAppear:
            if (t === yQ.Entered)
              return {
                keyframe: i.defaultKeyframe,
                transition: n.effectA.transition,
              };
            break;
          case $e.OnScroll:
            if (t === yQ.Entered)
              return {
                keyframe: n.effectA.keyframe,
                transition: n.effectA.transition,
              };
            if (t === yQ.Initial)
              return {
                keyframe: i.defaultKeyframe,
                transition: n.effectA.transition,
              };
            break;
          case $e.ElementInView:
          case $e.SectionInView: {
            const e =
              t === yQ.Exited || r === yQ.Exited ? n.effectB : n.effectA;
            if (e) {
              return {
                keyframe: t === yQ.Entered ? i.defaultKeyframe : e.keyframe,
                transition: e.transition,
              };
            }
            break;
          }
        }
      }
      function IQ(e) {
        const { state: t } = e,
          { currentState: n, desiredState: i } = t;
        if (n === i) return;
        const r = (function (e, t) {
          const n = [yQ.Initial, yQ.Entered, yQ.Exited],
            i = n.indexOf(e),
            r = n.indexOf(t);
          return r < i ? n[i - 1] : r > i ? n[i + 1] : e;
        })(n, i);
        return n !== r ? { nextState: r, effect: SQ(e, r) } : void 0;
      }
      const MQ = (e) => (t, n, i) => {
        e && n.opacity >= Number.EPSILON && (t.style.pointerEvents = "auto");
        const r = zk(t, n, i);
        return (
          r.then(() => {
            e && n.opacity < Number.EPSILON && (t.style.pointerEvents = "none");
          }),
          r
        );
      };
      function TQ(e) {
        const { state: t } = e,
          n = IQ(e);
        if (!n) return;
        const { nextState: i, effect: r } = n;
        if (!r)
          return (t.currentState = i), (t.animationInProgress = !1), void TQ(e);
        t.animationInProgress = !0;
        const s = t.isFirstAnimation
          ? Object.assign(Object.assign({}, r.transition), { velocity: 0 })
          : r.transition;
        t.isFirstAnimation = !1;
        const { el: a } = t,
          { keyframe: o } = r;
        MQ(e.animation.clickThrough)(a, o, s).then(() => {
          (t.currentState = i), (t.animationInProgress = !1), TQ(e);
        });
      }
      function BQ(e) {
        const { state: t } = e;
        t.animationInProgress || TQ(e);
      }
      function RQ(e) {
        const { animation: t, state: n } = e,
          { el: i } = n;
        (i.style.opacity = `${t.effectA.keyframe.opacity}`),
          MQ(t.clickThrough)(i, t.effectA.keyframe, { duration: 0 }),
          jk(i, () => {
            (n.desiredState = yQ.Entered), BQ(e);
          });
      }
      function DQ(e) {
        switch (e) {
          case tt.Top:
            return 0;
          case tt.Center:
            return 0.5;
          case tt.Bottom:
            return 1;
          default:
            return 0.5;
        }
      }
      function PQ(e) {
        return (e.top + e.bottom) / 2;
      }
      function LQ(e) {
        const { animation: t, state: n } = e,
          { el: i } = n;
        t.effectA &&
          ((i.style.opacity = `${t.effectA.keyframe.opacity}`),
          MQ(t.clickThrough)(i, t.effectA.keyframe, { duration: 0 }));
        const r = jk(
          i,
          (i) => {
            const s = PQ(i.boundingClientRect);
            return (
              t.effectA && !t.replay && r(),
              (n.desiredState = yQ.Entered),
              BQ(e),
              (i) => {
                t.replay || r();
                const a = PQ(i.boundingClientRect) <= s;
                (n.desiredState = a ? yQ.Exited : yQ.Initial), BQ(e);
              }
            );
          },
          { amount: DQ(t.start) }
        );
      }
      function UQ(e) {
        switch (e) {
          case tt.Top:
            return "0px 0px -100% 0px";
          case tt.Center:
            return "-50% 0px -50% 0px";
          case tt.Bottom:
            return "-100% 0px 0px 0px";
          default:
            return "-50% 0px -50% 0px";
        }
      }
      function FQ(e) {
        const { animation: t, state: n } = e,
          { el: i } = n;
        t.effectA &&
          ((i.style.opacity = `${t.effectA.keyframe.opacity}`),
          MQ(t.clickThrough)(i, t.effectA.keyframe, { duration: 0 }));
        const r = jk(
          t.section.el,
          (i) => {
            const s = PQ(i.boundingClientRect);
            return (
              t.effectA && !t.replay && r(),
              (n.desiredState = yQ.Entered),
              BQ(e),
              (i) => {
                t.replay || r();
                const a = PQ(i.boundingClientRect) <= s;
                (n.desiredState = a ? yQ.Exited : yQ.Initial), BQ(e);
              }
            );
          },
          { amount: "some", root: document, margin: UQ(t.start) }
        );
      }
      function OQ(e, t) {
        e.effectA && (e.effectA.keyframe.opacity *= t.defaultKeyframe.opacity),
          (e.type !== $e.ElementInView && e.type !== $e.SectionInView) ||
            (e.effectB &&
              (e.effectB.keyframe.opacity *= t.defaultKeyframe.opacity));
      }
      function NQ(e) {
        const t = (function (e) {
            const t = new Map();
            if (!e) return t;
            const n = e.scrollAnimations || {};
            return (
              Object.entries(n).forEach(([e, n]) => {
                if (!n) return;
                const i = wQ(n);
                i && t.set(e, i);
              }),
              t
            );
          })(e),
          n = (function (e) {
            const t = new Map();
            for (const [n] of e) {
              const e = document.getElementById(n);
              if (!e) continue;
              const i = CQ(e),
                r = {
                  isFirstAnimation: !0,
                  animationInProgress: !1,
                  desiredState: yQ.Initial,
                  currentState: yQ.Initial,
                  el: e,
                  defaultKeyframe: i,
                };
              t.set(n, r);
            }
            return t;
          })(t),
          i = new Map();
        for (const [e, r] of t) {
          const t = n.get(e);
          if (t)
            switch ((OQ(r, t), r.type)) {
              case $e.OnAppear:
                RQ({ animation: r, state: t });
                break;
              case $e.OnScroll:
                i.set(e, { animation: r, state: t });
                break;
              case $e.ElementInView:
                LQ({ animation: r, state: t });
                break;
              case $e.SectionInView:
                FQ({ animation: r, state: t });
            }
        }
        let r;
        const s = (function (e, t) {
          const n = vQ(t);
          return "function" == typeof e ? FU(e, n) : e.attachTimeline(n);
        })((e) => {
          const t = r;
          if (((r = e), void 0 === t)) return;
          const n = _Q.lastScrollDirection;
          e > t
            ? (_Q.lastScrollDirection = et.Down)
            : e < t && (_Q.lastScrollDirection = et.Up),
            _Q.lastScrollDirection &&
              _Q.lastScrollDirection !== n &&
              (function (e, t) {
                const n = [];
                for (const [i, r] of t) {
                  const { animation: t, state: s } = r,
                    a = t.direction === e,
                    o = s.desiredState === yQ.Initial;
                  a && o
                    ? ((s.desiredState = yQ.Entered),
                      BQ(r),
                      t.replay || n.push(i))
                    : a || o || ((s.desiredState = yQ.Initial), BQ(r));
                }
                for (const e of n) t.delete(e);
              })(_Q.lastScrollDirection, i);
        });
        VL(() => {
          s(), (_Q.lastScrollDirection = void 0);
        });
      }
      var kQ = n(683),
        QQ = function (e, t, n, i) {
          return new (n || (n = Promise))(function (r, s) {
            function a(e) {
              try {
                c(i.next(e));
              } catch (e) {
                s(e);
              }
            }
            function o(e) {
              try {
                c(i.throw(e));
              } catch (e) {
                s(e);
              }
            }
            function c(e) {
              var t;
              e.done
                ? r(e.value)
                : ((t = e.value),
                  t instanceof n
                    ? t
                    : new n(function (e) {
                        e(t);
                      })).then(a, o);
            }
            c((i = i.apply(e, t || [])).next());
          });
        };
      let GQ = {
        loadPromise: void 0,
        loadingDone: !1,
        audios: void 0,
        onLeavePauseAudios: [],
        tabFocus: !0,
        documentVisibility: !0,
        audioFadeOut: !1,
      };
      function HQ(e, t) {
        var n;
        const i =
            (null === (n = null == e ? void 0 : e.audio) || void 0 === n
              ? void 0
              : n[t]) || {},
          r = (function (e) {
            return {
              sourceType: e,
              src: "",
              autoplay: !1,
              loop: !1,
              progress: 0,
              volume: 0.25,
              onLeave: rt.Pause,
            };
          })((null == i ? void 0 : i.sourceType) || Fp);
        return Object.assign(Object.assign({}, r), i);
      }
      function zQ(e, t) {
        var n;
        const i =
            (null === (n = null == e ? void 0 : e.audioStyle) || void 0 === n
              ? void 0
              : n[t]) || {},
          r = {
            playCursor: Np,
            playIconType: Op,
            playIconColor: kp,
            iconPlayUrl: "",
            iconPauseUrl: "",
          };
        return Object.assign(Object.assign({}, r), i);
      }
      function VQ(e) {
        var t, n;
        null === (t = e.iconDivEl) || void 0 === t || t.remove(),
          (e.iconDivEl = void 0);
        const i = !!(null === (n = e.howl) || void 0 === n
          ? void 0
          : n.playing());
        i && (e.playedOnce = !0);
        const r = i ? e.iconPauseBlobUrl : e.iconPlayBlobUrl;
        if (!r) return;
        const s = zp(r, e.style);
        e.el.prepend(s), (e.iconDivEl = s);
      }
      function jQ(e) {
        var t, n;
        !!(null === (t = e.howl) || void 0 === t ? void 0 : t.playing()) ||
          null === (n = e.howl) ||
          void 0 === n ||
          n.play();
      }
      function WQ(e) {
        return QQ(this, void 0, void 0, function* () {
          e.iconPlayBlobUrl = yield bf(Gp(e.style));
        });
      }
      function XQ(e) {
        return QQ(this, void 0, void 0, function* () {
          e.iconPauseBlobUrl = yield bf(Hp(e.style));
        });
      }
      function qQ(e) {
        return QQ(this, void 0, void 0, function* () {
          const t = (function (e) {
            const t = new Map(),
              n = document.getElementsByClassName("pwb-audio");
            for (let i = 0; i < n.length; i++) {
              const r = n[i].id;
              if (!r) continue;
              const s = document.getElementById(r);
              s &&
                t.set(r, {
                  el: s,
                  attrs: HQ(e, r),
                  style: zQ(e, r),
                  playedOnce: !1,
                  isUnlocked: !1,
                  wasFadedOut: !1,
                  wasPausedByFadeOut: !1,
                });
            }
            return t;
          })(e);
          GQ.audios = t;
          const n = [];
          Array.from(t.values()).forEach((e) => {
            n.push(
              (function (e) {
                return QQ(this, void 0, void 0, function* () {
                  yield Promise.all([WQ(e), XQ(e)]);
                });
              })(e)
            );
          }),
            yield Promise.all(n),
            (GQ.loadingDone = !0);
        });
      }
      function YQ(e) {
        return QQ(this, void 0, void 0, function* () {
          GQ.loadPromise || (GQ.loadPromise = qQ(e)), yield GQ.loadPromise;
        });
      }
      function KQ(e) {
        if (!e) return;
        const t = (function (e) {
          (e = xp(e)), (e = new URL(e).pathname);
          const t = (e = (e = bp(e, "/")).substring(
            e.lastIndexOf("/") + 1
          )).lastIndexOf(".");
          return t < 0 ? "" : e.substring(t + 1);
        })(e).toLowerCase();
        return [
          "mp3",
          "opus",
          "ogg",
          "wav",
          "aac",
          "m4a",
          "m4b",
          "mp4",
          "webm",
        ].includes(t)
          ? [t]
          : void 0;
      }
      function JQ(e) {
        var t, n;
        if ((VQ(e), !e.playedOnce)) {
          if (e.attrs.progress > 0) {
            const i =
              ((null === (t = e.howl) || void 0 === t
                ? void 0
                : t.duration()) || 0) * e.attrs.progress;
            null === (n = e.howl) || void 0 === n || n.seek(i);
          }
          e.attrs.autoplay && jQ(e);
        }
      }
      function ZQ(e) {
        if ((VQ(e), e.attrs.src)) {
          const t = new kQ.Howl({
            src: [e.attrs.src],
            format: KQ(e.attrs.src),
            html5: !0,
            loop: e.attrs.loop,
            volume: e.attrs.volume,
            onplay: () => VQ(e),
            onplayerror: () => VQ(e),
            onend: () => VQ(e),
            onpause: () => VQ(e),
            onstop: () => VQ(e),
            onload: () => {
              JQ(e);
            },
            onunlock: () => {
              JQ(e), (e.isUnlocked = !0);
            },
            onfade: () => {
              var t, n, i;
              const r =
                  (null === (t = e.howl) || void 0 === t
                    ? void 0
                    : t.volume()) || 0,
                s = !!(null === (n = e.howl) || void 0 === n
                  ? void 0
                  : n.playing());
              r <= 0 &&
                s &&
                e.wasFadedOut &&
                ((e.wasPausedByFadeOut = !0),
                null === (i = e.howl) || void 0 === i || i.pause());
            },
          });
          (e.howl = t),
            e.attrs.onLeave === rt.Pause && GQ.onLeavePauseAudios.push(e);
        }
        const t = (function (e) {
            return (t) => {
              var n, i;
              Dp(t),
                Pp(t),
                (!e.attrs.autoplay || e.playedOnce) &&
                  ((
                    null === (n = e.howl) || void 0 === n ? void 0 : n.playing()
                  )
                    ? null === (i = e.howl) || void 0 === i || i.pause()
                    : jQ(e));
            };
          })(e),
          { el: n } = e;
        e.style.playCursor === Te.Pointer && (n.style.cursor = "pointer"),
          n.addEventListener("click", t);
      }
      function $Q() {
        const e = !GQ.documentVisibility;
        if (GQ.audioFadeOut !== e)
          if (((GQ.audioFadeOut = e), GQ.audioFadeOut))
            for (const e of GQ.onLeavePauseAudios) {
              (e.wasFadedOut = !1), (e.wasPausedByFadeOut = !1);
              const t = e.howl;
              if (!t) continue;
              t.playing() && ((e.wasFadedOut = !0), t.fade(t.volume(), 0, 1e3));
            }
          else
            for (const e of GQ.onLeavePauseAudios) {
              if (!e.wasFadedOut) continue;
              e.wasFadedOut = !1;
              const t = e.howl;
              t &&
                (t.fade(t.volume(), e.attrs.volume, 1e3),
                e.wasPausedByFadeOut && jQ(e));
            }
      }
      function eG(e) {
        (GQ.tabFocus = e), $Q();
      }
      function tG(e, t) {
        if (!e.id) return;
        const { audios: n } = GQ;
        if (!n) return;
        const i = n.get(e.id);
        if (!i) return;
        if (!i.howl) return;
        if (!i.isUnlocked && t !== dt.MouseClick) return;
        if (
          ((e.event !== ut.Pause && e.event !== ut.Stop) ||
            (i.attrs.autoplay = !1),
          i.attrs.autoplay && !i.playedOnce)
        )
          return;
        const r = !!i.howl.playing(),
          s = (function (e, t) {
            return e === ut.TogglePlayPause
              ? t
                ? ut.Pause
                : ut.Play
              : e === ut.TogglePlayStop
              ? t
                ? ut.Stop
                : ut.Play
              : e;
          })(e.event, r);
        r
          ? s === ut.Pause
            ? i.howl.pause()
            : s === ut.Stop && i.howl.stop()
          : s === ut.Play
          ? i.howl.play()
          : s === ut.Stop && i.howl.stop();
      }
      function nG() {
        const { loadingDone: e, audios: t } = GQ;
        if (!e || !t)
          throw new Error(
            "UIAudioModule needs to be loaded before it can be initialized."
          );
        Array.from(t.values()).forEach((e) => {
          ZQ(e);
        });
        const n = () => eG(!0),
          i = () => eG(!1);
        window.addEventListener("focus", n),
          window.addEventListener("blur", i),
          eG(!!document.hasFocus());
        const r = () => {
          return (e = !document.hidden), (GQ.documentVisibility = e), void $Q();
          var e;
        };
        document.addEventListener("visibilitychange", r),
          r(),
          lU(lt.UIAudio, tG);
        VL(() => {
          var e;
          uU(lt.UIAudio, tG),
            document.removeEventListener("visibilitychange", r),
            window.removeEventListener("blur", i),
            window.removeEventListener("focus", n);
          const t = Array.from(GQ.audios ? GQ.audios.values() : []);
          for (const n of t)
            null === (e = n.howl) || void 0 === e || e.unload();
          GQ = {
            loadPromise: void 0,
            loadingDone: !1,
            audios: void 0,
            onLeavePauseAudios: [],
            tabFocus: !0,
            documentVisibility: !0,
            audioFadeOut: !1,
          };
        });
      }
      const iG = function (e, t, n) {
        var i = !0,
          r = !0;
        if ("function" != typeof e) throw new TypeError("Expected a function");
        return (
          b(n) &&
            ((i = "leading" in n ? !!n.leading : i),
            (r = "trailing" in n ? !!n.trailing : r)),
          hv(e, t, { leading: i, maxWait: t, trailing: r })
        );
      };
      var rG,
        sG,
        aG = function (e, t, n, i) {
          return new (n || (n = Promise))(function (r, s) {
            function a(e) {
              try {
                c(i.next(e));
              } catch (e) {
                s(e);
              }
            }
            function o(e) {
              try {
                c(i.throw(e));
              } catch (e) {
                s(e);
              }
            }
            function c(e) {
              var t;
              e.done
                ? r(e.value)
                : ((t = e.value),
                  t instanceof n
                    ? t
                    : new n(function (e) {
                        e(t);
                      })).then(a, o);
            }
            c((i = i.apply(e, t || [])).next());
          });
        };
      !(function (e) {
        (e.Relative = "relative"), (e.Fixed = "fixed");
      })(rG || (rG = {})),
        (function (e) {
          (e.Closed = "closed"), (e.Open = "open");
        })(sG || (sG = {}));
      const oG = { [sG.Closed]: sG.Open, [sG.Open]: sG.Closed },
        cG = { overlays: new Map() };
      function lG(e) {
        const t = [];
        if (!e) return t;
        const n = e[At.RelativeOverlays] || {};
        return (
          Object.entries(n).forEach(([e, n]) => {
            if (!n) return;
            const i = document.getElementById(e);
            if (!i) return;
            const r = {
                position: at.Bottom,
                align: ot.Center,
                offsetOrthogonal: 8,
                offsetParallel: 0,
                dismissType: ct.Auto,
              },
              s = Object.assign(Object.assign({}, r), n);
            t.push({
              id: e,
              el: i,
              type: rG.Relative,
              desiredState: sG.Closed,
              currentState: sG.Closed,
              isAnimating: !1,
              isDisposed: !1,
              overlay: s,
            });
          }),
          t
        );
      }
      function uG(e) {
        return [
          { x: e.left, y: e.top },
          { x: e.right, y: e.top },
          { x: e.right, y: e.bottom },
          { x: e.left, y: e.bottom },
        ];
      }
      function hG(e) {
        const { el: t } = e,
          n = t.parentElement;
        if (!n) return;
        const i = iG(
            (i) => {
              const s = (function (e) {
                if (e.length < 3) return;
                const t = [];
                let n = 0;
                for (let t = 1; t < e.length; t++)
                  (e[t].x < e[n].x || (e[t].x === e[n].x && e[t].y < e[n].y)) &&
                    (n = t);
                let i,
                  r = n;
                do {
                  t.push(e[r]), (i = (r + 1) % e.length);
                  for (let t = 0; t < e.length; t++) {
                    const n = Mp(e[r], e[t], e[i]);
                    (2 == n || (0 == n && Tp(e[r], e[t]) > Tp(e[r], e[i]))) &&
                      (i = t);
                  }
                  r = i;
                } while (r != n);
                return t;
              })([
                ...uG(t.getBoundingClientRect()),
                ...uG(n.getBoundingClientRect()),
              ]);
              if (!s) return;
              Rp({ x: i.clientX, y: i.clientY }, s) ||
                ((e.desiredState = sG.Closed), gG(e), r());
            },
            200,
            { leading: !0, trailing: !0 }
          ),
          r = () => {
            document.removeEventListener("mousemove", i),
              (e.disposeMouseMoveListenerCb = void 0);
          };
        return document.addEventListener("mousemove", i), r;
      }
      function dG(e, t) {
        return !!t && (!!t.classList.contains(e) || dG(e, t.parentElement));
      }
      function pG(e) {
        const { el: t } = e,
          n = t.parentElement;
        if (!n) return;
        const i = pU(e.id),
          r = () => {
            (e.desiredState = sG.Closed), gG(e), o();
          },
          s = (e) => {
            const t = e.target;
            n.contains(t) || dG(i, t) || r();
          },
          a = (e) => {
            ("Escape" !== e.key && "Esc" !== e.key) || r();
          },
          o = () => {
            document.removeEventListener("mousedown", s),
              document.removeEventListener("touchstart", s),
              document.removeEventListener("keydown", a),
              (e.disposeClickAwayListenerCb = void 0);
          };
        return (
          document.addEventListener("mousedown", s),
          document.addEventListener("touchstart", s),
          document.addEventListener("keydown", a),
          o
        );
      }
      function fG(e) {
        var t, n;
        null === (t = e.disposeMouseMoveListenerCb) ||
          void 0 === t ||
          t.call(e),
          null === (n = e.disposeClickAwayListenerCb) ||
            void 0 === n ||
            n.call(e);
      }
      function AG(e) {
        return aG(this, void 0, void 0, function* () {
          e.isAnimating = !0;
          const { el: t, desiredState: n } = e;
          n === sG.Open
            ? ((t.style.display = "block"),
              e.type === rG.Relative &&
                (function (e) {
                  var t, n;
                  e.overlay.dismissType === ct.Auto &&
                    (null === (t = e.disposeMouseMoveListenerCb) ||
                      void 0 === t ||
                      t.call(e),
                    (e.disposeMouseMoveListenerCb = hG(e))),
                    [ct.Auto, ct.Click].includes(e.overlay.dismissType) &&
                      (null === (n = e.disposeClickAwayListenerCb) ||
                        void 0 === n ||
                        n.call(e),
                      (e.disposeClickAwayListenerCb = pG(e)));
                })(e),
              yield zk(
                t,
                { opacity: 1 },
                { type: "tween", ease: Je.EaseInOut, delay: 0, duration: 0.3 }
              ),
              (e.currentState = sG.Open))
            : (e.type === rG.Relative && fG(e),
              yield zk(
                t,
                { opacity: 0 },
                { type: "tween", ease: Je.EaseInOut, delay: 0, duration: 0.3 }
              ),
              (t.style.display = "none"),
              (e.currentState = sG.Closed)),
            (e.isAnimating = !1),
            gG(e);
        });
      }
      function gG(e) {
        e.isAnimating ||
          e.isDisposed ||
          (e.desiredState !== e.currentState && AG(e));
      }
      function mG(e) {
        const { el: t, overlay: n } = e;
        (t.style.display = "none"),
          (t.style.opacity = "0"),
          (function (e, t) {
            const n = jp(t);
            for (const [t, i] of Object.entries(n)) e.style[t] = i;
          })(t, n);
        const i = t.parentElement;
        i &&
          ((i.style.cursor = "pointer"),
          t.style.cursor || (t.style.cursor = "auto"),
          i.addEventListener("click", (t) => {
            Dp(t), Pp(t), (e.desiredState = sG.Open), gG(e);
          }),
          cG.overlays.set(e.id, e));
      }
      function vG(e) {
        const { overlays: t } = cG,
          n = t.get(e.id);
        if (n) {
          switch (e.event) {
            case ht.Open:
              n.desiredState = sG.Open;
              break;
            case ht.Close:
              n.desiredState = sG.Closed;
              break;
            case ht.ToggleOpenClose:
              n.desiredState = oG[n.desiredState];
          }
          gG(n);
        }
      }
      function yG(e) {
        iU(),
          vU(e),
          AU(e),
          (function (e) {
            const t = lG(e);
            for (const e of t) mG(e);
            lU(lt.UIOverlay, vG),
              VL(() => {
                uU(lt.UIOverlay, vG);
                const e = Array.from(cG.overlays.values());
                for (const t of e)
                  (t.isDisposed = !0), t.type === rG.Relative && fG(t);
                cG.overlays = new Map();
              });
          })(e),
          (function (e) {
            const t = mU(),
              n = yU(e, t);
            for (const [e, t] of n) {
              const n = document.getElementById(e);
              if (!n) continue;
              const i = t.type === pt.External ? bU(t) : _U(t);
              (n.style.cursor = "pointer"), n.addEventListener("click", i);
            }
            xU(t);
          })(e),
          NQ(e),
          nG();
      }
      function bG(e) {
        const t = document.getElementById(uf);
        t.replaceWith(...t.childNodes);
        document.querySelector(`div#${lf}`).remove(), yG(e);
      }
      var _G = function (e, t, n, i) {
        return new (n || (n = Promise))(function (r, s) {
          function a(e) {
            try {
              c(i.next(e));
            } catch (e) {
              s(e);
            }
          }
          function o(e) {
            try {
              c(i.throw(e));
            } catch (e) {
              s(e);
            }
          }
          function c(e) {
            var t;
            e.done
              ? r(e.value)
              : ((t = e.value),
                t instanceof n
                  ? t
                  : new n(function (e) {
                      e(t);
                    })).then(a, o);
          }
          c((i = i.apply(e, t || [])).next());
        });
      };
      const xG = {
        isInitialized: !1,
        isNavigating: !1,
        styleLoadedPaths: new Set(),
      };
      function EG(e, t, n = !1) {
        (xG.currentPath = e),
          (xG.currentSectionHash = t || void 0),
          n || gf || history.pushState({}, "", `${e}${t ? `#${t}` : ""}`);
      }
      function wG() {
        return _G(this, void 0, void 0, function* () {
          try {
            const [e, t] = yield Promise.all([Mf(), Tf()]),
              n = new DOMParser().parseFromString(e, "text/html"),
              i = n.getElementById(hf);
            if (!i) throw new Error("Error page wrap not found.");
            jL(),
              document.body.replaceChildren(i),
              (document.title = n.title),
              Array.from(document.body.attributes).forEach((e) => {
                document.body.removeAttribute(e.name);
              });
            const r = document.createElement("style");
            (r.textContent = t), document.head.append(r);
          } catch (e) {
            console.error("Load error page error:", e);
          }
        });
      }
      function CG(e, t, n) {
        const { isInitialized: i, isNavigating: r } = xG;
        i && !r
          ? ((xG.isNavigating = !0),
            EG(e, t, n),
            (function () {
              return _G(this, void 0, void 0, function* () {
                const e = xG.currentPath;
                if (!e) return;
                const [t, n, i, { engineState: r, animations: s }] =
                  yield Promise.all([Sf(e), If(e), Cf(e), wf()]);
                jL();
                const a = new DOMParser().parseFromString(t, "text/html"),
                  o = a.getElementById(uf);
                if (!o)
                  throw new Error(
                    "Failed loading a new page: page body wrap not found."
                  );
                const c = a.getElementById(lf);
                if (!c)
                  throw new Error(
                    "Failed loading a new page: page loading wrap not found."
                  );
                if (
                  (document.body.replaceChildren(o, c),
                  (document.title = a.title),
                  window._pwExecLoadingPageJavascript(),
                  Array.from(document.body.attributes).forEach((e) => {
                    document.body.removeAttribute(e.name);
                  }),
                  Array.from(a.body.attributes).forEach((e) => {
                    document.body.setAttribute(e.name, e.value);
                  }),
                  !xG.styleLoadedPaths.has(e))
                ) {
                  xG.styleLoadedPaths.add(e);
                  const t = document.createElement("style");
                  (t.textContent = n), document.head.append(t);
                }
                const l = YQ(i);
                yield aU(r, i), oU(s), yield l, bG(i);
              });
            })()
              .then(() => {
                (xG.isNavigating = !1), SG();
              })
              .catch((e) => {
                console.error("Router navigation error:", e),
                  wG().finally(() => {
                    (xG.isNavigating = !1), SG();
                  });
              }))
          : (xG.nextNavigateTo = {
              path: e,
              sectionHash: t,
              omitHistoryPush: n,
            });
      }
      function SG() {
        if (!xG.nextNavigateTo) return;
        const { path: e, sectionHash: t } = xG.nextNavigateTo;
        (xG.nextNavigateTo = void 0), CG(e, t);
      }
      function IG() {
        const e = Af,
          t = yp(window.location.hash, "#"),
          n = document.location.search || "";
        gf || history.replaceState({}, "", `${e}${t ? `#${t}` : ""}${n}`),
          EG(e, t, !0),
          (function () {
            return _G(this, void 0, void 0, function* () {
              const e = xG.currentPath;
              if (!e) return;
              xG.styleLoadedPaths.add(e);
              const t = wf(),
                n = Cf(e),
                i = yield n,
                { engineState: r, animations: s } = yield t,
                a = YQ(i),
                o = aU(r, i);
              yield Promise.all([a, o]), oU(s), bG(i);
            });
          })()
            .then(() => {
              (xG.isInitialized = !0), SG();
            })
            .catch((e) => {
              console.error("Router initialization error:", e),
                wG().finally(() => {
                  (xG.isInitialized = !0), SG();
                });
            }),
          window.addEventListener("popstate", () => {
            CG(window.location.pathname, yp(window.location.hash, "#"), !0);
          });
      }
      iU(),
        requestAnimationFrame(function e(t) {
          var n;
          null === (n = eU.val) || void 0 === n || n.raf(t),
            requestAnimationFrame(e);
        });
      !(function () {
        const e = navigator.userAgent || navigator.vendor,
          t = bp(window.location.href, "/"),
          n =
            !!Me(window, "TelegramWebview") ||
            !!Me(window, "TelegramWebviewProxy");
        if (
          ["Instagram", "LinkedIn", "FBAN", "FBAV", "Slack", "Twitter"].some(
            (t) => e.includes(t)
          ) ||
          n
        ) {
          const n = !!e.match(/iPhone|iPad|iPod/i);
          window.location.replace(
            n ? `x-safari-${t}` : `intent:${t}#Intent;end`
          );
        }
      })(),
        window._pwIsInitialized
          ? console.warn("The client app was initialized more than once!")
          : ((window._pwIsInitialized = !0),
            gf &&
              (() => {
                const e = (t) => {
                  const n = t.data;
                  if (n.type === Re.WebsitePreviewData) {
                    const t = n.previewPages.find((e) => e.path === Af);
                    if (t) {
                      const e = document.createElement("style");
                      document.head.append(e), (e.textContent = t.css);
                    }
                    _f(
                      `/${Be.SceneState}`,
                      new Blob([JSON.stringify(n.previewSceneState)], {
                        type: "application/json",
                      })
                    );
                    for (const e of n.previewPages) {
                      const t = _p(e.path);
                      _f(
                        `${t}${Be.Index}`,
                        new Blob([e.html], { type: "text/html" })
                      ),
                        _f(
                          `${t}${Be.Styles}`,
                          new Blob([e.css], { type: "text/css" })
                        ),
                        _f(
                          `${t}${Be.UIState}`,
                          new Blob([JSON.stringify(e.uiState)], {
                            type: "application/json",
                          })
                        );
                    }
                    window.removeEventListener("message", e);
                  }
                };
                window.addEventListener("message", e);
              })(),
            IG());
    })();
})();
